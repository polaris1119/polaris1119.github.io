<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>文章列表 on polarisxu</title>
		<link>https://polarisxu.studygolang.com/posts/</link>
		<description>Recent content in 文章列表 on polarisxu</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en</language>
		<copyright>本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，转载请注明 polarisxu 和出处链接。</copyright>
		<lastBuildDate>Mon, 20 Sep 2021 22:30:00 +0800</lastBuildDate>
		<atom:link href="https://polarisxu.studygolang.com/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Go Fiber 框架系列教程 01: 和 Express 对比学习</title>
			<link>https://polarisxu.studygolang.com/posts/go/fiber/go-fiber-basic-tutorial01/</link>
			<pubDate>Mon, 20 Sep 2021 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/fiber/go-fiber-basic-tutorial01/</guid>
			<description>大家好，我是 polarisxu。 每次发框架相关的文章，总有人提到 Go Fiber 框架。于是乎，学习了下 Fiber，感觉确实挺不错的。因此写下这个 Fiber 系列。 Fiber 项目地址：https://github.com/gofiber/fiber ，目前 Star 数 15.3k+。 01 Fiber 框架 这是一个 Go 语言 Web 框架，启发自 NodeJS 框架：Express 。该框架基于 FastHTTP 构建，旨在简化、零内存分配和提高性能，以便快速开</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>每次发框架相关的文章，总有人提到 Go Fiber 框架。于是乎，学习了下 Fiber，感觉确实挺不错的。因此写下这个 Fiber 系列。</p>
<p>Fiber 项目地址：<a href="https://github.com/gofiber/fiber" target="_blank" rel="noopener">https://github.com/gofiber/fiber</a>
，目前 Star 数 15.3k+。</p>
<h2 id="01-fiber-框架">01 Fiber 框架</h2>
<p>这是一个 Go 语言 Web 框架，启发自 NodeJS 框架：<a href="https://github.com/expressjs/express" target="_blank" rel="noopener">Express</a>
。该框架基于 <a href="https://github.com/valyala/fasthttp" target="_blank" rel="noopener">FastHTTP</a>
 构建，旨在<strong>简化</strong>、<strong>零内存分配</strong>和<strong>提高性能</strong>，以便<strong>快速</strong>开发。</p>
<blockquote>
<p>如果你是一位 NodeJS 开发者，想学习 Go，这个框架应该很适合你，同时这里还有一份专门为 NodeJS 开发者准备的 Go 学习资料：<a href="https://github.com/miguelmota/golang-for-nodejs-developers" target="_blank" rel="noopener">https://github.com/miguelmota/golang-for-nodejs-developers</a>
</p>
</blockquote>
<p>这个框架是 2020 年 1 月份启动开发的，没想到短时间就受到很多人关注。从 README 的多国语言就可见一斑：</p>
<p><p class="md__image">
  <img src="../imgs/fiber-readme.png"
    alt=""  />
</p>
</p>
<p>从第三方性能测试结果看，Fiber 的表现比 Gin、Echo 好很多。这里有详细的 Benchmark 测试说明：<a href="https://docs.gofiber.io/extra/benchmarks" target="_blank" rel="noopener">https://docs.gofiber.io/extra/benchmarks</a>
。</p>
<p>摘抄一段官方关于 Fiber 的哲学：</p>
<blockquote>
<p>Fiber 作为一个 Web 框架 ，是按照极简主义的思想并遵循 UNIX 方式创建的，因此新的 gopher 可以在热烈和可信赖的欢迎中迅速进入 Go 的世界。</p>
<p>Fiber 受到了互联网上最流行的 Web 框架 Express 的启发 。我们结合了 Express 的易用性和 Go 的原始性能 。如果您曾经在 Node.js 上实现过 Web 应用程序(使用 Express 或类似工具)，那么许多方法和原理对您来说应该非常易懂。</p>
<p>我们关注 整个互联网 用户在 issues 和 Discord channel 的消息，为了创建一个迅速，灵活以及友好的 Go Web 框架，满足任何任务，最后期限和开发者技能。就像 Express 在 JavaScript 世界中一样。</p>
</blockquote>
<p>所以，总结一下 Fiber 的特点（优势）：</p>
<ul>
<li>强大的路由</li>
<li>静态文件服务</li>
<li>极致高性能</li>
<li>内存占用低</li>
<li>API 接口</li>
<li>中间件和 Next 支持</li>
<li>快速服务器端编程</li>
<li>支持各种模版引擎</li>
<li>WebSocket 支持</li>
<li>频率限制器</li>
<li>文档被翻译为 16 种语言</li>
</ul>
<p>不过有两点需要注意，Fiber 使用了 unsafe 和 fasthttp，所以可能和 Go 最新版本有兼容性问题。目前 Fiber 2.18.0 兼容 Go 1.14 到 Go1.17；但 fasthttp 和 net/http 是不兼容的，因此 net/http 生态的项目无法使用在 fiber 上。</p>
<h2 id="02-和-express-的简短比较">02 和 Express 的简短比较</h2>
<p>既然是受 Express 启发，那就和它比较下。</p>
<h3 id="hello-world">Hello World</h3>
<p>基于 Express 的 Hello World 程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">express</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&#34;express&#34;</span><span class="p">);</span> <span class="c1">// 引用 Express library
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nx">express</span><span class="p">();</span> <span class="c1">// 创建一个 Express 实例
</span><span class="c1"></span>
<span class="c1">// 路由：/ endpoint
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="s2">&#34;Hello World!&#34;</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 在 3000 端口启动服务
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>
</code></pre></div><p>确实挺简单，几行代码就搞定了一个 Web 服务。</p>
<p>现在用 Fiber 实现类似上面的功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;github.com/gofiber/fiber/v2&#34;</span> <span class="c1">// 注意，最新版本是 v2.18.0，所以有 v2
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">app</span> <span class="o">:=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span> <span class="c1">// 创建一个 Fiber 实例
</span><span class="c1"></span>
  <span class="c1">// 路由：/ endpoint
</span><span class="c1"></span>  <span class="nx">app</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">Ctx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">SendString</span><span class="p">(</span><span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
  <span class="p">})</span>

  <span class="c1">// 在 3000 端口启动服务
</span><span class="c1"></span>  <span class="nx">app</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;:3000&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>目前，几乎所有 Go 框架都是类似的路子，没有太多好解释的。</p>
<p>Fiber 启动后终端的输出结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run main.go

 ┌───────────────────────────────────────────────────┐
 │                   Fiber v2.18.0                   │
 │               http://127.0.0.1:3000               │
 │       <span class="o">(</span>bound on host 0.0.0.0 and port 3000<span class="o">)</span>       │
 │                                                   │
 │ Handlers ............. <span class="m">2</span>  Processes ........... <span class="m">1</span> │
 │ Prefork ....... Disabled  PID ............. <span class="m">83538</span> │
 └───────────────────────────────────────────────────┘
</code></pre></div><h3 id="路由和端点">路由和端点</h3>
<p>任何 Web 应用程序、微服务或 API 都包含一个基于描述 HTTP 方法的端点（endpoint）和处理程序函数的路由系统，只有在这个端点接收到客户端的请求后才会执行这个路由系统。</p>
<p>除了上面的 HTTP GET 方法，Express 和 Fiber 还支持其他 HTTP 基本方法（当然还支持其他 HTTP 方法）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="c1">// Endpoint for POST method
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// function that stores a new data
</span><span class="c1"></span><span class="p">});</span>

<span class="c1">// Endpoint for PUT method
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// function that replaces the existing data
</span><span class="c1"></span><span class="p">});</span>

<span class="c1">// Endpoint for PATCH method
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">patch</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// function that replaces part of the existing data
</span><span class="c1"></span><span class="p">});</span>

<span class="c1">// Endpoint for DELETE method
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="c1">// function that deletes the data
</span><span class="c1"></span><span class="p">});</span>
</code></pre></div><p>对应的 Fiber 代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Endpoint for Post method
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nf">Post</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">Ctx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="c1">// function that stores a new data
</span><span class="c1"></span><span class="p">})</span>

<span class="c1">// Endpoint for PUT method
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">Ctx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="c1">// function that replaces the existing data
</span><span class="c1"></span><span class="p">})</span>

<span class="c1">// Endpoint for PATH method
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nf">Path</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">Ctx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="c1">// function that replaces part of the existing data
</span><span class="c1"></span><span class="p">})</span>

<span class="c1">// Endpoint for DELETE method
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">Ctx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="c1">// function that deletes the data
</span><span class="c1"></span><span class="p">})</span>
</code></pre></div><h3 id="中间件">中间件</h3>
<p>中间件函数可以访问 HTTP 请求和响应对象，以及调用下一个中间件函数。一般地，中间件函数执行如下动作：</p>
<ul>
<li>执行我们想让其执行的代码</li>
<li>对请求或响应对象做任何修改</li>
<li>完成请求-响应循环</li>
<li>调用堆栈中的下一个中间件函数</li>
</ul>
<p>看一个中间件的例子，它们在 Express 和 Fiber 中如何写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 打印当前时间
</span><span class="c1"></span>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Date:&#34;</span><span class="p">,</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">());</span>

  <span class="nx">next</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div><p>对应 Fiber 的代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">app</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">Ctx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="c1">// 打印当前时间
</span><span class="c1"></span>  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Date:&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>

  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
<span class="p">})</span>
</code></pre></div><h3 id="服务静态文件">服务静态文件</h3>
<p>Web 应用经常会有静态文件，它们需要能够被请求，比如图片、css/js 文件等。</p>
<p>服务静态文件，一般基于如下几个点：</p>
<ul>
<li>一个存储静态文件的文件夹</li>
<li>在 Web 程序中指定挂载点</li>
<li>对挂载点进行引用</li>
</ul>
<p>看看 Express 如何做到的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span>
  <span class="s2">&#34;/static&#34;</span><span class="p">,</span> <span class="c1">// mount address
</span><span class="c1"></span>  <span class="nx">express</span><span class="p">.</span><span class="kr">static</span><span class="p">(</span><span class="s2">&#34;public&#34;</span><span class="p">)</span> <span class="c1">// path to the file folder
</span><span class="c1"></span><span class="p">);</span>
</code></pre></div><p>对应 Fiber 的代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">app</span><span class="p">.</span><span class="nf">Static</span><span class="p">(</span>
  <span class="s">&#34;/static&#34;</span><span class="p">,</span>  <span class="c1">// mount address
</span><span class="c1"></span>  <span class="s">&#34;./public&#34;</span><span class="p">,</span> <span class="c1">// path to the file folder
</span><span class="c1"></span><span class="p">)</span>
</code></pre></div><p>因此，我们对 <code>/static/</code> 下的文件访问，都对应到 public 下的文件。比如：</p>
<blockquote>
<p><code>http://localhost:3000/static/images/background.jpg</code> 对应是 <code>public/images/background.jpg</code> 文件</p>
</blockquote>
<h3 id="使用模板">使用模板</h3>
<p>目前，Go 很多框架对各种模板引擎支持是不够的。但 Fiber 做到了和 Express 类似，支持大量开箱即用的模板引擎，比如：<a href="https://pugjs.org/" target="_blank" rel="noopener">Pug</a>
、<a href="https://jade-lang.com/" target="_blank" rel="noopener">Jade</a>
、<a href="https://mustache.github.io/" target="_blank" rel="noopener">Mustache</a>
 和 <a href="https://handlebarsjs.com/" target="_blank" rel="noopener">Handlebars</a>
 等。</p>
<p>以 Pug 为例，看看 Express 和 Fiber 如何使用的。（注意，以下代码会查找 ./views 目录下的 index.pug 文件，没有该文件会报错）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nx">app</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&#34;view engine&#34;</span><span class="p">,</span> <span class="s2">&#34;pug&#34;</span><span class="p">);</span>

<span class="c1">// 初始化模板文件夹
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s2">&#34;views&#34;</span><span class="p">,</span> <span class="s2">&#34;./views&#34;</span><span class="p">);</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="s2">&#34;index&#34;</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">title</span><span class="o">:</span> <span class="s2">&#34;Hey!&#34;</span><span class="p">,</span>
    <span class="nx">message</span><span class="o">:</span> <span class="s2">&#34;This is the index template.&#34;</span><span class="p">,</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div><p>对应的 Fiber 代码如下（注意，Fiber 对模板的支持是 <a href="https://github.com/gofiber/template" target="_blank" rel="noopener">https://github.com/gofiber/template</a>
 包）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 基于 ./views 文件夹初始化 Pug 模板引擎
</span><span class="c1"></span><span class="nx">engine</span> <span class="o">:=</span> <span class="nx">pug</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;./views&#34;</span><span class="p">,</span> <span class="s">&#34;.pug&#34;</span><span class="p">)</span>

<span class="nx">app</span> <span class="o">:=</span> <span class="nx">fiber</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
  <span class="nx">Views</span><span class="p">:</span> <span class="nx">engine</span><span class="p">,</span> <span class="c1">// 设置模板引擎
</span><span class="c1"></span><span class="p">})</span>

<span class="nx">app</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">fiber</span><span class="p">.</span><span class="nx">Ctx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="s">&#34;index&#34;</span><span class="p">,</span> <span class="nx">fiber</span><span class="p">.</span><span class="nx">Map</span><span class="p">{</span>
    <span class="s">&#34;Title&#34;</span><span class="p">:</span>   <span class="s">&#34;Hey!&#34;</span><span class="p">,</span>
    <span class="s">&#34;Message&#34;</span><span class="p">:</span> <span class="s">&#34;This is the index template.&#34;</span><span class="p">,</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre></div><h2 id="03-小结">03 小结</h2>
<p>本文简单介绍了 Fiber 的一些特性。因为 Fiber 是受 Express 启发实现的，因此和 Express 进行了对比。不知道你对 Fiber 有什么感觉？</p>
<p>下篇文章会较详细的介绍 Fiber 的一些特性。</p>
]]></content>
		</item>
		
		<item>
			<title>Go Module：私有不合规库怎么解决引用问题</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/go-illegal-private-import/</link>
			<pubDate>Sun, 12 Sep 2021 17:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/go-illegal-private-import/</guid>
			<description>大家好，我是 polarisxu。 有一个朋友咨询一个问题： 实际项目中，使用 Go Module 难免会有一些自己的库要引用，这些库使用自建的 Git 服务管理，比如 GitLab 等。针对这样的情况，不少教程都是让设置 GOPRIVATE，即不走 GOPROXY。 然而，有些时候，不仅库是私有的，而且地址很可能不是「合规」的。什么是「不合规」的？ 不是 HTTPS 非 443 或 80 端口 直接使用 IP 地址 不是 HTTPS 问题不大，主要是非 443 或</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>有一个朋友咨询一个问题：</p>
<p><p class="md__image">
  <img src="../imgs/goprivate01.png"
    alt="网友咨询"  />
</p>
</p>
<p>实际项目中，使用 Go Module 难免会有一些自己的库要引用，这些库使用自建的 Git 服务管理，比如 GitLab 等。针对这样的情况，不少教程都是让设置 GOPRIVATE，即不走 GOPROXY。</p>
<p>然而，有些时候，不仅库是私有的，而且地址很可能不是「合规」的。什么是「不合规」的？</p>
<ul>
<li>不是 HTTPS</li>
<li>非 443 或 80 端口</li>
<li>直接使用 IP 地址</li>
</ul>
<p>不是 HTTPS 问题不大，主要是非 443 或 80，以及直接 IP 地址的问题比较大。因为 Go 不支持下面的语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;studygolang.com:8081/polarisxu/util&#34;</span>
<span class="kn">import</span> <span class="s">&#34;192.168.1.1:80/polarisxu/util&#34;</span>
</code></pre></div><p>一般地，我们应该避免出现这样的情况，毕竟太恶心，而且没必要自讨苦吃。</p>
<p>但万一遇到了，怎么办？本文就探讨这个问题。</p>
<h2 id="01-模拟环境">01 模拟环境</h2>
<p>因为之前没遇到这样的问题，为了我更好的解决，这位朋友直接提供了他的环境供我试验。我注册了账号，并创建了一个仓库 testgo：<a href="http://vitogo.tpddns.cn:9000/polarisxu/testgo" target="_blank" rel="noopener">http://vitogo.tpddns.cn:9000/polarisxu/testgo</a>
。（为了方便，这个仓库是 public）</p>
<blockquote>
<p>提示：你想试验，可以自己注册一个账号试试。当然，也可以通过 gitlab 本地搭建一个。</p>
</blockquote>
<p>仓库中创建文件 testgo.go，内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">testgo</span>

<span class="kd">func</span> <span class="nf">MyName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="s">&#34;polarisxu&#34;</span>
<span class="p">}</span>
</code></pre></div><p>关键是这个库的 go.mod 如何写？</p>
<p>很显然，我们不能直接用 <code>vitogo.tpddns.cn:9000/polarisxu/testgo</code> 这样的 module 名称。</p>
<h2 id="02-module-名称">02 module 名称</h2>
<p>那怎么办？</p>
<p>我们可以借助 git 的功能，将 <code>vitogo.tpddns.cn:9000</code> 替换掉：（也可以直接修改 <code>~/.gitconfig</code> 文件）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">git config --global url.<span class="s2">&#34;http://vitogo.tpddns.cn:9000/&#34;</span>.insteadof <span class="s2">&#34;https://{{gitlab_url}}/&#34;</span>
</code></pre></div><p>这里有两点需要注意：</p>
<p>1）url 后面的内容，具体什么值，需要根据你的情况定。</p>
<p>可以通过你的自建仓库查看：</p>
<p><p class="md__image">
  <img src="../imgs/goprivate02.png"
    alt="查看 clone"  />
</p>
</p>
<p>这里选择 HTTP 方式（因为我创建了一个 public 仓库）。也可以选择使用 ssh 方式，这样即使私有仓库，你配置上自己的 SSH KEY 也可正常 Pull。（如何配置 SSH KEY，网上很容易查到教程，GitHub 上就有）</p>
<p>我们这里使用了 <code>http://vitogo.tpddns.cn:9000/</code>，表示这个域名下所有的内容。</p>
<p>2）insteadOf 后面的内容，表示访问这个链接时，将替换为上面 url 后的链接。</p>
<p>这个值写什么？很显然，必须是合规的域名。我们任意使用一个域名试试，比如使用 <code>https://studygolang.com/</code>。</p>
<p>这时，我们尝试执行如下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git config --global url.<span class="s2">&#34;http://vitogo.tpddns.cn:9000/&#34;</span>.insteadof <span class="s2">&#34;https://studygolang.com/&#34;</span>
<span class="c1"># 让 studygolang.com 不走 GOPROXY</span>
$ go env -w <span class="nv">GOPRIVATE</span><span class="o">=</span>studygolang.com
$ go get -v studygolang.com/polarisxu/testgo
go get: unrecognized import path <span class="s2">&#34;studygolang.com/polarisxu/testgo&#34;</span>: parsing studygolang.com/polarisxu/testgo: XML syntax error on line 15: unescaped &lt; inside quoted string
</code></pre></div><p>很好理解，go get 最终需要将代码下载下来，怎么下载？这张图很好的说明了：</p>
<p><p class="md__image">
  <img src="../imgs/goprivate03.png"
    alt="go get 过程"  />
</p>
</p>
<p>那 go get 怎么知道当前仓库使用 VCS 托管的呢？对于 studygolang.com 这种域名，它会尝试请求，判断 CVS 类型。很显然，studygolang.com 没有做任何处理，不是 CVS 类型，所以报错。</p>
<blockquote>
<p>关于这个过程感兴趣的，可以参考该文：<a href="https://studygolang.com/articles/35235" target="_blank" rel="noopener">https://studygolang.com/articles/35235</a>
</p>
</blockquote>
<p>网友希望使用 vitogo.tpddns.cn 这个他的域名，但同样有这个问题。如果要让它正常，需要做特殊处理，具体参考上面的文章。</p>
<p>所以，我们使用一个非常用的现成 Git 公开托管服务，比如 gitea.com。（polarisxu/testgo 我打了一个 tag：v0.0.1）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git config --global url.<span class="s2">&#34;http://vitogo.tpddns.cn:9000/&#34;</span>.insteadof <span class="s2">&#34;https://gitea.com/&#34;</span>
$ go env -w <span class="nv">GOPRIVATE</span><span class="o">=</span>gitea.com
$ go get -v gitea.com/polarisxu/testgo
get <span class="s2">&#34;gitea.com/polarisxu/testgo&#34;</span>: found meta tag vcs.metaImport<span class="o">{</span>Prefix:<span class="s2">&#34;gitea.com/polarisxu/testgo&#34;</span>, VCS:<span class="s2">&#34;git&#34;</span>, RepoRoot:<span class="s2">&#34;https://gitea.com/polarisxu/testgo.git&#34;</span><span class="o">}</span> at //gitea.com/polarisxu/testgo?go-get<span class="o">=</span><span class="m">1</span>
go: downloading gitea.com/polarisxu/testgo v0.0.1
gitea.com/polarisxu/testgo
</code></pre></div><p>成功了！你可以到 <code>$GOPATH/pkg/mod</code> 下面看是否有对应的包。</p>
<blockquote>
<p>注意其中 <code>?go-get=1</code> 这个参数，你可以浏览器访问 <a href="https://gitea.com/polarisxu/testgo?go-get=1" target="_blank" rel="noopener">https://gitea.com/polarisxu/testgo?go-get=1</a>
，然后查看源码，看看里面是什么内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!doctype html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
	<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;go-import&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;gitea.com/polarisxu/testgo git https://gitea.com/polarisxu/testgo.git&#34;</span><span class="p">&gt;</span>
		<span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;go-source&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;gitea.com/polarisxu/testgo _ https://gitea.com/polarisxu/testgo/src/branch/master{/dir} https://gitea.com/polarisxu/testgo/src/branch/master{/dir}/{file}#L{line}&#34;</span><span class="p">&gt;</span>
	<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
	<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
		go get gitea.com/polarisxu/testgo
	<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div></blockquote>
<p>因此，我们可以在 polarisxu/testgo 中增加 go.mod 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">go mod init gitea.com/polarisxu/testgo
</code></pre></div><p>然后打上第二个 tag：v0.0.2，再次获取：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get -v gitea.com/polarisxu/testgo
get <span class="s2">&#34;gitea.com/polarisxu/testgo&#34;</span>: found meta tag vcs.metaImport<span class="o">{</span>Prefix:<span class="s2">&#34;gitea.com/polarisxu/testgo&#34;</span>, VCS:<span class="s2">&#34;git&#34;</span>, RepoRoot:<span class="s2">&#34;https://gitea.com/polarisxu/testgo.git&#34;</span><span class="o">}</span> at //gitea.com/polarisxu/testgo?go-get<span class="o">=</span><span class="m">1</span>
go: downloading gitea.com/polarisxu/testgo v0.0.2
gitea.com/polarisxu/testgo
</code></pre></div><h2 id="03-使用该包">03 使用该包</h2>
<p>本地创建一个项目，引用上面定义的包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ mkdir ~/testprivate
$ <span class="nb">cd</span> ~/testprivate
$ go mod init testprivate
$ touch main.go
</code></pre></div><p>在 main.go 中输入如下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;gitea.com/polarisxu/testgo&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="nx">testgo</span><span class="p">.</span><span class="nf">MyName</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><p>执行 go mod tidy 后，运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run main.go
Hello polarisxu
</code></pre></div><p>正常输出我们期望的结果。</p>
<h2 id="04-总结">04 总结</h2>
<p>通过了解 go get 的基本原理，知晓 git 的一些处理方式，以及 GOPRIVATE 的作用。我相信遇到类似的问题，你自己也能够解决了。</p>
<p>注意，如果 gitea.com 你有实际使用，可以选择 gitee.com、try.gogs.io 等。</p>
<p>另外，关于本文的问题，Go 有几个相关 issue 讨论：</p>
<ul>
<li><a href="https://github.com/golang/go/issues/34436" target="_blank" rel="noopener">https://github.com/golang/go/issues/34436</a>
</li>
<li><a href="https://github.com/golang/go/issues/38213" target="_blank" rel="noopener">https://github.com/golang/go/issues/38213</a>
</li>
</ul>
<h2 id="参考文章">参考文章</h2>
<ul>
<li>私有化仓库的 GO 模块使用实践：<a href="https://studygolang.com/articles/35235" target="_blank" rel="noopener">https://studygolang.com/articles/35235</a>
</li>
<li>go modules 使用本地库、合规库、私有库：<a href="https://studygolang.com/articles/35234" target="_blank" rel="noopener">https://studygolang.com/articles/35234</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Go1.17 新特性：go get 变了</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/1.17-golang-go-get-updated/</link>
			<pubDate>Sat, 04 Sep 2021 20:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/1.17-golang-go-get-updated/</guid>
			<description>大家好，我是 polarisxu。 为什么把 Go 的一些小变化单独写文章，而不是一篇文章介绍所有的变化？主要是想让大家对某一个特性有更深的记忆。全部列出，很容易一眼而过，过段时间就忘记了。但一个变化，专门一篇文章介绍，更容易记住。 01 安装命令会警告 一直以来，go get 用于下载并安装 Go 包、命令等，而 go install 在 module 时代几乎很少使用，在 GOPATH 年代，go install 用来编译安装本地项目。 自 1.16 起，官方</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>为什么把 Go 的一些小变化单独写文章，而不是一篇文章介绍所有的变化？主要是想让大家对某一个特性有更深的记忆。全部列出，很容易一眼而过，过段时间就忘记了。但一个变化，专门一篇文章介绍，更容易记住。</p>
<h2 id="01-安装命令会警告">01 安装命令会警告</h2>
<p>一直以来，go get 用于下载并安装 Go 包、命令等，而 go install 在 module 时代几乎很少使用，在 GOPATH 年代，go install 用来编译安装本地项目。</p>
<p>自 1.16 起，官方说，不应该 go get 下载安装命令（即可执行程序），不过只是这么说，却依然可以使用。</p>
<p>但 Go1.17 开始，如果使用 go get 安装命令，会警告：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get github.com/github/hub
go get: installing executables with <span class="s1">&#39;go get&#39;</span> in module mode is deprecated.
	To adjust and download dependencies of the current module, use <span class="s1">&#39;go get -d&#39;</span>.
	To install using requirements of the current module, use <span class="s1">&#39;go install&#39;</span>.
	To install ignoring the current module, use <span class="s1">&#39;go install&#39;</span> with a version,
	like <span class="s1">&#39;go install example.com/cmd@latest&#39;</span>.
	For more information, see https://golang.org/doc/go-get-install-deprecation
	or run <span class="s1">&#39;go help get&#39;</span> or <span class="s1">&#39;go help install&#39;</span>.
</code></pre></div><p>也就是说，go get 只用来下载普通的包，安装可执行程序，应该使用 go install。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go install github.com/github/hub
</code></pre></div><p>这会将 hub 命令安装到 <code>$GOBIN</code> 下。</p>
<p>此外，go get 有一个 flag <code>-d</code>，指示 go get 下载对应的包，但不做编译和安装。将来的版本，<code>-d</code> 会成为默认行为，这样会更快。此外，因为不编译，即使目标依赖在特定平台编译报错，go get 也能正常执行完。</p>
<p>至于为什么用 go install 代替 go get 执行命令安装，这里有详细的说明：<a href="https://docs.studygolang.com/doc/go-get-install-deprecation" target="_blank" rel="noopener">https://docs.studygolang.com/doc/go-get-install-deprecation</a>
，简单说就是和命令的语义更符合。</p>
<blockquote>
<p>告诉大家一个参与开源项目的机会：</p>
<p>如果某个项目提供了怎么安装可执行文件的方法，大概率使用的是 go get，你可以提交一个 PR，将其改为 go install，哈哈哈~</p>
</blockquote>
<h2 id="02-废弃--insecure">02 废弃 -insecure</h2>
<p>go get 的这个 flag 使用的人可能不多。什么时候会用到呢？Go1.16 版本关于这个 flag 的说明：</p>
<blockquote>
<p>The -insecure flag permits fetching from repositories and resolving
custom domains using insecure schemes such as HTTP, and also bypassess
module sum validation using the checksum database. Use with caution.
This flag is deprecated and will be removed in a future version of go.
To permit the use of insecure schemes, use the GOINSECURE environment
variable instead. To bypass module sum validation, use GOPRIVATE or
GONOSUMDB. See &lsquo;go help environment&rsquo; for details.</p>
</blockquote>
<p>这主要用来处理私有仓库没有提供 HTTPS 的情况，同时避免进行数据库校验和检查。不过更建议使用 GOINSECURE 环境变量。看看这个环境变量的说明：</p>
<blockquote>
<p>GOINSECURE
Comma-separated list of glob patterns (in the syntax of Go&rsquo;s path.Match)
of module path prefixes that should always be fetched in an insecure
manner. Only applies to dependencies that are being fetched directly.
Unlike the -insecure flag on &lsquo;go get&rsquo;, GOINSECURE does not disable
checksum database validation. GOPRIVATE or GONOSUMDB may be used
to achieve that.</p>
</blockquote>
<p>Go1.17 直接废弃了 <code>-insecure</code> 这个 flag，必须使用 GOINSECURE 环境变量。但这个环境变量不会禁用数据库校验和检查。</p>
<p>因此，对于私有仓库，如果没有提供 HTTPS，应该配置 GOINSECURE，指明哪些地址启用 INSECURE 模式，同时配置 GOPRIVATE 环境变量，避免数据库校验和检查。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get -insecure github.com/labstack/echo/v4
go get: -insecure flag is no longer supported<span class="p">;</span> use GOINSECURE instead
</code></pre></div><h2 id="03-总结">03 总结</h2>
<p>建议你实际动手试试 go get 命令，同时切换不同的 Go 版本，看看效果，以加深印象。对其中有任何疑问，都可以通过 go 命令的相关帮助找到。比如查看具体环境变量的意思，可以 <code>go help environment</code> 查看 Go 提供的所有环境变量。</p>
]]></content>
		</item>
		
		<item>
			<title>Go1.17 新特性：testing 包的相关变化</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go-1-17-new-features-added-to-testing/</link>
			<pubDate>Sat, 04 Sep 2021 19:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go-1-17-new-features-added-to-testing/</guid>
			<description>大家好，我是 polarisxu。 今天介绍下 Go1.17 中的特性：testing 包的一些变化。先看 Release Notes 关于 testing 变化的描述： Added a new testing flag -shuffle which controls the execution order of tests and benchmarks. The new T.Setenv and B.Setenv methods support setting an environment variable for the duration of the test or benchmark. 关于 shuffle 这个 flag，1.17 还未发布时，我就写过文章介绍：Go1.17这个新特性竟然是6年前提出来的 。关于它的作用，记住关键一点：我们写测试时，测试之间别相互依赖，应该是独立的。 本文着</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>今天介绍下 Go1.17 中的特性：testing 包的一些变化。先看 Release Notes 关于 testing 变化的描述：</p>
<blockquote>
<p>Added a new testing flag -shuffle which controls the execution order of tests and benchmarks.</p>
<p>The new T.Setenv and B.Setenv methods support setting an environment variable for the duration of the test or benchmark.</p>
</blockquote>
<p>关于 shuffle 这个 flag，1.17 还未发布时，我就写过文章介绍：<a href="https://mp.weixin.qq.com/s/8Ju2-daS0s-esDAezP-lZw" target="_blank" rel="noopener">Go1.17这个新特性竟然是6年前提出来的</a>
。关于它的作用，记住关键一点：我们写测试时，测试之间别相互依赖，应该是独立的。</p>
<p>本文着重介绍另外一个特性：T.Setenv 和 B.Setenv。</p>
<p>从名字可以看出，这是设置环境变量用的。T 是单元测试，而 B 是基准测试。</p>
<p>你可能会说，os 包不是有 Setenv 吗？</p>
<p><code>os.Setenv</code> 会影响当前进程的环境变量，而 T.Setenv 和 B.Setenv 只会影响当前测试函数的环境变量，不会对其他测试函数造成影响。通过它们，可以做到每个测试有自己的独立的环境变量。</p>
<p>Go 源码中，有不少测试文件使用了这个新功能，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestImportVendor</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">testenv</span><span class="p">.</span><span class="nf">MustHaveGoBuild</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// really must just have source
</span><span class="c1"></span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;GO111MODULE&#34;</span><span class="p">,</span> <span class="s">&#34;off&#34;</span><span class="p">)</span>

	<span class="nx">ctxt</span> <span class="o">:=</span> <span class="nx">Default</span>
	<span class="nx">wd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getwd</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ctxt</span><span class="p">.</span><span class="nx">GOPATH</span> <span class="p">=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">wd</span><span class="p">,</span> <span class="s">&#34;testing/demo&#34;</span><span class="p">)</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctxt</span><span class="p">.</span><span class="nf">Import</span><span class="p">(</span><span class="s">&#34;c/d&#34;</span><span class="p">,</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">ctxt</span><span class="p">.</span><span class="nx">GOPATH</span><span class="p">,</span> <span class="s">&#34;src/a/b&#34;</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;cannot find vendored c/d from testdata src/a/b directory: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">want</span> <span class="o">:=</span> <span class="s">&#34;a/vendor/c/d&#34;</span>
	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ImportPath</span> <span class="o">!=</span> <span class="nx">want</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Import succeeded but found %q, want %q&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ImportPath</span><span class="p">,</span> <span class="nx">want</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>具体源码：<a href="https://github.com/golang/go/blob/891547e2d4bc2a23973e2c9f972ce69b2b48478e/src/go/build/build_test.go#L556" target="_blank" rel="noopener">https://github.com/golang/go/blob/891547e2d4bc2a23973e2c9f972ce69b2b48478e/src/go/build/build_test.go#L556</a>
。</p>
<p>如果你项目中的测试依赖环境变量，可以考虑使用这个新的函数。</p>
<p>注意：在 Parallel 测试中不能使用 Setenv。</p>
]]></content>
		</item>
		
		<item>
			<title>StackOverflow 上关于 Go select 死锁的问题</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/chained-channel-operations-in-a-single-select-case/</link>
			<pubDate>Mon, 30 Aug 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/chained-channel-operations-in-a-single-select-case/</guid>
			<description>大家好，我是 polarisxu。 前两天，火丁笔记发了一篇文章：《一个 select 死锁问题》 ，又是一个小细节。我将其中的问题改一下，更好理解： package main import &amp;#34;sync&amp;#34; func main() { var wg sync.WaitGroup foo := make(chan int) bar := make(chan int) wg.Add(1) go func() { defer wg.Done() select { case foo &amp;lt;- &amp;lt;-bar: default: println(&amp;#34;default&amp;#34;) } }() wg.Wait() } 按常规理解，go func 中的 select 应该执行 default 分支，程序正常运行。但结果却不是，而是死锁。可以通过该链接测试：https://play.studygolang.com/p</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>前两天，火丁笔记发了一篇文章：<a href="https://blog.huoding.com/2021/08/29/947" target="_blank" rel="noopener">《一个 select 死锁问题》</a>
，又是一个小细节。我将其中的问题改一下，更好理解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;sync&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">foo</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="nx">bar</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">foo</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">bar</span><span class="p">:</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nb">println</span><span class="p">(</span><span class="s">&#34;default&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>按常规理解，go func 中的 select 应该执行 default 分支，程序正常运行。但结果却不是，而是死锁。可以通过该链接测试：<a href="https://play.studygolang.com/p/kF4pOjYXbXf" target="_blank" rel="noopener">https://play.studygolang.com/p/kF4pOjYXbXf</a>
。</p>
<p>原因文章也解释了，Go 语言规范中有这么一句：</p>
<blockquote>
<p>For all the cases in the statement, the channel operands of receive operations and the channel and right-hand-side expressions of send statements are evaluated exactly once, in source order, upon entering the “select” statement. The result is a set of channels to receive from or send to, and the corresponding values to send. Any side effects in that evaluation will occur irrespective of which (if any) communication operation is selected to proceed. Expressions on the left-hand side of a RecvStmt with a short variable declaration or assignment are not yet evaluated.</p>
</blockquote>
<p>不知道大家看懂没有？于是，最后来了一个例子验证你是否理解了：为什么每次都是输出一半数据，然后死锁？（同样，这里可以运行查看结果：<a href="https://play.studygolang.com/p/zoJtTzI7K5T" target="_blank" rel="noopener">https://play.studygolang.com/p/zoJtTzI7K5T</a>
）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">talk</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">sleep</span> <span class="kt">int</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s %d&#34;</span><span class="p">,</span> <span class="nx">msg</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">sleep</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">fanIn</span><span class="p">(</span><span class="nx">input1</span><span class="p">,</span> <span class="nx">input2</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">input1</span><span class="p">:</span>
			<span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">input2</span><span class="p">:</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nf">fanIn</span><span class="p">(</span><span class="nf">talk</span><span class="p">(</span><span class="s">&#34;A&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="nf">talk</span><span class="p">(</span><span class="s">&#34;B&#34;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\n&#34;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>有没有这种感觉：</p>
<p><p class="md__image">
  <img src="../imgs/select-channel-deadlock.png"
    alt="算法入门"  />
</p>
</p>
<p>这是 StackOverflow 上的一个问题：<a href="https://stackoverflow.com/questions/51167940/chained-channel-operations-in-a-single-select-case" target="_blank" rel="noopener">https://stackoverflow.com/questions/51167940/chained-channel-operations-in-a-single-select-case</a>
。</p>
<p>关键点和文章开头例子一样，在于 select case 中两个 channel 串起来，即 fanIn 函数中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">input1</span><span class="p">:</span>
<span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">input2</span><span class="p">:</span>
<span class="p">}</span>
</code></pre></div><p>如果改为这样就一切正常：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="nx">t</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">input1</span><span class="p">:</span>
  <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">t</span>
<span class="k">case</span> <span class="nx">t</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">input2</span><span class="p">:</span>
  <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">t</span>
<span class="p">}</span>
</code></pre></div><p>结合这个更复杂的例子分析 Go 语言规范中的那句话。</p>
<p>对于 select 语句，在进入该语句时，会按源码的顺序对每一个 case 子句进行求值：这个求值只针对发送或接收操作的额外表达式。</p>
<p>比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ch 是一个 chan int；
</span><span class="c1">// getVal() 返回 int
</span><span class="c1">// input 是 chan int
</span><span class="c1">// getch() 返回 chan int
</span><span class="c1"></span><span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nf">getVal</span><span class="p">():</span>
  <span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">input</span><span class="p">:</span>
  <span class="k">case</span> <span class="nf">getch</span><span class="p">()</span> <span class="o">&lt;-</span> <span class="mi">1</span><span class="p">:</span>
  <span class="k">case</span> <span class="o">&lt;-</span> <span class="nf">getch</span><span class="p">():</span>
<span class="p">}</span>
</code></pre></div><p>在没有选择某个具体 case 执行前，例子中的 <code>getVal()</code>、<code>&lt;-input</code> 和 <code>getch()</code> 会执行。这里有一个验证的例子：<a href="https://play.studygolang.com/p/DkpCq3aQ1TE" target="_blank" rel="noopener">https://play.studygolang.com/p/DkpCq3aQ1TE</a>
。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nf">getVal</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;in first case&#34;</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nf">getVal</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;in second case&#34;</span><span class="p">)</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;default&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;The val:&#34;</span><span class="p">,</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getVal</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;getVal, i=&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</code></pre></div><p>无论 select 最终选择了哪个 case，<code>getVal()</code> 都会按照源码顺序执行：<code>getVal(1)</code> 和 <code>getVal(2)</code>，也就是它们必然先输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">getVal, <span class="nv">i</span><span class="o">=</span> <span class="m">1</span>
getVal, <span class="nv">i</span><span class="o">=</span> <span class="m">2</span>
</code></pre></div><p>你可以仔细琢磨一下。</p>
<p>现在回到 StackOverflow 上的那个问题。</p>
<p>每次进入以下 select 语句时：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">input1</span><span class="p">:</span>
<span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">input2</span><span class="p">:</span>
<span class="p">}</span>
</code></pre></div><p><code>&lt;-input1</code> 和 <code>&lt;-input2</code> 都会执行，相应的值是：A x 和 B x（其中 x 是 0-5）。但每次 select 只会选择其中一个 case 执行，所以 <code>&lt;-input1</code> 和 <code>&lt;-input2</code> 的结果，必然有一个被丢弃了，也就是不会被写入 ch 中。因此，一共只会输出 5 次，另外 5 次结果丢掉了。（你会发现，输出的 5 次结果中，x 比如是 0 1 2 3 4）</p>
<p>而 main 中循环 10 次，只获得 5 次结果，所以输出 5 次后，报死锁。</p>
<hr>
<p>虽然这是一个小细节，但实际开发中还是有可能出现的。比如文章提到的例子写法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ch 是一个 chan int；
</span><span class="c1">// getVal() 返回 int
</span><span class="c1">// input 是 chan int
</span><span class="c1">// getch() 返回 chan int
</span><span class="c1"></span><span class="k">select</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nf">getVal</span><span class="p">():</span>
  <span class="k">case</span> <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="o">&lt;-</span><span class="nx">input</span><span class="p">:</span>
  <span class="k">case</span> <span class="nf">getch</span><span class="p">()</span> <span class="o">&lt;-</span> <span class="mi">1</span><span class="p">:</span>
  <span class="k">case</span> <span class="o">&lt;-</span> <span class="nf">getch</span><span class="p">():</span>
<span class="p">}</span>
</code></pre></div><p>因此在使用 select 时，一定要注意这种可能的问题。</p>
<p>不要以为这个问题不会遇到，其实很常见。最多的就是 time.After 导致内存泄露问题，网上有很多文章解释原因，如何避免，其实最根本原因就是因为 select 这个机制导致的。</p>
<p>比如如下代码，有内存泄露（传递给 time.After 的时间参数越大，泄露会越厉害），你能解释原因吗？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span>  <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="p">{</span>
            <span class="nx">i</span><span class="o">++</span>
            <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">i</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">x</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">ch</span><span class="p">:</span>
            <span class="nb">println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">):</span>
            <span class="nb">println</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>新书推荐：用 Gin 框架构建分布式应用</title>
			<link>https://polarisxu.studygolang.com/posts/go/book/building-distributed-applications-in-gin/</link>
			<pubDate>Wed, 25 Aug 2021 22:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/book/building-distributed-applications-in-gin/</guid>
			<description>大家好，我是 polarisxu。 有段时间没推荐新书了。最近看到一本书《Building Distributed Applications in Gin》，本书是学习如何使用 Gin 中的各种功能构建大规模分布式应用程序的有效指南。出版日期：2021 年 7 月 23 日，英文版（目前肯定没有中文版）。购买地址：https://www.packtpub.com/web-development/building-distribute</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>有段时间没推荐新书了。最近看到一本书《Building Distributed Applications in Gin》，本书是学习如何使用 Gin 中的各种功能构建大规模分布式应用程序的有效指南。出版日期：2021 年 7 月 23 日，英文版（目前肯定没有中文版）。购买地址：<a href="https://www.packtpub.com/web-development/building-distributed-applications-in-gin" target="_blank" rel="noopener">https://www.packtpub.com/web-development/building-distributed-applications-in-gin</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/build-application-with-gin.png"
    alt=""  />
</p>
</p>
<p>介绍下本书的作者：<strong>Mohamed Labouardy</strong></p>
<p>他是 Crew 的 CTO 和联合创始人，同时也是 DevSecOps 的布道师。他是 Komiser 的创始人，经常在会议上演讲，并且写了几本关于无服务器和分布式应用的书。他也是诸如 Jenkins、 Docker 和 Telegraf 等许多开源项目的贡献者。</p>
<p>从这本书，你可以学习到如下知识点：</p>
<ul>
<li>使用 Gin 框架构建一个生产环境可用的 REST API</li>
<li>基于事件驱动架构构建可扩展 Web 应用程序</li>
<li>使用 NoSQL 数据库进行数据持久化</li>
<li>使用 JWT 和 Auth0 建立身份验证中间件</li>
<li>使用 Docker 和 Kubernetes 在 AWS 上部署基于 gin 的 RESTful API</li>
<li>为 Gin Web 应用实现 CI/CD 工作流</li>
</ul>
<p>全书一共分成三部分：</p>
<p>1）第一部分，介绍 Gin 框架。包括简单介绍 Go、安装 Go 环境，以及安装 Gin。</p>
<p>2）第二部分，分布式微服务。分 5 章介绍，包括确认 Endpoint、存储、API 认证、HTML 渲染和扩展 Gin 应用。</p>
<p>3）第三部分，非基础功能。分 4 章介绍，包括 Gin HTTP 路由测试、在 AWS 上部署应用（这个咱们可能用的较少，一般会使用国内的云服务）、实现 CI/CD 和获取 Gin 的度量指标用于监控等。</p>
<hr>
<p>对于没有 Go 项目经验的朋友，这本书也许能够让你更好开始自己的项目，包括练手项目，为找工作、实际工作做准备！</p>
]]></content>
		</item>
		
		<item>
			<title>Go 官网要变天。。。</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/golang.org-change/</link>
			<pubDate>Tue, 24 Aug 2021 22:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/golang.org-change/</guid>
			<description>大家好，我是 polarisxu。 Golang 官网，有些人可能从来没有访问过，因为国内一般访问不了。但我经常和「它」打交道，因为 Go 语言中文网很早就对 Go 官网做了一个镜像。最近 Go1.17 发布了，利用周末，我把 Go 官网镜像升级了下，但折腾了很久。。。发现 Go 官网要「变天」了！ 之前写过一篇文章：《回顾 Go 官网的演变史》 ，没看的可以看看。 01 这次又变了 如果你访问了 Go 官网（golang.org），</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>Golang 官网，有些人可能从来没有访问过，因为国内一般访问不了。但我经常和「它」打交道，因为 Go 语言中文网很早就对 Go 官网做了一个镜像。最近 Go1.17 发布了，利用周末，我把 Go 官网镜像升级了下，但折腾了很久。。。发现 Go 官网要「变天」了！</p>
<p>之前写过一篇文章：<a href="https://mp.weixin.qq.com/s/7lkBRmjEkElvqHmJVVBWwQ" target="_blank" rel="noopener">《回顾 Go 官网的演变史》</a>
，没看的可以看看。</p>
<h2 id="01-这次又变了">01 这次又变了</h2>
<p>如果你访问了 Go 官网（golang.org），会发现：点击 Packages，跳转到 pkg.go.dev 去了；点击 Blog，跳转到 <a href="https://go.dev/blog/" target="_blank" rel="noopener">https://go.dev/blog/</a>
 了。而且，<a href="https://go.dev/blog/tidy-web" target="_blank" rel="noopener">Russ Cox 发博文</a>
说，在接下来的 1、2 个月内，要将 golang.org 合并入 go.dev。根据 Russ Cox 的说法，现在 Go 相关网站很混乱：</p>
<blockquote>
<p>go.dev 包含了一些有用的信息来帮助人们评估 Go，但是 golang. org 继续提供分发下载、文档和标准库的包参考。其他网站 &mdash;- blog.golang. org、 play.golang. org、 talks.golang.org 和 tour.golang. org&mdash;- 也提供其他材料。这一切都有点支离破碎，令人困惑。</p>
</blockquote>
<p>所以，Go 官方希望能够统一。</p>
<h2 id="02-目前-go-语言中文网继续提供原风格镜像">02 目前 Go 语言中文网继续提供原风格镜像</h2>
<p>实话说，我个人不太喜欢 go.dev 的风格，特别是看标准库，有点别扭，不过可能迟早要习惯！</p>
<p>因为官方大的变动，导致每次想搭建一个镜像，特别费劲。经过折腾，目前依然保持了原 golang.org 风格的官网镜像：<a href="https://docs.studygolang.com" target="_blank" rel="noopener">https://docs.studygolang.com</a>
，国内随便访问，同时 blog、play 等都可以正常访问。</p>
<p>不过，如果 golang.org 彻底废弃，这个镜像可能很难维持原风格，毕竟需要保持更新。还有一种方案就是，更新的内容，我处理成兼容原风格版本！我尽量努力做到，因为我还在基于这个风格翻译成中文版。</p>
<hr>
<p>你喜欢 go.dev 的风格吗？欢迎留言交流！</p>
]]></content>
		</item>
		
		<item>
			<title>Gin 这是要成为 Go 官方框架？</title>
			<link>https://polarisxu.studygolang.com/posts/go/web-service-gin/</link>
			<pubDate>Mon, 23 Aug 2021 22:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/web-service-gin/</guid>
			<description>大家好，我是 polarisxu。 常浏览 Go 官方网站的朋友可能留意到，Go 网站近一段时间增加了不少文档、教程。可能官方意识到，Go 被越来越多的用于 API 开发，于是近期又出了一个这方面的教程：《Tutorial: Developing a RESTful API with Go and Gin》 。 是的，基于 Gin 框架。在众多框架中，Go 官方选择了 Gin 框架，可见这个框架的受欢迎程度。 这份官方的教程包含以下几个方面： 设计 API 接口：以一个虚拟</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>常浏览 Go 官方网站的朋友可能留意到，Go 网站近一段时间增加了不少文档、教程。可能官方意识到，Go 被越来越多的用于 API 开发，于是近期又出了一个这方面的教程：<a href="https://docs.studygolang.com/doc/tutorial/web-service-gin" target="_blank" rel="noopener">《Tutorial: Developing a RESTful API with Go and Gin》</a>
。</p>
<p>是的，基于 Gin 框架。在众多框架中，Go 官方选择了 Gin 框架，可见这个框架的受欢迎程度。</p>
<p>这份官方的教程包含以下几个方面：</p>
<ul>
<li>设计 API 接口：以一个虚拟相册应用为例</li>
<li>创建项目目录结构</li>
<li>构建需要的数据</li>
<li>处理器（handler）：获取所有相册数据、创建一条记录、获取一条记录</li>
</ul>
<p>这是一个超级简单的入门教程，完整代码也就 60 多行。这份教程让你对 Gin 框架有一个基本了解，同时如何构建一个项目有一定的参考。</p>
<p>这个教程出现在 Go 官方网站，对 Gin 来说是大好事，毕竟 Go 框架那么多，现在一定程度上说是得到了官方的认可。</p>
<p>目前 Gin 项目有 50k+ 的 Star，Go 框架类 Star 数第一，甚至在 GitHub 整个 Go Topic 下都排第 6。它的官方文档也已经有各国语言翻译版，其中包括简体中文版：<a href="https://gin-gonic.com/zh-cn/docs/" target="_blank" rel="noopener">https://gin-gonic.com/zh-cn/docs/</a>
。</p>
<p>Gin 官方也有很多示例：<a href="https://github.com/gin-gonic/examples" target="_blank" rel="noopener">https://github.com/gin-gonic/examples</a>
。</p>
<p>此外，Gin 这个框架的教程也很多，框架也有了马太效应。。。</p>
<p>所以，这个框架建议你了解、试用下。当然，也顺带推荐我一直在用的一个框架：<a href="https://github.com/labstack/echo" target="_blank" rel="noopener">https://github.com/labstack/echo</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>扬眉吐气：刚刚，Go 已经默认支持泛型了</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go-generic/</link>
			<pubDate>Sun, 22 Aug 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go-generic/</guid>
			<description>大家好，我是 polarisxu。 上周 Go 1.17 发布，在发布文档中，没有提到泛型的事情。但在发布之前，大家就发现，泛型的相关代码在 1.17 中埋下了，只是默认不启用。 就在最近，gotip 已经默认启用泛型。Go 泛型官方叫做：type parameters。 -G 的默认值由 0 改为了 3，那 Go 1.17 有没有这个 flag？ 01 Go1.17 启用泛型支持 安装 Go1.17，推荐使用类似 goup 这样的工具，方便切换版本，</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>上周 Go 1.17 发布，在发布文档中，没有提到泛型的事情。但在发布之前，大家就发现，泛型的相关代码在 1.17 中埋下了，只是默认不启用。</p>
<p>就在最近，gotip 已经默认启用泛型。Go 泛型官方叫做：type parameters。</p>
<p><p class="md__image">
  <img src="../imgs/go-generic01.png"
    alt=""  />
</p>
</p>
<p><code>-G</code> 的默认值由 0 改为了 3，那 Go 1.17 有没有这个 flag？</p>
<h2 id="01-go117-启用泛型支持">01 Go1.17 启用泛型支持</h2>
<p>安装 Go1.17，推荐使用类似 <a href="https://mp.weixin.qq.com/s/yTblk9Js1Zcq5aWVcYGjOA" target="_blank" rel="noopener">goup</a>
 这样的工具，方便切换版本，确保已经是 1.17：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go version
go version go1.17 darwin/amd64
</code></pre></div><p>然后执行如下命令，查看编译器 flag：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go tool compile -h
usage: compile <span class="o">[</span>options<span class="o">]</span> file.go...
  -% int
    	debug non-static initializers
  -+	compiling runtime
  -B	disable bounds checking
  -C	disable printing of columns in error messages
  -D path
    	<span class="nb">set</span> relative path <span class="k">for</span> <span class="nb">local</span> imports
  -E	debug symbol <span class="nb">export</span>
  -G	accept generic code
  -I directory
    	add directory to import search path
  ....
</code></pre></div><p>注意到：<code>-G	accept generic code</code> 了吧，通过它来控制是否接受泛型代码，这个 flag 可能是临时性的。从这个帮助文档上没有看到 <code>-G</code> 能够接受那些值，通过查代码可以知晓（包括上面提到默认值由 0 改为 3），0 表示不启用泛型，3 表示启用泛型。</p>
<p>看一个具体泛型的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Addable</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span>
		<span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">,</span> <span class="kt">uintptr</span><span class="p">,</span>
		<span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span><span class="p">,</span> <span class="kt">complex64</span><span class="p">,</span> <span class="kt">complex128</span><span class="p">,</span>
		<span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">add</span><span class="p">[</span><span class="nx">T</span> <span class="nx">Addable</span><span class="p">](</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">add</span><span class="p">(</span><span class="s">&#34;foo&#34;</span><span class="p">,</span><span class="s">&#34;bar&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>例子来自：<a href="https://github.com/mattn/go-generics-example" target="_blank" rel="noopener">https://github.com/mattn/go-generics-example</a>
。</p>
</blockquote>
<p>使用 Go1.17 编译：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go build test.go
<span class="c1"># command-line-arguments</span>
./test.go:8:2: syntax error: unexpected type, expecting method or interface name
./test.go:14:6: missing <span class="k">function</span> body
./test.go:14:9: syntax error: unexpected <span class="o">[</span>, expecting <span class="o">(</span>
</code></pre></div><p>发现报语法错误。</p>
<p>改成这样编译：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go build -gcflags<span class="o">=</span>-G<span class="o">=</span><span class="m">3</span> test.go
</code></pre></div><p>一切正常，运行也得到了正确的结果。表明 Go1.17 支持泛型了。</p>
<h2 id="02-gotip-默认支持泛型">02 gotip 默认支持泛型</h2>
<p>上面提到，目前 gotip 已经将 <code>-G</code> 默认值改为了 3，也就是默认就支持泛型了。（gotip 即是 go 仓库的 master 分支代码）</p>
<p>基于上面的代码用 gotip 试验下，确保版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go version
go version devel go1.18-6416bde023 Sun Aug <span class="m">22</span> 13:54:24 <span class="m">2021</span> +0000 darwin/amd64
</code></pre></div><p>直接运行上面的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run add.go
<span class="m">3</span>
foobar
</code></pre></div><p>关于默认启用泛型 HN 上有很多讨论：<a href="https://news.ycombinator.com/item?id=28253692" target="_blank" rel="noopener">https://news.ycombinator.com/item?id=28253692</a>
，有认为泛型来的太晚的，有说 Go 根本不需要泛型的。</p>
<p>我觉得，如果你不喜欢泛型，完全可以不用嘛。很多时候，泛型还是很有好处的。相关泛型的教程，后续可以慢慢出了。</p>
<h2 id="03-总结">03 总结</h2>
<p>Go 1.17 虽然支持了泛型，但不建议线上使用，毕竟官方承诺的是 Go1.18 正式启用泛型。而且，有了泛型，需要更多相关工具、标准库的支持，才能够用起来更顺手。Go1.18，2022 年 2 月见！</p>
]]></content>
		</item>
		
		<item>
			<title>Go 1.17 新特性：Module 有哪些变化？</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go1.17-module/</link>
			<pubDate>Sat, 21 Aug 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go1.17-module/</guid>
			<description>大家好，我是 polarisxu。 自从 Go1.11 增加 Go Module 以来，每个版本都在不断改进 Module。Go1.17 也不例外。这次最主要的变化有两点： Module graph pruning：Module 依赖图修剪 Lazy Loading：Module 延迟加载 此外还有 Deprecated 注释等。本文就一起探究下这些新变化，因为有人没看懂，不知道这些变化是什么意思。 01 Module 依赖图修剪 要搞懂这个知识点，需要对比 1.17 之前的情况。 注意，</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>自从 Go1.11 增加 Go Module 以来，每个版本都在不断改进 Module。Go1.17 也不例外。这次最主要的变化有两点：</p>
<ul>
<li>Module graph pruning：Module 依赖图修剪</li>
<li>Lazy Loading：Module 延迟加载</li>
</ul>
<p>此外还有 Deprecated 注释等。本文就一起探究下这些新变化，因为有人没看懂，不知道这些变化是什么意思。</p>
<h2 id="01-module-依赖图修剪">01 Module 依赖图修剪</h2>
<p>要搞懂这个知识点，需要对比 1.17 之前的情况。</p>
<blockquote>
<p>注意，这个变化并不会影响 go mod 的任何使用</p>
</blockquote>
<p>为了方便演示，我们构建一个这样的例子。</p>
<p>有四个模块：主模块（studymod）和 a、b、c 三个模块，如下图：</p>
<p><p class="md__image">
  <img src="../imgs/study1.17mod01.png"
    alt=""  />
</p>
</p>
<p>module studymod 是我们的项目，它依赖模块 a 中的 x 包，而 x 包依赖模块 b，同时 a 包中的 y 包依赖模块 c。</p>
<p>很显然，对我们的项目 studymod 来说，模块 c 的代码根本没用上。Go 1.17 对 module 的改进主要就是在这种没用上的模块上。</p>
<h3 id="基于-go116">基于 Go1.16</h3>
<p>假定在 <code>$HOME</code> 下创建一个新目录 gomod116，构建如下目录结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>xuxinhua@/Users/xuxinhua/gomod116<span class="o">]</span>
$ tree -L <span class="m">3</span>
.
├── a
│   ├── x
│   │   └── x.go	// 包含正确的包定义和 import
│   └── y
│       └── y.go
├── b
│   └── b.go
├── c
│   └── c.go
└── studymod.go
</code></pre></div><p>在 Go 文件中只是简单的定义包和 import。几个 go 文件的内容分别如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// x.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">x</span>

<span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;b&#34;</span>

<span class="c1">// y.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">y</span>

<span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;c&#34;</span>

<span class="c1">// b.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">b</span>

<span class="c1">// c.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">c</span>

<span class="c1">// studymod.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">studymod</span>

<span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;a/x&#34;</span>
</code></pre></div><p>进入 gomod116 目录，将 Go 版本切换到 Go1.16.x（多版本发挥作用了，多版本问题，可以看看这篇文章：<a href="https://mp.weixin.qq.com/s/yTblk9Js1Zcq5aWVcYGjOA" target="_blank" rel="noopener">终于找到了一款我喜欢的安装和管理 Go 版本的工具</a>
），然后执行下列命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go mod init studymod
$ <span class="nb">cd</span> a
$ go mod init a
$ <span class="nb">cd</span> ../b
$ go mod init b
$ <span class="nb">cd</span> ../c
$ go mod init c
</code></pre></div><p>因为模块 a 依赖模块 b 和 c，往 a/go.mod 增加如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">module a

go 1.16

require <span class="o">(</span>
    b v0.1.0
    c v0.1.0
<span class="o">)</span>
</code></pre></div><p>在 gomod116 根目录的 go.mod 增加如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">module studymod

go 1.16

require a v0.1.0

replace <span class="o">(</span>
        a v0.1.0 <span class="o">=</span>&gt; ./a
        b v0.1.0 <span class="o">=</span>&gt; ./b
        c v0.1.0 <span class="o">=</span>&gt; ./c
<span class="o">)</span>
</code></pre></div><p>因为 studymod 只直接依赖模块 a。replace 部分可以忽略，只是为了本地能够正常引入模块。</p>
<p>此时，在 gomod116 目录下执行 go build，如果不报错，表示一切正常，我们可以执行如下命令看到依赖关系：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go mod graph
studymod a@v0.1.0
a@v0.1.0 b@v0.1.0
a@v0.1.0 c@v0.1.0
</code></pre></div><p>studymod 依赖 a，a 依赖 b 和 c。</p>
<p>但我们知道，studymod 模块实际根本不需要模块 c，因此，我们尝试在 studymod 模块中删除模块 c 的引用，即删除 go.mod 中 replace 部分的 <code> c v0.1.0 =&gt; ./c</code>，再次执行 go build：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go build
go: a@v0.1.0 requires
	c@v0.1.0: missing go.sum entry<span class="p">;</span> to add it:
	go mod download c
</code></pre></div><p>可见模块 c 不能少。（验证后，记得将 go.mod 恢复原样）</p>
<h3 id="基于-go117">基于 Go1.17</h3>
<p>现在我们基于 Go1.17 做类似的验证，将 Go 切到 1.17，执行如下命令，将 gomod116 拷贝一份：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ cp -rf gomod116 gomod117
</code></pre></div><p>然后进入 gomod117 目录，将 go.mod 的 版本由 1.16 改为 1.17：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">module studymod

go 1.17

require a v0.1.0

replace <span class="o">(</span>
    a v0.1.0 <span class="o">=</span>&gt; ./a
    b v0.1.0 <span class="o">=</span>&gt; ./b
    c v0.1.0 <span class="o">=</span>&gt; ./c
<span class="o">)</span>
</code></pre></div><p>接着执行 go mod tidy，发现 go.mod 变成这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">module studymod

go 1.17

require a v0.1.0

require b v0.1.0 // indirect

replace <span class="o">(</span>
        a v0.1.0 <span class="o">=</span>&gt; ./a
        b v0.1.0 <span class="o">=</span>&gt; ./b
        c v0.1.0 <span class="o">=</span>&gt; ./c
<span class="o">)</span>
</code></pre></div><p>多了一行 require，记录了 module studymod 的间接依赖：module <a href="mailto:b@v0.1.0">b@v0.1.0</a>
。执行 go build 一切正常。</p>
<p>跟 Go1.16 一样，删除掉 <code>c v0.1.0 =&gt; ./c</code> 这行，再次执行 go build，依然正常。这就是依赖图裁剪，再看依赖关系，跟 Go1.16 是不一样的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go mod graph
studymod a@v0.1.0
studymod b@v0.1.0
a@v0.1.0 b@v0.1.0
a@v0.1.0 c@v0.1.0
</code></pre></div><h3 id="这么做的优劣">这么做的优劣</h3>
<p>这么做是基于社区的反馈，有兴趣的可以看看这个提案：<a href="https://go.googlesource.com/proposal/&#43;/master/design/36460-lazy-module-loading.md" target="_blank" rel="noopener">Proposal: Lazy Module Loading</a>
，这也是合理的，毕竟没有用到的代码为什么一定需要呢？</p>
<p>此外，裁剪后，go.mod 中会包含入更多的依赖项（完整的依赖列表），新包含的依赖项单独放在一个 require 下。可以通过 <a href="https://github.com/studygolang/studygolang" target="_blank" rel="noopener">https://github.com/studygolang/studygolang</a>
 试验下。下载该代码后，执行如下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go mod tidy -go<span class="o">=</span>1.17
</code></pre></div><p>diff 后，在原来的基础上多出了如下的 require：</p>
<p><p class="md__image">
  <img src="../imgs/study1.17mod02.png"
    alt=""  />
</p>
</p>
<p>有点类似其他语言中 xxx.lock 文件的感觉了。</p>
<p>当然，这种方式后，go.mod 的文件会更大，这也是该方式的一个相对劣势。</p>
<h2 id="02-延迟加载lazy-loading">02 延迟加载（lazy Loading）</h2>
<p>理解了上面依赖图的裁剪，延迟加载就一句话：那些根本没有用上的模块（比如上面例子中的模块 c），Go 1.17 后，Go 命令不会去读取其 go.mod 文件。如果之后需要了，再去加载。</p>
<h2 id="03-deprecated-注释">03 Deprecated 注释</h2>
<p>Go1.17 go.mod 中支持 Deprecated 注释，用来标明该模块废弃了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">// Deprecated: use example.com/mod/v2 instead.
module example.com/mod
</code></pre></div><p>对于那些使用了被废弃的 module 的 go 项目，go list、go get 命令都会给出 warning。</p>
<p>看过我这篇文章：<a href="https://mp.weixin.qq.com/s/mBJ3hQ6oR1V9YtdXpkTnow" target="_blank" rel="noopener">《从 go-chi 框架撤回所有主版本聊 Go1.16 的新特性》</a>
 的朋友，可能会有疑问，撤回和废弃有何不同，如何分别使用？这里稍微总结下：</p>
<p><strong>撤回的使用场景</strong>：</p>
<ul>
<li>发现了一个严重的安全漏洞；</li>
<li>发现了严重的不兼容性或 bug；</li>
<li>这个版本是偶然发布的，或是过早发布了；</li>
</ul>
<p>而 Deprecated 是用来作废整个 module 的，也就是说，不能废弃某个 minor 或 patch 版本。Deprecated 更多用来提示使用者升级到更新的 major 版本，比如要废弃 v1，希望大家升级到 v2，就应该使用 Deprecated。</p>
<h2 id="04-总结">04 总结</h2>
<p>还有其他一些小的变动，这里不一一列举。提醒下大家，从 Go1.16 版本开始，下载安装 Go 二进制程序，不再使用 go get，而是 go install，go get 只用来下载普通包。</p>
<p>因为 module 越来越完善，官方针对 module 也有更完整的文档：<a href="https://docs.studygolang.com/ref/mod" target="_blank" rel="noopener">https://docs.studygolang.com/ref/mod</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 第三方库推荐：类型转换如此简单</title>
			<link>https://polarisxu.studygolang.com/posts/go/pkg/cast/</link>
			<pubDate>Tue, 10 Aug 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/pkg/cast/</guid>
			<description>大家好，我是 polarisxu。 强类型语言有它的优势，但也有不便利的地方，最典型的就是类型转换。Golang 作为一门强类型语言，而且不支持隐式类型转换，因此这个问题更突出。虽然 Go 提供了不少方式进行类型转换，包括相关的标准库，比如 strconv 包。 然而，strconv 包使用没那么方便，比如 &amp;quot;8&amp;quot; 转为 int 类型： s := &amp;#34;8&amp;#34; i, err := strconv.Atoi(s) 你必须对 err 进行处理，因为返回两个值，没法直接将结果传递给</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>强类型语言有它的优势，但也有不便利的地方，最典型的就是类型转换。Golang 作为一门强类型语言，而且不支持隐式类型转换，因此这个问题更突出。虽然 Go 提供了不少方式进行类型转换，包括相关的标准库，比如 strconv 包。</p>
<p>然而，strconv 包使用没那么方便，比如 <code>&quot;8&quot;</code> 转为 int 类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="s">&#34;8&#34;</span>
<span class="nx">i</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</code></pre></div><p>你必须对 err 进行处理，因为返回两个值，没法直接将结果传递给接收 int 参数的函数，使用不方便。</p>
<p>今天给大家介绍一个第三方库，专门处理类型转换的问题。</p>
<h2 id="01-为什么需要类型转换">01 为什么需要类型转换</h2>
<p>有一些场景会需要使用类型转换：</p>
<ul>
<li>从 yaml、toml、json 等配置文件中读取数据；</li>
<li>从网络接收请求数据；</li>
<li>其他通过 interface{} 处理数据的情况；</li>
<li>。。。</li>
</ul>
<p>转换为正确的类型，能充分利用强类型的好处，让程序更健壮、更安全。</p>
<h2 id="02-spf13cast">02 spf13/cast</h2>
<p>第三方包 github.com/spf13/cast 专门解决类型转换的问题，这个包产生于 hugo。当时主要用于处理 yaml 等配置文件数据的转换。该包不会 panic。</p>
<p>该包目前有 1.6k+ 的 Star，有超过 4000 多个开源项目使用了该包。</p>
<p>这个包使用很简单，主要有两套函数：</p>
<p>1）To_ 形式函数</p>
<p>这些函数始终返回所需的类型。如果无法正确转换为对应的类型，则返回目标类型的零值。</p>
<p>支持的类型包括所有的基本数据类型，还支持 time.Time、time.Duration、slice、map 等常用类型。</p>
<p>比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">cast</span><span class="p">.</span><span class="nf">ToString</span><span class="p">(</span><span class="s">&#34;mayonegg&#34;</span><span class="p">)</span>         <span class="c1">// &#34;mayonegg&#34;
</span><span class="c1"></span><span class="nx">cast</span><span class="p">.</span><span class="nf">ToString</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>                  <span class="c1">// &#34;8&#34;
</span><span class="c1"></span><span class="nx">cast</span><span class="p">.</span><span class="nf">ToString</span><span class="p">(</span><span class="mf">8.31</span><span class="p">)</span>               <span class="c1">// &#34;8.31&#34;
</span><span class="c1"></span><span class="nx">cast</span><span class="p">.</span><span class="nf">ToString</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;one time&#34;</span><span class="p">))</span> <span class="c1">// &#34;one time&#34;
</span><span class="c1"></span><span class="nx">cast</span><span class="p">.</span><span class="nf">ToString</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>                <span class="c1">// &#34;&#34;
</span><span class="c1"></span><span class="nx">cast</span><span class="p">.</span><span class="nf">ToTime</span><span class="p">(</span><span class="s">&#34;2021-08-10 22:00:00&#34;</span><span class="p">)</span>	<span class="c1">// 2021-08-10 22:00:00 +0000 UTC
</span></code></pre></div><p>注意，转换为 time.Time 时，需要注意时区问题。ToTime 默认使用 UTC，如果想用其他时区，得类似这么做：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">secondsEastOfUTC</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">((</span><span class="mi">8</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span><span class="p">).</span><span class="nf">Seconds</span><span class="p">())</span>
<span class="nx">beijing</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">FixedZone</span><span class="p">(</span><span class="s">&#34;Beijing Time&#34;</span><span class="p">,</span> <span class="nx">secondsEastOfUTC</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cast</span><span class="p">.</span><span class="nf">ToTimeInDefaultLocation</span><span class="p">(</span><span class="s">&#34;2021-08-10 22:00:00&#34;</span><span class="p">,</span> <span class="nx">beijing</span><span class="p">))</span>
</code></pre></div><p>当然，你也可以这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">cast</span><span class="p">.</span><span class="nf">ToTimeInDefaultLocation</span><span class="p">(</span><span class="s">&#34;2021-08-10 22:00:00&#34;</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Local</span><span class="p">))</span>
</code></pre></div><p>不过，Local 表示本地时区，要明确这个本地是不是你想要的。</p>
<p>2）To_E 形式函数</p>
<p>E 表示 error，也就是说，这一系列函数会返回 error。在无法进行类型转换时，会将错误原因返回。To_ 形式内部调用的是 To_E 形似，只是它忽略了错误。</p>
<p>这种形式就不举例了。一般地，除非你需要区分零值是因为出错导致的还是本身就是零值，否则应该使用 To_ 系列函数，毕竟更省事。</p>
<h2 id="03-总结">03 总结</h2>
<p>大概率，不少公司都有自己类似的库。如果没有，可以考虑使用该库，这样的轮子，没太多必要造。不过这个库有一点我不太喜欢，就是没法指定默认值。</p>
<p>比如，我想在转换失败时，返回我的默认值，而不是默认零值，这个包做不到。常见的场景就是，处理用户可选输入，如果用户没输入，给一个默认值。</p>
<p>配置文件也有这样的场景，比如某个配置项如果没有配置，我希望硬编码一个默认值。因为 cast 不支持，依赖 cast 的 github.com/spf13/viper 库也不支持默认值，导致我会写出这样的繁琐代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">viper</span><span class="p">.</span><span class="nf">SetDefault</span><span class="p">(</span><span class="s">&#34;listen.port&#34;</span><span class="p">,</span> <span class="s">&#34;2021&#34;</span><span class="p">)</span>
<span class="nx">port</span> <span class="o">:=</span> <span class="nx">viper</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="s">&#34;listen.port&#34;</span><span class="p">)</span>
</code></pre></div><p>我更希望的是这样的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">port</span> <span class="o">:=</span> <span class="nx">viper</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="s">&#34;listen.port&#34;</span><span class="p">,</span> <span class="s">&#34;2021&#34;</span><span class="p">)</span>	<span class="c1">// listen.port 没设置时，返回 2021
</span></code></pre></div>]]></content>
		</item>
		
		<item>
			<title>担心密码提交到 GitHub？建议使用这个 Go 开源工具</title>
			<link>https://polarisxu.studygolang.com/posts/go/project/gosec-tool-intro/</link>
			<pubDate>Tue, 10 Aug 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/project/gosec-tool-intro/</guid>
			<description>大家好，我是 polarisxu。 最近跟安全扛上了！这是我分享的 Go 安全相关的第 5 篇文章，前 4 篇文章如下： 《Go 团队开始重视安全问题了》 《Go Module 有漏洞？免费的 Go 漏洞扫描 VSCode 插件》 《这个工具真好：看看你的Go项目依赖有无漏洞》 重磅！GitHub 为 Go 社区带来安全支持 今天要分享的这个开源工具，我个人认为更实用，可以当作一个 vet 工具使用，切切实实检查日常开发经常会忽略的安全</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>最近跟安全扛上了！这是我分享的 Go 安全相关的第 5 篇文章，前 4 篇文章如下：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/-Zv1QwM1lYNWEvIoUNjmXQ" target="_blank" rel="noopener">《Go 团队开始重视安全问题了》</a>
</li>
<li><a href="https://mp.weixin.qq.com/s/NkxIEoOHXbjgqLPhWsKYRA" target="_blank" rel="noopener">《Go Module 有漏洞？免费的 Go 漏洞扫描 VSCode 插件》</a>
</li>
<li><a href="https://mp.weixin.qq.com/s/pzCefw0g82f6fNqiW3wqEg" target="_blank" rel="noopener">《这个工具真好：看看你的Go项目依赖有无漏洞》</a>
</li>
<li><a href="https://mp.weixin.qq.com/s/m3VkJU-m_TXnY59ELW12fQ" target="_blank" rel="noopener">重磅！GitHub 为 Go 社区带来安全支持</a>
</li>
</ul>
<p>今天要分享的这个开源工具，我个人认为更实用，可以当作一个 vet 工具使用，切切实实检查日常开发经常会忽略的安全问题，最常见的，比如将密码提交到 GitHub 上了。。。</p>
<p>这个工具就是 gosec，GitHub 地址：<a href="https://github.com/securego/gosec" target="_blank" rel="noopener">https://github.com/securego/gosec</a>
，截止目前 Star 数 4.9k+，目测这一波能涨不少~</p>
<h2 id="01-简介">01 简介</h2>
<p>这个工具通过扫描 Go 代码的 AST 树来发现安全问题，具体来说，它通过一些规则来检查代码的安全。有专门的官网：<a href="https://securego.io/" target="_blank" rel="noopener">https://securego.io/</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/gosec-logo.png"
    alt="gosec"  />
</p>
</p>
<h2 id="02-安装">02 安装</h2>
<p>官方提供了几种安装方式。作为一个 Go 程序员，我喜欢使用 go get 或 go install 安装。</p>
<blockquote>
<p>Go1.16 开始，安装可执行 Go 程序使用 go install，下载安装普通库，使用 go get</p>
</blockquote>
<p>因为目前最新版本是 v2，因此这么安装：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go install github.com/securego/gosec/v2/cmd/gosec@latest
</code></pre></div><p>当然，你也可以使用官方编译好的安装：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="c1"># binary will be $(go env GOPATH)/bin/gosec</span>
curl -sfL https://raw.githubusercontent.com/securego/gosec/master/install.sh <span class="p">|</span> sh -s -- -b <span class="k">$(</span>go env GOPATH<span class="k">)</span>/bin vX.Y.Z

<span class="c1"># or install it into ./bin/</span>
curl -sfL https://raw.githubusercontent.com/securego/gosec/master/install.sh <span class="p">|</span> sh -s vX.Y.Z

<span class="c1"># In alpine linux (as it does not come with curl by default)</span>
wget -O - -q https://raw.githubusercontent.com/securego/gosec/master/install.sh <span class="p">|</span> sh -s vX.Y.Z

<span class="c1"># If you want to use the checksums provided on the &#34;Releases&#34; page</span>
<span class="c1"># then you will have to download a tar.gz file for your operating system instead of a binary file</span>
wget https://github.com/securego/gosec/releases/download/vX.Y.Z/gosec_vX.Y.Z_OS.tar.gz
</code></pre></div><p>如果你想将其和 CI 工具集成，可以参考和 GitHub Action 的集成方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Run Gosec</span><span class="w">
</span><span class="w"></span><span class="nt">on</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">push</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">master</span><span class="w">
</span><span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">master</span><span class="w">
</span><span class="w"></span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">tests</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-latest</span><span class="w">
</span><span class="w">    </span><span class="nt">env</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">GO111MODULE</span><span class="p">:</span><span class="w"> </span><span class="kc">on</span><span class="w">
</span><span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Checkout Source</span><span class="w">
</span><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actions/checkout@v2</span><span class="w">
</span><span class="w">      </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Run Gosec Security Scanner</span><span class="w">
</span><span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">securego/gosec@master</span><span class="w">
</span><span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">args</span><span class="p">:</span><span class="w"> </span><span class="l">./...</span><span class="w">
</span></code></pre></div><h2 id="03-使用和规则介绍">03 使用和规则介绍</h2>
<p>本地安装好后，执行 gosec -h 可以看到使用帮助：（请确保 gosec 在 PATH 环境变量中）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ gosec -h

gosec - Golang security checker

gosec analyzes Go <span class="nb">source</span> code to look <span class="k">for</span> common programming mistakes that
can lead to security problems.

VERSION: dev
GIT TAG:
BUILD DATE:

USAGE:

	<span class="c1"># Check a single package</span>
	$ gosec <span class="nv">$GOPATH</span>/src/github.com/example/project

	<span class="c1"># Check all packages under the current directory and save results in</span>
	<span class="c1"># json format.</span>
	$ gosec -fmt<span class="o">=</span>json -out<span class="o">=</span>results.json ./...

	<span class="c1"># Run a specific set of rules (by default all rules will be run):</span>
	$ gosec -include<span class="o">=</span>G101,G203,G401  ./...

	<span class="c1"># Run all rules except the provided</span>
	$ gosec -exclude<span class="o">=</span>G101 <span class="nv">$GOPATH</span>/src/github.com/example/project/...


OPTIONS:

  -color
    	Prints the text format report with colorization when it goes in the stdout <span class="o">(</span>default <span class="nb">true</span><span class="o">)</span>
  -conf string
    	Path to optional config file
  -confidence string
    	Filter out the issues with a lower confidence than the given value. Valid options are: low, medium, high <span class="o">(</span>default <span class="s2">&#34;low&#34;</span><span class="o">)</span>
  -exclude string
    	Comma separated list of rules IDs to exclude. <span class="o">(</span>see rule list<span class="o">)</span>
  -exclude-dir value
    	Exclude folder from scan <span class="o">(</span>can be specified multiple <span class="nb">times</span><span class="o">)</span>
  -fmt string
    	Set output format. Valid options are: json, yaml, csv, junit-xml, html, sonarqube, golint, sarif or text <span class="o">(</span>default <span class="s2">&#34;text&#34;</span><span class="o">)</span>
  -include string
    	Comma separated list of rules IDs to include. <span class="o">(</span>see rule list<span class="o">)</span>
  -log string
    	Log messages to file rather than stderr
  -no-fail
    	Do not fail the scanning, even <span class="k">if</span> issues were found
  -nosec
    	Ignores <span class="c1">#nosec comments when set</span>
  -nosec-tag string
    	Set an alternative string <span class="k">for</span> <span class="c1">#nosec. Some examples: #dontanalyze, #falsepositive</span>
  -out string
    	Set output file <span class="k">for</span> results
  -quiet
    	Only show output when errors are found
  -severity string
    	Filter out the issues with a lower severity than the given value. Valid options are: low, medium, high <span class="o">(</span>default <span class="s2">&#34;low&#34;</span><span class="o">)</span>
  -sort
    	Sort issues by severity <span class="o">(</span>default <span class="nb">true</span><span class="o">)</span>
  -stdout
    	Stdout the results as well as write it in the output file
  -tags string
    	Comma separated list of build tags
  -tests
    	Scan tests files
  -verbose string
    	Overrides the output format when stdout the results <span class="k">while</span> saving them in the output file.
    	Valid options are: json, yaml, csv, junit-xml, html, sonarqube, golint, sarif or text
  -version
    	Print version and quit with <span class="nb">exit</span> code <span class="m">0</span>


RULES:

	G101: Look <span class="k">for</span> hardcoded credentials
	G102: Bind to all interfaces
	G103: Audit the use of unsafe block
	G104: Audit errors not checked
	G106: Audit the use of ssh.InsecureIgnoreHostKey <span class="k">function</span>
	G107: Url provided to HTTP request as taint input
	G108: Profiling endpoint is automatically exposed
	G109: Converting strconv.Atoi result to int32/int16
	G110: Detect io.Copy instead of io.CopyN when decompression
	G201: SQL query construction using format string
	G202: SQL query construction using string concatenation
	G203: Use of unescaped data in HTML templates
	G204: Audit use of <span class="nb">command</span> execution
	G301: Poor file permissions used when creating a directory
	G302: Poor file permissions used when creation file or using chmod
	G303: Creating tempfile using a predictable path
	G304: File path provided as taint input
	G305: File path traversal when extracting zip archive
	G306: Poor file permissions used when writing to a file
	G307: Unsafe defer call of a method returning an error
	G401: Detect the usage of DES, RC4, MD5 or SHA1
	G402: Look <span class="k">for</span> bad TLS connection settings
	G403: Ensure minimum RSA key length of <span class="m">2048</span> bits
	G404: Insecure random number <span class="nb">source</span> <span class="o">(</span>rand<span class="o">)</span>
	G501: Import blocklist: crypto/md5
	G502: Import blocklist: crypto/des
	G503: Import blocklist: crypto/rc4
	G504: Import blocklist: net/http/cgi
	G505: Import blocklist: crypto/sha1
	G601: Implicit memory aliasing in RangeStmt
</code></pre></div><p>拿 Go 语言中文网试验一下，切换到 studygolang 源码目录，执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ gosec ./...
...
Summary:
  Gosec  : dev
  Files  : <span class="m">186</span>
  Lines  : <span class="m">27434</span>
  Nosec  : <span class="m">0</span>
  Issues : <span class="m">292</span>
</code></pre></div><p>中间过程输出内容很多，最后进行了汇总。根据默认规则，一共发现了 292 个 issue。但别慌，这里面有些规则太严格了，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>/Users/xuxinhua/project/golang/studygolang/cmd/studygolang/background.go:57<span class="o">]</span> - G104 <span class="o">(</span>CWE-703<span class="o">)</span>: Errors unhandled. <span class="o">(</span>Confidence: HIGH, Severity: LOW<span class="o">)</span>
    56: 		// 生成阅读排行榜
  &gt; 57: 		c.AddFunc<span class="o">(</span><span class="s2">&#34;@daily&#34;</span>, genViewRank<span class="o">)</span>
    58:
</code></pre></div><p>因为 c.AddFunc 会返回 error，这个 error 一般不需要处理（这是启动定时任务进行处理），它提示没有处理，对应的规则是 G104。所以，我们将该规则排除掉：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ gosec -exclude ./...
...
Summary:
  Gosec  : dev
  Files  : <span class="m">186</span>
  Lines  : <span class="m">27434</span>
  Nosec  : <span class="m">0</span>
  Issues : <span class="m">51</span>
</code></pre></div><p>这次 issue 只剩下 51 个。查看过程中指出的问题代码，依然发现有些规则可以忽略，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span>/Users/xuxinhua/project/golang/studygolang/logic/sitemap.go:266<span class="o">]</span> - G307 <span class="o">(</span>CWE-703<span class="o">)</span>: Deferring unsafe method <span class="s2">&#34;Close&#34;</span> on <span class="nb">type</span> <span class="s2">&#34;*os.File&#34;</span> <span class="o">(</span>Confidence: HIGH, Severity: MEDIUM<span class="o">)</span>
    265: 	<span class="o">}</span>
  &gt; 266: 	defer file.Close<span class="o">()</span>
    267:
</code></pre></div><p>对应规则是 G307：Deferring a method which returns an error。大家一般都会这么做，因此这个规则也可以排除。</p>
<p>有兴趣的可以一步步看，默认提供的 30 来个规则都检测了哪些问题，根据你的项目情况，排除或使用哪些规则。</p>
<p>接下来，看一下密码安全问题规则，这是第一个规则：G101，只使用这个规则检测 studygolang 试试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ gosec -include<span class="o">=</span>G101 ./...
...
<span class="o">[</span>/Users/xuxinhua/project/golang/studygolang/http/http.go:437<span class="o">]</span> - G101 <span class="o">(</span>CWE-798<span class="o">)</span>: Potential hardcoded credentials <span class="o">(</span>Confidence: LOW, Severity: HIGH<span class="o">)</span>
    436: const <span class="o">(</span>
  &gt; 437: 	<span class="nv">TokenSalt</span>       <span class="o">=</span> <span class="s2">&#34;b3%JFOykZx_golang_polaris&#34;</span>
    438: 	<span class="nv">NeedReLoginCode</span> <span class="o">=</span> <span class="m">600</span>

Summary:
  Gosec  : dev
  Files  : <span class="m">186</span>
  Lines  : <span class="m">27434</span>
  Nosec  : <span class="m">0</span>
  Issues : <span class="m">1</span>
</code></pre></div><p>挺厉害，检查出了 TokenSalt 写死在代码里了，这是当时准备做 APP 时写的一个 Token，虽然影响不大（因为没有使用），也提醒了这样的应该提前写在配置文件中。</p>
<p>那 gosec 是怎么检测到的呢？在官网对这个规则有说明。它根据名称是否类似下面这些来判断的：</p>
<ul>
<li>“password”</li>
<li>“pass”</li>
<li>“passwd”</li>
<li>“pwd”</li>
<li>“secret”</li>
<li>“token”</li>
</ul>
<p>此外，安全相关特别要注意的就是 XSS 和 SQL 注入，这方面 gosec 也会有相关规则检测，比如 G201、G202、G203。</p>
<p>注意：通过 gosec 检测出的 issue，不代表一定有问题，但对我们是一个很好的提醒，让我们能够审视自己的代码，确保相关地方没问题，知道自己为什么这么写。</p>
<p>gosec 工具其他的使用，可以看文档说明，自己尝试。</p>
<h2 id="04-总结">04 总结</h2>
<p>安全问题，我们永远不能忽视。很多时候，可能不会有问题，但真出了问题可能就是大问题。在写代码时，我们难免会有疏忽，通过使用 gosec 这样的工具，可以为我们把好最后一道关。</p>
<p>赶紧用 gosec 检验一下你的项目吧。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 的时间格式化为什么是 2006-01-02 15:04:05？</title>
			<link>https://polarisxu.studygolang.com/posts/go/why-time-use-2006/</link>
			<pubDate>Tue, 03 Aug 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/why-time-use-2006/</guid>
			<description>大家好，我是 polarisxu。 没有什么是完美的！而且，有些东西，有些人认为好，有些人认为很糟糕。Go 也是如此。喜欢 Go 语言的朋友，大概率对其中某些地方不喜欢。比如，你喜欢 Go 中时间格式化固定的 2006-01-02 15:04:05 -0700 吗？为什么是这么一个时间？今天来一探究竟！ 01 新手的困惑 无论是各种群里还是网上搜一下，包括国外的，对 2006-01-02 15:04:05 -0700 都很困惑。 一般的困扰主要有： 不知道只能固定要这个时间，换其他</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>没有什么是完美的！而且，有些东西，有些人认为好，有些人认为很糟糕。Go 也是如此。喜欢 Go 语言的朋友，大概率对其中某些地方不喜欢。比如，你喜欢 Go 中时间格式化固定的 <code>2006-01-02 15:04:05 -0700</code> 吗？为什么是这么一个时间？今天来一探究竟！</p>
<h2 id="01-新手的困惑">01 新手的困惑</h2>
<p>无论是各种群里还是网上搜一下，包括国外的，对 2006-01-02 15:04:05 -0700 都很困惑。</p>
<p><p class="md__image">
  <img src="../imgs/time-format.png"
    alt=""  />
</p>
</p>
<p>一般的困扰主要有：</p>
<ul>
<li>不知道只能固定要这个时间，换其他的，出来的结果莫名其妙，然后一脸懵逼；</li>
<li>为什么没有像其他语言一样，yyyy-mm-dd 这样的形式？</li>
<li>这个时间有什么特殊意义吗？为什么挑这么个时间，完全记不住；</li>
</ul>
<p>这很正常，毕竟这一点上，Go 很另类，也可以说很“奇葩”。甚至有人注册了一个域名：<a href="http://fuckinggodateformat.com/" target="_blank" rel="noopener">http://fuckinggodateformat.com/</a>
，我也是醉了。。。</p>
<p>但是这真的不好？</p>
<h2 id="02-为什么这么设计">02 为什么这么设计？</h2>
<p>为什么选择这个时间？不少人有这样的疑问。有人猜测是 Go 项目启动的时间等。但仔细研究，发现 Go Team 还是用心良苦，目的是解决大家记忆问题。</p>
<p>比如常规的 ymd 格式，以 PHP 为例，一般这样 <code>Y-m-d H:i:s</code>，输出类似：2021-08-03 09:30:00，但如果我想输出：<code>21-8-4 9:30:00</code>，你不查手册，能写出来吗？你看看 PHP 文档中关于 date 格式化的说明，头有点大，竟然那么多，虽然常用的形式，大部分人都记得，但遇到不怎么常用的，就得查手册了。</p>
<p>反观 Go 语言，它直接使用一个具体的时间来当做格式化字符串，需要什么格式，改这个时间格式即可。比如上面的例子，常规方式：2006-01-02  15:04:05，而 21-8-4 9:30:00 这种格式，只需要对应的改变值即可：06-1-2 3:04:05。而且，我查了下，PHP 没法表示没有前导零的分钟数和秒数，而 Go 很容易实现。很显然，Go 的方式是更合理、更易用的，对于各种变化，也能够更自如的应对。</p>
<p>只不过，很多人对这个具体的时间觉得记不住。这一点，Go 官方也考虑到了。毕竟采用特殊的时间，目的就是为了解决大家记忆问题，因此要确保这个特殊时间也好记。Go 是这么设计的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">1: month <span class="o">(</span>January, Jan, 01, etc<span class="o">)</span>
2: day
3: hour <span class="o">(</span><span class="m">15</span> is 3pm on a <span class="m">24</span> hour clock<span class="o">)</span>
4: minute
5: second
6: year <span class="o">(</span>2006<span class="o">)</span>
7: timezone <span class="o">(</span>GMT-7 is MST<span class="o">)</span>
</code></pre></div><p>刚好是 1 2 3 4 5 6 7，据此进行变化即可。</p>
<p>比如官方定义的常量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">ANSIC</span>       <span class="p">=</span> <span class="s">&#34;Mon Jan _2 15:04:05 2006&#34;</span>
    <span class="nx">UnixDate</span>    <span class="p">=</span> <span class="s">&#34;Mon Jan _2 15:04:05 MST 2006&#34;</span>
    <span class="nx">RubyDate</span>    <span class="p">=</span> <span class="s">&#34;Mon Jan 02 15:04:05 -0700 2006&#34;</span>
    <span class="nx">RFC822</span>      <span class="p">=</span> <span class="s">&#34;02 Jan 06 15:04 MST&#34;</span>
    <span class="nx">RFC822Z</span>     <span class="p">=</span> <span class="s">&#34;02 Jan 06 15:04 -0700&#34;</span> <span class="c1">// RFC822 with numeric zone
</span><span class="c1"></span>    <span class="nx">RFC850</span>      <span class="p">=</span> <span class="s">&#34;Monday, 02-Jan-06 15:04:05 MST&#34;</span>
    <span class="nx">RFC1123</span>     <span class="p">=</span> <span class="s">&#34;Mon, 02 Jan 2006 15:04:05 MST&#34;</span>
    <span class="nx">RFC1123Z</span>    <span class="p">=</span> <span class="s">&#34;Mon, 02 Jan 2006 15:04:05 -0700&#34;</span> <span class="c1">// RFC1123 with numeric zone
</span><span class="c1"></span>    <span class="nx">RFC3339</span>     <span class="p">=</span> <span class="s">&#34;2006-01-02T15:04:05Z07:00&#34;</span>
    <span class="nx">RFC3339Nano</span> <span class="p">=</span> <span class="s">&#34;2006-01-02T15:04:05.999999999Z07:00&#34;</span>
    <span class="nx">Kitchen</span>     <span class="p">=</span> <span class="s">&#34;3:04PM&#34;</span>
<span class="p">)</span>
</code></pre></div><p>按 ANSIC 标准的日期格式，月、日、时、分、秒、年，最后加 MST 时区。对应就是 1 2 3 4 5 6 7。同时还可以随意加星期几。</p>
<p>发现没有？围绕着 1 2 3 4 5 6 7 随意变化，真的不要太爽。我相信你用习惯了会发现 Go 这个设计真的太好了。</p>
<h2 id="03-总结">03 总结</h2>
<p>Go 的设计原则之一：大道至简。尽量简洁，让大家开心编程。我认为这个格式化时间的设计也体现了这一点，他们设计的很用心。</p>
<p>知晓了为什么这么设计，我相信你看完这篇文章会从此爱上 Go 的时间格式化形式。</p>
]]></content>
		</item>
		
		<item>
			<title>GitHub 为 Go 社区带来安全支持</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/github-supply-chain-security-features-go-community/</link>
			<pubDate>Thu, 29 Jul 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/github-supply-chain-security-features-go-community/</guid>
			<description>大家好，我是 polarisxu。 关于 Go 安全相关的内容，我写过几篇文章：《Go 团队开始重视安全问题了》 、《Go Module 有漏洞？免费的 Go 漏洞扫描 VSCode 插件》 和《这个工具真好：看看你的Go项目依赖有无漏洞》 ，有兴趣的可以看看。 今天介绍另外一个关于安全的内容，是 GitHub 的。 大家都知晓，目前 Go 是严重依赖 GitHub 的，很多第三方库基本都托管在 GitHub 上。因为 Go 把 GitHub 既当作代码协作的平台，也当作发布包的</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>关于 Go 安全相关的内容，我写过几篇文章：<a href="https://mp.weixin.qq.com/s/-Zv1QwM1lYNWEvIoUNjmXQ" target="_blank" rel="noopener">《Go 团队开始重视安全问题了》</a>
、<a href="https://mp.weixin.qq.com/s/NkxIEoOHXbjgqLPhWsKYRA" target="_blank" rel="noopener">《Go Module 有漏洞？免费的 Go 漏洞扫描 VSCode 插件》</a>
和<a href="https://mp.weixin.qq.com/s/pzCefw0g82f6fNqiW3wqEg" target="_blank" rel="noopener">《这个工具真好：看看你的Go项目依赖有无漏洞》</a>
，有兴趣的可以看看。</p>
<p>今天介绍另外一个关于安全的内容，是 GitHub 的。</p>
<p>大家都知晓，目前 Go 是严重依赖 GitHub 的，很多第三方库基本都托管在 GitHub 上。因为 Go 把 GitHub 既当作代码协作的平台，也当作发布包的平台，从而使 Go 成为如今 GitHub 上排名前 5 的编程语言之一，见<a href="https://mp.weixin.qq.com/s/Y_9TN9XxlQjfa9oXenjpxg" target="_blank" rel="noopener">《GitHub 显示，Go 排名第 4 了，有视频为证！》</a>
。所以，GitHub 官方也更重视 Go 社区，最近宣布他们的安全特性可以用于 Go 模块，这将有助于 Go 社区发现、报告和防止安全漏洞。</p>
<h2 id="01-github-安全数据库">01 GitHub 安全数据库</h2>
<p>GitHub 有一个开放的安全建议数据库，叫 <a href="https://github.com/advisories" target="_blank" rel="noopener">Advisory Database</a>
，专注于为开发人员提供高质量、可操作的漏洞信息。它使用的是知识共享署名 4.0，所以数据可以在任何地方使用。</p>
<p><p class="md__image">
  <img src="../imgs/github-security01.png"
    alt="安全建议数据库"  />
</p>
</p>
<p>从上图可以看到，目前这个数据库支持 PHP、Go、Java、JS、.NET、Python、Ruby 等语言，GitHub 发文宣布支持 Go 时，该数据库有 155 条 Go 相关记录，现在已经 164，你看到这篇文章时，应该会更多。正如 GitHub 宣称的，随着他们对现有漏洞和新发现的漏洞进行筛选，这个数字每天都在增长。</p>
<h2 id="02-如何帮助发现漏洞">02 如何帮助发现漏洞</h2>
<p>有这个数据库，那 GitHub 是如何帮助发现漏洞的呢？</p>
<p>GitHub 很早就有一套安全策略，只是现在这套策略可以支持 Go 仓库。关于这套策略的详细信息，可以查看 GitHub 官方文档：<a href="https://docs.github.com/cn/code-security/getting-started/securing-your-repository" target="_blank" rel="noopener">https://docs.github.com/cn/code-security/getting-started/securing-your-repository</a>
，这里给的是中文版。</p>
<p>这里简单介绍几个点。</p>
<ul>
<li>公开的仓库，默认启动了相关的安全策略；如果是私有仓库，需要你手动处理，文档中有说明；</li>
<li>可以自定义用户如何报告安全漏洞。这点建议大的开源项目可以好好研究、利用下。官方建议是，再漏洞进入 GitHub   建议漏洞库之前，你和报告者私下沟通交流解决。</li>
</ul>
<p>具体来说，在仓库的 Security 选项卡，可以配置安全策略。</p>
<p><p class="md__image">
  <img src="../imgs/github-security02.png"
    alt=""  />
</p>
</p>
<p>在 Insights 选项卡可以查看依赖相关信息，包括配置是否触发依赖漏洞报警等。</p>
<p><p class="md__image">
  <img src="../imgs/github-security03.png"
    alt=""  />
</p>
</p>
<h2 id="03-哪个更好用">03 哪个更好用</h2>
<p>了解了几个安全相关的工具后，到底该用哪个？VSCode 插件是适合大部分人的选择，不过 jfrog 的 gocenter 不维护了，所以没法用了。</p>
<p>所以，我推荐谷歌的 deps.dev。不过如果你是开源项目作者，你应该好好研究、利用下 GitHub 提供的安全策略，让你的开源项目更健壮。</p>
]]></content>
		</item>
		
		<item>
			<title>Go开源项目推荐：500行代码确认请求时间花在哪</title>
			<link>https://polarisxu.studygolang.com/posts/go/project/httpstat/</link>
			<pubDate>Mon, 26 Jul 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/project/httpstat/</guid>
			<description>大家好，我是 polarisxu。 工作中遇到请求慢，难免想要查看时间都花在哪里了。办法肯定有不少，比如浏览器带的工具等。不过今天我要推荐一个命令行工具，目的有两个： 安装、使用方便，可以清晰的看出时间花在哪里了，建议放入自己的常用工具箱； Go 语言实现的，500 行左右代码，可以作为新手项目学习、练习、实战； 项目名称：httpstat，作者是 davecheney 大神。项目地址：http</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>工作中遇到请求慢，难免想要查看时间都花在哪里了。办法肯定有不少，比如浏览器带的工具等。不过今天我要推荐一个命令行工具，目的有两个：</p>
<ul>
<li>安装、使用方便，可以清晰的看出时间花在哪里了，建议放入自己的常用工具箱；</li>
<li>Go 语言实现的，500 行左右代码，可以作为新手项目学习、练习、实战；</li>
</ul>
<p>项目名称：httpstat，作者是 davecheney 大神。项目地址：<a href="https://github.com/davecheney/httpstat" target="_blank" rel="noopener">https://github.com/davecheney/httpstat</a>
，截止本文发布，Star 数 5.3k+。</p>
<p>先看使用的效果图：</p>
<p><p class="md__image">
  <img src="../imgs/httpstat01.png"
    alt=""  />
</p>
</p>
<p>最下面可以看到时间花在哪些阶段了，是不是一目了然？！</p>
<p>这个项目是受一个类似的 Python 项目启发的：<a href="https://github.com/reorx/httpstat" target="_blank" rel="noopener">https://github.com/reorx/httpstat</a>
。实话说，这个时候 Go 的优势很明显：跨平台方便，安装方便。那个 Python 项目现在甚至建议 Windows 用户使用这个 Go 版本的。</p>
<p><p class="md__image">
  <img src="../imgs/httpstat02.png"
    alt=""  />
</p>
</p>
<p>httpstat 安装的话，go install 安装即可。看看使用说明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ httpstat
Usage: httpstat <span class="o">[</span>OPTIONS<span class="o">]</span> URL

OPTIONS:
  -4    resolve IPv4 addresses only
  -6    resolve IPv6 addresses only
  -E string
        client cert file <span class="k">for</span> tls config
  -H value
        <span class="nb">set</span> HTTP header<span class="p">;</span> repeatable: -H <span class="s1">&#39;Accept: ...&#39;</span> -H <span class="s1">&#39;Range: ...&#39;</span>
  -I    don<span class="err">&#39;</span>t <span class="nb">read</span> body of request
  -L    follow 30x redirects
  -O    save body as remote filename
  -X string
        HTTP method to use <span class="o">(</span>default <span class="s2">&#34;GET&#34;</span><span class="o">)</span>
  -d string
        the body of a POST or PUT request<span class="p">;</span> from file use @filename
  -k    allow insecure SSL connections
  -o string
        output file <span class="k">for</span> body
  -v    print version number

ENVIRONMENT:
  HTTP_PROXY    proxy <span class="k">for</span> HTTP requests<span class="p">;</span> <span class="nb">complete</span> URL or HOST<span class="o">[</span>:PORT<span class="o">]</span>
                used <span class="k">for</span> HTTPS requests <span class="k">if</span> HTTPS_PROXY undefined
  HTTPS_PROXY   proxy <span class="k">for</span> HTTPS requests<span class="p">;</span> <span class="nb">complete</span> URL or HOST<span class="o">[</span>:PORT<span class="o">]</span>
  NO_PROXY      comma-separated list of hosts to exclude from proxy
</code></pre></div><p>从以上的选项可以看出支持的特性。</p>
<p>开头说了，这个项目的代码很少，可以作为一个实战项目学习。</p>
]]></content>
		</item>
		
		<item>
			<title>一道关于 len 函数的诡异 Go 面试题解析</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/weekly-question-104/</link>
			<pubDate>Sun, 25 Jul 2021 22:22:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/weekly-question-104/</guid>
			<description>大家好，我是 polarisxu。 在 Go语言爱好者周刊第 104 期有一道题目，以下代码输出什么： package main func main() { var x *struct { s [][32]byte } println(len(x.s[99])) } 答题结果如下： 正确率只有 16%。 本文就讲解下为什么结果是 32。 01 解析题目 先剖析下这段代码，x 变量： var x *struct { s [][32]byte } 注意这里不是定义一个结构体类型，而是定义一个结构体类型指针变量，即 x 是一个指针，指针类型是一个匿名结构体。很显然，x 的值是 nil，因</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>在 Go语言爱好者周刊第 104 期有一道题目，以下代码输出什么：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="p">[][</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span>
  <span class="p">}</span>
  
  <span class="nb">println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">s</span><span class="p">[</span><span class="mi">99</span><span class="p">]))</span>
<span class="p">}</span>
</code></pre></div><p>答题结果如下：</p>
<p><p class="md__image">
  <img src="../imgs/weekly-question-104-01.png"
    alt=""  />
</p>
</p>
<p>正确率只有 16%。</p>
<p>本文就讲解下为什么结果是 32。</p>
<h2 id="01-解析题目">01 解析题目</h2>
<p>先剖析下这段代码，x 变量：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">x</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">s</span> <span class="p">[][</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></div><p>注意这里不是定义一个结构体类型，而是定义一个结构体类型指针变量，即 x 是一个指针，指针类型是一个匿名结构体。很显然，x 的值是 nil，因为没有初始化，可以打印证实这一点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">x</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">s</span> <span class="p">[][</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;x.Type = %T; x.Value= %v\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">x.Type <span class="o">=</span> *struct <span class="o">{</span> s <span class="o">[][</span>32<span class="o">]</span>uint8 <span class="o">}</span><span class="p">;</span> x.Value<span class="o">=</span> &lt;nil&gt;
</code></pre></div><p>这也是为什么 48% 的人选择 A （panic） 的原因，毕竟 x 是 nil，panic 很自然的。比如这样就会 panic：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nb">println</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">s</span><span class="p">)</span>
<span class="c1">// panic: runtime error: invalid memory address or nil pointer dereference
</span></code></pre></div><p>相应的，fmt.Println(x.s[99]) 也会 panic。但为什么 <code>len(x.s[99])</code> 就不 panic 了呢？所以得从 len 入手一探究竟。</p>
<h2 id="02-len-详解">02 len 详解</h2>
<p>len 函数是一个内置类型，什么意思？就是由编译器实现的。它的参数可以接收多种类型，有泛型的味道。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nb">len</span><span class="p">(</span><span class="nx">v</span> <span class="nx">Type</span><span class="p">)</span> <span class="kt">int</span>
</code></pre></div><p>关于它的说明，标准库文档有说明：</p>
<blockquote>
<p>内建函数 len 返回 v 的长度，这取决于具体类型：</p>
<ul>
<li>数组：v 中元素的数量</li>
<li>数组指针：*v 中元素的数量（v 为 nil 时 panic）</li>
<li>切片、map：v 中元素的数量；若 v 为nil，len(v) 即为零</li>
<li>字符串：v 中字节的数量</li>
<li>通道：通道缓存中队列（未读取）元素的数量；若 v 为 nil，len(v) 即为零</li>
</ul>
</blockquote>
<p>光这个解释，还不够全面，len 函数还有其他一些特殊的点。这要看 Go 语言规范。</p>
<p>在规范中，有一节是<a href="https://hao.studygolang.com/golang_spec.html#id221" target="_blank" rel="noopener">关于 len 和 cap 的</a>
。有如下几个要点：</p>
<ul>
<li>返回结果总是 int；</li>
<li>返回结果有可能是常量；</li>
<li>有时对函数参数不求值，即编译期确定返回值；</li>
</ul>
<p>2、3 点解释下。（规范中有说明）</p>
<p>如果 len 或 cap 的函数参数 v 是字符串常量，则返回值是一个常量。</p>
<p><strong>如果 v 的类型是数组或指向数组的指针，且表达式 v 没有包含 channel 接收或（非常量）函数调用，则返回值也是一个常量。这种情况下，不会对 v 进行求值（即编译期就能确定）。否则返回值不是常量，且会对 v 进行求值（即得运行时确定）。</strong></p>
<p><strong>这一点是这道题的关键。</strong></p>
<p>首先，x.s[99] 的类型是 <code>[32]byte</code>，它是一个数组，且表达式 <code>x.s[99]</code> 没有包含 channel 接收也不是函数调用，因此不会对  x.s[99] 进行求值，不求值自然不会 panic（想不明白？可以想成没有解引用操作）。也就是说，编译器能够在编译阶段分析出 x.s[99] 的类型是 [32]byte，且不需要对 x.s[99] 求值，因此直接返回数组的长度，即 32。</p>
<h2 id="03-其他类似情况">03 其他类似情况</h2>
<p>类似这样不求值的情况还有没有？还真有。比如下面的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">testdata</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="o">*</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>
<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">testdata</span><span class="p">.</span><span class="nx">a</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>同样不会 panic，原理和上面的类似，<a href="https://hao.studygolang.com/golang_spec.html#id355" target="_blank" rel="noopener">在 Go 语言规范有说明</a>
。</p>
<p>&ldquo;range&rdquo; 子句中右侧的表达式被称为 range 表达式 ，它可以是数组、数组的指针、切片、字符串、map或是允许接收操作 的 channel。range 表达式会在开始此循环前被求值一次，但有一个例外：当存在最多一个迭代变量且 <code>len(x)</code> 是常量时，range 表达式是不被求值的。</p>
<p>所以上面代码中 testdata.a 不会被求值，因为 len(testdata.a) 是常量。</p>
<p>但如果改为这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">testdata</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">a</span> <span class="o">*</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="kt">int</span>
<span class="p">}</span>
<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">testdata</span><span class="p">.</span><span class="nx">a</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>就会 panic。</p>
<h2 id="04-总结">04 总结</h2>
<p>通过这么一道「诡异」的面试题，希望你能够对 len 有更深的理解，也希望你能够重视 Go 语言规范，多留意一些细节，同时学会如何寻找问题的答案。</p>
]]></content>
		</item>
		
		<item>
			<title>厉害了我的 Go：推荐系统都有开源实现</title>
			<link>https://polarisxu.studygolang.com/posts/go/project/recommender-gorse/</link>
			<pubDate>Mon, 19 Jul 2021 14:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/project/recommender-gorse/</guid>
			<description>大家好，我是 polarisxu。 看到一个项目：https://gorse.io/ ，这是一个用 Go 编写的开源推荐系统。Gorse 的目标是成为一个通用的开源推荐系统，可以迅速地引入到各种各样的在线服务中。通过将项目、用户和交互数据导入 Gorse，系统将自动训练模型，为每个用户生成推荐。 这个项目代码托管在 GitHub 上：https://github.com/zhenghaoz</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>看到一个项目：<a href="https://gorse.io/" target="_blank" rel="noopener">https://gorse.io/</a>
，这是一个用 Go 编写的开源推荐系统。Gorse 的目标是成为一个通用的开源推荐系统，可以迅速地引入到各种各样的在线服务中。通过将项目、用户和交互数据导入 Gorse，系统将自动训练模型，为每个用户生成推荐。</p>
<p>这个项目代码托管在 GitHub 上：<a href="https://github.com/zhenghaoz/gorse" target="_blank" rel="noopener">https://github.com/zhenghaoz/gorse</a>
，目前 Star 数 1.7k+，查了下记录，2018 年中旬，国人发起开发的这个项目（国人对 Go 确实情有独钟？！），因为他们参考的项目，一个是 Java 实现的，一个是 Python 实现的。</p>
<p>经过近 3 年的发展，目前该项目版本是 0.2.2，有两个实际的使用案例：</p>
<p><p class="md__image">
  <img src="../imgs/case.png"
    alt=""  />
</p>
</p>
<p>可见该项目有了一定的成熟度，小型创业团队，想要有自己的推荐系统，可以考虑基于这个项目。这个项目有如下特点：</p>
<ul>
<li>自动化：通过后台模型搜索，自动选择最佳推荐模型和策略；</li>
<li>分布式推荐：单节点训练、分布式预测以及在推荐阶段实现水平扩展的能力；</li>
<li>Restful API：为数据 CRUD 和推荐请求提供 RESTful API；</li>
<li>数据仪表盘：提供数据导入和导出、监控和集群状态检查的仪表板；</li>
</ul>
<p>这是官方给的仪表盘示例：</p>
<p><p class="md__image">
  <img src="../imgs/dashboard.jpg"
    alt=""  />
</p>
</p>
<p>这个项目提供了比较完整的文档：<a href="https://docs.gorse.io/" target="_blank" rel="noopener">https://docs.gorse.io/</a>
，包括安装、使用的介绍，同时还提供了设计的思路、架构图，方便使用者学习、理解。从提交记录看，贡献者很活跃。</p>
<p>如果你只是对推荐系统感兴趣，刚好也想通过一个项目更熟悉 Go 语言，我觉得这个项目一定很适合你，可以好好学习学习。</p>
]]></content>
		</item>
		
		<item>
			<title>Go1.17 新特性：新版构建约束</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go1.17-build-contraints/</link>
			<pubDate>Thu, 15 Jul 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go1.17-build-contraints/</guid>
			<description>大家好，我是 polarisxu。 Go 1.17 下个月就要正式发布了。很多人要问泛型了吧，泛型已经很明确了，Go1.18 会有。今天给大家介绍 Go1.17 的一个新特性：构建约束 — Build Constraints。 确切来说，这个特性相关的工作在 1.16 时就加入，但处于过度阶段，1.17 在各方面都更完善，更完整的支持，是时候了解它了。 01 什么是构建约束 构建约束（build constraint），也叫做</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>Go 1.17 下个月就要正式发布了。很多人要问泛型了吧，泛型已经很明确了，Go1.18 会有。今天给大家介绍 Go1.17 的一个新特性：构建约束 — Build Constraints。</p>
<p>确切来说，这个特性相关的工作在 1.16 时就加入，但处于过度阶段，1.17 在各方面都更完善，更完整的支持，是时候了解它了。</p>
<h2 id="01-什么是构建约束">01 什么是构建约束</h2>
<p>构建约束（build constraint），也叫做构建标记（build tag），是在 Go 源文件最开始的注释行，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// +build linux
</span></code></pre></div><p>看到这个，相信很多人都不陌生，因为这是 Go 一开始就有的特性，在 Go 源码中有很多这样的注释行。上面注释行的意思，这个文件只在 Linux 系统会包含在包中，其他系统会忽略这个文件。</p>
<p>几个注意点：</p>
<ul>
<li>约束可以出现在任何源文件中，比如 <code>.go</code>、<code>.s</code> 等；</li>
<li>必须在文件顶部附近，它的前面只能有空行或其他注释行；可见包子句也在约束之后；</li>
<li>约束可以有多行；</li>
<li>为了区别约束和包文档，在约束之后必须有空行；</li>
</ul>
<p>针对某个构建约束，可使用的词如下：</p>
<ul>
<li>特定操作系统，对应 runtime.GOOS 的可用值，比如 linux、windows 等；</li>
<li>特定的架构，对应 runtime.GOARCH 的可用值，比如 386、amd64 等；</li>
<li>使用的编译器，比如 gc、gccgo；</li>
<li>支持 cgo 命令时，可以使用 cgo；</li>
<li>Go 的主要发布版本，比如 go1.17、go1.16 等；（测试版本和 fixbug 版本不支持）</li>
<li>自定义的 tag，编译时通过 <code>-tags</code> 传递的值；</li>
<li>可以加入任意值，一般用 ignore 来忽略构建；</li>
</ul>
<p>此外，文件名可以通过 GOOS 和 GOARCH 来做构建约束。</p>
<h2 id="02-旧版构建约束">02 旧版构建约束</h2>
<p>从上面看到，构建约束的语法是 <code>// +build</code> 这种形式，如果多个条件组合，通过空格、逗号或多行构建约束表示。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// +build linux,386
</span></code></pre></div><p>你知道什么意思吗？表示在 linux AND 386。逗号表示 AND，空格表示 OR。那看一个复杂的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// +build linux,386 darwin,!cgo
</span></code></pre></div><p>是不是有点懵？我也有点懵！它表示的意思是：(linux AND 386) OR (darwin AND (NOT cgo)) 。</p>
<p>有些时候，多个约束分成多行书写，会更易读些：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// +build linux darwin
</span><span class="c1">// +build amd64
</span></code></pre></div><p>这相当于：(linux OR darwin) AND amd64 。</p>
<p>是不是很复杂，很难记忆？</p>
<p>正因为太复杂，很容易出错。而且，Go 中有不少注释是有特殊意义的，也为了一致性考虑，因此有了新版的构建约束。</p>
<h2 id="03-新版构建约束">03 新版构建约束</h2>
<p>在 Go 源码中，经常会见到类似下面开头的注释：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:link
</span></code></pre></div><p>新版的构建约束，也使用了 <code>//go:</code> 开头：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:build
</span></code></pre></div><p>注意 <code>//</code> 和 go 之间不能有空格。</p>
<p>同时新版语法使用布尔表达式，而不是逗号、空格等。布尔表达式，会更清晰易懂，出错可能性大大降低。</p>
<p>比如旧语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// +build linux,386
</span></code></pre></div><p>对应的新语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:build linux &amp;&amp; 386
</span></code></pre></div><p>构建标记的基础语法与其当前形式没有变化，但是构建标记的组合现在是用 Go 的 || 、 &amp;&amp; 和 ! 运算符和括号。（请注意，构建标记并不总是有效的 Go 表达式，即使它们共享操作符，因为标记并不总是有效的标识符。例如：”go1.1&quot;。)</p>
<p>新语法可以使用 Go spec 的 EBNF 标记来表示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">BuildLine</span>      <span class="p">=</span> <span class="s">&#34;//go:build&#34;</span> <span class="nx">Expr</span>
<span class="nx">Expr</span>           <span class="p">=</span> <span class="nx">OrExpr</span>
<span class="nx">OrExpr</span>         <span class="p">=</span> <span class="nx">AndExpr</span>   <span class="p">{</span> <span class="s">&#34;||&#34;</span> <span class="nx">AndExpr</span> <span class="p">}</span>
<span class="nx">AndExpr</span>        <span class="p">=</span> <span class="nx">UnaryExpr</span> <span class="p">{</span> <span class="s">&#34;&amp;&amp;&#34;</span> <span class="nx">UnaryExpr</span> <span class="p">}</span>
<span class="nx">UnaryExpr</span>      <span class="p">=</span> <span class="s">&#34;!&#34;</span> <span class="nx">UnaryExpr</span> <span class="p">|</span> <span class="s">&#34;(&#34;</span> <span class="nx">Expr</span> <span class="s">&#34;)&#34;</span> <span class="p">|</span> <span class="nx">tag</span>
<span class="nx">tag</span>            <span class="p">=</span> <span class="nx">tag_letter</span> <span class="p">{</span> <span class="nx">tag_letter</span> <span class="p">}</span>
<span class="nx">tag_letter</span>     <span class="p">=</span> <span class="nx">unicode_letter</span> <span class="p">|</span> <span class="nx">unicode_digit</span> <span class="p">|</span> <span class="s">&#34;_&#34;</span> <span class="p">|</span> <span class="s">&#34;.&#34;</span>
</code></pre></div><p>采用新语法后，一个文件只能有一行构建语句，而不是像旧版那样有多行。这样可以避免多行的关系到底是什么的问题。</p>
<p>Go1.17 中，gofmt 工具会自动根据旧版语法生成对应的新版语法，为了兼容性，两者都会保留。比如原来是这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// +build !windows,!plan9
</span></code></pre></div><p>执行 Go1.17 的 gofmt 后，变成了这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:build !windows &amp;&amp; !plan9
</span><span class="c1">// +build !windows,!plan9
</span></code></pre></div><p>如果文件中已经有了这两种约束形式，gofmt 会根据 <code>//go:buid</code> 自动覆盖 <code>// +build</code> 的形式，确保两者表示的意思一致。如果只有新版语法，不会自动生成旧版的，这时，你需要注意，它不兼容旧版本了。</p>
<p>另外，Vet 工具现在能够检测出两种语法的不一致。所以，建议大家在编辑器中保存文件时自动执行 gofmt。</p>
<p>早在 Go1.16 时就新增了一个包：<a href="https://docs.studygolang.com/pkg/go/build/constraint/" target="_blank" rel="noopener">go/build/constraint</a>
，专门处理新版构建约束。</p>
<p>关于新版约束的设计文档请移步：<a href="https://go.googlesource.com/proposal/&#43;/master/design/draft-gobuild.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/draft-gobuild.md</a>
。</p>
<h2 id="04-总结">04 总结</h2>
<p>新版本的构建约束可读性更强，更容易书写，不容易出错。有兴趣的可以自己针对构建约束，同时书写两种形式，体会下新版的好处。</p>
<p>最后提醒一点，新版约束中，一定要注意 <code>//</code> 和 go 之间不能有空格！</p>
]]></content>
		</item>
		
		<item>
			<title>这个工具真好：看看你的Go项目依赖有无漏洞</title>
			<link>https://polarisxu.studygolang.com/posts/go/project/google-deps/</link>
			<pubDate>Sun, 11 Jul 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/project/google-deps/</guid>
			<description>大家好，我是 polarisxu。 发现了一个好工具，推荐给大家！ https://deps.dev/ ，这是 Google 新出的一个实验性工具，命名为：Open Source Insights，它能让你更了解你的项目依赖。 通过这个网站，你可以查询任意开源项目的依赖情况，还包括依赖的依赖，可以看到完整的依赖关系图，而且可以看到它们的许可证。 目前该工具支持 Go Modules、NPM packages、Java 的Mavan 和 Rust 的 C</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>发现了一个好工具，推荐给大家！</p>
<p><a href="https://deps.dev/" target="_blank" rel="noopener">https://deps.dev/</a>
，这是 Google 新出的一个实验性工具，命名为：Open Source Insights，它能让你更了解你的项目依赖。</p>
<p>通过这个网站，你可以查询任意开源项目的依赖情况，还包括依赖的依赖，可以看到完整的依赖关系图，而且可以看到它们的许可证。</p>
<p>目前该工具支持 Go Modules、NPM packages、Java 的Mavan 和 Rust 的 Cargo，将来可能还会支持 .Net 的 NuGet 和 Python 的 PyPI。</p>
<p><p class="md__image">
  <img src="../imgs/deps01.png"
    alt=""  />
</p>
</p>
<p>以 Go 语言中文网的源码为例，看看使用情况。</p>
<p>输入包名：github.com/studygolang/studygolang，<a href="https://deps.dev/go/github.com%2Fstudygolang%2Fstudygolang" target="_blank" rel="noopener">https://deps.dev/go/github.com%2Fstudygolang%2Fstudygolang</a>
 结果如下：</p>
<p><p class="md__image">
  <img src="../imgs/deps02.png"
    alt=""  />
</p>
</p>
<p>发现有几处安全问题，查看详细信息，发现有几个库有漏洞：</p>
<ul>
<li>golang.org/x/crypto</li>
<li>golang.org/x/text</li>
<li>github.com/dgrijalva/jwt-go</li>
<li>github.com/labstack/echo/v4</li>
<li>github.com/tidwall/gjson</li>
</ul>
<p>拿 github.com/tidwall/gjson 看看：</p>
<p><p class="md__image">
  <img src="../imgs/deps03.png"
    alt=""  />
</p>
</p>
<p>gjson 1.6.3 及以下版本存在这个漏洞，具体信息来源：<a href="https://github.com/tidwall/gjson/issues/192" target="_blank" rel="noopener">https://github.com/tidwall/gjson/issues/192</a>
，由于不正确的边界检查，恶意构造的 JSON 对象可能会引起越界 panic。如果解析用户输入，这可能被用作分布式拒绝服务攻击。</p>
<p>根据这个提示应该升级我们的依赖，修复漏洞。</p>
<p>在 Dependencies 标签可以看到项目依赖，支持表格方式和图表方式查看依赖。在 Dependents 标签可以看到哪些项目依赖了当前项目。</p>
<p>赶紧看看你在使用的开源项目有无安全漏洞，会不会有安全隐患。比如 Gin 项目就有安全漏洞：</p>
<p><p class="md__image">
  <img src="../imgs/deps04.png"
    alt=""  />
</p>
</p>
]]></content>
		</item>
		
		<item>
			<title>网友很强大，发现了Go并发下载的Bug</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/studygolang-downloader-bug/</link>
			<pubDate>Wed, 07 Jul 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/studygolang-downloader-bug/</guid>
			<description>大家好，我是 polarisxu。 前几天我写了一篇文章：Go项目实战：一步步构建一个并发文件下载器 ，有小伙伴评论问，请求 https://studygolang.com/dl/golang/go1.16.5.src.tar.gz 为什么没有返回 Accept-Ranges。在写那篇文章时，我也试了，确实没有返回，因此我以为它不支持。 但有一个小伙伴很认真，他改用 GET 方法请求这个地址，结果却有 Accept-Ranges，于是就很困惑，问我什么原因。经过一顿操作猛如虎，终于知</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>前几天我写了一篇文章：<a href="https://polarisxu.studygolang.com/posts/go/action/build-a-concurrent-file-downloader/" target="_blank" rel="noopener">Go项目实战：一步步构建一个并发文件下载器</a>
，有小伙伴评论问，请求 <code>https://studygolang.com/dl/golang/go1.16.5.src.tar.gz</code> 为什么没有返回 Accept-Ranges。在写那篇文章时，我也试了，确实没有返回，因此我以为它不支持。</p>
<p>但有一个小伙伴很认真，他改用 GET 方法请求这个地址，结果却有 Accept-Ranges，于是就很困惑，问我什么原因。经过一顿操作猛如虎，终于知道原因了。记录下排查过程，供大家参考！（小伙伴的留言可以查看那篇文章）</p>
<h2 id="01-排查过程">01 排查过程</h2>
<p>通过 curl 命令，分别用 GET 和 HEAD 方法请求这个地址，结果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ curl -X GET --head https://studygolang.com/dl/golang/go1.16.5.src.tar.gz
HTTP/1.1 <span class="m">303</span> See Other
Server: nginx
Date: Wed, <span class="m">07</span> Jul <span class="m">2021</span> 09:09:35 GMT
Content-Length: <span class="m">0</span>
Connection: keep-alive
Location: https://golang.google.cn/dl/go1.16.5.src.tar.gz
X-Request-Id: 83ee595c-6270-4fb0-a2f1-98fdc4d315be

$ curl --head https://studygolang.com/dl/golang/go1.16.5.src.tar.gz
HTTP/1.1 <span class="m">200</span> OK
Server: nginx
Date: Wed, <span class="m">07</span> Jul <span class="m">2021</span> 09:09:44 GMT
Connection: keep-alive
X-Request-Id: f2ba473d-5bee-44c3-a591-02c358551235
</code></pre></div><p>虽然都没有 Accept-Ranges，但有一个奇怪现象：一个状态码是 303，一个是 200。很显然，303 是正确的，HEAD 为什么会是 200？</p>
<p>我以为是 Nginx 对 HEAD 请求做了特殊处理，于是直接访问 Go 服务的方式（不经过 Nginx 代理），结果一样。</p>
<p>于是，我用 Go 实现一个简单的 Web 服务，Handler 里面也重定向。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/dl&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">http</span><span class="p">.</span><span class="nf">Redirect</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusSeeOther</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Hello World&#34;</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:2022&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>用 curl 请求 <code>http://localhost:2022/dl</code>，GET 和 HEAD 都返回 303。于是我怀疑是不是 Echo 框架哪里的问题（studygolang 使用 Echo 框架构建的）。</p>
<p>所以，我用 Echo 框架写个 Web 服务测试：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
  
	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/dl&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Redirect</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusSeeOther</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>
  <span class="p">})</span>
  <span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
  <span class="p">})</span>
	
	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2022&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>同样用 curl 请求  <code>http://localhost:2022/dl</code>，GET 返回 303，而 HEAD 报 405 Method Not Allowed，这符合预期。我们的路由设置只允许 GET 请求。但为什么 studygolang 没有返回 405，因为它也限制只能 GET 请求。</p>
<p>于是我对随便一个地址发起 HEAD 请求，发现都返回 200，可见 HTTP 错误被“吞掉”了。查找 studygolang 的中间件，发现了这个：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">HTTPError</span><span class="p">()</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">MiddlewareFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">next</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">next</span><span class="p">(</span><span class="nx">ctx</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>

				<span class="k">if</span> <span class="p">!</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Response</span><span class="p">().</span><span class="nx">Committed</span> <span class="p">{</span>
					<span class="k">if</span> <span class="nx">he</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HTTPError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
						<span class="k">switch</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Code</span> <span class="p">{</span>
						<span class="k">case</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">:</span>
							<span class="k">if</span> <span class="nx">util</span><span class="p">.</span><span class="nf">IsAjax</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
								<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">`{&#34;ok&#34;:0,&#34;error&#34;:&#34;接口不存在&#34;}`</span><span class="p">)</span>
							<span class="p">}</span>
							<span class="k">return</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;404.html&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
						<span class="k">case</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusForbidden</span><span class="p">:</span>
							<span class="k">if</span> <span class="nx">util</span><span class="p">.</span><span class="nf">IsAjax</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
								<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">`{&#34;ok&#34;:0,&#34;error&#34;:&#34;没有权限访问&#34;}`</span><span class="p">)</span>
							<span class="p">}</span>
							<span class="k">return</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;403.html&#34;</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span><span class="s">&#34;msg&#34;</span><span class="p">:</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Message</span><span class="p">})</span>
						<span class="k">case</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">:</span>
							<span class="k">if</span> <span class="nx">util</span><span class="p">.</span><span class="nf">IsAjax</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
								<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">`{&#34;ok&#34;:0,&#34;error&#34;:&#34;接口服务器错误&#34;}`</span><span class="p">)</span>
							<span class="p">}</span>
							<span class="k">return</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;500.html&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这里对 404、403、500 错误都做了处理，但其他 HTTP 错误直接忽略了，导致最后返回了 200 OK。只需要在上面 switch 语句加一个 default 分支，同时把 err 原样 return，采用系统默认处理方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">default</span><span class="p">:</span>
	<span class="k">return</span> <span class="nx">err</span>
</code></pre></div><p>这样 405 Method Not Allowed 会正常返回。</p>
<p>同时，为了解决 HEAD 能用来判断下载行为，针对下载路由，我加上了允许 HEAD 请求，这样就解决了小伙伴们的困惑。</p>
<h2 id="02-curl-和-go-代码行为异同">02 curl 和 Go 代码行为异同</h2>
<p>不知道大家发现没有，通过 curl 请求 <code>https://studygolang.com/dl/golang/go1.16.5.src.tar.gz</code> 和 Go 代码请求，结果是不一样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ curl -X GET --head https://studygolang.com/dl/golang/go1.16.5.src.tar.gz
HTTP/1.1 <span class="m">303</span> See Other
Server: nginx
Date: Thu, <span class="m">08</span> Jul <span class="m">2021</span> 02:05:10 GMT
Content-Length: <span class="m">0</span>
Connection: keep-alive
Location: https://golang.google.cn/dl/go1.16.5.src.tar.gz
X-Request-Id: 14d741ca-65c1-4b05-90b8-bef5c8b5a0a3
</code></pre></div><p>返回的是 303 重定向，自然没有 Accept-Ranges 头。</p>
<p>但改用如下 Go 代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;https://studygolang.com/dl/golang/go1.16.5.src.tar.gz&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;get err&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ranges&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Accept-Ranges&#34;</span><span class="p">))</span>
</code></pre></div><p>返回的是 200，且有 Accept-Ranges 头。可以猜测，应该是 Go 根据重定向递归请求重定向后的地址。可以查看源码确认下。</p>
<p>通过这个可以看到：<a href="https://docs.studygolang.com/src/net/http/client.go?s=20406:20458#L574" target="_blank" rel="noopener">https://docs.studygolang.com/src/net/http/client.go?s=20406:20458#L574</a>
，核心代码如下（比较容易看懂）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 循环处理所有需要处理的 url（包括重定向后的）
</span><span class="c1"></span><span class="k">for</span> <span class="p">{</span>
		<span class="c1">// For all but the first request, create the next
</span><span class="c1"></span>		<span class="c1">// request hop and replace req.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">reqs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="c1">// 如果是重定向，请求重定向地址
</span><span class="c1"></span>			<span class="nx">loc</span> <span class="o">:=</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Location&#34;</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">loc</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
				<span class="nx">resp</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;%d response missing Location header&#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="nx">u</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">loc</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">resp</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
				<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to parse Location header %q: %v&#34;</span><span class="p">,</span> <span class="nx">loc</span><span class="p">,</span> <span class="nx">err</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="nx">host</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>
			<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Host</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Host</span> <span class="o">!=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">.</span><span class="nx">Host</span> <span class="p">{</span>
				<span class="c1">// If the caller specified a custom Host header and the
</span><span class="c1"></span>				<span class="c1">// redirect location is relative, preserve the Host header
</span><span class="c1"></span>				<span class="c1">// through the redirect. See issue #22233.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">u</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">loc</span><span class="p">);</span> <span class="nx">u</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">u</span><span class="p">.</span><span class="nf">IsAbs</span><span class="p">()</span> <span class="p">{</span>
					<span class="nx">host</span> <span class="p">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Host</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="nx">ireq</span> <span class="o">:=</span> <span class="nx">reqs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="nx">req</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Request</span><span class="p">{</span>
				<span class="nx">Method</span><span class="p">:</span>   <span class="nx">redirectMethod</span><span class="p">,</span>
				<span class="nx">Response</span><span class="p">:</span> <span class="nx">resp</span><span class="p">,</span>
				<span class="nx">URL</span><span class="p">:</span>      <span class="nx">u</span><span class="p">,</span>
				<span class="nx">Header</span><span class="p">:</span>   <span class="nb">make</span><span class="p">(</span><span class="nx">Header</span><span class="p">),</span>
				<span class="nx">Host</span><span class="p">:</span>     <span class="nx">host</span><span class="p">,</span>
				<span class="nx">Cancel</span><span class="p">:</span>   <span class="nx">ireq</span><span class="p">.</span><span class="nx">Cancel</span><span class="p">,</span>
				<span class="nx">ctx</span><span class="p">:</span>      <span class="nx">ireq</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">includeBody</span> <span class="o">&amp;&amp;</span> <span class="nx">ireq</span><span class="p">.</span><span class="nx">GetBody</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">ireq</span><span class="p">.</span><span class="nf">GetBody</span><span class="p">()</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">resp</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
					<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="p">=</span> <span class="nx">ireq</span><span class="p">.</span><span class="nx">ContentLength</span>
			<span class="p">}</span>

			<span class="c1">// Copy original headers before setting the Referer,
</span><span class="c1"></span>			<span class="c1">// in case the user set Referer on their first request.
</span><span class="c1"></span>			<span class="c1">// If they really want to override, they can do it in
</span><span class="c1"></span>			<span class="c1">// their CheckRedirect func.
</span><span class="c1"></span>			<span class="nf">copyHeaders</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>

			<span class="c1">// Add the Referer header from the most recent
</span><span class="c1"></span>			<span class="c1">// request URL to the new one, if it&#39;s not https-&gt;http:
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">ref</span> <span class="o">:=</span> <span class="nf">refererForURL</span><span class="p">(</span><span class="nx">reqs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">reqs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">URL</span><span class="p">,</span> <span class="nx">req</span><span class="p">.</span><span class="nx">URL</span><span class="p">);</span> <span class="nx">ref</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
				<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Referer&#34;</span><span class="p">,</span> <span class="nx">ref</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">checkRedirect</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">reqs</span><span class="p">)</span>

			<span class="c1">// Sentinel error to let users select the
</span><span class="c1"></span>			<span class="c1">// previous response, without closing its
</span><span class="c1"></span>			<span class="c1">// body. See Issue 10069.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ErrUseLastResponse</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span>
			<span class="p">}</span>

			<span class="c1">// Close the previous response&#39;s body. But
</span><span class="c1"></span>			<span class="c1">// read at least some of the body so if it&#39;s
</span><span class="c1"></span>			<span class="c1">// small the underlying TCP connection will be
</span><span class="c1"></span>			<span class="c1">// re-used. No need to check for errors: if it
</span><span class="c1"></span>			<span class="c1">// fails, the Transport won&#39;t reuse it anyway.
</span><span class="c1"></span>			<span class="kd">const</span> <span class="nx">maxBodySlurpSize</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span>
			<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">&lt;=</span> <span class="nx">maxBodySlurpSize</span> <span class="p">{</span>
				<span class="nx">io</span><span class="p">.</span><span class="nf">CopyN</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">maxBodySlurpSize</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="c1">// Special case for Go 1 compatibility: return both the response
</span><span class="c1"></span>				<span class="c1">// and an error if the CheckRedirect function failed.
</span><span class="c1"></span>				<span class="c1">// See https://golang.org/issue/3795
</span><span class="c1"></span>				<span class="c1">// The resp.Body has already been closed.
</span><span class="c1"></span>				<span class="nx">ue</span> <span class="o">:=</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="nx">ue</span><span class="p">.(</span><span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">Error</span><span class="p">).</span><span class="nx">URL</span> <span class="p">=</span> <span class="nx">loc</span>
				<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">ue</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">reqs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">reqs</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
		<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
		<span class="kd">var</span> <span class="nx">didTimeout</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span>
		<span class="k">if</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">didTimeout</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">deadline</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// c.send() always closes req.Body
</span><span class="c1"></span>			<span class="nx">reqBodyClosed</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">deadline</span><span class="p">.</span><span class="nf">IsZero</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nf">didTimeout</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">httpError</span><span class="p">{</span>
					<span class="c1">// TODO: early in cycle: s/Client.Timeout exceeded/timeout or context cancellation/
</span><span class="c1"></span>					<span class="nx">err</span><span class="p">:</span>     <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; (Client.Timeout exceeded while awaiting headers)&#34;</span><span class="p">,</span>
					<span class="nx">timeout</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">uerr</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>

  	<span class="c1">// 确认重定向行为
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">shouldRedirect</span> <span class="kt">bool</span>
		<span class="nx">redirectMethod</span><span class="p">,</span> <span class="nx">shouldRedirect</span><span class="p">,</span> <span class="nx">includeBody</span> <span class="p">=</span> <span class="nf">redirectBehavior</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">reqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">shouldRedirect</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>

		<span class="nx">req</span><span class="p">.</span><span class="nf">closeBody</span><span class="p">()</span>
	<span class="p">}</span>
</code></pre></div><p>可以进一步看 redirectBehavior 函数 <a href="https://docs.studygolang.com/src/net/http/client.go?s=20406:20458#L497" target="_blank" rel="noopener">https://docs.studygolang.com/src/net/http/client.go?s=20406:20458#L497</a>
：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">redirectBehavior</span><span class="p">(</span><span class="nx">reqMethod</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">resp</span> <span class="o">*</span><span class="nx">Response</span><span class="p">,</span> <span class="nx">ireq</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="nx">redirectMethod</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">shouldRedirect</span><span class="p">,</span> <span class="nx">includeBody</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">301</span><span class="p">,</span> <span class="mi">302</span><span class="p">,</span> <span class="mi">303</span><span class="p">:</span>
		<span class="nx">redirectMethod</span> <span class="p">=</span> <span class="nx">reqMethod</span>
		<span class="nx">shouldRedirect</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">includeBody</span> <span class="p">=</span> <span class="kc">false</span>

		<span class="c1">// RFC 2616 allowed automatic redirection only with GET and
</span><span class="c1"></span>		<span class="c1">// HEAD requests. RFC 7231 lifts this restriction, but we still
</span><span class="c1"></span>		<span class="c1">// restrict other methods to GET to maintain compatibility.
</span><span class="c1"></span>		<span class="c1">// See Issue 18570.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">reqMethod</span> <span class="o">!=</span> <span class="s">&#34;GET&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">reqMethod</span> <span class="o">!=</span> <span class="s">&#34;HEAD&#34;</span> <span class="p">{</span>
			<span class="nx">redirectMethod</span> <span class="p">=</span> <span class="s">&#34;GET&#34;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="mi">307</span><span class="p">,</span> <span class="mi">308</span><span class="p">:</span>
		<span class="nx">redirectMethod</span> <span class="p">=</span> <span class="nx">reqMethod</span>
		<span class="nx">shouldRedirect</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="nx">includeBody</span> <span class="p">=</span> <span class="kc">true</span>

		<span class="c1">// Treat 307 and 308 specially, since they&#39;re new in
</span><span class="c1"></span>		<span class="c1">// Go 1.8, and they also require re-sending the request body.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Location&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="c1">// 308s have been observed in the wild being served
</span><span class="c1"></span>			<span class="c1">// without Location headers. Since Go 1.7 and earlier
</span><span class="c1"></span>			<span class="c1">// didn&#39;t follow these codes, just stop here instead
</span><span class="c1"></span>			<span class="c1">// of returning an error.
</span><span class="c1"></span>			<span class="c1">// See Issue 17773.
</span><span class="c1"></span>			<span class="nx">shouldRedirect</span> <span class="p">=</span> <span class="kc">false</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">ireq</span><span class="p">.</span><span class="nx">GetBody</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">ireq</span><span class="p">.</span><span class="nf">outgoingLength</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// We had a request body, and 307/308 require
</span><span class="c1"></span>			<span class="c1">// re-sending it, but GetBody is not defined. So just
</span><span class="c1"></span>			<span class="c1">// return this response to the user instead of an
</span><span class="c1"></span>			<span class="c1">// error, like we did in Go 1.7 and earlier.
</span><span class="c1"></span>			<span class="nx">shouldRedirect</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">redirectMethod</span><span class="p">,</span> <span class="nx">shouldRedirect</span><span class="p">,</span> <span class="nx">includeBody</span>
<span class="p">}</span>
</code></pre></div><p>很清晰了吧。</p>
<h2 id="03-总结">03 总结</h2>
<p>很开心，还是有读者很认真的在看我的文章，在跟着动手实践，还对其中的点提出质疑。希望通过这篇文章，大家能够对 HTTP 协议有更深的认识，同时体会问题排查的思路。</p>
<p>有其他问题，也欢迎留言交流！</p>
]]></content>
		</item>
		
		<item>
			<title>Rust 劝退系列 09：函数</title>
			<link>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-09/</link>
			<pubDate>Sat, 03 Jul 2021 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-09/</guid>
			<description>大家好，我是站长 polarisxu。 这是 Rust 劝退系列的第 9 个教程，探讨 Rust 中的函数。 Rust 是支持函数式编程的语言。Rust 中，函数作为一等公民，本身就是一种类型。函数类型变量可以作为其他函数的参数或返回值，也可以赋值给别的变量，还可以直接调用执行。 01 函数定义 在 Rust 中，函数使用 fn 关键字定义（Go 中使用 func，想着够省略了，没想到 Rust 来个更省略！）。 和大部分其他语言的语法</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这是 Rust 劝退系列的第 9 个教程，探讨 Rust 中的函数。</p>
<p>Rust 是支持函数式编程的语言。Rust 中，函数作为一等公民，本身就是一种类型。函数类型变量可以作为其他函数的参数或返回值，也可以赋值给别的变量，还可以直接调用执行。</p>
<h2 id="01-函数定义">01 函数定义</h2>
<p>在 Rust 中，函数使用 fn 关键字定义（Go 中使用 func，想着够省略了，没想到 Rust 来个更省略！）。</p>
<p>和大部分其他语言的语法类似，Rust 中的函数签名同样包括函数名、函数参数类型和返回值类型。和 Go 语言的函数比，Rust 的函数定义有些不同：</p>
<ul>
<li>除了上面说的关键字不同外，Rust 函数名一般建议使用下划线风格（小写字母），即 蛇形命名法（snake_case），否则编译器会警告；而 Go 使用驼峰风格；</li>
<li>返回值类型使用 -&gt; 标识；</li>
<li>大括号虽然没有严格要求怎么放，但一般建议紧接函数签名之后，而不是另起一行（Go 是只能这样）；</li>
</ul>
<p>函数声明如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">functionname</span><span class="p">(</span><span class="n">parametername</span>: <span class="nc">type</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">returntype</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span><span class="w">    </span><span class="c1">// 函数体（具体实现的功能）
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>函数示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">max</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">i32</span> <span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="02-函数参数">02 函数参数</h2>
<p>注意，和 Go 不同，虽然上面示例中，x、y 的类型相同，但 x 的类型不能省略。</p>
<p>和 Go 语言一样，Rust 中的函数也没有不能指定默认值。但 Go 支持不定参数，Rust目前不支持。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Go 中这样的函数，Rust 不支持
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Sum</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">z</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="c1">// 函数体
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>函数参数和变量一样，默认是不可变的，当需要可变参数时，一样得使用 mut 关键字。看一个例子：（来自 《Rust 编程之道》）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">modify</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
</span><span class="w">  </span><span class="n">v</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">modify</span><span class="p">(</span><span class="n">v</span><span class="p">);</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>按值传递参数，函数里需要对传入其中的动态数组进行修改，因此在参数前加上了 mut 关键字。正因为函数参数前使用了 mut（这叫做可变修饰），因此在 main 里的声明和调用处并没有使用 mut。</p>
<p>再看另一种情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">modify</span><span class="p">(</span><span class="n">v</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">v</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec</span><span class="o">!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w">  </span><span class="n">modify</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这是按引用传递参数。注意 mut 的位置：按值传递，参数可变，mut 放在参数前，这和定义可变变量是一样的写法；但按引用传递，<code>&amp;mut Vec&lt;u32&gt;</code> 这是一个整体，是可变引用类型，因此参数前面不再需要 mut。（mut 位置不一样，着实容易晕！）</p>
<p>此外，函数参数可以使用 <code>_</code> 忽略该它。</p>
<h2 id="03-函数返回值">03 函数返回值</h2>
<p>如果函数没有返回值，-&gt; 不写。其实，根据前面的介绍，没有返回值的函数，返回的类型是单元值 <code>()</code>。所以，也可以显示返回该类型。</p>
<p>虽然 Rust 不支持多返回值，但因为有元组类型，因此返回元组相当于支持多返回值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swap</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;x={},y={}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">swap</span><span class="p">(</span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不知道大家是否注意到，swap 函数要求返回一个元组，但我们并没有使用 return 语句，但要特别注意结尾是没有分号的。</p>
<p>前面说过，Rust 中一切都是表达式。if 表达式、循环表达式等，它们的值是最后一个表达式的值。对于函数，它的返回值是最后一个表达式的值。所以，Rust 中经常不通过 return 来返回值。当然，用 return 也是可以的，但需要注意加上分号。</p>
<h2 id="04-特殊函数-main">04 特殊函数 main</h2>
<p>这个不用多说，是 Rust 程序的入口函数，签名如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w">
</span></code></pre></div><p>没有参数、没有返回值。</p>
<h2 id="05-总结">05 总结</h2>
<p>关于函数还有很多其他知识点，比如高阶函数、方法、闭包等，下一节就介绍高阶函数和闭包。</p>
]]></content>
		</item>
		
		<item>
			<title>Go项目实战：一步步构建一个并发文件下载器</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/build-a-concurrent-file-downloader/</link>
			<pubDate>Sat, 03 Jul 2021 22:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/build-a-concurrent-file-downloader/</guid>
			<description>大家好，我是 polarisxu。 今天为大家带来一个实战项目。建议你一定要动手实践。 在往下看之前，你不妨思考下，用 Go 如何实现一个并发下载器。（我之前有推荐过一个类似的开源项目：推荐三个Go实战开源项目 ） 01 原理 对于服务器上的某个文件，我们要并发下载到本地，很容易想到，应该将文件分成多个部分，然后开多个 goroutine 并发地去下载，最后将这多个部分合并成一个文件，实现并发下载的</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>今天为大家带来一个实战项目。建议你一定要动手实践。</p>
<p>在往下看之前，你不妨思考下，用 Go 如何实现一个并发下载器。（我之前有推荐过一个类似的开源项目：<a href="https://mp.weixin.qq.com/s/v_wonIeuxQWT_qPTGv7GIw" target="_blank" rel="noopener">推荐三个Go实战开源项目</a>
）</p>
<h2 id="01-原理">01 原理</h2>
<p>对于服务器上的某个文件，我们要并发下载到本地，很容易想到，应该将文件分成多个部分，然后开多个 goroutine 并发地去下载，最后将这多个部分合并成一个文件，实现并发下载的目的。</p>
<p>现在的问题是，服务器上的一个文件，我们怎么做到分成多个呢？</p>
<p>这需要 HTTP 协议相关知识了。</p>
<p>HTTP 协议有一个响应头：Accept-Ranges，服务器通过该头来标识自身支持部分请求（partial requests），也叫范围请求。如果服务端支持部分请求，我们就可以实现并发下载。该头有两个可能的值：</p>
<pre tabindex="0"><code>Accept-Ranges: bytes
Accept-Ranges: none
</code></pre><ul>
<li>none：不支持任何部分请求单位，由于其等同于没有返回此头部，因此很少使用。不过一些浏览器，比如 IE9，会依据该头部去禁用或者移除下载管理器的暂停按钮。</li>
<li>bytes：部分请求的单位是 bytes （字节）。</li>
</ul>
<p>所以，我们在并发下载之前，应该先发起一个 Head 请求，来确认服务端是否支持部分请求。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Head</span><span class="p">(</span><span class="s">&#34;https://studygolang.com/dl/golang/go1.16.5.src.tar.gz&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">==</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="o">&amp;&amp;</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Accept-Ranges&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#34;bytes&#34;</span> <span class="p">{</span>
  <span class="c1">// 支持部分请求
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>确认了服务器支持部分请求，接下来就是如何进行部分请求。</p>
<p>这就用到 HTTP 的一个请求头部：Range。（详情参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range</a>
）</p>
<p>Range 告知服务器返回文件的哪一部分。在一个  Range 头部中，可以一次性请求多个部分，服务器会以 multipart 文件的形式将其返回。如果服务器返回的是范围响应，需要使用 206 Partial Content 状态码。假如所请求的范围不合法，那么服务器会返回  416 Range Not Satisfiable 状态码，表示客户端错误。服务器允许忽略  Range  首部，从而返回整个文件，状态码用 200。</p>
<p>具体语法：</p>
<pre tabindex="0"><code>Range: &lt;unit&gt;=&lt;range-start&gt;-
Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;
Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;
Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;
</code></pre><ul>
<li>
<p><code>&lt;unit&gt;</code></p>
<p>范围所采用的单位，通常是字节（bytes）。</p>
</li>
<li>
<p><code>&lt;range-start&gt;</code></p>
<p>一个整数，表示在特定单位下，范围的起始值。</p>
</li>
<li>
<p><code>&lt;range-end&gt;</code></p>
<p>一个整数，表示在特定单位下，范围的结束值。这个值是可选的，如果不存在，表示此范围一直延伸到文档结束。</p>
</li>
</ul>
<p>例如：</p>
<pre tabindex="0"><code>Range: bytes=200-1000, 2000-6576, 19000-
</code></pre><p>掌握了以上知识点，最后要做的就是将下载下来的各个部分合并成一个文件。需要注意各个部分的顺序，比如根据顺序，按 1、2、3 等编号。</p>
<h2 id="02-动手实现一个">02 动手实现一个</h2>
<p>知道了原理不代表你真的就会了，我们应该实际动手实现一个，加深理解。</p>
<p>在本地某个目录下创建目录：downloader。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ mkdir downloader
$ <span class="nb">cd</span> downloader
$ go mod init github.com/polaris1119/downloader
</code></pre></div><h3 id="命令行参数控制">命令行参数控制</h3>
<p>为了让工具更好用，我们应该支持命令行参数，而不是代码写死一个，比如要下载的 URL、并发数、输出的文件名等。关于命令行参数控制，除了使用标准库 flag，我比较喜欢 github.com/urfave/cli，最新版本 v2。</p>
<p>创建一个文件 main.go，内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;runtime&#34;</span>

	<span class="s">&#34;github.com/urfave/cli/v2&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 默认并发数
</span><span class="c1"></span>	<span class="nx">concurrencyN</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">NumCPU</span><span class="p">()</span>

	<span class="nx">app</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">cli</span><span class="p">.</span><span class="nx">App</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="s">&#34;downloader&#34;</span><span class="p">,</span>
		<span class="nx">Usage</span><span class="p">:</span> <span class="s">&#34;File concurrency downloader&#34;</span><span class="p">,</span>
		<span class="nx">Flags</span><span class="p">:</span> <span class="p">[]</span><span class="nx">cli</span><span class="p">.</span><span class="nx">Flag</span><span class="p">{</span>
			<span class="o">&amp;</span><span class="nx">cli</span><span class="p">.</span><span class="nx">StringFlag</span><span class="p">{</span>
				<span class="nx">Name</span><span class="p">:</span>     <span class="s">&#34;url&#34;</span><span class="p">,</span>
				<span class="nx">Aliases</span><span class="p">:</span>  <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;u&#34;</span><span class="p">},</span>
				<span class="nx">Usage</span><span class="p">:</span>    <span class="s">&#34;`URL` to download&#34;</span><span class="p">,</span>
				<span class="nx">Required</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
			<span class="p">},</span>
			<span class="o">&amp;</span><span class="nx">cli</span><span class="p">.</span><span class="nx">StringFlag</span><span class="p">{</span>
				<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;output&#34;</span><span class="p">,</span>
				<span class="nx">Aliases</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;o&#34;</span><span class="p">},</span>
				<span class="nx">Usage</span><span class="p">:</span>   <span class="s">&#34;Output `filename`&#34;</span><span class="p">,</span>
			<span class="p">},</span>
			<span class="o">&amp;</span><span class="nx">cli</span><span class="p">.</span><span class="nx">IntFlag</span><span class="p">{</span>
				<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;concurrency&#34;</span><span class="p">,</span>
				<span class="nx">Aliases</span><span class="p">:</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;n&#34;</span><span class="p">},</span>
				<span class="nx">Value</span><span class="p">:</span>   <span class="nx">concurrencyN</span><span class="p">,</span>
				<span class="nx">Usage</span><span class="p">:</span>   <span class="s">&#34;Concurrency `number`&#34;</span><span class="p">,</span>
			<span class="p">},</span>
		<span class="p">},</span>
		<span class="nx">Action</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cli</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span>
		<span class="p">},</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">app</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>执行 go mod tidy，下载必要的包。然后执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run main.go -h
NAME:
   downloader - File concurrency downloader

USAGE:
   downloader <span class="o">[</span>global options<span class="o">]</span> <span class="nb">command</span> <span class="o">[</span><span class="nb">command</span> options<span class="o">]</span> <span class="o">[</span>arguments...<span class="o">]</span>

COMMANDS:
   help, h  Shows a list of commands or <span class="nb">help</span> <span class="k">for</span> one <span class="nb">command</span>

GLOBAL OPTIONS:
   --url URL, -u URL                URL to download
   --output filename, -o filename   Output filename
   --concurrency number, -n number  Concurrency number <span class="o">(</span>default: 8<span class="o">)</span>
   --help, -h                       show <span class="nb">help</span> <span class="o">(</span>default: <span class="nb">false</span><span class="o">)</span>
</code></pre></div><p>关于 cli 这个库的使用，可以参阅官方文档，写的很详细，也有很多例子。</p>
<h3 id="检查是否支持并发下载">检查是否支持并发下载</h3>
<p>创建另外一个文件 downloader.go，定义一个结构体 Dowloader：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">type</span> <span class="nx">Downloader</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">concurrency</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewDownloader</span><span class="p">(</span><span class="nx">concurrency</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Downloader</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Downloader</span><span class="p">{</span><span class="nx">concurrency</span><span class="p">:</span> <span class="nx">concurrency</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>为该结构体增加 Download 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Downloader</span><span class="p">)</span> <span class="nf">Download</span><span class="p">(</span><span class="nx">strURL</span><span class="p">,</span> <span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">filename</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">filename</span> <span class="p">=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Base</span><span class="p">(</span><span class="nx">strURL</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Head</span><span class="p">(</span><span class="nx">strURL</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">StatusCode</span> <span class="o">==</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span> <span class="o">&amp;&amp;</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;Accept-Ranges&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#34;bytes&#34;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nf">multiDownload</span><span class="p">(</span><span class="nx">strURL</span><span class="p">,</span> <span class="nx">filename</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">ContentLength</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">d</span><span class="p">.</span><span class="nf">singleDownload</span><span class="p">(</span><span class="nx">strURL</span><span class="p">,</span> <span class="nx">filename</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Downloader</span><span class="p">)</span> <span class="nf">multiDownload</span><span class="p">(</span><span class="nx">strURL</span><span class="p">,</span> <span class="nx">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">contentLen</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Downloader</span><span class="p">)</span> <span class="nf">singleDownload</span><span class="p">(</span><span class="nx">strURL</span><span class="p">,</span> <span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>通过 Head 请求，判断是否支持部分请求。在原理部分已经讲解；</li>
<li>如果不支持，就直接下载整个文件；</li>
</ul>
<p>当支持部分请求时，文件总大小通过 Head 请求的响应中的 ContentLength 可以获得。有了文件总大小和并发数，就可以知道每个部分的大小了。</p>
<h3 id="并发下载">并发下载</h3>
<p>这部分第一个要点是如何发起部分请求：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="s">&#34;https://apache.claz.org/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="nx">rangeStart</span> <span class="o">:=</span> <span class="mi">2000</span>
<span class="nx">rangeStop</span> <span class="o">:=</span> <span class="mi">3000</span>
<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Range&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;bytes=%d-%d&#34;</span><span class="p">,</span> <span class="nx">rangeStart</span><span class="p">,</span> <span class="nx">rangeStop</span><span class="p">))</span>

<span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultClient</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
</code></pre></div><p>我们可以将其封装成一个方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Downloader</span><span class="p">)</span> <span class="nf">downloadPartial</span><span class="p">(</span><span class="nx">strURL</span><span class="p">,</span> <span class="nx">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rangeStart</span><span class="p">,</span> <span class="nx">rangeEnd</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">rangeStart</span> <span class="o">&gt;=</span> <span class="nx">rangeEnd</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">req</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">,</span> <span class="nx">strURL</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Range&#34;</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;bytes=%d-%d&#34;</span><span class="p">,</span> <span class="nx">rangeStart</span><span class="p">,</span> <span class="nx">rangeEnd</span><span class="p">))</span>
	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultClient</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">flags</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span> <span class="p">|</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span>
	<span class="nx">partFile</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nf">getPartFilename</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="nx">i</span><span class="p">),</span> <span class="nx">flags</span><span class="p">,</span> <span class="mo">0666</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">partFile</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">32</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">CopyBuffer</span><span class="p">(</span><span class="nx">partFile</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">,</span> <span class="nx">buf</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// getPartDir 部分文件存放的目录
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Downloader</span><span class="p">)</span> <span class="nf">getPartDir</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">SplitN</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// getPartFilename 构造部分文件的名字
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Downloader</span><span class="p">)</span> <span class="nf">getPartFilename</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">partNum</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">partDir</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">getPartDir</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s/%s-%d&#34;</span><span class="p">,</span> <span class="nx">partDir</span><span class="p">,</span> <span class="nx">filename</span><span class="p">,</span> <span class="nx">partNum</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>通过发起 Range 请求后，将请求的内容写入本地文件中；</li>
<li>为了方便后续合并，文件名加上了序号，这就是 downloadPartial 最后一个参数的作用；</li>
<li>rangeStart 和 rangeEnd 分别表示 Range 的开始和结束；</li>
</ul>
<p>然后就是 multiDownload 方法中怎么分部分，这和并发请求多个 URL 很类似，使用 sync.WaitGroup 进行控制：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Downloader</span><span class="p">)</span> <span class="nf">multiDownload</span><span class="p">(</span><span class="nx">strURL</span><span class="p">,</span> <span class="nx">filename</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">contentLen</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">partSize</span> <span class="o">:=</span> <span class="nx">contentLen</span> <span class="o">/</span> <span class="nx">d</span><span class="p">.</span><span class="nx">concurrency</span>

  <span class="c1">// 创建部分文件的存放目录
</span><span class="c1"></span>	<span class="nx">partDir</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">getPartDir</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
	<span class="nx">os</span><span class="p">.</span><span class="nf">Mkdir</span><span class="p">(</span><span class="nx">partDir</span><span class="p">,</span> <span class="mo">0777</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">os</span><span class="p">.</span><span class="nf">RemoveAll</span><span class="p">(</span><span class="nx">partDir</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">concurrency</span><span class="p">)</span>

	<span class="nx">rangeStart</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">d</span><span class="p">.</span><span class="nx">concurrency</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="c1">// 并发请求
</span><span class="c1"></span>		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">rangeStart</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>

			<span class="nx">rangeEnd</span> <span class="o">:=</span> <span class="nx">rangeStart</span> <span class="o">+</span> <span class="nx">partSize</span>
      <span class="c1">// 最后一部分，总长度不能超过 ContentLength
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">d</span><span class="p">.</span><span class="nx">concurrency</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
				<span class="nx">rangeEnd</span> <span class="p">=</span> <span class="nx">contentLen</span>
			<span class="p">}</span>

			<span class="nx">d</span><span class="p">.</span><span class="nf">downloadPartial</span><span class="p">(</span><span class="nx">strURL</span><span class="p">,</span> <span class="nx">filename</span><span class="p">,</span> <span class="nx">rangeStart</span><span class="p">,</span> <span class="nx">rangeEnd</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>

		<span class="p">}(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">rangeStart</span><span class="p">)</span>

		<span class="nx">rangeStart</span> <span class="o">+=</span> <span class="nx">partSize</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
  
  <span class="c1">// 合并文件
</span><span class="c1"></span>	<span class="nx">d</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Downloader</span><span class="p">)</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>计算出每个部分的大小；</li>
<li>通过 sync.WaitGroup 协调并发请求；</li>
<li>注意每个部分的 rangeStart 和 rangeEnd 的计算规则，特别注意最后一部分；</li>
<li>所有部分都请求完成后，需要进行合并；</li>
</ul>
<p>因为把每部分单独保存为文件了，所以合并只需要按照顺序处理这些文件即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">Downloader</span><span class="p">)</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">destFile</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">,</span> <span class="mo">0666</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">destFile</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">d</span><span class="p">.</span><span class="nx">concurrency</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">partFileName</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">getPartFilename</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">partFile</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">partFileName</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">destFile</span><span class="p">,</span> <span class="nx">partFile</span><span class="p">)</span>
		<span class="nx">partFile</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="nx">os</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">partFileName</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h3 id="连接程序">连接程序</h3>
<p>到这里，程序的核心部分已经完成。接下来该在 main.go 中的 Action 作如下处理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Action</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cli</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">strURL</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;url&#34;</span><span class="p">)</span>
  <span class="nx">filename</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;output&#34;</span><span class="p">)</span>
  <span class="nx">concurrency</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Int</span><span class="p">(</span><span class="s">&#34;concurrency&#34;</span><span class="p">)</span>
  <span class="k">return</span> <span class="nf">NewDownloader</span><span class="p">(</span><span class="nx">concurrency</span><span class="p">).</span><span class="nf">Download</span><span class="p">(</span><span class="nx">strURL</span><span class="p">,</span> <span class="nx">filename</span><span class="p">)</span>
<span class="p">},</span>
</code></pre></div><p>到这里可以运行测试下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">go run . --url https://apache.claz.org/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz
</code></pre></div><p>不出意外的话文件会下载成功。</p>
<h2 id="03-总结">03 总结</h2>
<p>实现了基本功能，读者朋友们可以进一步做优化、完善。比如：</p>
<ul>
<li>看到下载过程，体验更友好，可以加入 github.com/schollz/progressbar 库；</li>
<li>可以暂停下载，然后继续下载。即断点续传；</li>
<li>不支持并发下载的，支持单个下载，即完成 singleDownload 方法；</li>
</ul>
<p>类似下面这样：</p>
<p><p class="md__image">
  <img src="../imgs/downloader.png"
    alt=""  />
</p>
</p>
<p>这个实现的完整代码我放在了 GitHub：<a href="https://github.com/polaris1119/downloader" target="_blank" rel="noopener">https://github.com/polaris1119/downloader</a>
。</p>
<p>还有两点大家可以注意下：</p>
<ul>
<li>并发下载并不一定总是比简单下载快，一般文件越大，并发下载的优势才能体现。不过，并发下载可以端点续传；</li>
<li>并发下载可以进一步优化，毕竟写文件，再打开文件合并，是需要时间的；</li>
</ul>
<p>最后，再提醒一次，记得自己动手实现一个哦。</p>
]]></content>
		</item>
		
		<item>
			<title>这本 Go 新书挺期待的：100 个常见错误</title>
			<link>https://polarisxu.studygolang.com/posts/go/book/100-go-mistakes/</link>
			<pubDate>Tue, 29 Jun 2021 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/book/100-go-mistakes/</guid>
			<description>大家好，我是 polarisxu。 Go 虽然简单，但一样会有很多容易犯的错误。网上也有不少总结的 Go 常见错误。 Teiva Harsanyi 在 2019 年发表过一篇文章：《The Top 10 Most Common Mistakes I’ve Seen in Go Projects》 （这里有中文版：https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/ ）</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>Go 虽然简单，但一样会有很多容易犯的错误。网上也有不少总结的 Go 常见错误。</p>
<p>Teiva Harsanyi 在 2019 年发表过一篇文章：<a href="https://itnext.io/the-top-10-most-common-mistakes-ive-seen-in-go-projects-4b79d4f6cd65" target="_blank" rel="noopener">《The Top 10 Most Common Mistakes I’ve Seen in Go Projects》</a>
（这里有中文版：<a href="https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/" target="_blank" rel="noopener">https://tomotoes.com/blog/the-top-10-most-common-mistakes-ive-seen-in-go-projects/</a>
），总结了 Go 项目中常见的 10 个错误。这篇文章不仅分析每个错误的场景，还给出了最佳实践，值得一读。</p>
<p>看其中一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Status</span> <span class="kt">uint32</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">StatusOpen</span> <span class="nx">Status</span> <span class="p">=</span> <span class="kc">iota</span>
  <span class="nx">StatusClosed</span>
  <span class="nx">StatusUnknown</span>
<span class="p">)</span>
</code></pre></div><p>这样的代码，你认为有什么问题？</p>
<p>最近这篇文章的作者发文说，因为那篇文章挺受欢迎，他就想着能不能写一本这方面的图书。于是，他不断收集各种常见问题，研究博文、图书等。</p>
<p>去年年底，这样的错误达到了 100 个之多，于是他联系出版社准备出版该书。</p>
<p>和作者那篇文章类似，每一个错误都将尽可能用现实生活中的例子来说明。目标是希望能够帮助 Go 开发者更高效地工作，减少不必要的错误，真正做到 Go 提倡的 Happy Working！</p>
<p>目前这本书已经基本完成，在 manning 官方可以找到：<a href="https://www.manning.com/books/100-go-mistakes-how-to-avoid-them" target="_blank" rel="noopener">https://www.manning.com/books/100-go-mistakes-how-to-avoid-them</a>
，封面如下：</p>
<p><p class="md__image">
  <img src="../imgs/Harsanyi-MEAP-HI.png"
    alt=""  />
</p>
</p>
<p>该书目前出于预售阶段，打 5 折。不过，其中前三章已经可以免费阅读。作者给出了本书的目录，希望大家提建议。（可以访问这里看详细目录：<a href="https://medium.com/solvingalgo/100-go-mistakes-2022-4debd9449a72" target="_blank" rel="noopener">https://medium.com/solvingalgo/100-go-mistakes-2022-4debd9449a72</a>
）</p>
<p>从目录看，这本书挺适合作为手册翻阅的。作者预计，这本书得 2022 年春出版。期待一下！</p>
]]></content>
		</item>
		
		<item>
			<title>Go 启用新的官方问答社区</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/collectives-go/</link>
			<pubDate>Thu, 24 Jun 2021 23:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/collectives-go/</guid>
			<description>大家好，我是 polarisxu。 Go 官方宣布，在 StackOverflow 上启用新的问答社区，而这之前，官方的主要在 Google Groups。先简单介绍下 StackOverflow 的 Collective 。 01 Collective 是什么？ 我们知道 StackOverflow 是一个问答社区，针对某一个类问题，一般通过 Tag 的形式汇集，比如 Go 语言的：https://stackoverflow.com/questions/tagged/go 。而 Collective 是 StackOverflow 推出的，专门用于为你喜欢的技术构建一个社区</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>Go 官方宣布，在 StackOverflow 上启用新的问答社区，而这之前，官方的主要在 Google Groups。先简单介绍下 StackOverflow 的 <a href="https://stackoverflow.com/collectives" target="_blank" rel="noopener">Collective</a>
。</p>
<h2 id="01-collective-是什么">01 Collective 是什么？</h2>
<p>我们知道 StackOverflow 是一个问答社区，针对某一个类问题，一般通过 Tag 的形式汇集，比如 Go 语言的：<a href="https://stackoverflow.com/questions/tagged/go" target="_blank" rel="noopener">https://stackoverflow.com/questions/tagged/go</a>
。而 Collective 是 StackOverflow 推出的，专门用于为你喜欢的技术构建一个社区。</p>
<p>该社区最大的特点：帮助你更快地找到可信赖的答案，汇集了该领域专家，并围绕你最常使用的技术分享知识。</p>
<p>关于 Collective 更多介绍，可以查看官方博文：<a href="https://stackoverflow.blog/2021/06/23/collectives-stack-overflow/" target="_blank" rel="noopener">https://stackoverflow.blog/2021/06/23/collectives-stack-overflow/</a>
，这也是最近新推出的功能。</p>
<p>截止目前，只有两个 Collective 可用，分别是 Go 语言和 Google Cloud，相信马上会越来越多。</p>
<h2 id="02-go-collective">02 Go Collective</h2>
<p>根据 <a href="https://blog.golang.org/stackoverflow" target="_blank" rel="noopener">Go 官方介绍</a>
，Go Collective 是 StackOverflow Collective 上的第一个开源项目，是 Go &amp; StackOverflow 合作的结果。（<a href="https://stackoverflow.com/collectives/go" target="_blank" rel="noopener">https://stackoverflow.com/collectives/go</a>
）</p>
<p><p class="md__image">
  <img src="../imgs/go-collective01.png"
    alt=""  />
</p>
</p>
<p>官方访问时间的截图，15 个成员，目前已经近 1000 成员。</p>
<p>相比 StackOverflow 上普通的 Go 问答，Go Collective 是一个改进版的 StackOverflow。它将保留从 StackOverflow 得到的问答经验。但它也将为 Gopher 提供一个家园，为 Go 社区领袖提供一个发表意见和帮助建立最佳实践的机会。</p>
<p>具体来说，根据 Go 官方介绍，Go Collective 有如下好处：</p>
<ul>
<li>更快地找到可信的答案。一般，我们通过网上找答案之前，需要甄别以下方案的优劣，做一些对比。通过 Go Collective，你现在可以看到由 Go 团队推荐的答案，或者由认可的成员提供的答案，即 Go 团队成员、 Go Google 开发专家和 StackOverflow 用户，这些用户已经被 Stack Overflow 认可为 Go 生态系统技术的主题专家。当这些用户发布或编辑问题、提供答案或撰写文章时，他们将有一个徽章，标识他们为已认可成员。</li>
<li>希望在一个统一的地方获得需要的信息（这挺难的，需要时间，但真做到了，对社区来说是一件大好事）。StackOverflow 上的 Go Collectives 页面集中了所有与 Go 和相关标签相关的问题和答案以及其他内容。将包括从 Collective 到关键的 Go 网站的链接，同时 Go 网站也会引导 Gopher 到来到 Go Collective。</li>
<li>探索新的内容格式。Go 官方会随时更新技术，在 Go Collective 页面上可以找到更深入的产品信息，包括文章、长形式的内容，如 how-to 指南和公告。</li>
<li>赢得认可。StackOverflow 上的 Collective 也为 Go 官方提供了一种方式来认可你对社区的贡献。会有一个排行榜，你可以通过 Go Collective (<a href="https://stackoverflow.com/collectives/go?tab=members" target="_blank" rel="noopener">见“成员”标签</a>
)访问，这将有助于识别被指定为认可成员的可信任的贡献者。如果你有兴趣成为认可会员，请发邮件至 stackoverflow@golang. org。</li>
</ul>
<p>如果你是 Go 领域专家，同时英语还可以，建议试试成为 Go Collective 认可会员。</p>
<h2 id="03-总结">03 总结</h2>
<p>Go 官方和 Google Cloud 入驻 StackOverflow Collective，因为 Go 是构建云基础设施和应用程序的最佳语言，而 Google Cloud 是运行 Go 应用程序的最佳场所，所以现在 StackOverflow 是找到 Go 和云计算问题答案的最佳地点。</p>
<p>有官方的加持，相信 Go 社区会更好，遇到问题，大家可以多尝试上 Go Collective 查找。一些好问题、常见问题，我会考虑引入 Go 语言中文网，方便大家访问。</p>
<p>对 Go Collective，你有什么想说的吗？欢迎留言交流。</p>
]]></content>
		</item>
		
		<item>
			<title>这是要干嘛？！微软招 Go 编译器全职开发人员</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/microsoft-go/</link>
			<pubDate>Thu, 24 Jun 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/microsoft-go/</guid>
			<description>大家好，我是 polarisxu。 微软在其招聘主页上挂了一个招聘信息，招聘高级软件工程师（职位链接：https://careers.microsoft.com/us/en/job/1038385/Senior-Software-Engineer ）。这个职位有点特别： 个人贡献者。具体来说，找为 Go 语言编译器和工具开发的全职员工。 我们都知道，一直以来，微软搞了不少开</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>微软在其招聘主页上挂了一个招聘信息，招聘高级软件工程师（职位链接：<a href="https://careers.microsoft.com/us/en/job/1038385/Senior-Software-Engineer" target="_blank" rel="noopener">https://careers.microsoft.com/us/en/job/1038385/Senior-Software-Engineer</a>
）。这个职位有点特别：</p>
<p><p class="md__image">
  <img src="../imgs/microsoft-go01.png"
    alt=""  />
</p>
</p>
<p>个人贡献者。具体来说，找为 Go 语言编译器和工具开发的全职员工。</p>
<p>我们都知道，一直以来，微软搞了不少开发语言，最有名的是 VB、C#（.NET 框架）等。现在他们计划招全职人员，专门为 Go 编译器和工具贡献代码，这个真的很赞。</p>
<p>招聘需求中还提到，这个角色，将与 Microsoft 其他产品组密切合作，以收集需求并为 Go 开发工具改进。微软的愿景是希望这个角色支持 Go 在微软的应用，同时与更广泛的 Go 社区合作并分享这些改进。</p>
<p>从这点可以看出，Go 在微软内部肯定有不少产品在使用，这对 Go 来说是大好事。同时也反映了微软这些年在纳德拉的带领下发生了很大的变化，拥抱开源就是其中之一。</p>
<p>具体职责方面，该职位信息提到，为 Go 编译器和工具生态系统的设计和实现做出贡献，结合开源和封闭源代码开发工具技术，专注于提供 Go 工具集改进以支持内部产品组。</p>
<p>具体要求截图给大家看看：</p>
<p><p class="md__image">
  <img src="../imgs/microsoft-go02.png"
    alt=""  />
</p>
</p>
<p>对于那些从事 Go 编译器和工具相关的社区爱好者来说，这也许是一个很好的机会。</p>
<p>反观国内，有这样的大厂招类似的职位吗？</p>
]]></content>
		</item>
		
		<item>
			<title>Go1.17 快报之标准库越来越注重易用性</title>
			<link>https://polarisxu.studygolang.com/posts/go/pkg/go1.17-std/</link>
			<pubDate>Tue, 22 Jun 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/pkg/go1.17-std/</guid>
			<description>大家好，我是 polarisxu。 说起 Go 的优点，很多人会提到 Go 拥有强大的标准库，比如开发一个 HTTP 服务，几行代码就搞定。不过，如果是一个 PHPer 转到 Go，又会觉得 Go 标准库不够便利，很多东西都需要自己二次封装。这其实是一个取舍的问题。 Go 官方也在不断完善、优化标准库，在坚持一定原则的基础上，尽可能让标准库好用、易用。今天就看看 Go1.17 中，官方在这方面做了哪些改进。 01 time 包 Unix 时间戳，</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>说起 Go 的优点，很多人会提到 Go 拥有强大的标准库，比如开发一个 HTTP 服务，几行代码就搞定。不过，如果是一个 PHPer 转到 Go，又会觉得 Go 标准库不够便利，很多东西都需要自己二次封装。这其实是一个取舍的问题。</p>
<p>Go 官方也在不断完善、优化标准库，在坚持一定原则的基础上，尽可能让标准库好用、易用。今天就看看 Go1.17 中，官方在这方面做了哪些改进。</p>
<h2 id="01-time-包">01 time 包</h2>
<p>Unix 时间戳，大家知道单位是什么吗？Java 或 JavaScript 的同学大概率会回答是毫秒，因为这两门语言提供获取“时间戳”的方法，单位是毫秒。但实际上，标准的 Unix 时间戳，单位是秒，标准定义是：</p>
<blockquote>
<p>Unix 时间戳是从 1970 年 1 月 1 日（UTC/GMT 的午夜）开始所经过的秒数，不考虑闰秒。</p>
</blockquote>
<p>正因为如此，Go 标准库 time 包提供获取时间戳的方法是 <code>Unix()</code>，单位是秒：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Unix returns t as a Unix time, the number of seconds elapsed
</span><span class="c1">// since January 1, 1970 UTC. The result does not depend on the
</span><span class="c1">// location associated with t.
</span><span class="c1">// Unix-like operating systems often record time as a 32-bit
</span><span class="c1">// count of seconds, but since the method here returns a 64-bit
</span><span class="c1">// value it is valid for billions of years into the past or future.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Time</span><span class="p">)</span> <span class="nf">Unix</span><span class="p">()</span> <span class="kt">int64</span>
</code></pre></div><p>在和客户端/前端协商 API 时，一定要注意时间戳单位的问题。</p>
<p>为了方便，Go1.17 增加加了 Time.UnixMilli 方法，返回 Unix 时间戳的毫秒数，同时也提供了 UnixNano 和 UnixMicro。</p>
<p>此外，如果前端传递一个毫秒的时间戳，可以通过 Go1.17 新的函数 UnixMilli 转为 Time 类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">UnixMilli</span><span class="p">(</span><span class="nx">msec</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">Time</span>
</code></pre></div><p>注意 UnixMilli 函数和 Time.UnixMilli 方法的区别，互逆的关系。</p>
<h2 id="02-neturl-包">02 net/url 包</h2>
<p>在这个包中有一个类型 Values，定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Values</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span>
</code></pre></div><p>它通常用于查询参数和表单值。它提供了 Set、Get、Del 等方法，但没有提供判断某个 key 是否设置了的方法（虽然自己实现不难，但形式不一致），而且这种需求还挺多的。Go1.17 就增加了一个方法：Has，用来判断某个 key 是否设置了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Has checks whether a given key is set.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Values</span><span class="p">)</span> <span class="nf">Has</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></div><h2 id="03-net-包">03 net 包</h2>
<p>如何判断一个 IP 地址是否是内网地址？你查找标准库会发现没有这样的方法，这时只能自己实现，需要查找 IPv4 标准，看哪些是内网地址，还得处理 IPv6 的情况。</p>
<p>Go1.17 中增加了一个方法：IsPrivate，用来判断一个 IP 地址是否是内网地址：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// IsPrivate reports whether ip is a private address, according to
</span><span class="c1">// RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="nx">IP</span><span class="p">)</span> <span class="nf">IsPrivate</span><span class="p">()</span> <span class="kt">bool</span>
</code></pre></div><p>是不是方便很多。看它的实现，自己实现可能不那么容易：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="nx">IP</span><span class="p">)</span> <span class="nf">IsPrivate</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ip4</span> <span class="o">:=</span> <span class="nx">ip</span><span class="p">.</span><span class="nf">To4</span><span class="p">();</span> <span class="nx">ip4</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Following RFC 1918, Section 3. Private Address Space which says:
</span><span class="c1"></span>		<span class="c1">//   The Internet Assigned Numbers Authority (IANA) has reserved the
</span><span class="c1"></span>		<span class="c1">//   following three blocks of the IP address space for private internets:
</span><span class="c1"></span>		<span class="c1">//     10.0.0.0        -   10.255.255.255  (10/8 prefix)
</span><span class="c1"></span>		<span class="c1">//     172.16.0.0      -   172.31.255.255  (172.16/12 prefix)
</span><span class="c1"></span>		<span class="c1">//     192.168.0.0     -   192.168.255.255 (192.168/16 prefix)
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">ip4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">||</span>
			<span class="p">(</span><span class="nx">ip4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">172</span> <span class="o">&amp;&amp;</span> <span class="nx">ip4</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;</span><span class="mh">0xf0</span> <span class="o">==</span> <span class="mi">16</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="nx">ip4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">192</span> <span class="o">&amp;&amp;</span> <span class="nx">ip4</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">168</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Following RFC 4193, Section 8. IANA Considerations which says:
</span><span class="c1"></span>	<span class="c1">//   The IANA has assigned the FC00::/7 prefix to &#34;Unique Local Unicast&#34;.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ip</span><span class="p">)</span> <span class="o">==</span> <span class="nx">IPv6len</span> <span class="o">&amp;&amp;</span> <span class="nx">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;</span><span class="mh">0xfe</span> <span class="o">==</span> <span class="mh">0xfc</span>
<span class="p">}</span>
</code></pre></div><h2 id="04-其他包">04 其他包</h2>
<p>math 包新提供了 MaxInt、MinInt、MaxUint 三个常量，分别对应 int 的最大、最小值和 uint 的最大值，这样我们不需要自己判断当前 CPU 架构确定最大最小值。</p>
<p>io/fs 包新增加 FileInfoToDirEntry 函数，它用于获取一个 FileInfo 的 DirEntry 信息，在操作文件系统时可能会用到。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">FileInfoToDirEntry</span><span class="p">(</span><span class="nx">info</span> <span class="nx">FileInfo</span><span class="p">)</span> <span class="nx">DirEntry</span>
</code></pre></div><p>database/sql 包新增加了 NullByte 和 NullInt16，用于表示可能为 null 的 int16 和 byte 类型（我个人不建议创建数据表时支持 null，这样处理起来比较麻烦，建议全部 NOT NULL）。</p>
<h2 id="05-总结">05 总结</h2>
<p>简单、易用，一直是 Go 的哲学。标准库方面，Go 也会尽可能的做到易用，但不会封装到像 PHP 那样的程度，有些功能，还是需要自己进行二次封装。</p>
<p>你觉得 Go1.17 上面的改进如何？还有哪些功能是你希望标准库提供的？欢迎留言交流。</p>
]]></content>
		</item>
		
		<item>
			<title>Go1.17 新特性之切片变数组</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go1.17-slice-to-array/</link>
			<pubDate>Thu, 17 Jun 2021 07:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go1.17-slice-to-array/</guid>
			<description>大家好，我是 polarisxu。 按计划，Go 1.17 会在 2021 年 8 月份发布（目前已经发布了 Beta1 版本）。目前，1.17 相关的功能已经开发差不多了，上次介绍了测试顺序随机的问题，今天介绍 1.17 中的另一个新功能：切片显式地转换成数组指针。 温馨提示，如果要试验该功能，需要升级到 1.17 Beta1 版本。另外一个主意事项就是如果在有 go.mod 的目录中试验，确保其中的版本改为 1.17，否则会报错：conver</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>按计划，Go 1.17 会在 2021 年 8 月份发布（目前已经发布了 Beta1 版本）。目前，1.17 相关的功能已经开发差不多了，上次介绍了测试顺序随机的问题，今天介绍 1.17 中的另一个新功能：切片显式地转换成数组指针。</p>
<blockquote>
<p>温馨提示，如果要试验该功能，需要升级到 1.17 Beta1 版本。另外一个主意事项就是如果在有 go.mod 的目录中试验，确保其中的版本改为 1.17，否则会报错：conversion of slices to array pointers only supported as of -lang=go1.17</p>
</blockquote>
<h2 id="01-数组转切片">01 数组转切片</h2>
<p>介绍新功能之前，我们先看看在 Go 中如何将数组转为切片。（当然，数组指针也是 OK 的）</p>
<p>一般地，通过 slice 表达式（slice expressions）可以从一个数组得到一个切片。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span><span class="p">[</span><span class="nx">low</span> <span class="p">:</span> <span class="nx">high</span> <span class="p">:</span> <span class="nx">max</span><span class="p">]</span>
</code></pre></div><p>其中，max 可以省略。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</code></pre></div><p>s 就是一个切片。</p>
<h2 id="02-切片转数组指针">02 切片转数组指针</h2>
<p>先了解下，为什么会有这样的需求。</p>
<p>该需求来自这个 issue：<a href="https://github.com/golang/go/issues/395" target="_blank" rel="noopener">https://github.com/golang/go/issues/395</a>
。rogpeppe 提到，很多时候，函数接收一个 slice 参数，但如果使用数组指针，则允许编译器在编译时检查常量索引。比如这样的情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nx">a</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>能够编译期进行索引检查。比如这样（当然，最后实现不是这样的）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">b</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">];</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="nx">b</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>此外，有时候我们通过数组得到切片，但有时候我们直接创建切片，底层数组是匿名的。如果我们想要获得底层数组怎么办？将切片转为数组指针可以实现这个需求。</p>
<p>看看具体的例子，以下来自 Go 语言规范（针对 Go1.17 这个语言特性新增）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nx">s0</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">s</span><span class="p">)</span>      <span class="c1">// s0 != nil
</span><span class="c1"></span><span class="nx">s2</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">s</span><span class="p">)</span>      <span class="c1">// &amp;s2[0] == &amp;s[0]
</span><span class="c1"></span><span class="nx">s4</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">s</span><span class="p">)</span>      <span class="c1">// panics: len([4]byte) &gt; len(s)
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">t</span> <span class="p">[]</span><span class="kt">string</span>
<span class="nx">t0</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="kt">string</span><span class="p">)(</span><span class="nx">t</span><span class="p">)</span>    <span class="c1">// t0 == nil
</span><span class="c1"></span><span class="nx">t1</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="kt">string</span><span class="p">)(</span><span class="nx">t</span><span class="p">)</span>    <span class="c1">// panics: len([1]string) &gt; len(s)
</span></code></pre></div><p>几个注意的点：</p>
<ul>
<li>当切片的长度小于数组长度（len）时会 panic。所以上面例子中，s4 和 t1 发生了 panic</li>
<li>将一个非空切片转为 0 长度的数组，得到的指针不是 nil（如 s0）；但将一个空切片转为 0 长度的数组，得到的指针是 nil（如 t0）；</li>
<li>多次转换，并不会创建多个数组（因为得到的是底层数组），这从 <code>&amp;s2[0] == &amp;s[0]</code> 可以看出；</li>
</ul>
<p>所以，总结一下就是，将切片转换为数组指针，产生指向切片的底层数组的指针。如果切片的长度小于数组的长度，则会发生运行时 panic。</p>
<p>不过针对 panic，目前没法做断言检查。只能通过 if 判断了。</p>
<h2 id="03-reflect-注意事项">03 reflect 注意事项</h2>
<p>针对语言这个改动，reflect 包中的 Type 接口有一个方法：ConvertibleTo。之前的说明是这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ConvertibleTo reports whether a value of the type is convertible to type u.
</span><span class="c1"></span><span class="nf">ConvertibleTo</span><span class="p">(</span><span class="nx">u</span> <span class="nx">Type</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></div><p>1.17 是这样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ConvertibleTo reports whether a value of the type is convertible to type u.
</span><span class="c1">// Even if ConvertibleTo returns true, the conversion may still panic.
</span><span class="c1">// For example, a slice of type []T is convertible to *[N]T,
</span><span class="c1">// but the conversion will panic if its length is less than N.
</span><span class="c1"></span><span class="nf">ConvertibleTo</span><span class="p">(</span><span class="nx">u</span> <span class="nx">Type</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></div><p>因为切片转为数组指针可能会 panic，所以才加了这么一句文档说明。</p>
<p>因此，如果通过反射转换做类型转换，虽然通过 ConvertibleTo 判断是可转换的，但调用 Convert 方法依然可能 panic。这点需要特别注意下。</p>
<h2 id="04-小结">04 小结</h2>
<p>这个语言改变，大部分时候可能用不到。但有些场景可以做到不需要内存拷贝（copy），比如标准库中有一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// https://docs.studygolang.com/src/crypto/sha256/sha256.go?s=5787:5834#L252
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Sum224</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">sum224</span> <span class="p">[</span><span class="nx">Size224</span><span class="p">]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">d</span> <span class="nx">digest</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">is224</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">d</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
	<span class="nx">d</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">checkSum</span><span class="p">()</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">sum224</span><span class="p">[:],</span> <span class="nx">sum</span><span class="p">[:</span><span class="nx">Size224</span><span class="p">])</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>官方计划修改为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Sum224</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[</span><span class="nx">Size224</span><span class="p">]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">d</span> <span class="nx">digest</span>
	<span class="nx">d</span><span class="p">.</span><span class="nx">is224</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">d</span><span class="p">.</span><span class="nf">Reset</span><span class="p">()</span>
	<span class="nx">d</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">checkSum</span><span class="p">()</span>
	<span class="nx">ap</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">Size224</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">sum</span><span class="p">[:</span><span class="nx">Size224</span><span class="p">])</span>
	<span class="k">return</span> <span class="o">*</span><span class="nx">ap</span>
<span class="p">}</span>
</code></pre></div><p>注意其中的区别。</p>
<p>但这里 bradfitz 在修改时，发现，为什么一定要转为数组指针，能否直接转为数组，毕竟，在 Go 中使用数组的话，不太常用数组指针。于是 bradfitz 给出了另一个提案：<a href="https://github.com/golang/go/issues/46505" target="_blank" rel="noopener">https://github.com/golang/go/issues/46505</a>
，即 allow conversion from slice to array。目前该提案是否接受，还没有结论。</p>
]]></content>
		</item>
		
		<item>
			<title>回顾 Go 官网的演变史</title>
			<link>https://polarisxu.studygolang.com/posts/go/golangorg-website/</link>
			<pubDate>Mon, 14 Jun 2021 20:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/golangorg-website/</guid>
			<description>大家好，我是 polarisxu。 最近 618，阿里云等云厂商都在促销，我之前有一台服务器在华为云，正好要过期了，发现续费要 2500 左右。而阿里云新客买一台服务器，3 年才 179.9（1 核 2 G），用来镜像一个 Go 官网还是绰绰有余的。因为很早就镜像过 Go 官网，这次发现官网搭建又有了很大变化，因此决定回顾下 Go 官网的演变。 新人常年有优惠，比如 99 元/年。有兴趣的可以购买：https</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>最近 618，阿里云等云厂商都在促销，我之前有一台服务器在华为云，正好要过期了，发现续费要 2500 左右。而阿里云新客买一台服务器，3 年才 179.9（1 核 2 G），用来镜像一个 Go 官网还是绰绰有余的。因为很早就镜像过 Go 官网，这次发现官网搭建又有了很大变化，因此决定回顾下 Go 官网的演变。</p>
<blockquote>
<p>新人常年有优惠，比如 99 元/年。有兴趣的可以购买：<a href="https://www.aliyun.com/1111/new?userCode=tdj9sqcr" target="_blank" rel="noopener">https://www.aliyun.com/1111/new?userCode=tdj9sqcr</a>
，如果不是新客，可以使用家里人的身份注册。</p>
</blockquote>
<p>大家应该知道，Go 官网 <a href="https://golang.org" target="_blank" rel="noopener">https://golang.org</a>
 我们默认访问不了。这对很多新手来说挺困惑的。所以我很早就搞了一个 Go 官网镜像：<a href="https://docs.studygolang.com" target="_blank" rel="noopener">https://docs.studygolang.com</a>
。下面就聊聊我搭建官网的一些事，也是官网的演变史。</p>
<h2 id="01-自带官网">01 自带官网</h2>
<p>Go 1.0 发布时，安装包中自带 godoc 程序，通过该程序可以在本地搭建一个官网镜像：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">godoc -http<span class="o">=</span>:6060
</code></pre></div><p>打开浏览器访问 http://localohst:6060 ，看到如下页面：</p>
<p><p class="md__image">
  <img src="../imgs/golangorgwebsite01.png"
    alt=""  />
</p>
</p>
<p>这解决了我们访问不了 Go 官网的问题，我也借此搭建了一个 Go 官网镜像：<a href="https://docs.studygolang.com" target="_blank" rel="noopener">https://docs.studygolang.com</a>
。</p>
<h2 id="02-从主仓库剥离">02 从主仓库剥离</h2>
<p>从 Go1.2 开始，godoc 从 Go 主仓库剥离，放入了 <a href="https://github.com/golang/tools" target="_blank" rel="noopener">https://github.com/golang/tools</a>
 中。这时，如果想要本地搭建 Go 官网镜像，可以通过 go get 命名安装：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">go get golang.org/x/tools/cmd/godoc
</code></pre></div><p>但那时候这样多半安装不成功，因为 golang.org 访问不了。</p>
<h2 id="03-官网改版">03 官网改版</h2>
<p>2019 年，官网做了改版，也就是现在的样子。代码也不再使用 golang.org/x/tools/cmd/godoc，而是使用新仓库 <a href="https://github.com/golang/website" target="_blank" rel="noopener">https://github.com/golang/website</a>
，相当于完全重写。</p>
<p>要在本地搭建官网镜像，clone 该仓库代码，然后执行如下命令即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">go run ./cmd/golangorg
</code></pre></div><p>新官网长这样：</p>
<p><p class="md__image">
  <img src="../imgs/golangorgwebsite02.png"
    alt=""  />
</p>
</p>
<p>但有两个问题：</p>
<ul>
<li>官方博客在单独的域名：<a href="https://blog.golang.org" target="_blank" rel="noopener">https://blog.golang.org</a>
；</li>
<li>play 在另一个单独的域名：<a href="https://play.golang.org" target="_blank" rel="noopener">https://play.golang.org</a>
；</li>
</ul>
<p>这两个域名一样访问不了。而且，虽然 Go 官方特意为我们搭建了 <a href="https://golang.google.cn" target="_blank" rel="noopener">https://golang.google.cn</a>
，但这是阉割版，没有 blog 和 play。</p>
<p>play 主程序在 <a href="https://github.com/golang/tools" target="_blank" rel="noopener">https://github.com/golang/tools</a>
 仓库中，而 blog 在 <a href="https://github.com/golang/blog" target="_blank" rel="noopener">https://github.com/golang/blog</a>
 中， 为了搭建自己的 blog，得费一番心思。</p>
<p>Go1.16 发布后，使用了 Go  内嵌功能。最近在 website 仓库中，把 blog 也包含进来了（原 blog 仓库也删除了），同时 go.dev 网站主程序也放在了 website 中。</p>
<p>现在 Go 语言中文网搭建的 Go 官网镜像：<a href="https://docs.studygolang.com" target="_blank" rel="noopener">https://docs.studygolang.com</a>
 可以正常访问 blog 和 play，欢迎使用。</p>
<h2 id="04-总结">04 总结</h2>
<p>Go 官网在 website 仓库中，一个网站涉及几个程序，之前分开好几个项目。现在，通过 website 集中管理，同样的代码放在了该项目的 internal 子包中。</p>
<p>现在自己搭建一个 Go 官网镜像，只要 clone website 仓库代码，运行 <code>go run ./cmd/golangorg</code> 即可。</p>
]]></content>
		</item>
		
		<item>
			<title>站长8年前的Go代码竟然进入大厂的项目里了</title>
			<link>https://polarisxu.studygolang.com/posts/talk/about-writing/</link>
			<pubDate>Sun, 13 Jun 2021 20:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/about-writing/</guid>
			<description>大家好，我是 polarisxu。 在群里有一位大厂大佬发了这么一条信息： 有点惊住了！ 这是我在 2013 年 1 月写的一篇关于 RSA 的文章：《GO加密解密之RSA》 ，没想到进入了大厂的项目里。只不过，这 CTRL + C、CTRL +V 有点小猛，邮箱地址直接进入了仓库。。。不愧是： 群友们很有才，说可以写一篇文章：当初写下的示例程序，已然在巨头大厂安稳运行 6 年，创造的价值数以亿记。 这件事还是有些</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>在群里有一位大厂大佬发了这么一条信息：</p>
<p><p class="md__image">
  <img src="../imgs/rsa-polarisxu.png"
    alt=""  />
</p>
</p>
<p>有点惊住了！</p>
<p>这是我在 2013 年 1 月写的一篇关于 RSA 的文章：<a href="http://blog.studygolang.com/2013/01/go%e5%8a%a0%e5%af%86%e8%a7%a3%e5%af%86%e4%b9%8brsa/" target="_blank" rel="noopener">《GO加密解密之RSA》</a>
，没想到进入了大厂的项目里。只不过，这 CTRL + C、CTRL +V 有点小猛，邮箱地址直接进入了仓库。。。不愧是：</p>
<p><p class="md__image">
  <img src="../imgs/ctrl-c-v.jpeg"
    alt=""  />
</p>
</p>
<p>群友们很有才，说可以写一篇文章：当初写下的示例程序，已然在巨头大厂安稳运行 6 年，创造的价值数以亿记。</p>
<p>这件事还是有些启发：</p>
<ul>
<li>对外输出，一定要认真负责。输出，是提升能力很好的方式，通过输出也能倒逼输入。但输出一定要对读者负责，因为你的输出会成为别人的输入。我又重新验证了 2013 年文章的例子，虽然 Go 升级了这么多版本，但得益于 Go1 的兼容性，代码运行正常；</li>
<li>做一个「高端程序员，采用最朴素的编程方式」没错，但不能只是这种方式，复制、粘贴完后，一定要自己读一遍，看看有没有需要修改的地方，不能犯低级错误。我见过最多的就是，把注释也一起复制过去，然后从来不改注释，弄得注释和代码完全不是一回事。。。</li>
</ul>
<p>如果你是一个「高端程序员」，建议你试试输出，让别人也享受下「最朴素的编程方式」。</p>
]]></content>
		</item>
		
		<item>
			<title>Go图书翻译：一个好消息，一个坏消息</title>
			<link>https://polarisxu.studygolang.com/posts/go/book/practical-go-lessons-decline/</link>
			<pubDate>Sat, 12 Jun 2021 21:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/book/practical-go-lessons-decline/</guid>
			<description>大家好，我是 polarisxu。 看到广大 gopher 们的需求，昨天我发文宣布组织翻译《Practical Go Lessons》 这本书。发文后，有将近一百人要参与。感受到了大家的热情~ 昨天下午，我给作者发信息，请求授权我们翻译。昨天一天没有回应（虽然看到信息已读，但没有给我答复）。但我们觉得，大概率会取得授权，所以，昨天做好了准备工作：流程、规范等，并且大家觉得端午节假期可</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>看到广大 gopher 们的需求，昨天我发文宣布<a href="https://mp.weixin.qq.com/s/ry-qn0-7GuS0qb6ylU_4qA" target="_blank" rel="noopener">组织翻译《Practical Go Lessons》</a>
这本书。发文后，有将近一百人要参与。感受到了大家的热情~</p>
<p>昨天下午，我给作者发信息，请求授权我们翻译。昨天一天没有回应（虽然看到信息已读，但没有给我答复）。但我们觉得，大概率会取得授权，所以，昨天做好了准备工作：流程、规范等，并且大家觉得端午节假期可以搞定，因为参与人数多，一个人翻译一章，假期抽空完全可以搞定。同时也敲定了十来个校对者。又一次体会到了人多力量大！昨晚，就有几个人陆陆续续提交了 PR，翻译完成了几章。</p>
<p>然而，今天下午 3 点 24，我收到了作者的回信：</p>
<p><p class="md__image">
  <img src="../imgs/go-lessions-decline.png"
    alt=""  />
</p>
</p>
<p>被“无情”的拒绝了~所以，我立马通知了大家，没有获得授权。大家还是挺失望的，不过已经翻译了的，也算是一种学习，也是收获！而且，我们会考虑翻译其他 Go 图书。</p>
<p>但也有一个好消息，作者和他的朋友正在出中文版，虽然进度肯定没那么快，但毕竟官方出品。不得不佩服作者，一个法国人，用英文写该书，然后还自己搞定中文版。值得敬佩！</p>
<p>我昨天给他发消息，说明了国内 Gopher 的热情。也许他看到了中国 Gopher 的市场，所以决定自己出中文版。这，是好事！</p>
<p>虽然组织了半天，最后没取得授权，但得知了官方会出中文版，挺好！中文版出来，我会第一时间分享给大家！</p>
<p>再次感谢大家的热情和支持！祝大家端午节快乐！</p>
]]></content>
		</item>
		
		<item>
			<title>不怕烂尾！决定组织翻译这本 Go 图书</title>
			<link>https://polarisxu.studygolang.com/posts/go/book/practical-go-lessons-translate/</link>
			<pubDate>Thu, 10 Jun 2021 23:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/book/practical-go-lessons-translate/</guid>
			<description>大家好，我是 polarisxu。 前些天给大家分享了一本书：《Practical Go Lessons》 ，挺受欢迎，大家纷纷建议组织翻译。 实话说，我是担心烂尾的，因为之前组织过其他的，比如标准库翻译等，很多人都是一时热情，过些天就把这事忘得一干二净！最后想要有始有终，只能我自己慢慢收尾。 但看到大家的热情，我又觉得，也许这次大家能坚持呢？要不再试一次？大不了最后烂尾，</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>前些天给大家分享了一本书：<a href="https://mp.weixin.qq.com/s/Z97eT7FrqeJhygQwKvJaIw" target="_blank" rel="noopener">《Practical Go Lessons》</a>
，挺受欢迎，大家纷纷建议组织翻译。</p>
<p><p class="md__image">
  <img src="../imgs/go-lessions-translate01.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/go-lessions-translate02.png"
    alt=""  />
</p>
</p>
<p>实话说，我是担心烂尾的，因为之前组织过其他的，比如标准库翻译等，很多人都是一时热情，过些天就把这事忘得一干二净！最后想要有始有终，只能我自己慢慢收尾。</p>
<p>但看到大家的热情，我又觉得，也许这次大家能坚持呢？要不再试一次？大不了最后烂尾，万一能帮到更多人呢？！</p>
<p>于是，我昨天创建好了仓库，准备开搞。端午节期间，大家有空就可以搞起来。</p>
<p>因为 GitHub 最近访问实在有点难受，我选择在 Gitee 上进行，仓库地址：<a href="https://gitee.com/polarisxu/practical-go-lessons" target="_blank" rel="noopener">https://gitee.com/polarisxu/practical-go-lessons</a>
。</p>
<p>有兴趣参与的，加我微信：274768166 或 gopherstudio ，方便沟通交流，一起为社区做点事！</p>
<p>本书一共 41 章，如果有 41 人参与，一人一章，应该可以很快搞定。毕竟每章的内容不是特别多。期待你的参与！</p>
<p>这么可爱的封面，你不心动吗？</p>
<p><p class="md__image">
  <img src="../imgs/go-lessons-cover.jpg"
    alt=""  />
</p>
</p>
<p>请大家三连走一波，让更多人看到！</p>
]]></content>
		</item>
		
		<item>
			<title>Rust 劝退系列 08：模式匹配</title>
			<link>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-08/</link>
			<pubDate>Tue, 08 Jun 2021 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-08/</guid>
			<description>大家好，我是站长 polarisxu。 这是 Rust 劝退系列的第 8 个教程，探讨 Rust 中的模式匹配。 01 match 表达式 关于 match 表达式，很多其他语言并没有，比如 Go 语言。不过有些语言开始支持 match，比如 PHP 8.0 就有了 match 表达式。 一般地可以认为 match 和 switch 类似，所以 Rust 中没有 switch。 match 用于检查某个当前的值是否匹配一组/列值中的某一个。看一个具体的例子： fn test_match(number: i32)-&amp;gt; &amp;amp;&amp;#39;staticstr{matchnumber{// 匹配单个值 1=&amp;gt;{println!(&amp;#34;One!&amp;#34;);&amp;#34;One!&amp;#34;},// 匹配多个值 2|3|5|7|11=&amp;gt;&amp;#34;This is a prime&amp;#34;,// 匹配</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这是 Rust 劝退系列的第 8 个教程，探讨 Rust 中的模式匹配。</p>
<h2 id="01-match-表达式">01 match 表达式</h2>
<p>关于 match 表达式，很多其他语言并没有，比如 Go 语言。不过有些语言开始支持 match，比如 PHP 8.0 就有了 match 表达式。</p>
<p>一般地可以认为 match 和 switch 类似，所以 Rust 中没有 switch。</p>
<p>match 用于检查某个当前的值是否匹配一组/列值中的某一个。看一个具体的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">test_match</span><span class="p">(</span><span class="n">number</span>: <span class="kt">i32</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 匹配单个值
</span><span class="c1"></span><span class="w">        </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;One!&#34;</span><span class="p">);</span><span class="w"> </span><span class="s">&#34;One!&#34;</span><span class="p">},</span><span class="w">
</span><span class="w">        </span><span class="c1">// 匹配多个值
</span><span class="c1"></span><span class="w">        </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;This is a prime&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="c1">// 匹配一个闭区间范围
</span><span class="c1"></span><span class="w">        </span><span class="mi">13</span><span class="p">..</span><span class="o">=</span><span class="mi">19</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;A teen&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="c1">// 处理其他情况
</span><span class="c1"></span><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;Ain&#39;t special&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>看起来是一个简单的语法结构，但大概率在其他语言没见过。简单解释下：</p>
<ul>
<li>跟其他语言的 switch 类似，可以匹配多个分支；多个分支之间，使用 <code>,</code> 分隔；</li>
<li>在 match 分支中，<code>=&gt;</code> 左侧是模式，因此叫做模式匹配，比如 | 表示匹配多个值；<code>..=</code> 表示匹配一个范围；右侧是在左侧匹配成功时要执行的操作；</li>
<li>match 要求穷尽，也就是要包含所有可能的值。因此提供了 <code>_</code>，用来处理所有其他情况，类似 switch 的 default 分支；但只要穷尽了，可以没有 <code>_</code>；</li>
<li>如果右侧操作是多个语句，需要放在 <code>{}</code> 中；</li>
<li>match 是表达式，它的结果是匹配到的模式中，执行操作的最后一个表达式的结果。这在 Rust 中是很常见的，之前提到过，Rust 中一切皆表达式。所以，这个例子中 match 表达式的值即为函数的返回值。因此，match 的所有分支必须返回同一数据类型；</li>
<li>注意 match 表达式最后是否有分号的区别；</li>
</ul>
<blockquote>
<p>日常吐槽：在 match 中匹配区间，如果想和 for in 一样，使用 <code>..</code> 来表示半闭半开区间，结果报错。看到资料说应该使用 <code>…</code>，但却提示该语法已废弃！为啥语法结构还不保持一致呢？！</p>
</blockquote>
<p>看一个接收 match 结果的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">binary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">boolean</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kc">false</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="kc">true</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">};</span><span class="w">	</span><span class="c1">// 注意这里的分号
</span><span class="c1"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{} -&gt; {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">boolean</span><span class="p">,</span><span class="w"> </span><span class="n">binary</span><span class="p">);</span><span class="w">
</span></code></pre></div><h2 id="02-match-其他用法">02 match 其他用法</h2>
<p>上面介绍了常规的 match 操作。match 还有很多其他的用法。</p>
<h3 id="解构">解构</h3>
<p>当元组和 match 一起时，可以解构元组。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="c1">// 试一试将不同的值赋给 `pair`
</span><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="w">    
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Tell me about {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="c1">// match 可以解构一个元组
</span><span class="c1"></span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="c1">// 解构出第二个值
</span><span class="c1"></span><span class="w">        </span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;First is `0` and `y` is `{:?}`&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;`x` is `{:?}` and last is `0`&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">_</span><span class="w">      </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;It doesn&#39;t matter what they are&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="c1">// `_` 表示不将值绑定到变量
</span><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>关于枚举和指针、引用和 match 的结合，以后遇到再讲解。</p>
<h3 id="guard-语句">guard 语句</h3>
<p>在 match 分支中可以加上过滤条件。接着上面元组解构的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Tell me about {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;These are twins&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="c1">// `if` 条件部分是一个卫语句
</span><span class="c1"></span><span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Antimatter, kaboom!&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The first one is odd&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;No correlation...&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h3 id="绑定">绑定</h3>
<p>这是什么意思呢？看一个例子：（来自 rust by example）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// `age` 函数，返回一个 `u32` 值。
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">age</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="mi">15</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Tell me type of person you are&#34;</span><span class="p">);</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">age</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">0</span><span class="w">             </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;I&#39;m not born yet I guess&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="c1">// 可以直接 `match` 1 ..= 12，但怎么把岁数打印出来呢？
</span><span class="c1"></span><span class="w">        </span><span class="c1">// 在 1 ..= 12 分支中绑定匹配值到 `n` 。现在年龄就可以读取了。
</span><span class="c1"></span><span class="w">        </span><span class="n">n</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="p">..</span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;I&#39;m a child of age {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">n</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mi">13</span><span class="w"> </span><span class="p">..</span><span class="o">=</span><span class="w"> </span><span class="mi">19</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;I&#39;m a teen of age {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="c1">// 不符合上面的范围。返回结果。
</span><span class="c1"></span><span class="w">        </span><span class="n">n</span><span class="w">             </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;I&#39;m an old person of age {:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>match 后是一个函数，我们希望在分支中，根据匹配结果，使用 age 函数的返回值。当然，这个例子有点多此一举，完全可以在 match 之前用变量存储 age 函数的返回值。</p>
<p>那换一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">some_number</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="mi">41</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">some_number</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">@</span><span class="w"> </span><span class="mi">40</span><span class="p">..</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;The Answer: {}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w">      </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Not interesting... {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">),</span><span class="w">
</span><span class="w">        </span><span class="n">_</span><span class="w">            </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><ul>
<li>关于 Option 以后讲解</li>
</ul>
<p>这个例子很好的讲解了绑定的作用：分支中想要使用匹配的结果，通过 @ 符号可以将匹配的结果和某个变量绑定，然后就可以使用这个变量了。</p>
<h2 id="03-if-let-和-while-let">03 if let 和 while let</h2>
<p>这两个结构其他语言没见过，可以理解为是某些场景下替代 match，让代码更简洁，因为 match 必须穷尽所有情况，而 if let 和 while let 没有此限制。</p>
<p>以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">some_u8_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="k">u8</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">some_u8_value</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;three&#34;</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span><span class="w">	</span><span class="c1">// 有点多余
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>改为 if let：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">some_u8_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="k">u8</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">some_u8_value</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;three&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><ul>
<li>和 match 一样，if let 和 while let 都是表达式；</li>
<li>if/while let 等号左侧是模式，右侧是要匹配的值；所以当右侧的值和左侧的模式匹配时，执行对应的语句块；所以，有时候 if let 也可以单纯的当做解构使用；</li>
<li>if let 支持普通的 else if 和 else；while let 没有 else；</li>
</ul>
<p>while let 语法和 if let 类似。这里就不举例子了。</p>
<h2 id="04-小结">04 小结</h2>
<p>Rust 中的 match 虽然和其他语言的 switch 类似，很显然，match 的复杂度比 switch 高。当然，不管复杂与否，最关键还是要实际使用，需要不断实际练习。</p>
<p>通常，match 和 Option、枚举一起使用，因此，在讲解这两个知识点时，一般会使用到 match。</p>
]]></content>
		</item>
		
		<item>
			<title>一本花了2.5年写成的Go免费在线图书</title>
			<link>https://polarisxu.studygolang.com/posts/go/book/practical-go-lessons/</link>
			<pubDate>Mon, 07 Jun 2021 21:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/book/practical-go-lessons/</guid>
			<description>大家好，我是 polarisxu。 又一次为大家推荐 Go 图书，这是一本免费的 Go 语言在线图书：https://www.practical-go-lessons.com/ 。以下是该书的一个封面： 这本书采用渐进的方式讲解 Go 语言。作者还试图解释一些难以掌握的计算机科学概念，对于新人来说很有用。因此这本书对于那些没有计算机基础的人也有帮助。 我也写过书，也一直在坚持写文章，知</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>又一次为大家推荐 Go 图书，这是一本免费的 Go 语言在线图书：<a href="https://www.practical-go-lessons.com/" target="_blank" rel="noopener">https://www.practical-go-lessons.com/</a>
。以下是该书的一个封面：</p>
<p><p class="md__image">
  <img src="../imgs/go-lessons-cover.jpg"
    alt=""  />
</p>
</p>
<p>这本书采用渐进的方式讲解 Go 语言。作者还试图解释一些难以掌握的计算机科学概念，对于新人来说很有用。因此这本书对于那些没有计算机基础的人也有帮助。</p>
<p>我也写过书，也一直在坚持写文章，知道写作的不容易。但我看到这本书作者的写作经历，实在是佩服！！！</p>
<p>这本书是从 2018 年开始写的，作者都是利用晚上和周末。在 2020 年底，作者决定辞掉工作全职写该书，一本花了 2.5 年的书。可见作者多用心。而且，作者在书中每一章节开头都配置了一幅 Gopher 图，超级可爱，猜测是作者自己画的！上面的图就是其中一张。</p>
<p>花了这么多心血，还全职写该书，但万万没想到，作者竟然决定在网上免费分享该书。是不是很不理解？作者却认为，多年来他从互联网上获取到了很多知识。现在，他想通过这本书回馈社区！真的是良心作者。</p>
<p>当然，大家也可以购买支持。在这里可以购买：<a href="https://www.practical-go-lessons.com/buy-digital-or-hard-copy" target="_blank" rel="noopener">https://www.practical-go-lessons.com/buy-digital-or-hard-copy</a>
。老师和学生 10% 折扣。</p>
<p>这本书一共 41 章，758 页。可惜是英文的。大家有兴趣可以组织翻译一波？！</p>
<p>最后，附上该书的一些插图。</p>
<p><p class="md__image">
  <img src="../imgs/go-lessons01.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/go-lessons02.png"
    alt=""  />
</p>
</p>
]]></content>
		</item>
		
		<item>
			<title>被黑惨了：一句话，说明自己会 Go，咋整？</title>
			<link>https://polarisxu.studygolang.com/posts/talk/explain-you-programming-in-go/</link>
			<pubDate>Fri, 04 Jun 2021 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/explain-you-programming-in-go/</guid>
			<description>大家好，我是 polarisxu。 今天在「Go语言中文网」微信群里有网友问了这么一个问题：一句话，说明自己会 go，咋整？一个哥们立马给出了一个回复，竟然无法反驳，感觉 Go 被黑的很惨？！（被黑的最惨的一次？！！） 关于 if err != nil 的调侃真的不要太多。这里列举几个： 1）之前发过一篇文章：写了50万行Go代码是一种什么样的体验？ ，有人留言调侃说：有 10 万行是 if err != nil。。。</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>今天在「Go语言中文网」微信群里有网友问了这么一个问题：一句话，说明自己会 go，咋整？一个哥们立马给出了一个回复，竟然无法反驳，感觉 Go 被黑的很惨？！（被黑的最惨的一次？！！）</p>
<p><p class="md__image">
  <img src="../imgs/wechat-group-go.png"
    alt=""  />
</p>
</p>
<p>关于 <code>if err != nil</code> 的调侃真的不要太多。这里列举几个：</p>
<p>1）之前发过一篇文章：<a href="https://mp.weixin.qq.com/s/pzoTAl8xA9sefI_Ckpv8PA" target="_blank" rel="noopener">写了50万行Go代码是一种什么样的体验？</a>
，有人留言调侃说：有 10 万行是 <code>if err != nil</code>。。。</p>
<p>2）VSCode 有一个插件，配合 Mac 的 touch bar 可以一键生成 <code>if err != nil</code>，地址：<a href="https://github.com/dongri/touch-bar-if-err" target="_blank" rel="noopener">https://github.com/dongri/touch-bar-if-err</a>
</p>
<p><p class="md__image">
  <img src="../imgs/touch-bar.png"
    alt=""  />
</p>
</p>
<p>3）GoLand 编辑器也支持快捷键生成 <code>if err != nil</code></p>
<p>关于错误处理的问题确实是 Go 争议最多的，也有大量的文章讨论相关的问题，包括各种推荐的做法。在 Go 语言提案中，也有这种各样的错误处理提案。看几个：</p>
<ul>
<li><a href="https://github.com/golang/go/issues/33387" target="_blank" rel="noopener">simplify error handling with try err == nil {} except {}</a>
，目前这个提案被否了；</li>
<li><a href="https://github.com/golang/go/issues/46433" target="_blank" rel="noopener">try-catch by assignment</a>
，还是想要回到传统的 try catch，目测大概率会被否；</li>
<li><a href="https://github.com/golang/go/issues/36338" target="_blank" rel="noopener">error handling with error receiver function</a>
，增加了 or 关键字；</li>
<li>。。。</li>
</ul>
<p><p class="md__image">
  <img src="../imgs/simple-programming.jpeg"
    alt=""  />
</p>
</p>
<p>因为 error 大改影响挺大的，目前相关的提案都收录在了这个 issue 中：<a href="https://github.com/golang/go/issues/33892" target="_blank" rel="noopener">https://github.com/golang/go/issues/33892</a>
，这里包含了各种放在 go2 处理的 issue，有兴趣的可以了解。</p>
<p>一句话，说明自己会 Go，咋整？你会如何回答，欢迎留言交流！</p>
]]></content>
		</item>
		
		<item>
			<title>Go1.16 中的新函数 signal.NotifyContext 怎么用？</title>
			<link>https://polarisxu.studygolang.com/posts/go/signal-notifycontext/</link>
			<pubDate>Tue, 01 Jun 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/signal-notifycontext/</guid>
			<description>大家好，我是 polarisxu。 os/signal 这个包大家可能用的不多。但自从 Go1.8 起，有些人开始使用这个包了，原因是 Go1.8 在 net/http 包新增了一个方法： func (srv *Server) Shutdown(ctx context.Context) error 有了它就不需要借助第三方库实现优雅关闭服务了。具体怎么做呢？ func main() { server = http.Server{ Addr: &amp;#34;:8080&amp;#34;, } http.HandleFunc(&amp;#34;/&amp;#34;, func(w http.ResponseWriter, r *http.Request) { time.Sleep(time.Second * 10) fmt.Fprint(w, &amp;#34;Hello world!&amp;#34;) }) go server.ListenAndServe() // 监听中断信号（CTRL + C） c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) &amp;lt;-c // 重置 os.Interrupt 的默认行为 signal.Reset(os.Interrupt) fmt.Println(&amp;#34;shutting down gracefully, press Ctrl+C again to force&amp;#34;) // 给程序最多 5 秒时间处理正在服务的</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>os/signal 这个包大家可能用的不多。但自从 Go1.8 起，有些人开始使用这个包了，原因是 Go1.8 在 net/http 包新增了一个方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">srv</span> <span class="o">*</span><span class="nx">Server</span><span class="p">)</span> <span class="nf">Shutdown</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></div><p>有了它就不需要借助第三方库实现优雅关闭服务了。具体怎么做呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">server</span> <span class="p">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
		<span class="nx">Addr</span><span class="p">:</span> <span class="s">&#34;:8080&#34;</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Hello world!&#34;</span><span class="p">)</span>
	<span class="p">})</span>
  
	<span class="k">go</span> <span class="nx">server</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>

	<span class="c1">// 监听中断信号（CTRL + C）
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Interrupt</span><span class="p">)</span>
	<span class="o">&lt;-</span><span class="nx">c</span>

	<span class="c1">// 重置 os.Interrupt 的默认行为
</span><span class="c1"></span>	<span class="nx">signal</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Interrupt</span><span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;shutting down gracefully, press Ctrl+C again to force&#34;</span><span class="p">)</span>

	<span class="c1">// 给程序最多 5 秒时间处理正在服务的请求
</span><span class="c1"></span>	<span class="nx">timeoutCtx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">Shutdown</span><span class="p">(</span><span class="nx">timeoutCtx</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>这里利用 os/signal 包监听 Interrupt 信号；</li>
<li>收到该信号后，16 行 <code>&lt;-c</code> 会返回；</li>
<li>为了可以再次 CTRL + C 强制退出，通过 Reset 恢复 os.Interrupt 的默认行为；（这不是必须的）</li>
</ul>
<p>优雅退出的关键：1）新请求进不来；2）已有请求给时间处理完。所以，在接收到信号后，调用 server.Shutdown 方法，阻止新请求进来，同时给 5 秒等待时间，让已经进来的请求有时间处理。</p>
<p>在 Go1.16 中，os/signal 包新增了一个函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NotifyContext</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">signals</span> <span class="o">...</span><span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">stop</span> <span class="nx">context</span><span class="p">.</span><span class="nx">CancelFunc</span><span class="p">)</span>
</code></pre></div><p>功能和 Notify 类似，但用法上有些不同。上面的例子改用 NotifyContext：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">after</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">server</span> <span class="p">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
		<span class="nx">Addr</span><span class="p">:</span> <span class="s">&#34;:8080&#34;</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;Hello world!&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="k">go</span> <span class="nx">server</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">()</span>
	
  <span class="c1">// 监听中断信号（CTRL + C）
</span><span class="c1"></span>	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">stop</span> <span class="o">:=</span> <span class="nx">signal</span><span class="p">.</span><span class="nf">NotifyContext</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Interrupt</span><span class="p">)</span>
	<span class="o">&lt;-</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>

  <span class="c1">// 重置 os.Interrupt 的默认行为，类似 signal.Reset
</span><span class="c1"></span>	<span class="nf">stop</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;shutting down gracefully, press Ctrl+C again to force&#34;</span><span class="p">)</span>

  <span class="c1">// 给程序最多 5 秒时间处理正在服务的请求
</span><span class="c1"></span>	<span class="nx">timeoutCtx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">server</span><span class="p">.</span><span class="nf">Shutdown</span><span class="p">(</span><span class="nx">timeoutCtx</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>和上面的写法有区别，完成的功能一样的。其实 NotifyContext 的内部就是基于 Notify 实现的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NotifyContext</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">signals</span> <span class="o">...</span><span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">)</span> <span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">stop</span> <span class="nx">context</span><span class="p">.</span><span class="nx">CancelFunc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">signalCtx</span><span class="p">{</span>
		<span class="nx">Context</span><span class="p">:</span> <span class="nx">ctx</span><span class="p">,</span>
		<span class="nx">cancel</span><span class="p">:</span>  <span class="nx">cancel</span><span class="p">,</span>
		<span class="nx">signals</span><span class="p">:</span> <span class="nx">signals</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nf">Notify</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">ch</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">signals</span><span class="o">...</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Err</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">.</span><span class="nx">ch</span><span class="p">:</span>
				<span class="nx">c</span><span class="p">.</span><span class="nf">cancel</span><span class="p">()</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
			<span class="p">}</span>
		<span class="p">}()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">stop</span>
<span class="p">}</span>
</code></pre></div><p>只是在返回的 stop 被调用时，会执行 os/signal 包中的 Stop 函数，这个 Stop 函数的功能和 Reset 类似。因此上面 Notify 的例子，Reset 的地方可以改为 Stop。</p>
<p>从封装上看，NotifyContext 做的更好。而且，如果在某些需要 Context 的场景下，它把监控系统信号和创建 Context 一步搞定。</p>
<p>NotifyContext 的用法，优雅的关闭服务，你掌握了吗？希望你实际动手试验下，启动服务，通过 <code>curl http://localhost:8080/</code> 访问，然后按 CTRL + C，看看具体效果。只看不动手，基本知识不是你的。</p>
<p>关于 NotifyContext 函数的文档可以在这里查看：<a href="https://docs.studygolang.com/pkg/os/signal/#NotifyContext" target="_blank" rel="noopener">https://docs.studygolang.com/pkg/os/signal/#NotifyContext</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 1.17 新特性提前学之测试执行随机化</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go1.17-testing-shuffle-flag/</link>
			<pubDate>Sun, 30 May 2021 22:20:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go1.17-testing-shuffle-flag/</guid>
			<description>大家好，我是 polarisxu。 Go1.17 预计在 8 月份发布。目前 tip.golang.org 可以浏览 Go1.17 的相关内容，https://tip.golang.org/doc/go1.17 也有了 Go1.17 相关改动的部分文档。这段时间，我会陆续给大家分享 Go1.17 中相关的新特性，提前学习。。。好吧，提前卷了~ 今天先聊聊在测试中增加的随机化 flag：shuffle。 01 安装 tip 版本 由于 Go1.17 还未发布，因此为了体验它的新特性，我</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>Go1.17 预计在 8 月份发布。目前 tip.golang.org 可以浏览 Go1.17 的相关内容，<a href="https://tip.golang.org/doc/go1.17" target="_blank" rel="noopener">https://tip.golang.org/doc/go1.17</a>
 也有了 Go1.17 相关改动的部分文档。这段时间，我会陆续给大家分享 Go1.17 中相关的新特性，提前学习。。。好吧，提前卷了~</p>
<p>今天先聊聊在测试中增加的随机化 flag：shuffle。</p>
<h2 id="01-安装-tip-版本">01 安装 tip 版本</h2>
<p>由于 Go1.17 还未发布，因此为了体验它的新特性，我们需要安装 tip 版本。这是一个正在开发的版本，也就是仓库的 master 分支代码。因此，我们需要通过源码编译安装。</p>
<p>这里我使用 <a href="https://mp.weixin.qq.com/s/yTblk9Js1Zcq5aWVcYGjOA" target="_blank" rel="noopener">goup</a>
 这个管理工具进行安装：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ goup install tip
</code></pre></div><p>安装成功后，查看版本信息（你看到的大概率和我的不一样）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go version
go version devel go1.17-1607c28172 Sun May <span class="m">30</span> 02:37:38 <span class="m">2021</span> +0000 darwin/amd64
</code></pre></div><h2 id="02-新的-shuffle-flag">02 新的 shuffle flag</h2>
<p>安装完 tip 版本后，执行如下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go <span class="nb">help</span> testflag
</code></pre></div><p>然后找到下面这个 flag：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text">-shuffle off,on,N
		Randomize the execution order of tests and benchmarks.
		It is off by default. If -shuffle is set to on, then it will seed
		the randomizer using the system clock. If -shuffle is set to an
		integer N, then N will be used as the seed value. In both cases,
		the seed will be reported for reproducibility.
</code></pre></div><p>这是 Go1.17 新增的，提交的代码见：<a href="https://golang.org/cl/310033" target="_blank" rel="noopener">https://golang.org/cl/310033</a>
。</p>
<p>从名称可以看出，这是控制测试执行顺序是否随机的 flag。它有三个值：off、on 和 N，其中默认是 off，即不启用随机，这相当于 Go1.17 版本之前的测试行为。而 on 表示启用 shuffle，那 N 是什么意思？它也表示启用随机。on 和 N 的区别解释下：</p>
<blockquote>
<p>因为是随机，就涉及到随机种子（seed）问题。当值是 on 时，随机数种子使用系统时钟；如果值是 N，则直接用这个 N 当做随机数种子。注意 N 是整数。</p>
<p>当测试失败时，如果启用了 shuffle，这个种子会打印出来，方便你重现之前测试场景。</p>
</blockquote>
<h2 id="03-例子体验下">03 例子体验下</h2>
<p>创建一个包 calc，增加「加减乘除」四个函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Minus</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span> <span class="o">-</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Mul</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Div</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span> <span class="o">/</span> <span class="nx">y</span>
<span class="p">}</span>
</code></pre></div><p>并为这四个函数写好单元测试（代码太长，这里只列出 Add 的，写法不重要，按你喜欢的方式写单元测试即可）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestAdd</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="nx">args</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">x</span> <span class="kt">int</span>
		<span class="nx">y</span> <span class="kt">int</span>
	<span class="p">}</span>
	<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">args</span> <span class="nx">args</span>
		<span class="nx">want</span> <span class="kt">int</span>
	<span class="p">}{</span>
		<span class="p">{</span>
			<span class="nx">args</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
			<span class="mi">3</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="p">{</span>
			<span class="nx">args</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
			<span class="mi">3</span><span class="p">,</span>		<span class="c1">// 特意构造一个 failure 的 case
</span><span class="c1"></span>		<span class="p">},</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">got</span> <span class="o">:=</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">tt</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">y</span><span class="p">);</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Add() = %v, want %v&#34;</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后运行单元测试（不加 shuffle flag）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go <span class="nb">test</span> -v ./...
<span class="o">===</span> RUN   TestAdd
    calc_test.go:27: Add<span class="o">()</span> <span class="o">=</span> 2, want <span class="m">3</span>
--- FAIL: TestAdd <span class="o">(</span>0.00s<span class="o">)</span>
<span class="o">===</span> RUN   TestMinus
--- PASS: TestMinus <span class="o">(</span>0.00s<span class="o">)</span>
<span class="o">===</span> RUN   TestMul
--- PASS: TestMul <span class="o">(</span>0.00s<span class="o">)</span>
<span class="o">===</span> RUN   TestDiv
--- PASS: TestDiv <span class="o">(</span>0.00s<span class="o">)</span>
FAIL
FAIL	test/shuffle	0.441s
FAIL
</code></pre></div><p>多次运行，发现执行顺序都是你文件中写好的单元测试顺序，我这里是 Add、Minus、Mul、Div。</p>
<p>加上 shuffle flag 后运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go <span class="nb">test</span> -v -shuffle<span class="o">=</span>on ./...
-test.shuffle <span class="nv">1622383890431866000</span>
<span class="o">===</span> RUN   TestMul
--- PASS: TestMul <span class="o">(</span>0.00s<span class="o">)</span>
<span class="o">===</span> RUN   TestDiv
--- PASS: TestDiv <span class="o">(</span>0.00s<span class="o">)</span>
<span class="o">===</span> RUN   TestAdd
    calc_test.go:27: Add<span class="o">()</span> <span class="o">=</span> 2, want <span class="m">3</span>
--- FAIL: TestAdd <span class="o">(</span>0.00s<span class="o">)</span>
<span class="o">===</span> RUN   TestMinus
--- PASS: TestMinus <span class="o">(</span>0.00s<span class="o">)</span>
FAIL
FAIL	test/shuffle	0.177s
FAIL
</code></pre></div><p>输出有两处变化:</p>
<ul>
<li>多了 <code>-test.shuffle 1622383890431866000</code>，即上面说到的种子。如果不是 on 而是 N，则这里的值就是 N 的值；</li>
<li>顺序不确定。你多次运行，发现每次顺序可能不一样；</li>
</ul>
<p>顺便提一句，对于 benchmark，shuffle 这个 flag 也是适用的。</p>
<h2 id="04-有什么用">04 有什么用</h2>
<p>有人可能会问，这个玩意有啥用？</p>
<p>确实，大部分时候这个特性没啥用。但如果你不希望测试之间有依赖关系，而担心实际上依赖了，可以加上这个 flag，以便发现潜在的问题。</p>
<p>其实，这个 flag 早在 2015 年 bradfitz 就提 <a href="https://github.com/golang/go/issues/10655" target="_blank" rel="noopener">issue</a>
 建议加上，原计划在 Go1.6 加上的，但没有人写提案，因此搁置了。6 年过去了，才加上该功能，可见需求不强烈。日常工作中，你大概率也不会用到，但知晓有这么个东西还是有用处的，万一需要时，可以用上。</p>
]]></content>
		</item>
		
		<item>
			<title>Rust 劝退系列 07：流程控制</title>
			<link>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-07/</link>
			<pubDate>Tue, 25 May 2021 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-07/</guid>
			<description>大家好，我是站长 polarisxu。 这是 Rust 劝退系列的第 7 个教程，探讨 Rust 中的流程控制。注意，跟其他语言一样，Rust 中有条件、循环，但没有 switch，而是有 match 模式匹配。 01 运算符 开始讲解流程控制之前，先补充一个知识点，那就是 Rust 的运算符。 Rust 支持算术运算符、关系运算符、逻辑运算符和位运算符 4 种，它们和其他语言没有什么不同，因此不细讲了，只提醒一点：Rust 中没有自</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这是 Rust 劝退系列的第 7 个教程，探讨 Rust 中的流程控制。注意，跟其他语言一样，Rust 中有条件、循环，但没有 switch，而是有 match 模式匹配。</p>
<h2 id="01-运算符">01 运算符</h2>
<p>开始讲解流程控制之前，先补充一个知识点，那就是 Rust 的运算符。</p>
<p>Rust 支持算术运算符、关系运算符、逻辑运算符和位运算符 4 种，它们和其他语言没有什么不同，因此不细讲了，只提醒一点：Rust 中没有自增（++）和自减运算符（&ndash;）。</p>
<blockquote>
<p>Go 中 <code>++</code> 或 <code>--</code> 是语句，只有一种形式：后缀，即 i++；而 C 等语言支持前缀和后缀，如 i++、++i。Rust 干脆全没有。</p>
</blockquote>
<p>吐槽：自增和自减运算符，有时候挺好用的，Rust 为啥不支持呢？！（难道因为没有常规的 for 循环，所以不需要？）</p>
<h2 id="02-语句和表达式">02 语句和表达式</h2>
<p>为什么专门介绍语句和表达式？！</p>
<p>上文提到，Go 中的自增或自减是语句而不是表达式，这有什么不同呢？</p>
<p>很多语言对语句和表达式基本不会特意区分、强调，所以很多人也不会在意这两者有什么不同。但在 Rust 中，还是很有必要区分它们的。</p>
<p>实际上，Rust 中的语法可以分为两大类：语句（Statement）和表达式（Expression）。语句是指要执行的一些操作和产生副作用的表达式；而表达式主要用于计算求值。</p>
<p>语句通常分为声明语句和表达式语句。像声明各种语言项，如变量、常量、结构体、函数等，都是声明语句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">PI</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mf">3.14</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>而表达式语句，指的是以分号结尾的表达式，一般会涉及到将多个表达式组合为语句。</p>
<p>《Rust 编程之道》上说，Rust 中的表达式一般分为「位置表达式」和「值表达式」，概念太多，容易劝退，直接按照其他语言的叫法：左值和右值。</p>
<blockquote>
<p>之所以都用表达式的说法，是因为 Rust 中一切皆表达式。</p>
</blockquote>
<p>罗里吧嗦讲一堆，似乎没啥用。知道有这么回事即可。只需要记住 Rust 中一切皆表达式即可。</p>
<h2 id="03-条件表达式">03 条件表达式</h2>
<p>知道为什么要强调「表达式」了吗？一般语言中都叫：条件语句，但 Rust 中却是条件表达式。</p>
<p>首先，条件表达式的语法和其他语言的条件语句类似，支持 if、else if、else 等，但它和 Go 中类似，条件默认都不需要括号。但因为是表达式，所以它有返回值，而 Rust 是强类型语言，因此返回值的类型必须确定。比如以下代码是能正常编译的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">testif</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;polarisxu&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#34;polarisxu&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;Welcome&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;Forbidden&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>看不懂没关系。我们只关注 if-else 部分。</p>
<p>在块表达式里（由 <code>{}</code> 包围），直接一个字符串字面值（这是值表达式），连分号都没有。Rust 没有分号和 Go 中的没有分号意义是不一样的。</p>
<ul>
<li>Go 语句以分号结尾，分号推荐不写，编译器会自动补上；</li>
<li>Rust 语句必须手动加分号，如果不加分号，那是一个表达式。</li>
</ul>
<p>一切皆表达式，大括号包围起来的是块表达式，那块表达式的值是什么？它的值是里面一系列表达式中最后一个表达式的值。</p>
<p>所以，上面的代码，无论是执行到 if 还是 else，整个 if 表达式的值的类型是字符串。所以，以上代码可以改为这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">testif</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;polarisxu&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#34;polarisxu&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;Welcome&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;Forbidden&#34;</span><span class="w">
</span><span class="w">    </span><span class="p">};</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="n">hello</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>我们将 if 表达式的结果保存在 result 变量中，注意 if 表达式大括号最后的分号，这种情况，分号不能省略。</p>
<p>因此，在 if 表达式中，各个分支表达式最终的结果类型必须一致，否则编译不通过。这也是为什么 Rust 不支持三元操作符 ?: 的原因。</p>
<p>if 是表达式有它的好处。在 Go 语言中，经常会写类似这样的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">result</span> <span class="kt">string</span>
<span class="k">if</span> <span class="nx">name</span> <span class="o">==</span> <span class="s">&#34;polarisxu&#34;</span> <span class="p">{</span>
  <span class="nx">result</span> <span class="p">=</span> <span class="s">&#34;Welcome&#34;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">result</span> <span class="p">=</span> <span class="s">&#34;Forbidden&#34;</span>
<span class="p">}</span>
</code></pre></div><p>而 Rust 的代码，result 少写了很多次。但需要注意各分支结果类型的一致性。</p>
<p>if 表达式可以这么用，其他流程控制表达式也可以这么用。</p>
<p><strong>特别说明一点</strong>。如果块表达式的最后一个表达式是语句，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">testif</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;polarisxu&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#34;polarisxu&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;Welcome&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;forbidden&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>这时编译会报错：mismatched types。</p>
<p>因为函数要求返回值类型是 &amp;str，而函数体最后返回的类型是空。这个空，在其他语言中一般是没有返回值，或者是 void。但在 Rust 中，这个空是前面介绍类型时介绍过的「unit」类型，即 ()，该类型有唯一的值，也是 ()。</p>
<p>所以，我们可以去掉函数的返回值，或者返回 ()：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">testif</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;polarisxu&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#34;polarisxu&#34;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;Welcome&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="s">&#34;forbidden&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>很另类，有木有？！</p>
<h2 id="04-循环表达式">04 循环表达式</h2>
<p>Rust 中包含三种循环表达式：while、loop 和 for…in。其用法和其他编程语言相应的语句类似。（注意，Go 中只有 for 一种循环语句）</p>
<p>loop 循环比较特殊，一般语言中没有，它其实就是 <code>while true {}</code>，相当于 Go 中的 <code>for {}</code>。不得不说，还是 Go 简单呀！</p>
<p>而 while 循环，相当于 Go 中的 <code>for condition {}</code>，condition 为 true 时，执行循环体。</p>
<p>你发现没，循环搞这么复杂，竟然没有其他语言中普通的 for 循环？因为 for…in 可以搞定。</p>
<p>比如 Go 中的 <code>for i := 0; i &lt; 10; i++</code>，在 Rust 中是这样的：<code>for i in 0..10 {}</code>。来个简单的例子，从 1 加到 100：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">..</span><span class="o">=</span><span class="mi">100</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;1+2+..+100={}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">sum</span><span class="p">);</span><span class="w">
</span></code></pre></div><blockquote>
<p>小细节：1..10 表示范围 [1, 10)，而 1..=10 表示范围 [1, 10]</p>
</blockquote>
<p>最后，和其他语言一样，循环支持 continue 和 break 语句。</p>
<h2 id="05-小结">05 小结</h2>
<p>Rust 中一切皆表达式，当某个地方需要一个表达式，但却是一个语句时，编译器会自动补上单元值，即 ()，这算是一个特殊的表达式。</p>
<p>虽然控制结构，if、循环等都是表达式，为了不搞特殊化（毕竟大家习惯很多其他语言，特殊化可能容易把自己搞迷糊），建议大家尽量别把它们当表达式看待，很其他语言一样正常写，该有分号的加分号。</p>
<p>不过，如果是 Go 程序员写 Rust，很可能忘记分号。而 Rust 中，有时候有分号和没有分号都能编译，但意思可能变了，这个要特别注意。（PHPer 表示，经常在 PHP 和 Go 之间切换时，分号的问题很纠结，有木有？！）</p>
<p>控制流程中的模式匹配，下节再讲！</p>
]]></content>
		</item>
		
		<item>
			<title>官方的 Go 多版本管理：使用和原理</title>
			<link>https://polarisxu.studygolang.com/posts/go/managing-multiple-go-versions/</link>
			<pubDate>Mon, 24 May 2021 20:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/managing-multiple-go-versions/</guid>
			<description>大家好，我是 polarisxu。 有些人可能注意到，每次 Go 发布新版本，官方都会提供类似这样的升级截图： 这可以说是官方的 Go 多版本管理，也是升级 Go 的方式。今天就一起聊一聊这种多版本管理方式及其实现原理。（我之前介绍过一个第三方多版本管理工具 goup ，是我比较推荐的）。 注意，Windows 用户应该使用 WSL2。 01 为什么需要多个 Go 版本 有些人可能觉得没有这样的需求。实际工作中</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>有些人可能注意到，每次 Go 发布新版本，官方都会提供类似这样的升级截图：</p>
<p><p class="md__image">
  <img src="../imgs/1.16.4.png"
    alt=""  />
</p>
</p>
<p>这可以说是官方的 Go 多版本管理，也是升级 Go 的方式。今天就一起聊一聊这种多版本管理方式及其实现原理。（我之前介绍过一个第三方多版本管理工具 <a href="https://mp.weixin.qq.com/s/yTblk9Js1Zcq5aWVcYGjOA" target="_blank" rel="noopener">goup</a>
，是我比较推荐的）。</p>
<blockquote>
<p>注意，Windows 用户应该使用 WSL2。</p>
</blockquote>
<h2 id="01-为什么需要多个-go-版本">01 为什么需要多个 Go 版本</h2>
<p>有些人可能觉得没有这样的需求。实际工作中，这样的需求还是很常见的。以下一些场景，可能会希望有多版本：</p>
<ul>
<li>一般为了稳定，线上版本通常不会激进升级到最新版本，但你本地很可能想试用新版本的功能。这时候就希望能方便的支持多版本；</li>
<li>为了测试或重现特定的问题，希望能够在特定的版本进行，这是为了避免不同版本干扰。</li>
<li>。。。</li>
</ul>
<p>多版本并存，让我们可以更自如的使用 Go。</p>
<h2 id="02-官方多版本的使用方式">02 官方多版本的使用方式</h2>
<p>根据上面的图，安装某个版本的 Go，跟一般 Go 包安装一样，执行 go get 命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get golang.org/dl/go&lt;version&gt;		// 其中 &lt;version&gt; 替换为你希望安装的 Go 版本
</code></pre></div><p>这一步，只是安装了一个特定 Go 版本的包装器，真正安装特定的 Go 版本，还需要执行如下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go&lt;version&gt; download			// 和上面一样，&lt;version&gt; 是具体的版本
</code></pre></div><p>因此，如果需要安装 Go1.16.4，执行如下两个命令即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get golang.org/dl/go1.16.4
$ go1.16.4 download
</code></pre></div><p>几个注意的点：</p>
<ul>
<li>有一个特殊的版本标记：gotip，用来安装最新的开发版本；</li>
<li>因为 golang.org 访问不了，你应该配置 GOPROXY（所以，启用 Module 是必须的）；</li>
<li>跟安装其他包一样，go get 之后，go1.16.4 这个命令会被安装到 <code>$GOBIN</code> 目录下，默认是 <code>~/go/bin</code> 目录，所以该目录应该放入 PATH 环境变量；</li>
<li>没有执行 download 之前，运行 go1.16.4，会提示 <code>go1.16.4: not downloaded. Run 'go1.16.4 download' to install to ~/sdk/go1.16.4</code>；</li>
</ul>
<p>可见，最后下载下来的 Go 放在了 ~/sdk/go1.16.4 目录下。</p>
<p>现在你是否有这样的疑问：没执行 download 之前，直接运行 go1.16.4 会报错，执行之后，它就成了具体的 Go 命令了，怎么做到的？</p>
<h2 id="03-扒一扒原理">03 扒一扒原理</h2>
<p><code>golang.org/dl/go&lt;version&gt;</code> 对应的源码在 <a href="https://github.com/golang/dl" target="_blank" rel="noopener">https://github.com/golang/dl</a>
（这是一个镜像）。</p>
<p>查看该仓库代码，发现一堆以各个版本命名的目录：</p>
<p><p class="md__image">
  <img src="../imgs/golang-dl.png"
    alt=""  />
</p>
</p>
<p>可见，每次发布新版本，都需要往这个仓库增加一个对应的版本文件夹。</p>
<p>随便打开一个（比如 go1.16.4），看看里面包含什么文件：</p>
<p>就一个 main.go 文件（从 go get 安装操作，你应该猜到一定有一个 main.go 文件）。</p>
<p>main.go 文件的内容如下：（gotip 的内容不一样，它调用的是 version.RunTip()）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;golang.org/dl/internal/version&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">version</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;go1.16.4&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>所以，关键在于 internal/version 包的 Run 函数（不同版本，version 参数不同）。注意以下代码我给的注释：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Run runs the &#34;go&#34; tool of the provided Go version.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Run</span><span class="p">(</span><span class="nx">version</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">SetFlags</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

  <span class="c1">// goroot 获取 go 安装的目录，即 ~/sdk/go&lt;version&gt;
</span><span class="c1"></span>	<span class="nx">root</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">goroot</span><span class="p">(</span><span class="nx">version</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;%s: %v&#34;</span><span class="p">,</span> <span class="nx">version</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

  <span class="c1">// 执行下载操作
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#34;download&#34;</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">install</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">version</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;%s: download failed: %v&#34;</span><span class="p">,</span> <span class="nx">version</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>

  <span class="c1">// 怎么验证是否已经下载好了 Go？在下载的 Go 中会创建一个 .unpacked-success 文件，用来指示下载好了。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Stat</span><span class="p">(</span><span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">unpackedOkay</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;%s: not downloaded. Run &#39;%s download&#39; to install to %v&#34;</span><span class="p">,</span> <span class="nx">version</span><span class="p">,</span> <span class="nx">version</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>
	<span class="p">}</span>

  <span class="c1">// 运行下载好的 Go
</span><span class="c1"></span>	<span class="nf">runGo</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这里主要是下载和运行 Go。</p>
<h3 id="下载">下载</h3>
<p>我们先看下载、安装 Go。</p>
<p>当执行 go1.16.4 download 时，会运行 install 函数，查看该函数发现，它调用了 versionArchiveURL 函数获取要下载的 Go 的 URL：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// versionArchiveURL returns the zip or tar.gz URL of the given Go version.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">versionArchiveURL</span><span class="p">(</span><span class="nx">version</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">goos</span> <span class="o">:=</span> <span class="nf">getOS</span><span class="p">()</span>

    <span class="nx">ext</span> <span class="o">:=</span> <span class="s">&#34;.tar.gz&#34;</span>
    <span class="k">if</span> <span class="nx">goos</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
        <span class="nx">ext</span> <span class="p">=</span> <span class="s">&#34;.zip&#34;</span>
    <span class="p">}</span>
    <span class="nx">arch</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOARCH</span>
    <span class="k">if</span> <span class="nx">goos</span> <span class="o">==</span> <span class="s">&#34;linux&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOARCH</span> <span class="o">==</span> <span class="s">&#34;arm&#34;</span> <span class="p">{</span>
        <span class="nx">arch</span> <span class="p">=</span> <span class="s">&#34;armv6l&#34;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&#34;https://dl.google.com/go/&#34;</span> <span class="o">+</span> <span class="nx">version</span> <span class="o">+</span> <span class="s">&#34;.&#34;</span> <span class="o">+</span> <span class="nx">goos</span> <span class="o">+</span> <span class="s">&#34;-&#34;</span> <span class="o">+</span> <span class="nx">arch</span> <span class="o">+</span> <span class="nx">ext</span>
<span class="p">}</span>
</code></pre></div><p>也就是从 <a href="https://dl.google.com" target="_blank" rel="noopener">https://dl.google.com</a>
 下载 Go 包，最终的包（是一个归档文件，Wiindows 下是 .zip，其他系统是 .tar.gz）会放到 ~/sdk/go1.16.4 目录下。</p>
<p>之后通过 sha256 验证文件的完整性（因为服务端放了 sha256 校验文件），最后解压缩，并创建上面说的 <code>.unpacked-success</code> 空标记文件。这样这个版本的 Go 就安装成功了。</p>
<blockquote>
<p>注意，gotip 的下载是通过 git 获取源码的方式进行的，它会通过源码构建安装最新的 gotip 版本。具体逻辑在 internal/version/gotip.go 中。</p>
</blockquote>
<h3 id="运行">运行</h3>
<p>因为下载的 Go 是预编译好的，因此可以直接使用。</p>
<p>但是它将 Go 下载到了 <code>~/sdk/go&lt;version&gt;</code> 目录下了，我们并没有将这个目录的 bin 目录加入 PATH，因此直接 go 命令运行的还是之前的版本，而不是刚安装的 go1.16.4。这个问题我们一会再说，先看看为什么这个时候 go1.16.4 命令可以当作 go 命令来使用。</p>
<p>上文说了，go1.16.4 只是一个包装器。当对应的 Go1.16.4 安装成功后，再次运行 go1.16.4，会执行 internal/version/version.go 中的 runGo(root) 函数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">runGo</span><span class="p">(</span><span class="nx">root</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">gobin</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="s">&#34;bin&#34;</span><span class="p">,</span> <span class="s">&#34;go&#34;</span><span class="o">+</span><span class="nf">exe</span><span class="p">())</span>
    <span class="nx">cmd</span> <span class="o">:=</span> <span class="nx">exec</span><span class="p">.</span><span class="nf">Command</span><span class="p">(</span><span class="nx">gobin</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
    <span class="nx">cmd</span><span class="p">.</span><span class="nx">Stdin</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdin</span>
    <span class="nx">cmd</span><span class="p">.</span><span class="nx">Stdout</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>
    <span class="nx">cmd</span><span class="p">.</span><span class="nx">Stderr</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stderr</span>
    <span class="nx">newPath</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="s">&#34;bin&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;PATH&#34;</span><span class="p">);</span> <span class="nx">p</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
        <span class="nx">newPath</span> <span class="o">+=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">filepath</span><span class="p">.</span><span class="nx">ListSeparator</span><span class="p">)</span> <span class="o">+</span> <span class="nx">p</span>
    <span class="p">}</span>
    <span class="nx">cmd</span><span class="p">.</span><span class="nx">Env</span> <span class="p">=</span> <span class="nf">dedupEnv</span><span class="p">(</span><span class="nx">caseInsensitiveEnv</span><span class="p">,</span> <span class="nb">append</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nf">Environ</span><span class="p">(),</span> <span class="s">&#34;GOROOT=&#34;</span><span class="o">+</span><span class="nx">root</span><span class="p">,</span> <span class="s">&#34;PATH=&#34;</span><span class="o">+</span><span class="nx">newPath</span><span class="p">))</span>

    <span class="nf">handleSignals</span><span class="p">()</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cmd</span><span class="p">.</span><span class="nf">Run</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// TODO: return the same exit status maybe.
</span><span class="c1"></span>        <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>该函数通过 os/exec 包运行 <code>~/sdk/go1.16.4/bin/go</code> 命令，并设置好响应的标准输入输出流等，同时为新运行的进程设置好相关环境变量，可以认为，执行 go1.16.4，相当于执行 <code>~/sdk/go1.16.4/bin/go</code>。</p>
<p>所以，go1.16.4 这个命令，一直都只是一个包装器。如果你希望新安装的 go1.16.4 成为系统默认的 Go 版本，即希望运行 go 运行的是 go1.16.4，方法有很多：</p>
<ul>
<li>将 <code>~/sdk/go1.16.4/bin/go</code> 加入 PATH 环境变量（替换原来的）；</li>
<li>做一个软连，默认 go 执行 go1.16.4（推荐这种方式），不需要频繁修改 PATH；</li>
<li>移动 go1.16.4 替换之前的 go（不推荐）；</li>
</ul>
<h2 id="03-每次升级版本创建一个包装器">03 每次升级版本创建一个包装器</h2>
<p>手动复制粘贴代码做这件事情肯定是很笨的办法。在 golang.org/dl 中提供了一个工具，可以快速生成对应版本的包装器：<a href="https://github.com/golang/dl/blob/master/internal/genv/main.go" target="_blank" rel="noopener">https://github.com/golang/dl/blob/master/internal/genv/main.go</a>
。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ genv go1.16.4
</code></pre></div><p>就可以生成 go1.16.4 包装器。这里的实现，有一个点提一下，它使用了 go list -m -json 命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go list -m -json
<span class="o">{</span>
        <span class="s2">&#34;Path&#34;</span>: <span class="s2">&#34;golang.org/dl&#34;</span>,
        <span class="s2">&#34;Main&#34;</span>: true,
        <span class="s2">&#34;Dir&#34;</span>: <span class="s2">&#34;&lt;workspace&gt;/dl&#34;</span>,
        <span class="s2">&#34;GoMod&#34;</span>: <span class="s2">&#34;&lt;workspace&gt;/dl/go.mod&#34;</span>,
        <span class="s2">&#34;GoVersion&#34;</span>: <span class="s2">&#34;1.11&#34;</span>
<span class="o">}</span>
</code></pre></div><p>可以方便解析相关信息。</p>
<h2 id="04-总结">04 总结</h2>
<p>官方的 Go 多版本管理就介绍完了。总结一下：</p>
<ul>
<li>官方通过 genv 命令生成对应版本的包装器；</li>
<li>通过 go get 命令下载安装对应的包装器；</li>
<li>运行包装器，提供 download 这个 flag，下载对应版本的 Go 安装包并解压、校验；</li>
<li>之后，运行包装器，会执行对应版本的 go 命令；</li>
</ul>
<p>这样达到了多版本管理的目的。这个设计思路还是可以的。</p>
<p>但这种多版本管理，我认为存在一些问题：</p>
<ul>
<li>上面说的，让某个版本成为默认 Go 版本，没有命令一键搞定；</li>
<li>没法知道有哪些版本，比如无法方便的知晓 1.15.13 是否存在，更无法方便的知晓 1.15.x 系列，x 的最大版本；</li>
<li>删除某个版本，得手动进行（删除包装器和下载的 Go 安装包）；</li>
</ul>
<p>你喜欢这种方式管理还是类似 goup 这样的第三方工具呢？你现在是怎么管理多版本的，欢迎交流！</p>
]]></content>
		</item>
		
		<item>
			<title>Rust新书：给你一个劝退的理由</title>
			<link>https://polarisxu.studygolang.com/posts/rust/rust-new-book-20210520/</link>
			<pubDate>Thu, 20 May 2021 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/rust-new-book-20210520/</guid>
			<description>大家好，我是 polarisxu。 过去一段时间，我每周写一篇「Rust 劝退系列」，发现阅读量越来越低。于是我在思考，怎么能够调动大家学习的热情。思考再三，我决定试试这个办法！ 最近看到机械工业出版社出了一本 Rust 新书：《Rust编程：入门、实战和进阶》，我看完目录，发现很符合我一直想要的。 我在学习 Rust 的过程中，发现目前市面上的 Rust 图书，内容组织方式和其他语言的图书不太一</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>过去一段时间，我每周写一篇「Rust 劝退系列」，发现阅读量越来越低。于是我在思考，怎么能够调动大家学习的热情。思考再三，我决定试试这个办法！</p>
<p>最近看到机械工业出版社出了一本 Rust 新书：《Rust编程：入门、实战和进阶》，我看完目录，发现很符合我一直想要的。</p>
<p>我在学习 Rust 的过程中，发现目前市面上的 Rust 图书，内容组织方式和其他语言的图书不太一样。一般语言类图书都是这样组织内容的：</p>
<ul>
<li>变量</li>
<li>类型</li>
<li>常量</li>
<li>流程控制（if、循环等）</li>
<li>函数</li>
<li>。。。</li>
</ul>
<p>也许是因为 Rust 语法的特殊性？Rust 的图书一般都早早的介绍借用、所有权等复杂的概念，让人看了就想放弃（我写系列文章也是希望尽可能循序进阶，让大家能更好地接受 Rust，而不是早早被劝退）。</p>
<p>但这本**《Rust编程：入门、实战和进阶》**的组织方式和大家平时看的编程语言书籍很类似，我给大家详细介绍下。</p>
<p>本书一共分为三大部分：语言基础篇、编程能力训练篇和综合实战篇，刚好对应入门、实战和进阶。</p>
<p>在语言基础篇部分，章节内容如下：</p>
<ol>
<li>认识 Rust</li>
<li>变量与数据类型</li>
<li>流程控制</li>
<li>函数、闭包与迭代器</li>
<li>类型系统</li>
<li>所有权系统</li>
<li>智能指针</li>
<li>并发编程</li>
<li>错误处理</li>
<li>模块化编程</li>
<li>单元测试</li>
</ol>
<p>在编程能力训练篇，将常见数据结构和算法与 Rust 编程实战相结合，同时精选 39 道 LeetCode 高频算法面试题，帮助大家巩固基础知识，实战是最好的学习方式之一。</p>
<p>在综合进阶实战部分以排序算法为主题，围绕功能和性能扩展两条主线，将前面各大基础知识组合起来，进行综合训练，进一步帮助读者提升编程水平。</p>
<p>这是一本很注重动手实践的 Rust 图书（实际上，编程类的图书都应该要动手实践，这也是我为什么写《Go语言编程之旅》的原因），因此你在阅读此书的过程中，一定要动手写代码，否则收获甚微，切记切记！！！</p>
]]></content>
		</item>
		
		<item>
			<title>周刊题解：常量表达式这个规则应该了解下</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/weekly-question-94/</link>
			<pubDate>Thu, 20 May 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/weekly-question-94/</guid>
			<description>大家好，我是 polarisxu。 之前周刊题目正确率一直挺低的，于是我在「94期」出了一道简单的题目，如下： package main import ( &amp;#34;fmt&amp;#34; ) func main() { var ans float64 = 15 + 25 + 5.2 fmt.Println(ans) } 没想到，这道题的正确率也才 62%： 这篇文章就给大家讲解下这道题涉及到的常量表达式的一个知识点。 概念 常量表达式是指仅包含常量操作数，且是在编译的时候进行计算的。 而常量，在 Go 语言中又可以分为无类型常量和有类型常量，也可</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>之前周刊题目正确率一直挺低的，于是我在「94期」出了一道简单的题目，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">ans</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mi">15</span> <span class="o">+</span> <span class="mi">25</span> <span class="o">+</span> <span class="mf">5.2</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ans</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>没想到，这道题的正确率也才 62%：</p>
<p><p class="md__image">
  <img src="../imgs/weekly-question-94-01.png"
    alt=""  />
</p>
</p>
<p>这篇文章就给大家讲解下这道题涉及到的常量表达式的一个知识点。</p>
<h2 id="概念">概念</h2>
<p>常量表达式是指仅包含常量操作数，且是在编译的时候进行计算的。</p>
<p>而常量，在 Go 语言中又可以分为无类型常量和有类型常量，也可以分为字面值常量和具名常量。说人话？！</p>
<p>通过代码看看：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">a</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> 			<span class="c1">// a == 3，是无类型常量
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">b</span> <span class="kt">int8</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> 	<span class="c1">// b == 3，是有类型常量，类型是 int8
</span><span class="c1"></span>
<span class="c1">// 而 1、2 这样的就是字面值常量
</span><span class="c1">// a、b 这样的就是具名常量
</span></code></pre></div><blockquote>
<p>无类型常量英文是 untyped constants；具名常量英文是 named constants。</p>
</blockquote>
<p>无类型常量也叫类型不确定常量，有类型常量也叫类型确定常量。虽然无类型常量类型不确定，但对于大多数类型不确定值来说，它们各自都有一个默认类型， 除了预声明的<code>nil</code>。<code>nil</code>是没有默认类型的。（参考 Go101）</p>
<ul>
<li>一个字符串字面量的默认类型是 string 类型。</li>
<li>一个布尔字面量的默认类型是 bool 类型。</li>
<li>一个整数型字面量的默认类型是 int 类型。</li>
<li>一个 rune 字面量的默认类型是 rune（也就是 int32）类型。</li>
<li>一个浮点数字面量的默认类型是 float64 类型。</li>
<li>如果一个字面量含有虚部字面量，则此字面量的默认类型是 complex128 类型。</li>
</ul>
<h2 id="02-类型推断">02 类型推断</h2>
<p>大家都知道，Go 能自动进行类型推导。因此，在一些场景下，我们可以使用类型不确定值，而 Go 编译器会自动推断出这些值在特定场景下的类型。</p>
<p>如果根据上下文，没有确定的类型，则编译器会将这些不确定类型值视为它们的默认类型。</p>
<p>以上是 Go 中的隐式类型转换。除了这些情况，Go 是不支持隐式类型转换的，必须进行显示类型转换。</p>
<h2 id="03-常量表达式">03 常量表达式</h2>
<p>现在回到题目，说说常量表达式。</p>
<p>在 Go 语言规范中提到，任何在无类型常量上的操作结果是同一个类别的无类型常量，也就是：布尔、整数、浮点数、复数或者字符串常量。如果一个二元运算（非位移）的无类型操作数是不同类的，那么其结果是在如下列表中靠后显示的操作数的类：整数、 rune、浮点数、复数。又该说人话了？！</p>
<p>通过解析题目就明白这段话的意思了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">ans</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mi">15</span> <span class="o">+</span> <span class="mi">25</span> <span class="o">+</span> <span class="mf">5.2</span>
</code></pre></div><p>根据这段话，15 + 25 + 5.2 是常量表达式，因为这个表达式的操作数都是无类型的常量，因为其中有 5.2，它的默认类型是浮点型，所以这个常量表达式的结果虽然是无类型的，但默认类型是浮点型。</p>
<p>其实这道题抛开编程语言来说，就是一个常规的数学算式：15 + 25 + 5.2，这么简单的算式相信大家都会。所以，这道题做错了的，大概率是想多了，想复杂了！</p>
<p>当然，也有人说，看到这道题，怕有陷阱，所以想多了。。。</p>
]]></content>
		</item>
		
		<item>
			<title>盘点那些使用 Go 语言的国外公司</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/companies-using-golang/</link>
			<pubDate>Wed, 19 May 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/companies-using-golang/</guid>
			<description>大家好，我是 polarisxu。 一直以来，各种语言都是国外大规模使用，但 Go 语言很不一样，国内更火。因为这样，有些人质疑：Go 也就国人瞎炒作，国外根本没啥公司用。真的是这样吗？今天就盘点一下那些使用 Go 的国外公司，看看他们的案例，希望对大家的技术选型有所借鉴！ 为了更清晰，以下盘点进行了必要的归类。 01 技术平台公司 技术平台提供了一组加速应用程序开发的通用功能，因此可</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>一直以来，各种语言都是国外大规模使用，但 Go 语言很不一样，国内更火。因为这样，有些人质疑：Go 也就国人瞎炒作，国外根本没啥公司用。真的是这样吗？今天就盘点一下那些使用 Go 的国外公司，看看他们的案例，希望对大家的技术选型有所借鉴！</p>
<p>为了更清晰，以下盘点进行了必要的归类。</p>
<h2 id="01-技术平台公司">01 技术平台公司</h2>
<p>技术平台提供了一组加速应用程序开发的通用功能，因此可以更快地将解决方案部署到业务中。它们通常要求高的可扩展性和可靠性，这正是 Golang 所擅长的。</p>
<h3 id="dropbox">Dropbox</h3>
<p>Dropbox 有些人可能用过。在国内云盘流行之前，很多人使用它。Dropbox 的成功很大程度上归功于 Python：它使公司能够快速开发和迭代。然而，随着用户基数的不断增长，他们开始探索以更有效的方式扩展系统。这导致将性能至关重要的后端从 Python 迁移到 Go，以利用更好的并发支持和更快的执行速度。</p>
<p>对 Dropbox 来说，这个工程是巨大的。没有点魄力和对 Go 语言足够的调研和信心，真不敢迈出这一步。因为有大约 20万行 Go 代码，需要由一小组工程师完成。现在他们已经成功地将基础设施的主要部分移到了 Go 上。其中的细节，有兴趣的可以看看这个视频：<a href="https://www.youtube.com/watch?v=JOx9enktnUM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=JOx9enktnUM</a>
</p>
<p>因为尝到了 Go 高效的甜头，Dropbox 将基础设施都使用 Go 构建，同时新业务也都优先考虑使用 Go。</p>
<p>此外，Dropbox 还开放了几个有助于改进缓存、标准错误接口等的 Golang 库，关于这些库的信息，可以参考该文：<a href="https://dropbox.tech/infrastructure/open-sourcing-our-go-libraries" target="_blank" rel="noopener">https://dropbox.tech/infrastructure/open-sourcing-our-go-libraries</a>
。</p>
<p>在 2020 年，Dropbox 对 Python 整体代码库下手，并将其发展成为一个无服务器的托管平台，这将减少代码耦合，解放服务及其底层工程师团队。为此，他们正在创新体系结构，例如标准化 gRPC 和使用 Envoy’s  gRPC-http 转码。其中细节，可以看看他们几个礼拜前发的一篇博文：<a href="https://dropbox.tech/infrastructure/atlas--our-journey-from-a-python-monolith-to-a-managed-platform" target="_blank" rel="noopener">https://dropbox.tech/infrastructure/atlas--our-journey-from-a-python-monolith-to-a-managed-platform</a>
。</p>
<h3 id="sendgrid">SendGrid</h3>
<p>这个公司很多人可能没听过，但我熟悉，因为它提供的邮件服务我在使用。网站给用户发邮件，其实是一个很苦恼的事情。Go 语言中文网之前一直使用腾讯企业邮，但经常提示超过发送额度。后来我找到了 SendGrid，然后一直使用它的产品。没想到他们也在使用 Go。</p>
<p>下面简单介绍下它。</p>
<p>SendGrid 是一个基于云计算的电子邮件服务，为世界上一些大公司可靠地发送大量的电子邮件，这些公司包括 Uber、 Airbnb、 Spotify 等等。他们使用 Golang 开发了 SendGrid 的可定制、可靠和可伸缩的 API。这样的电子邮件应用程序可以在正确的时间将最相关的内容发送给正确的用户。</p>
<p>从根本上说，SendGrid 在开发中面临的最大挑战是并发编程。为什么这么说？因为他们每天发送 5 亿条信息，这是极具挑战性的。</p>
<p>他们为什么选择 Go 语言，这篇文章是他们的回答：<a href="https://sendgrid.com/blog/convince-company-go-golang/" target="_blank" rel="noopener">https://sendgrid.com/blog/convince-company-go-golang/</a>
。</p>
<h2 id="02-在线预订系统">02 在线预订系统</h2>
<p>在线预订系统允许通过网络或移动应用程序订购服务和支付，允许企业进行规模化经营。作为日常操作的一部分，这些系统需要一流的可靠性、可伸缩性以及与其他系统的集成。</p>
<h3 id="uber优步">Uber（优步）</h3>
<p>尽管从历史上看，Uber 主要使用 Node.js 和 Python，但是很多人 Gopher 应该知晓，他们已经有很多服务使用 Go 构建，包括他们开源的一些流行库，一些 Go 代码规范，在 Go 圈都很受欢迎。Go 语言已经成为 Uber 许多新服务的首选语言。这是它们的 Go 组织：<a href="https://github.com/uber-go" target="_blank" rel="noopener">https://github.com/uber-go</a>
，在这里可以找到他们开源的 Go 相关项目。</p>
<p>Uber  已经有超过 100 个服务是使用 Go 构建的。Geobase 是 Uber 最近推出的一个服务，也是使用 Go 构建的，该服务匹配乘客和司机。在 Uber 上，Go 每秒处理极大量的查询。</p>
<p>2016 年，Uber 一个工程师在官方博客发了一篇文章：<a href="https://eng.uber.com/go-geofence-highest-query-per-second-service/" target="_blank" rel="noopener">https://eng.uber.com/go-geofence-highest-query-per-second-service/</a>
，文章提到了：</p>
<ul>
<li>Go 有很高的开发效率。对于 C++，Java 或 Node.js 开发人员，学习 Go 通常只需要几天，并且 Go 的代码易于维护。</li>
<li>高性能、低延迟。在 Uber 的主数据中心，服务于非中国的流量（因为当时在中国正和滴滴竞争，所以中国的流量必然得额外算），这项服务处理了 170k QPS 的峰值负载，在 NYE 2015 上有 40 台机器以 35% 的 CPU 使用率运行。响应时间在 95 百分位 &lt; 5ms，在 99 百分位 &lt; 50ms。</li>
<li>超级可靠。这项服务自启动以来已经有 99.99% 的正常运行时间。唯一的停机时间是由初学者编程错误和第三方库中的文件描述符泄漏漏洞造成的。重要的是，我们没有发现 Go 运行时有任何问题。</li>
</ul>
<h3 id="delivery-hero">Delivery Hero</h3>
<blockquote>
<p>这个公司，我之前不了解</p>
</blockquote>
<p>Delivery Hero 正在建设下一代全球在线食品订购平台。它们使用微服务体系结构，而 API REST、 gRPC、 SQS/SNS 用于部署到基于云的基础设施的应用程序之间的通信，使用 Kubernetes/Docker，并遵循 12 factors。</p>
<p>Go 和 PHP 是他们的主要语言，但是 Go 正在成为 foodora 和 foodpanda 平台的核心技术。</p>
<h3 id="trivago">trivago</h3>
<p>一个旅行网站。2020 年初，他们在网站发了一篇文章：<a href="https://tech.trivago.com/2020/03/02/why-we-chose-go/" target="_blank" rel="noopener">https://tech.trivago.com/2020/03/02/why-we-chose-go/</a>
，介绍他们为什么选择 Go。</p>
<blockquote>
<p>Go 的简单性和它强大的工具让我们不仅可以扩展我们的服务，更重要的是扩展软件工程本身的过程，减少新员工入职和培训过程中的摩擦，对公司的生产率有着重大影响，在 trivago 这样不断变化的环境中更是如此。</p>
</blockquote>
<h3 id="sixt">Sixt</h3>
<p>SIXT 是世界上最大的技术驱动的移动公司之一。它允许客户计划他们的旅程，通过远程信息处理打开和关闭汽车，审查他们的使用数据等等。它是建立在最先进的云本地化、基于微服务、事件驱动的 Golang 基础设施之上的。</p>
<p>自 2015 年以来，他们就开始使用 Golang。那时候，他们那没有多少人在生产环境上使用 Go，大部分是辅助项目。所以对他们来说这确实是一个大胆的举动，但是事实证明这是相当成功的。快进到 2019 年，他们有超过 15 个 Team 在使用 Go。</p>
<p>这篇文章详细介绍了他们使用 Go 的情况：<a href="https://www.facebook.com/sixtkarriere/posts/find-out-more-about-golang-at-sixt-to-become-a-godeveloper-mfd-at-sixt-click-her/2049632898495842/" target="_blank" rel="noopener">https://www.facebook.com/sixtkarriere/posts/find-out-more-about-golang-at-sixt-to-become-a-godeveloper-mfd-at-sixt-click-her/2049632898495842/</a>
。</p>
<h2 id="03-电子商务">03 电子商务</h2>
<p>电子商务初创企业、中小企业和大型企业都面临着页面加载时间、可扩展性和网站可用性等方面的挑战。Golang 被广泛用于解决这些问题。</p>
<h3 id="allegro">Allegro</h3>
<p>这是波兰最大的在线购物平台。超过 2100 万的注册用户和每月超过 2.2 亿的访问量，在全球在线销售领域排名第 13 位。</p>
<p>和国内的淘宝类似，虽然大多数微服务是用 Java 或其他基于 JVM 的语言编写的，但有些是用 Python 编写的。然而，当想编写一个非常快速的缓存服务时，他们决定尝试一些新的东西，并在 Go 中实现这个服务。</p>
<blockquote>
<p>最后，我们将应用程序的加速时间从超过 2.5 秒提高到最长请求的不足 250 毫秒</p>
</blockquote>
<p>2016 年，他们写了一篇文章，介绍他们使用 Go 实现这个缓存服务的情况：<a href="https://blog.allegro.tech/2016/03/writing-fast-cache-service-in-go.html" target="_blank" rel="noopener">https://blog.allegro.tech/2016/03/writing-fast-cache-service-in-go.html</a>
，这就是 <a href="https://github.com/allegro/bigcache" target="_blank" rel="noopener">BigCache</a>
。</p>
<h3 id="mercadolibre">Mercadolibre</h3>
<p>公司拥有拉丁美洲最大的在线商务生态系统，在 18 个国家都有业务。公司已经转向 Go 来帮助它扩大规模并使其生态系统现代化。</p>
<p>通过使用 Go，他们将服务器的数量从 32 台减少到 4 台，构建速度加快了 3 倍，测试套件运行时间从 90 秒减少到 3 秒。</p>
<blockquote>
<p>Go 对我们来说太神奇了。它非常强大，而且非常容易学习，并且拥有后端基础设施，在可扩展性方面对我们来说非常有帮助。</p>
</blockquote>
<p>他们使用 Go 的案例可以参考该文：<a href="https://go.dev/solutions/mercadolibre/" target="_blank" rel="noopener">https://go.dev/solutions/mercadolibre/</a>
。</p>
<h2 id="04-金融科技">04 金融科技</h2>
<p>在金融科技领域，许多客户对金融数据的需求是 24*7 无间断。在处理交易和访问财务数据方面，Go 是一个非常合适的语言。</p>
<h3 id="solarisbank">SolarisBank</h3>
<p>这是一家拥有完整的德国银行许可证的科技公司。他们的“银行即服务”平台使企业能够使用简单的 api 提供自己的金融产品，比如数字银行、支付、信用卡、身份识别和借贷服务。</p>
<p>从银行业的战壕深处到服务的边缘，Go 在 Solarisbank 被多个团队使用：</p>
<ul>
<li>核心银行团队 —— 建立骨干，协议级银行系统，如环保总局和环球银行金融电信协会</li>
<li>Auth Team —— 反向代理和身份验证/授权系统</li>
<li>数据平台团队 —— 建立管道（pipeline），作为将数据转化为知识的基础设施</li>
</ul>
<p>该公司的主要技术栈如下：</p>
<p>Docker，Microservices，Ruby，Grape，Golang，Elixir，Phoenix，React.js，MySQL，Postgres，Redis，Concourse，GitHub，Prometheus，AWS</p>
<p>更多信息可以参考该文：<a href="https://boards.greenhouse.io/solarisbank/jobs/4220372002" target="_blank" rel="noopener">https://boards.greenhouse.io/solarisbank/jobs/4220372002</a>
。</p>
<h3 id="monzo-bank">Monzo Bank</h3>
<p>总部位于英国的初创企业 Monzo 于 2017 年 4 月获得正式银行牌照。它在 2019 年夏天为美国开设了一个等候名单。</p>
<p>对于银行操作系统，他们决定建立自己的平台，使用的主要是开源生态：Linux、 Cassandra 分布式数据库、Go 语言和 PostgreSQL。基础设施托管在亚马逊网络服务(AWS)云上。该银行的两个数据中心用于与万事达卡（Mastercard）系统进行交互。</p>
<blockquote>
<p>Go 是创建微服务架构的完美语言，围绕着‘单一责任原则’，Go 的并发特性和通用型语言，使得在 Monzo 轻松创建小而简单的网络服务成为可能。</p>
</blockquote>
<p>关于他们使用 Go 的更多信息可以参考该文：<a href="https://www.infoq.com/news/2017/03/monzo-bank-golang/" target="_blank" rel="noopener">https://www.infoq.com/news/2017/03/monzo-bank-golang/</a>
。</p>
<h3 id="capital-one">Capital One</h3>
<p>这是一家以科技为导向的金融公司。他们的服务之一是 Credit Offers API，其中的联盟合作伙伴如 Credit Sesame、 CreditCards.com 和 Bankrate 显示可用的信用卡选项。</p>
<p>在 2016 年中期，他们为 API 创建了新的 Go 端点。</p>
<blockquote>
<p>Go 在 Capital One 开始获得了巨大的、令人印象深刻的动力，基于我的团队整合的 POC，我们看到了与 Java 的巨大性能提升。这些结果很清楚，所以我们决定将其用于这个新的端点。当时，没有一个团队成员知道 Go，但不到一个月，每个人都用 Go 写东西，我们在构建端点。它的灵活性、易用性和 Go 背后真正酷的概念（Go 如何处理原生并发、垃圾收集，当然还有安全 + 速度）在构建过程中帮助我们参与进来。</p>
</blockquote>
<p>详细情况一通过该文了解：<a href="https://medium.com/capital-one-tech/a-serverless-and-go-journey-credit-offers-api-74ef1f9fde7f" target="_blank" rel="noopener">https://medium.com/capital-one-tech/a-serverless-and-go-journey-credit-offers-api-74ef1f9fde7f</a>
。</p>
<h2 id="05-支付系统">05 支付系统</h2>
<p>支付系统，一直依赖似乎都是 Java 的天下。</p>
<p>支付处理系统允许企业使用信用卡、借记卡和支票为商品和服务进行支付。这些系统检查交易过程中收到的详细资料，并在结算交易之前采取一系列反欺诈措施。</p>
<p>对于 24*7 的服务，稳定性和自动恢复是必须的，因此要求在支付处理流水线中的每个步骤都需要 Go 提供的尽可能低的延迟。</p>
<h3 id="american-express">American Express</h3>
<p>美国运通主要以其信用卡和支付处理而闻名。截至 2019 年 12 月 31 日，该公司已有 1.144 亿张有效卡，其中包括 5470 万张在美国有效的卡。</p>
<p>2016 年，他们的付款和奖励平台团队是第一批开始评估 Go 的团队之一。他们的主要关注点是微服务、事务路由和负载均衡，并且他们需要对其体系结构进行现代化改造。</p>
<blockquote>
<p>在 Go 上工作之后，我们的大多数开发人员都不想回到其他语言上。” ー Benjamin Cane，美国运通公司副总裁兼首席工程师</p>
</blockquote>
<p>为了帮助其他企业确定 Go 是否适合他们，他们发布了一个 Go 案例研究：<a href="https://americanexpress.io/choosing-go/" target="_blank" rel="noopener">https://americanexpress.io/choosing-go/</a>
。</p>
<h3 id="paypal">PayPal</h3>
<p>PayPal 是在线支付的先驱，现在仍然是在线供应商、拍卖网站和世界各地许多其他商业用户的领先支付处理器。</p>
<p>目前在 PayPal 有超过 100 个 Go 开发者。虽然 Go 可能永远不会取代 Node.js 的某些应用程序，但 Go 是 PayPal 的一级语言。</p>
<blockquote>
<p>Go 提供了处理复杂性的通道和 Goroutine，我们能构造代码来满足需求。</p>
</blockquote>
<p>信息来源：<a href="https://go.dev/solutions/paypal/" target="_blank" rel="noopener">https://go.dev/solutions/paypal/</a>
。</p>
<h3 id="izettle">iZettle</h3>
<p>Zettle 开发了改变游戏规则的商业工具，比如移动读卡器和销售点应用程序，这些应用程序赋予小企业与大企业竞争的能力。他们于 2010 年在斯德哥尔摩成立，用世界上第一个迷你芯片读卡器和移动设备软件彻底改变了移动支付。</p>
<p>Go 是 iZettle 的主要后端语言。技术栈包括用于持久化的 PostgreSQL 和 Dynamo，用于异步服务的 AmazonSQS 和 AmazonSNS。</p>
<p>更多信息参考：<a href="https://careers.sh/pl/firma/izettle/prace/68805" target="_blank" rel="noopener">https://careers.sh/pl/firma/izettle/prace/68805</a>
。</p>
<h3 id="bolt">Bolt</h3>
<p>Bolt Payments 是电子商务零售商的一个一体化支付平台。他们的端到端支付平台旨在使整个结账体验尽可能无摩擦。</p>
<p>为了提高他们的灵活性，Bolt 团队创建了 <a href="https://github.com/BoltApp/sleet" target="_blank" rel="noopener">sleet</a>
，一个开源的库，用于使用 Golang 与不同的 PSPs 接口。</p>
<blockquote>
<p>我们的灵感来源于 ActiveMerchant，它是另一个用 Ruby on Rails 编写的库，也达到了同样的目的。在确认 Go 没有这样的解决方案之后，我们决定自己开发。</p>
</blockquote>
<h2 id="06-网络安全">06 网络安全</h2>
<p>前段时间，我<a href="https://mp.weixin.qq.com/s/-Zv1QwM1lYNWEvIoUNjmXQ" target="_blank" rel="noopener">写文提到</a>
，说 Go Team 越来越重视安全问题了。安全和隐私持续引起人们的兴趣，网络安全市场正在蓬勃发展，并继续增长。静态语言、注重安全的 Golang 非常适合该领域，并在服务器和云环境中得到广泛应用。</p>
<h3 id="1password">1Password</h3>
<p>这个是大名鼎鼎的密码管理软件。保护着超过 60,000 家企业的数据，1Password 让你完全控制密码和其他敏感的商业信息。</p>
<p>1Password Administrator Tools 的后端完全用 Golang 编写。它使管理员能够为整个公司管理 1Password，并使帐户恢复简单，安全。</p>
<h3 id="keybase">Keybase</h3>
<p>Keybase 是允许用户加密消息和验证身份的密钥目录（key directory）。</p>
<blockquote>
<p>为什么要在 Keybase 使用 Go？Go 的库真是太棒了。过去，我花了很多时间在 OKCupid 上使用 C++ ，很难找到一个真正协同工作的库。相反的，Go 中大量的核心库，基本上可以满足你的所有需求。</p>
</blockquote>
<p>信息来源：<a href="https://softwareengineeringdaily.com/2015/09/04/identity-and-encryption-with-keybase-founder-max-krohn/" target="_blank" rel="noopener">https://softwareengineeringdaily.com/2015/09/04/identity-and-encryption-with-keybase-founder-max-krohn/</a>
。</p>
<h2 id="07-音乐和视频">07 音乐和视频</h2>
<p>Golang 的 HLS 等协议使构建流服务变得容易，安装简单，同时提供最高效的性能。它支持最常用的文件和编码格式。使用该语言进行流媒体播放的最大优势是速度，尤其是在直播方面。如果在编码、解码和打包视频和音频时没有无缝转换，就不可能实现流媒体直播。Go 处理所有这些流程很方便，可以给用户更好的体验。</p>
<h3 id="soundcloud">SoundCloud</h3>
<p>这是一个消费者网站，是网络上领先的音频平台，这意味着任何东西都可以和大家分享。SoundCloud 维护了大约 6 个服务和超过 12 个完全使用 Go 编写的仓库。当开发新的后端项目时，他们也越来越多地转向 Go。</p>
<p>关于 Go 在他们公司的具体情况，可以通过这篇文章详细了解：<a href="https://developers.soundcloud.com/blog/go-at-soundcloud" target="_blank" rel="noopener">https://developers.soundcloud.com/blog/go-at-soundcloud</a>
。</p>
<h3 id="twitch">Twitch</h3>
<p>这是一个直播视频平台，主要关注视频游戏的直播，同时也播放音乐、创意内容、电子竞技比赛等等。</p>
<p>Twitch 在流量最大的系统中使用 Go。它的简单性、安全性、性能和可读性使它成为一个很好的工具，解决了在向数百万用户提供实时视频和聊天服务时遇到的问题。Go 是 Twitch scales 的重要组成部分，尤其是与 AWS Lambda 的结合。</p>
<p>在 2018 年 Twitch 使用了 RPC 框架，不同服务间的通讯通过 Twirp 这个框架实现，这是一个 Go 语言实现的 RPC 框架。关于该框架的信息参考该文：<a href="https://blog.twitch.tv/pl-pl/2018/01/16/twirp-a-sweet-new-rpc-framework-for-go-5f2febbf35f/" target="_blank" rel="noopener">https://blog.twitch.tv/pl-pl/2018/01/16/twirp-a-sweet-new-rpc-framework-for-go-5f2febbf35f/</a>
。</p>
<h3 id="dailymotion">Dailymotion</h3>
<p>这是一个在法国托管的视频分享网站。这个网站类似于 YouTube，它播放视频，包括 Dailymotion 工作室创建的原创内容。Dailymotion 使用 Golang 实现自动化 api 和端到端测试用例。</p>
<p>他们每个月使用 Golang 进行数百次自动化测试。他们选择 Golang 进行大量的自动化测试，因为它快速而强大。由于其性能、静态类型检查和简单性，他们用 Golang 开发了大部分后端项目。</p>
<h2 id="08-im-领域">08 IM 领域</h2>
<p>聊天服务器必须能够执行许多功能。并发性很重要，在构建消息传递应用程序时利用了高可伸缩性。在消息需要几乎同时发送和接收的时候，Go 的速度有利于支持消息和聊天平台中的项目。</p>
<h3 id="stream">Stream</h3>
<p>Stream 是一个企业级的聊天和活动提供商，为超过 10 亿的最终用户提供服务。</p>
<p>Go 的优秀生态系统、新开发人员容易入门、快速性能、对并发性的友好支持和高效编程环境的组合使其成为一个很好的选择。使得 Stream 这样小型开发团队能为超过 5 亿的终端用户提供 feed 和聊天功能。</p>
<p>他们发表过为什么从 Python 迁移到 Go 的文章：<a href="https://getstream.io/blog/switched-python-go/" target="_blank" rel="noopener">https://getstream.io/blog/switched-python-go/</a>
。</p>
<h3 id="slack">Slack</h3>
<p>很多人对此不陌生。全球超过 1000 万用户每天依靠 Slack 与同事合作。随着用户数量的增加，他们的重点也在增强性能，并确保它们在高负载下正常运行。</p>
<p>他们团队发表的相关文章：</p>
<ul>
<li><a href="https://slack.engineering/scaling-slacks-job-queue/" target="_blank" rel="noopener">https://slack.engineering/scaling-slacks-job-queue/</a>
</li>
<li><a href="https://slack.engineering/load-testing-with-koi-pond/" target="_blank" rel="noopener">https://slack.engineering/load-testing-with-koi-pond/</a>
</li>
</ul>
<h2 id="09-物联网iot">09 物联网（IoT）</h2>
<p>随着物联网的不断发展和边缘设备数量的迅速增加，需要对大量数据迅速处理和计算。Golang 的内置并发性使得这种语言成为许多物联网应用的优秀候选者。</p>
<h3 id="samsara">Samsara</h3>
<p>Samsara 平台带来了人工智能安全程序、实时可视性、工作流程、报告以及一个集成的生态系统来连接驱动经济的运作：从生产到物流、建筑、政府等等。</p>
<p>该物联网平台完全使用 Go 构建：</p>
<ul>
<li>后端服务（包括自己的、开源的 GraphQL 实现)</li>
<li>云配置，包括 fenerating Terraform 文件，管理用户和团队等</li>
<li>运行设备的固件</li>
</ul>
<p>信息来源：<a href="https://medium.com/samsara-engineering/a-chapter-in-the-life-of-gos-compiler-c89b9db74617" target="_blank" rel="noopener">https://medium.com/samsara-engineering/a-chapter-in-the-life-of-gos-compiler-c89b9db74617</a>
。</p>
<h3 id="tibco">TIBCO</h3>
<p>2017 年，TIBCO 开放了其核心项目 Flogo。最初，Flogo 是物联网框架，后来发展成为一个专注于 FaaS 的框架。</p>
<p>今天，Flogo 运行在 AWS Lambda 上，使你能够将 Flogo 流作为 function 部署。此外，Flogo 最新的能力之一是支持嵌入式机器学习模型，可以部署在边缘设备。</p>
<h2 id="10-real-time-事件平台">10 Real-time 事件平台</h2>
<p>随着人们对更高效、更准确的工具和智能的需求不断增加，实时事件平台经历了难以置信的变化。为了保持领先地位，公司不得不更新和改进他们的系统，以便对应用程序中的事件作出的响应几乎是即时发送的。速度是 Golang 的招牌，因为它结合了轻量级的内存需求和快速的交付时间，这将使你的客户对应用程序的服务感到满意。</p>
<h3 id="pusher">Pusher</h3>
<p>在全世界 25 万以上的开发者的网络和移动应用程序中使用 api 来创建协作和通信功能。</p>
<p>每天，Pusher 在不到 100 毫秒的时间内发送数十亿条实时消息：源到目的地。我们如何实现这一目标？一个关键因素是 Go 的低延迟垃圾收集器。</p>
<p>详细信息可参考：<a href="https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/index.html" target="_blank" rel="noopener">https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/index.html</a>
。</p>
<h3 id="pubnative">PubNative</h3>
<p>一个移动货币化平台，允许应用程序发布者通过灵活的广告单元来提高他们的收入策略。它使移动发布商最大化他们的程序性广告收入。</p>
<p>由于每天大约有 25B 左右的流量，PubNative 的广告服务端是用 Go 编写的，并连接到 Spark 数据管道。</p>
<h2 id="11-游戏领域">11 游戏领域</h2>
<p>随着游戏持续以指数级增长，你所使用语言能否跟上你的系统可能需要的任何更新是很重要的。使用现有的 Go 库，如 Nano，一个用 Go 编写的游戏服务器库，可以通过预先编写代码来减少编程所需的时间，这些代码可以在你的项目中使用。这可以帮助你专注于游戏的其他方面，节省你宝贵的时间。</p>
<h3 id="riot-games">Riot Games</h3>
<p>Riot Games 成立于 2006 年，致力于在全球开发以玩家为中心的游戏。2009 年，他们发布了处女作，《英雄联盟》已经成为世界上大家玩得最多的电脑游戏，也是电子竞技爆炸式增长的关键驱动力。</p>
<p>Riot 的一级服务端语言是 Java 和 Go，它们是可互操作的，并且相对容易打包和部署。</p>
<p>他们喜欢 Go 有很多原因，包括：</p>
<ul>
<li>部署工具，用于部署和管理运行在 Docker 运行时中的服务的生命周期</li>
<li>为了最小化向后端可观察性平台转发日志和指标时的请求延迟</li>
<li>在多个项目中，使用 Golang 的 httputil 反向代理来处理代理请求，为请求的生命周期添加中间件来注入额外的身份验证或头部</li>
<li>整个后端微服务架构都是使用 Golang 构建的——从游戏服务器流程的分离和管理到购买商品，所有的事情都是使用 Go 编写的服务完成的</li>
</ul>
<p>这里是他们发的文章：<a href="https://technology.riotgames.com/news/leveraging-golang-game-development-and-operations" target="_blank" rel="noopener">https://technology.riotgames.com/news/leveraging-golang-game-development-and-operations</a>
。</p>
<h3 id="nakama">Nakama</h3>
<p>提供实时、社交和多人游戏体验需要的一切，让游戏开发公司可以专注于开发令人惊叹的游戏。他们用来构建、部署和赚钱的开源工具箱，就是使用 Golang 构建的。</p>
<p>Nakama 处理超过 1.5 亿玩家的游戏，并每月处理超过 700 亿请求。</p>
<p>信息来源：<a href="https://heroiclabs.com/" target="_blank" rel="noopener">https://heroiclabs.com/</a>
。</p>
<h2 id="12-总结">12 总结</h2>
<p>看到这么多领域，这么多公司，你是不是很惊叹：原来 Go 可以在这么多领域大放异彩，而且有这么多公司在使用。不管有些公司使用的规模如何，至少，有 Go 的一席之地。</p>
<p>Go 语言在性能和开发人员生产力之间取得了很好的平衡。在接下来的 10 年里，随着云解决方案、物联网数据和 5G 等新技术的使用不断增加，Golang 毕竟会吸引越来越多的公司。</p>
<p>看了这么公司和方向，你还怀疑 Go 的前景吗？！</p>
]]></content>
		</item>
		
		<item>
			<title>编写了50万行Go代码是一种什么体验</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/half-a-million-lines-of-go/</link>
			<pubDate>Mon, 17 May 2021 20:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/half-a-million-lines-of-go/</guid>
			<description>大家好，我是 polarisxu。 今天看到一篇文章，分享给大家，看看写了 50 万行代码的 Gopher 对 Go 有什么感想。 先简单介绍下可汗学院（Khan Academy）。 这是一个非营利性组织，其使命是在任何地方为任何人提供免费的、世界级的教育。 全球有 6.17 亿儿童缺乏基本的数学和阅读技能。可汗学院是一个提供他们所需教育的非营利组织，因此需要大家的帮助，你的帮忙可以改变一个孩子的一生。 所</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>今天看到一篇文章，分享给大家，看看写了 50 万行代码的 Gopher 对 Go 有什么感想。</p>
<p>先简单介绍下可汗学院（Khan Academy）。</p>
<blockquote>
<p>这是一个非营利性组织，其使命是在任何地方为任何人提供免费的、世界级的教育。</p>
<p>全球有 6.17 亿儿童缺乏基本的数学和阅读技能。可汗学院是一个提供他们所需教育的非营利组织，因此需要大家的帮助，你的帮忙可以改变一个孩子的一生。</p>
<p>所以，从网站介绍可以看出，这个组织主要靠大家的赞助维持运营。如果你支持这样的公益事业，可以到官网：<a href="https://www.khanacademy.org/" target="_blank" rel="noopener">https://www.khanacademy.org/</a>
 赞助。</p>
</blockquote>
<h2 id="从-python2-迁移到-go">从 Python2 迁移到 Go</h2>
<p>可汗学院的项目 Goliath，最开始使用 Python2 实现的，2019 年逐步将其迁移到了 Go。这里有一篇文章介绍了迁移的事情：<a href="https://blog.khanacademy.org/go-services-one-goliath-project/" target="_blank" rel="noopener">https://blog.khanacademy.org/go-services-one-goliath-project/</a>
。</p>
<p>因为这个决定，现在可汗学院所有的后端和全栈工程师都开始写 Go 代码，经过几年的积累，该项目跨域了一个巨大的里程碑：有超过 50 万行 Go 代码在线上运行着。这对于 Go 整个社区来说也是一件好事。</p>
<h2 id="工程师很喜欢-go">工程师很喜欢 Go</h2>
<p>可汗学院的工程师们普遍认为「Go 很容易写和读」，用 Go 越多就越喜欢它。</p>
<p>一个有多年 .NET 经验的工程师说，Go 的错误处理和 .NET 的异常处理很不一样。虽然经常要处理 error，但如果一个函数没有返回错误，那可以确定它一定成功了，这一点还是很棒的。</p>
<p>此外，他们对 Go 的工具链很喜欢。比如通过 go doc 可以查找标准库的文档，特别方便。gofmt 让代码格式都一直，很适合阅读代码。虽然 Go Module 在社区抱怨的声音不少，但相比之前来说，还是有很大进步，而且可汗学院在使用过程中没有什么特别差的体验。</p>
<p>同时，他们很喜欢 Go 的编译速度，那叫一个快！</p>
<h2 id="泛型还是需要的">泛型，还是需要的</h2>
<p>虽然大部分时候，并不需要泛型。但有时候，特别是是在写内部库时，尤其涉及到 slice 时，明显得感觉到需要泛型。</p>
<p>没有泛型是目前社区对 Go 抱怨最多的（虽然也有人说不需要泛型，有泛型了就不用 Go 了。。。），目前 Go 团队花了大量的时间在推进泛型。目前已经可以尝鲜，预计泛型会在 1.18 正式发布。</p>
<p>他们在迁移 Python 代码时，有些 Python 的语言结构，使用 Go 实现需要花费较多时间。不过，Go 的语言特性少，使得代码更一致，可读性更好。就他们的系统，有些特性，需要 2.7 倍的 Go 代码实现同样功能的 Python 代码。注意，是部分功能。</p>
<p>习惯了 Python 的人，他们希望 Go 中能够有更多的高阶函数。随着泛型的加入，这方面可能会加强，比如计划增加的 slices 包。</p>
<h2 id="性能和并发性">性能和并发性</h2>
<p>相比 Python，发现 Go 的性能非常优秀。尽管迁移过程中，有点直接从 Python 翻译到 Go 的感觉，没有对 Go 代码做专门优化，但性能表现依然抢眼。优化后会有更好的表现。</p>
<p>其中一名工程师发现，Python 版本中，某些批量数据更改每小时会产生大约 100 个 Google Cloud Datastore 竞争警告，而在 Go 版本中，竞争警告接近于零，因为它处理数据的速度要快得多。他们有一个包含 1000 名学生的课程，在 Python 中加载需要 28 秒，而在 Go 中只需要 4 秒。</p>
<p>虽然他们的 Python 版本时候单线程的，但 Go 版本还是使用了并发的特性。</p>
<p>Go 官方一般推荐使用 Goroutiine + Channel，但可汗学院发现，他们使用 sync 包的数量远超 channel，不知道这种情况将来会不会改变。</p>
<h2 id="50-万行代码后的总结">50 万行代码后的总结</h2>
<ul>
<li>一般来说，实现同样的功能，Go 代码会比 Python 多；</li>
<li>但 Go 的速度快，工具好用，而且在线上运行稳定、良好；</li>
</ul>
<p>虽然可汗学院的工程师有不同的背景，对 Go 和其他语言也有不同的看法。经过这段时间的磨合，目前看，对 Go 他们还算满意。</p>
<hr>
<p>你写了多少 Go 代码？你对 Go 的感受是什么？</p>
]]></content>
		</item>
		
		<item>
			<title>Rust 劝退系列 06：常量</title>
			<link>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-06/</link>
			<pubDate>Thu, 13 May 2021 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-06/</guid>
			<description>大家好，我是站长 polarisxu。 这是 Rust 劝退系列的第 6 个教程，探讨 Rust 中的常量，因为 static 和常量有类似之处，因此一并探讨。（Rust By Example 中甚至将常量分成两种类型：const 和 static，我个人觉得常量是常量，static 修饰的是变量，不能算是常量） 01 常量 在 Rust 语言中，术语&amp;quot;常量&amp;quot;用于表示固定的值，比如 5 、-89、 I love Rust、3.14 等等。一</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这是 Rust 劝退系列的第 6 个教程，探讨 Rust 中的常量，因为 static 和常量有类似之处，因此一并探讨。（Rust By Example 中甚至将常量分成两种类型：const 和 static，我个人觉得常量是常量，static 修饰的是变量，不能算是常量）</p>
<h2 id="01-常量">01 常量</h2>
<p>在 Rust 语言中，术语&quot;常量&quot;用于表示固定的值，比如 5 、-89、 I love Rust、3.14 等等。一旦我们定义了一个常量，那么就再也不能改变常量的值了。</p>
<p>Rust 语言中使用 <code>const</code> 关键字来定义一个常量。定义常量时需要明确指定常量的数据类型。</p>
<p>看看下面的代码：（&amp;str 类型以后讲解）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">const</span><span class="w"> </span><span class="n">NUM</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">		</span><span class="c1">// const NUM = 5i8	编译不通过
</span><span class="c1"></span><span class="k">const</span><span class="w"> </span><span class="n">PI</span>: <span class="kt">f64</span> <span class="o">=</span><span class="w"> </span><span class="mf">3.14</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="n">LOVE</span>: <span class="kp">&amp;</span><span class="kt">str</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;I love Rust!&#34;</span><span class="p">;</span><span class="w">	</span><span class="c1">// 也可以使用： &amp;&#39;static str，即指定声明周期
</span></code></pre></div><p>在变量那一节讲过字面量。常量要求赋值时只能是常量表达式（字面量是常量表达式一种），这一点大部分语言都类似，即要求是编译期能计算出值的。</p>
<p>关于常量，需要注意以下几点：</p>
<ul>
<li>必须显示指定数据类型。这一点我认为不如 Go。变量能推断，为什么常量不能推断呢？Go 甚至是无类型常量，这样在具体参与计算或赋值时，在赋予合适的类型，有点类似 Rust 变量的动态推断。即使有字面量类型后缀也不行。</li>
<li>常量名一般使用大写字母，否则编译器会报 Warning。</li>
<li>在编译时，常量会被替换为具体的值。这有点类似于 C 语言中的 <code>#define</code>。</li>
<li>常量不支持重定义（遮蔽），这和变量是不同的。</li>
</ul>
<h2 id="02-静态变量">02 静态变量</h2>
<blockquote>
<p>这部分内容，我建议你看完就忘掉它！！！</p>
</blockquote>
<p>Rust 中，静态变量也叫全局变量。一般不建议使用。通过 static 定义静态变量。（Go 中没有 static 关键字）</p>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">static</span><span class="w"> </span><span class="n">NUM</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>之所以将它和常量放在一起讲，是因为和常量有一些相似之处：</p>
<ul>
<li>定义方式类型，一个使用 static，一个使用 const；</li>
<li>名称都要求使用大写，否则会报 Warning；</li>
<li>都必须明确指定类型；</li>
<li>两者都要求必须使用常量表达式进行赋值，即必须是编译期能计算出的值；</li>
</ul>
<p>但和常量也有一些重要的区别：</p>
<ul>
<li>常量在编译时被内联，但静态变量不会。在整个程序中静态变量只有一个实例，也就是说所有引用都指向同一个地址。</li>
<li>常量不可变，而静态变量和普通变量一样，默认不可变，但可以通过 mut 关键字定义为可变。</li>
</ul>
<p>也正是因为全局变量有可变特性，导致多个线程同时访问时，可能引发数据竞争，导致内存安全问题。因此，对于全局可变变量的访问和修改必须放在 unsafe 块中进行。以下代码编译不通过：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">static</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">NUM</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">NUM</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">NUM</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>编译器提示：</p>
<blockquote>
<p>error[E0133]: use of mutable static is unsafe and requires unsafe function or block</p>
</blockquote>
<p>改为这样就可以了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">static</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">NUM</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">NUM</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">NUM</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>unsafe，Go 程序员应该很熟悉。在 Go 中一般也建议别用它。</p>
<p>如果不用 unsafe，也就是静态变量别定义为可变，那这和常量似乎没啥区别，直接使用 const 更好。</p>
<h2 id="03-小结">03 小结</h2>
<p>Rust 中的常量没有太多特殊的地方，但静态变量，我建议忘记它的存在。可能有极端的场景，通过静态变量能带来一些好处，但应该不是必须的。Rust 本身就够复杂的了，能学简单点就简单点。因此，我建议你可以忘掉关于 static 的内容。</p>
<hr>
<p>上次有朋友截了个图，发现这个系列阅读量阶梯型下跌：</p>
<p><p class="md__image">
  <img src="../imgs/tutorial06-01.png"
    alt=""  />
</p>
</p>
<p>如果你都看到这里了，说明你还在坚持学习 Rust，随手给我来个三连吧：在看、点赞、转发，让我有坚持写下去的动力~</p>
]]></content>
		</item>
		
		<item>
			<title>Uber 使用 Go 的规模这么大？！都自己定制的 Go 编译器了</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/uber-pprof-pp/</link>
			<pubDate>Thu, 13 May 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/uber-pprof-pp/</guid>
			<description>大家好，我是站长 polarisxu。 今天看到 Uber 使用 Go 的情况，挺吃惊的，给大家分享下情况。 01 Uber 使用 Go 的情况 Uber 有数千个后端服务是使用 Go 实现的，它们运行在数百万个 CPU 内核上。因此，对于 Uber 来说，详细准确掌握 CPU 瓶颈至关重要。这不仅为了减少服务延迟，同时也能提高计算机运行效率。Uber 这个量级的规模，要求对代码和微观结构的影响有深入的了解。 02 定制 Go 编译器 其实说定制 Go 编译器</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天看到 Uber 使用 Go 的情况，挺吃惊的，给大家分享下情况。</p>
<h2 id="01-uber-使用-go-的情况">01 Uber 使用 Go 的情况</h2>
<p>Uber 有数千个后端服务是使用 Go 实现的，它们运行在数百万个 CPU 内核上。因此，对于 Uber 来说，详细准确掌握 CPU 瓶颈至关重要。这不仅为了减少服务延迟，同时也能提高计算机运行效率。Uber 这个量级的规模，要求对代码和微观结构的影响有深入的了解。</p>
<h2 id="02-定制-go-编译器">02 定制 Go 编译器</h2>
<p>其实说定制 Go 编译器有点不准确。主要是基于以上规模和要求，虽然 Go 内置了 Profiler，但这个 CPU Profiler 在基于 Linux 的系统上有严重的限制（也许在其他操作系统也有此问题，但 Uber 使用的是 Linux，其他机器并没有测试验证），同时内置的 Profiler 缺少掌握 CPU 瓶颈所需要的许多细节。</p>
<p>基于这些问题，Uber fork 了一份 github.com/golang/go 代码，在其上建立一个定制的 Go Profiler，以便更符合 Uber 的需求和 Uber 的商业运营规模。</p>
<p>具体来说，Uber 通过将丰富的硬件性能监视特性集成到 Go 的缺省 pprof 分析器中来增强它。这提供了几个关键好处：</p>
<ul>
<li>能够获得更准确和精确的 Go 程序分析文件（profiles）；</li>
<li>监控各种 CPU 事件的能力，比如缓存丢失、套接字间（NUMA）通信、 CPU 分支错误预测等等；</li>
<li>能够以非常高的采样频率（最高可达 10 微秒）监控 Go 程序；</li>
</ul>
<p>所以，Uber 定制的「Go 编译器」其实只是增强了 Profiler。注意，对 Profiler 的使用并不需要改变，也就是说，对外的接口、使用的工具和分析都没有变（比如堆栈属性、调用图和火焰图等），只是增加了更多的数据。</p>
<p>增强版的 Profiler，Uber 称之为 pprof++，这是带有硬件性能计数器的解决方案。</p>
<p>具体增加了哪些 CPU 事件，Uber 给了一张图，公开了最常见的一些事件。</p>
<p><p class="md__image">
  <img src="../imgs/cpu-event.png"
    alt=""  />
</p>
</p>
<p>关于这些事件的使用，以及 pprof++ 的更详细信息可以参考：<a href="https://eng.uber.com/pprof-go-profiler/" target="_blank" rel="noopener">https://eng.uber.com/pprof-go-profiler/</a>
。</p>
<p>Uber fork 的 Go 仓库地址：<a href="https://github.com/uber-research/go" target="_blank" rel="noopener">https://github.com/uber-research/go</a>
。</p>
<h2 id="03-感想">03 感想</h2>
<p>看到这个消息，惊叹 Uber 对 Go 的使用和研究之深，也证明了 Go 被大公司的规模使用，看好 Go 的前途。</p>
<p>不知道 Uber 开发的 pprof++，有没有和 Go Team 沟通，尝试合入 Go 官方仓库，毕竟既然开源出来了，如果能够在官方中使用，可以让更多人收益。当然，因为目前只支持 Linux 系统，可能不太适合合入。至少，不希望 Go 出现分裂！</p>
]]></content>
		</item>
		
		<item>
			<title>Go Team Leader — rsc 大神新开源了一个库，增强模板功能</title>
			<link>https://polarisxu.studygolang.com/posts/go/pkg/rsc-tmplfunc/</link>
			<pubDate>Wed, 12 May 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/pkg/rsc-tmplfunc/</guid>
			<description>大家好，我是站长 polarisxu。 今天给大家分享一个 rsc 新开源的一个库：rsc.io/tmplfunc 。 这个库是对 Go 标准库模板的扩展，可以像调用函数一样调用模板。通过一个例子看怎么使用。 01 标准库 因为 text/template 和 html/template 基本是一样的，且 tmplfunc 这个包同时支持两者，本文使用 text/template 来演示。 有如下代码： package main import ( &amp;#34;os&amp;#34; &amp;#34;text/template&amp;#34; ) var stdstr = `{{link&amp;#34;https://golang.org&amp;#34;&amp;#34;The Go language&amp;#34;}}{{link&amp;#34;https:</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天给大家分享一个 rsc 新开源的一个库：<a href="https://pkg.go.dev/rsc.io/tmplfunc" target="_blank" rel="noopener">rsc.io/tmplfunc</a>
。</p>
<p>这个库是对 Go 标准库模板的扩展，可以像调用函数一样调用模板。通过一个例子看怎么使用。</p>
<h2 id="01-标准库">01 标准库</h2>
<p>因为 text/template 和 html/template 基本是一样的，且 tmplfunc 这个包同时支持两者，本文使用 text/template 来演示。</p>
<p>有如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;text/template&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">stdstr</span> <span class="p">=</span> <span class="s">`</span><span class="cp">{{</span><span class="nx">link</span><span class="w"> </span><span class="s">&#34;https://golang.org&#34;</span><span class="w"> </span><span class="s">&#34;The Go language&#34;</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="nx">link</span><span class="w"> </span><span class="s">&#34;https://studygolang.com&#34;</span><span class="w"> </span><span class="s">&#34;Go语言中文网&#34;</span><span class="cp">}}</span><span class="s">
</span><span class="s">`</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">testStdlib</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testStdlib</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">funcMap</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nx">FuncMap</span><span class="p">{</span>
		<span class="s">&#34;link&#34;</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">title</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
			<span class="k">return</span> <span class="s">`&lt;a href=&#34;`</span> <span class="o">+</span> <span class="nx">url</span> <span class="o">+</span> <span class="s">`&#34;&gt;`</span> <span class="o">+</span> <span class="nx">title</span> <span class="o">+</span> <span class="s">`&lt;/a&gt;`</span>
		<span class="p">},</span>
	<span class="p">}</span>
	<span class="nx">t</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;tmplstd&#34;</span><span class="p">).</span>
		<span class="nf">Funcs</span><span class="p">(</span><span class="nx">funcMap</span><span class="p">).</span>
		<span class="nf">Parse</span><span class="p">(</span><span class="nx">stdstr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>这个例子在 Go 代码中定义了一个模板函数，构造一个 URL 链接。在模板中，通过调用这个函数生成 URL，达到了复用的目的。以上代码输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">&lt;a <span class="nv">href</span><span class="o">=</span><span class="s2">&#34;https://golang.org&#34;</span>&gt;The Go language&lt;/a&gt;
&lt;a <span class="nv">href</span><span class="o">=</span><span class="s2">&#34;https://studygolang.com&#34;</span>&gt;Go语言中文网&lt;/a&gt;
</code></pre></div><h2 id="02-使用-rsciotmplfunc">02 使用 rsc.io/tmplfunc</h2>
<p>现在使用 rsc.io/tmplfunc 这个库改写这个例子，代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;text/template&#34;</span>

	<span class="s">&#34;rsc.io/tmplfunc&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">tmplstr</span> <span class="p">=</span> <span class="s">`</span><span class="cp">{{</span><span class="nx">define</span><span class="w"> </span><span class="s">&#34;link url text&#34;</span><span class="cp">}}</span><span class="s">&lt;a href=&#34;</span><span class="cp">{{</span><span class="na">.url</span><span class="cp">}}</span><span class="s">&#34;&gt;</span><span class="cp">{{</span><span class="na">.text</span><span class="cp">}}</span><span class="s">&lt;/a&gt;</span><span class="cp">{{</span><span class="k">end</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="nx">link</span><span class="w"> </span><span class="s">&#34;https://golang.org&#34;</span><span class="w"> </span><span class="s">&#34;The Go language&#34;</span><span class="cp">}}</span><span class="s">
</span><span class="s"></span><span class="cp">{{</span><span class="nx">link</span><span class="w"> </span><span class="s">&#34;https://studygolang.com&#34;</span><span class="w"> </span><span class="s">&#34;Go语言中文网&#34;</span><span class="cp">}}</span><span class="s">
</span><span class="s">`</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">testTmplfunc</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">testTmplfunc</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;tmplfunc&#34;</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">tmplfunc</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tmplstr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>主意 tmplstr 这个变量的内容，相比标准库版本多了这一句 <code>{{define &quot;link url text&quot;}}&lt;a href=&quot;{{.url}}&quot;&gt;{{.text}}&lt;/a&gt;{{end}}</code>，这其实是定义模板的语法，tmplfunc 重用了它。link 可以理解为函数，url 和 text 理解为函数的参数。</li>
<li>在 testTmplfunc 函数中，得到 template 实例后，没有直接调用其 Parse 方法，而是调用了 tmplfunc 的函数 Parse，并将 template 的实例作为第一参数传递。</li>
</ul>
<p>其他的和标准库没有区别。运行后输出是一样的。</p>
<h2 id="03-学习更多">03 学习更多</h2>
<p>通过上面的例子，基本上我们已经掌握了该包的用法，同时也可以看出，该包让模板重用在模板页面完成，而不需要在 Go 代码中进行，目前我能想到的使用场景不多，但知晓有这么个库，也许在实际中有这样的需求。</p>
<p>关于该包，需要额外补充一点。在 define 定义时，除了上面例子的形式，还支持可选参数。可选参数通过 ? 表示，如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html">{{define &#34;link url text?&#34;}}<span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;{{.url}}&#34;</span><span class="p">&gt;</span>{{or .text .url}}<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>{{end}}
</code></pre></div><p>还支持可变参数，这和 Go 的语法一样，通过三个点表示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html">{{define &#34;myprint names...&#34;}}
	{{range .names}}
		{{.}}
	{{end}}
{{end}}
{{myprint &#34;polarisxu&#34; &#34;studygolang&#34;}}
</code></pre></div><p>定义是注意顺序：普通参数、可选参数、可变参数。</p>
<p>关于标准库中对应的 Parse，该库提供了对应的函数，具体可以查看文档。</p>
<p>密切关注大神的动态，努力跟随大神的步伐~加油！！！</p>
]]></content>
		</item>
		
		<item>
			<title>再一次看到了 Go 的节制：int128 类型要不要支持？</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/support-int128/</link>
			<pubDate>Sun, 09 May 2021 23:40:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/support-int128/</guid>
			<description>大家好，我是站长 polarisxu。 如果有看我写的 Rust 系列教程，会注意到，Rust 有一个整数类型：i128/u128，即 16 字节长的整数。而 Go 是不支持 int128/unit128 的。 当时，我也没有多想，感觉 128 长度应该用的也少。今天，我发现早在 2014 年就有人提议在 Go 中增加 int128/uint128 的支持：https://github.com/golang/go/issues/9455 。 为什么想要这个类型呢？ 有人提出了</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>如果有看我写的 Rust 系列教程，会注意到，Rust 有一个整数类型：i128/u128，即 16 字节长的整数。而 Go 是不支持 int128/unit128 的。</p>
<p>当时，我也没有多想，感觉 128 长度应该用的也少。今天，我发现早在 2014 年就有人提议在 Go 中增加 int128/uint128 的支持：<a href="https://github.com/golang/go/issues/9455" target="_blank" rel="noopener">https://github.com/golang/go/issues/9455</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/int128-01.png"
    alt=""  />
</p>
</p>
<p>为什么想要这个类型呢？</p>
<p>有人提出了相关的使用场景，总结下大概有如下几个：</p>
<ul>
<li>UUID</li>
<li>IPv6</li>
<li>hashing (MD5)</li>
<li>timestamps</li>
<li>cryptographic nonces</li>
<li>database keys</li>
<li>。。。</li>
</ul>
<p>针对有人提出的一些需求点，minux（很早期就参与 Go 开发的，华人，go mobile 项目是他主导的）给了如下答复：</p>
<p><p class="md__image">
  <img src="../imgs/int128-02.png"
    alt=""  />
</p>
</p>
<p>大家注意到没，被人 👎。</p>
<p>ianlancetaylor（泛型是他在主导设计）给出了这样的答复：</p>
<blockquote>
<p>UUID 和 IP6 的例子不够有说服力，它们很容易用其他方式实现。要不要支持 int128/uint128，关键在于有没有该类型相关的算术运算需求。在具体实现时，硬件是否很好的支持也需要考虑。</p>
<p>如果增加了该类型，strconv、math/big 等包为了兼容，需要增加额外的一些列函数。</p>
</blockquote>
<p>他还回复了很多人的其他疑问，他一直强调几点：</p>
<ul>
<li>你为什么需要 int128/uint128？</li>
<li>是否有做运算的需要？</li>
<li>对语言可能有破坏，因此这个提案标记为 「Go2」</li>
</ul>
<p>其中他的一句话不少人可能要吐槽：</p>
<blockquote>
<p>Go is not a language that decides what features to add based solely on demand. Of course demand plays a role, but it is not the determining factor.</p>
</blockquote>
<p>Go 是否增加某个特性，需求不是决定因素！</p>
<p>这就是 Go 一直坚持的理念：大道至简！节制！！！有人不喜欢，有人骂，但同样也会有人喜欢，有人爱。对我来说，挺喜欢 Go 的简单，Go 的节制！</p>
<p>最近有人在这个提案接着问：</p>
<p><p class="md__image">
  <img src="../imgs/int128-03.png"
    alt=""  />
</p>
</p>
<p>Rust 支持了，包括 PostgreSQL 数据库也支持，Go 还不支持吗？该提案的作者给出了回复：</p>
<p><p class="md__image">
  <img src="../imgs/int128-04.png"
    alt=""  />
</p>
</p>
<p>闲扯一句：不知道大家看出什么异样了吗？欢迎留言。</p>
<p>最后，int128/uint128 目测迟早应该会支持，因为 ianlancetaylor 在设计泛型时，考虑了对该类型的兼容问题。这个问题我们以后再聊。</p>
]]></content>
		</item>
		
		<item>
			<title>Rust 劝退系列 05：复合数据类型</title>
			<link>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-05/</link>
			<pubDate>Thu, 06 May 2021 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-05/</guid>
			<description>大家好，我是站长 polarisxu。 这是 Rust 劝退系列的第 5 个教程，探讨 Rust 中的复合数据类型（Compound types）。Rust 中有两种原生的复合类型：元组（tuple）和数组（array），顺带介绍切片。 01 元组类型 Go 语言没有元组类型，但多返回值有点类似元组（但还是有区别的哦）。Python 中有元组类型，因此如果你熟悉 Python，对元组应该很熟悉。 什么是元组</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这是 Rust 劝退系列的第 5 个教程，探讨 Rust 中的复合数据类型（Compound types）。Rust 中有两种原生的复合类型：元组（tuple）和数组（array），顺带介绍切片。</p>
<h2 id="01-元组类型">01 元组类型</h2>
<p>Go 语言没有元组类型，但多返回值有点类似元组（但还是有区别的哦）。Python 中有元组类型，因此如果你熟悉 Python，对元组应该很熟悉。</p>
<p><strong>什么是元组类型？</strong></p>
<p>元组是一个可以包含各种类型的值的组合。元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度无法增大或缩小。 元组的类型由各组成元素类型的序列定义。</p>
<p>元组通过小括号定义，里面的元素通过逗号分隔，例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="p">(</span><span class="mf">23.2</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>这个字面值元组的类型是：(f64, i32, char)，即对应每个元素的默认类型。因此，我们可以通过 let 将这个元组绑定到变量上，Rust 会进行类型推断：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">tup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">23.2</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>在 VSCode 中可以看到 tup 的类型就是：(f64, i32, char)。同样地，我们也可以为 tup 使用类型注解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">tup</span>: <span class="p">(</span><span class="kt">f32</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="p">,</span><span class="w"> </span><span class="n">char</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">23.2</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>因为元组是多个类型的集合，对元组中的类型没有限制。因此，可以嵌套。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mf">2.1</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">),</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>不过建议别嵌套太多，否则可读性太差。</p>
<p><strong>如何访问元组元素呢？</strong></p>
<p>上面说，Go 语言中函数多返回值类似元组，在接收多返回值时，通过多个变量接收，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Go 语言
</span><span class="c1"></span><span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">&#34;abc.txt&#34;</span><span class="p">)</span>
</code></pre></div><p>在 Rust 中，可以解构元组（这也叫模式匹配解构）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">tup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">23.2</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tup</span><span class="p">;</span><span class="w">	</span><span class="c1">// 注意：需要小括号
</span></code></pre></div><p>和 Go 语言一样，如果某个元素我们不关心，可以放入垃圾桶（<code>_</code>）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">tup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">23.2</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tup</span><span class="p">;</span><span class="w">	</span><span class="c1">// 注意：需要小括号
</span></code></pre></div><blockquote>
<p>Rust 中变量定义未使用，不会像 Go 一样报错，但会警告！</p>
</blockquote>
<p>除了模式匹配解构，还可以使用类似访问数组元素的方式访问元组元素，只不过不是用<code>[]</code>，而是用 <code>.</code> 加索引的方式（索引也是从 0 开始）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">tup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">23.2</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">tup</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span><span class="w">	</span><span class="c1">// 输出：27
</span></code></pre></div><p><strong>特殊的元组</strong></p>
<p>当元组中只有一个元素时（即元组长度是 1），唯一的元素后面必须加上逗号：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">tup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,);</span><span class="w">	</span><span class="c1">// 逗号不能少，否则会提示你，单个值应该去掉小括号。这是避免将小括号当做计算的优先级
</span></code></pre></div><p>自然，模式匹配解构元组时，也必须有逗号。</p>
<p>如果元组没有元素呢？即空元组。看下面的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test_tuple</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">test_tuple</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;test empty tuple&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>你猜打印 result 是啥？</p>
<p>擦，竟然是 <code>()</code>，即空元组。而且 Rust 给它专门取了一个名字：单元类型（unit type），也就是说，<code>()</code> 叫单元类型，它有一个唯一值：空元组 <code>()</code>。而且，因为没有任何元素，Rust 将其归为变量类型。</p>
<blockquote>
<p>还嫌 Rust 不够复杂吗？就叫空元组不行吗？非得搞一个单元类型，这么奇怪的类型。。。</p>
</blockquote>
<p>为了避免复杂性，我觉得大家将其理解为空元组即可。至于为什么这里会返回空元组，在函数部分会讲解。</p>
<p>注意：() 是不占空间的，这和 Go 中的空结构体类似。</p>
<h3 id="02-数组">02 数组</h3>
<p>Rust 中的数组和 Go 中的类似，是不可变的，由元素类型和长度确定，且长度必须是编译期常量。Rust 中，数组类型标记为 <code>[T; size]</code>。数组字面值使用 <code>[]</code> 表示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">
</span></code></pre></div><p>同样会进行类型推断（包括长度）（这里推断出 a 的类型是 <code>[i32; 4]</code>），也可以显示进行类型注解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span>: <span class="p">[</span><span class="kt">i8</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">
</span></code></pre></div><p>相比较而言，Rust 创建数组比 Go 简单，它和 PHP 这样的动态语言类似。在 Go 中一般这样创建数组：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Go 语言
</span><span class="c1"></span><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
</code></pre></div><p>也就是说，Go 中创建数组是，类型信息不能少，没法跟 Rust 一样进行类型推断。</p>
<p>除了上面的初始化方法，Rust 中还可以这样简单的初始化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">	</span><span class="c1">// 4 个元素都是 -1
</span></code></pre></div><p>Rust 变量必须初始化后才能使用，而 Go 语言中，变量会有默认值。所以，Go 中可以简单的定义一个数组，然后使用默认的初始值。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Go 语言
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span>		<span class="c1">// a 的值是：[0 0 0 0]
</span></code></pre></div><p>此外，Rust 中数组总是分配在栈中的，因此可以认为数组是「值类型」，和 Go 一样，我们不应该直接传递数组，而应该和 Go 一样，使用 slice。</p>
<h2 id="03-切片slice">03 切片（slice）</h2>
<p>Rust 中的切片和 Go 中的切片意思一样，表示对数组部分元素的引用。但和 Go 不同的是，Rust 的切片没有容量的概念，只有一个指向数据的指针和切片的长度。Rust 中切片的类型标记为 &amp;[T]，即对数组进行引用（&amp;）就是切片。</p>
<p>Go 语言中有直接创建切片的语法（比如 make），但 Rust 中没有，它必须依赖数组或 Vec（以后讲解），通过引用来创建。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">xs</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>既然切片是数组元素的片段引用，那如何引用部分片段呢？</p>
<p>在 Go 中是这么做的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">arr</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">slice1</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[:]</span>			<span class="c1">// 结果是 [1 2 3 4]，全部元素
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">slice2</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>		<span class="c1">// 结果是 [2 3]
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">slice3</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>		<span class="c1">// 结果是 [1 2 3]
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">slice4</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>		<span class="c1">// 结果是 [2 3 4]
</span></code></pre></div><p>而在 Rust 中是这么做的：（结果和上面一样）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">slice1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[..];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">slice2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">..</span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">slice3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[..</span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">slice4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">..];</span><span class="w">
</span></code></pre></div><p>看到不同了吗？</p>
<ul>
<li>Rust 中生成切片，需要引用（&amp;）；</li>
<li>Go 中使用 <code>:</code> 来引用片段；而 Rust 使用 <code>..</code>；</li>
</ul>
<p>相同的点是，都可以省略起始或终止位置，或都省略。</p>
<blockquote>
<p>关于 <code>..</code> 以后还会讲到</p>
</blockquote>
<h3 id="切片类型的方法也适用于数组">切片类型的方法（也适用于数组）</h3>
<p>在 Rust 中，一切类型都有实现一些 trait，包括上一节的标量类型（用面向对象来讲，一切皆对象）。现在先不探讨 trait，着重看看 len 方法。具体参考标准库文档：<a href="https://doc.rust-lang.org/std/primitive.slice.html" target="_blank" rel="noopener">https://doc.rust-lang.org/std/primitive.slice.html</a>
。</p>
<p><strong>1）len：计算长度</strong></p>
<p>数组或切片有一个 len() 方法可以计算长度。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span>

<span class="c1">// 具体使用
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">		</span><span class="c1">// assert_eq 和 println 一样，是一个宏，用来断言
</span></code></pre></div><p>而 Go 语言中，使用 len(arr) 的形式，len 是内置函数。</p>
<p>不过，关于 len 还有一些细小的点。看下面的 Go 代码，你觉得有问题吗？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">arr</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="kd">var</span> <span class="nx">slice</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[:]</span>

<span class="kd">var</span> <span class="nx">arr2</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)]</span><span class="kt">int</span>
<span class="kd">var</span> <span class="nx">arr3</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)]</span><span class="kt">int</span>
</code></pre></div><p>在 Go  中，要求数组长度要求是编译期常量。len(arr) 是编译期常量，而 len(slice) 却不是，因为 slice 的长度是可变的。所以，以上代码 arr2 正确，arr3 编译错误。</p>
<p>那 Rust 中是怎么样的呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[..];</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">arr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="n">arr</span><span class="p">.</span><span class="n">len</span><span class="p">()];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">arr3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">()];</span><span class="w">
</span></code></pre></div><p>arr2 和 arr3 都编译错误。arr3 错误可以理解，为什么 arr2 也不行呢？</p>
<p>根据编译器提示，怎么修改 arr2 就可以了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">const</span><span class="w"> </span><span class="n">ARR</span>:<span class="p">[</span><span class="kt">i32</span><span class="p">;</span><span class="w"> </span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">arr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">ARR</span><span class="p">.</span><span class="n">len</span><span class="p">()];</span><span class="w">
</span></code></pre></div><p>也就是说必须是数组常量。。。但数组本身不就是不可变的吗？非得定义成常量，多此一举？据说，Rust 有可能将数组改成可变的。。。有了切片，为啥还要把数组搞这么复杂？！</p>
<p><strong>2）其他方法</strong></p>
<ul>
<li>is_empty：判断数组或切片是否为空</li>
<li>first：获取第一个元素</li>
<li>last：获取最后一个元素</li>
<li>。。。</li>
</ul>
<p>first 和 last 有什么用？为啥不直接通过下标获取？</p>
<ul>
<li>last 的存在，使得我们不需要先调用 len 获取长度来间接获取最后一个元素。</li>
<li>而 first 的存在，使得我们不需要先判断是否为空。</li>
</ul>
<p>不过，因为存在数组或切片为空的情况，因此 first 和 last 返回的都是 Opiton 类型。关于该类型后续再讲。</p>
<h2 id="04-小结">04 小结</h2>
<p>我们用两篇讲解了 Rust 中的数据类型，同时和 Go 的数据类型进行了对比。但 Rust 中的数据类型不止这些，还有其他类型，我们以后再讲，包括通过标准库定义的数据类型。</p>
<p>再强调一次，本系列教程的目标是让大家学习尽可能不被劝退，因此有些特别复杂但我认为可以不用的，就不会介绍。关于 Rust 中的 primitive type 可以在标准库文档找到，以及每个类型的方法。<a href="https://doc.rust-lang.org/std/index.html#primitives" target="_blank" rel="noopener">https://doc.rust-lang.org/std/index.html#primitives</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>「卷」有理论依据：海勒姆定律—Go又是怎么卷的</title>
			<link>https://polarisxu.studygolang.com/posts/law/hyrumslaw-go/</link>
			<pubDate>Thu, 06 May 2021 13:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/law/hyrumslaw-go/</guid>
			<description>大家好，我是站长 polarisxu。 对开发人员来说，其实也是有不少定律或原则的，只是很多人可能经历了，但不知道原来是这么个定律。 「内卷」这个词很流行，几乎渗透到每一个角落： 幼儿园小朋友都学一年级知识了，你家的不学，一年级跟不上。。。 小学生就各种课外辅导班，你不报班，也没人一起玩，让他看电子产品？ 面试造火箭，工作拧螺丝的现象更加严重。。。 公众号各种卷：标题、内</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>对开发人员来说，其实也是有不少定律或原则的，只是很多人可能经历了，但不知道原来是这么个定律。</p>
<p>「内卷」这个词很流行，几乎渗透到每一个角落：</p>
<ul>
<li>幼儿园小朋友都学一年级知识了，你家的不学，一年级跟不上。。。</li>
<li>小学生就各种课外辅导班，你不报班，也没人一起玩，让他看电子产品？</li>
<li>面试造火箭，工作拧螺丝的现象更加严重。。。</li>
<li>公众号各种卷：标题、内容等，卷王之王都出现了。。。</li>
<li>。。。</li>
</ul>
<p>想起一个段子：「面试滴滴司机」，对话过程大概是这样的。（来源网络，如有雷同，纯属巧合）</p>
<blockquote>
<p>看你简历，你已经有八年的开车经验，咱们聊一聊从你按下汽车点火按钮后，汽车发生的一系列的动作。</p>
</blockquote>
<p>答：</p>
<blockquote>
<p>1）按下按钮后0.5秒，车辆完成电路自检。
2）按下1秒后，启动机马达的电路被接通，带动马达高速运转，马达转子带动发动机飞轮运动，汽车发动机在轰鸣声中启动。
3）油门踏板控制着发动机进气门（亦称作节气门）的开合角度。油门踩得越深，进气门开合角度就越大，进气量也就越大。
4）然后，火花塞适时点火，引燃可燃气形成“爆燃”，巨大的冲击力使得活塞进行运动。每分钟这样的“爆燃”会发生几百上千次。活塞的运动带动发动机曲轴飞速旋转。发动机转速的，就是每分钟内曲轴旋转的圈数。
5）气缸活塞在封闭爆燃的推动下往复运动，产生连续不断的动力。</p>
<p>至此，发动机顺利完成启动，挂好档位踩油门，转速和车速逐步攀升，我们可以出发啦！</p>
</blockquote>
<p>面试官接着问：</p>
<blockquote>
<p>嗯，那有在之前的工作中，做过启动优化吗？尽量减少发动的时间，提高用户体验。</p>
</blockquote>
<p>。。。</p>
<p>是不是卷的飞起？！</p>
<h2 id="01-海勒姆定律">01 海勒姆定律</h2>
<p>在程序设计中，接口和实现是很重要的两部分。通常在一个系统里面，接口就是一个与系统交互的抽象，比如汽车的方向盘和油门，刹车这些（我们通过这些来控制汽车，与汽车交互），而实现则是这个系统工作的一种方式，比如汽车的轮子和引擎（汽车实际是通过这些来工作的）。区分接口和实现的好处是非常明显的，当一个系统快速迭代，变得越来越复杂和难以理解的时候，抽象能非常好的帮助我们管理这些复杂性。</p>
<p>可见，一个接口在理论上需要清晰的将系统的使用者和该系统的实现隔离开。汽车系统是如此，其他系统也是如此。虽然设计者很努力，但现实往往是残酷的，当这个系统开始逐渐膨胀，一些用户开始依赖一些通过接口暴露出的内部的实现细节，「内卷」开始。。。</p>
<p>几年前，Google 的一名工程师，Hyrum（海勒姆）观察指出：</p>
<blockquote>
<p>当 API 有足够多的用户时，你在合同中的承诺已不重要：你系统的所有可观察行为都将被某些人所依赖。</p>
</blockquote>
<p>这也叫做「隐式接口定律」。</p>
<p>也就是说，当你的 API 有足够多的用户时，API 的所有行为（包括那些未囊括在公共说明中的一部分）最终都会被其他人所依赖。 一个简单的例子是 API 的响应时间这种非功能性因素；还有一个更微妙的例子是：用户使用正则表达式匹配错误提示来判断 API 的错误类型，即使 API 文档中没有任何关于错误提示的内容，而是指导用户应该使用相应的错误代码。一些用户依然会使用错误提示内容（而非错误代码），这种情况下变更 API 错误提示信息，实际上会破坏 API 的使用。</p>
<p>俗称：<strong>不按套路出牌</strong>。</p>
<h2 id="02-该定律在-go-中的体现">02 该定律在 Go 中的体现</h2>
<p>随着使用 Go 的人越来越多，大家超越 Go 规范，不满足于 Go 公开的 API，「卷入」其内部实现了。你会写 Go 代码，写过大型项目可能都不够，你必须得符合「海勒姆定律」，挖挖 GMP、GC 等 runtime 很多实现细节。</p>
<p>虽然 Go 官方一直在避免大家陷入实现细节，依赖实现细节，但还是挡不住「爱学习」的人们。比如 Go 中的 map 是无序的，但某个版本的实现，用户测试输出，咦，发现是有序的。。。然后依赖它。Go 官方「一怒之下」，故意打乱顺序。</p>
<p>再比如一个包中多个文件的初始化顺序，规范并没有进行约定。但目前官方的实现是按照文件名顺序初始化的，于是很可能就有面试题，并且多半答案就说是文件名顺序，因为现在是这么实现的，源码在那摆着呢。。。</p>
<p>再比如，Go 中 slice 的扩容，太多太多文章解释，扩容的规则是怎么样的，1.5 倍？2 倍？规范并没有对此做约定。而且 Go 不同版本的实现还经常变。用好 slice 貌似基本不能满足要求，你必须得知道它怎么扩容的，每次扩容增加多少？这跟开车需要知道发动机原理似乎没啥区别~</p>
<p>还有很多很多例子，欢迎留言！</p>
<h2 id="03-对我们有何启发">03 对我们有何启发</h2>
<p>在实际工作中，我们一方面要尽量设计好接口，将接口和实现隔离，但同时也要留意隐式接口问题。特别是对外提供服务（包括公司的基础部门，对其他部门提供服务），要求我们在构建和维护复杂系统的时候思考的更全面一点。我们需要意识到，隐示接口会限制我们系统的设计和发展。虽然隐式接口理论上不是你的锅，但使用者不会这么认为。</p>
<p>所以，「卷」有了理论依据。谷歌很多年前就用理论证明了「卷」的普遍存在，卷的有理有据，你还能不倦吗？🤣</p>
<h2 id="04-参考">04 参考</h2>
<p>海勒姆定律：<a href="https://www.hyrumslaw.com/" target="_blank" rel="noopener">https://www.hyrumslaw.com/</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>Go 真的也可以进行 GUI 开发：还有这样的图书呢</title>
			<link>https://polarisxu.studygolang.com/posts/go/book/go-gui-book/</link>
			<pubDate>Wed, 28 Apr 2021 18:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/book/go-gui-book/</guid>
			<description>大家好，我是站长 polarisxu。 最近看到一个视频：Building a Chess GUI with Fyne ，讲解如何使用 Go 构建一个完整的国际象棋应用程序。这个视频演示了如何构建 UI，添加动画，交互和拖放。所有这些都基于 Fyne 这个库构建，可以安装到桌面和移动设备！这个国际象棋的项目地址：https://github.com/andydotxyz/chess 。 出于好奇，我深挖了一下，访问了视</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>最近看到一个视频：<a href="https://www.youtube.com/watch?v=zlPDWBLhn6c" target="_blank" rel="noopener">Building a Chess GUI with Fyne</a>
，讲解如何使用 Go 构建一个完整的国际象棋应用程序。这个视频演示了如何构建 UI，添加动画，交互和拖放。所有这些都基于 <a href="https://fyne.io/" target="_blank" rel="noopener">Fyne</a>
 这个库构建，可以安装到桌面和移动设备！这个国际象棋的项目地址：<a href="https://github.com/andydotxyz/chess" target="_blank" rel="noopener">https://github.com/andydotxyz/chess</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/go-gui-book01.png"
    alt=""  />
</p>
</p>
<p>出于好奇，我深挖了一下，访问了视频作者的个人网站：<a href="https://andy.xyz/" target="_blank" rel="noopener">https://andy.xyz/</a>
，发现它就是 Fyne 的作者：Andrew Williams。他还创建了 <a href="https://fynelabs.com/" target="_blank" rel="noopener">FyneLabs</a>
，专门支持 Fyne 的发展。</p>
<h2 id="01-一本-go-gui-图书">01 一本 Go GUI 图书</h2>
<p>同时，通过作者的网站，我发现他写了一本书：<a href="https://andy.xyz/2019/03/07/meet-the-first-book-about-golang-gui-programming/" target="_blank" rel="noopener">《GUI Application Development in Go》</a>
，作者在这本书里对比了 Go 中可用的 GUI 工具包，包括一些传统的工具包（<a href="https://github.com/lxn/walk" target="_blank" rel="noopener">Walk</a>
、 <a href="https://github.com/andlabs/ui" target="_blank" rel="noopener">andlabs UI</a>
、 <a href="https://github.com/mattn/go-gtk" target="_blank" rel="noopener">Go-GTK</a>
、 <a href="https://github.com/therecipe/qt" target="_blank" rel="noopener">qt</a>
）和一些更前沿的项目（<a href="https://github.com/golang/exp/tree/master/shiny" target="_blank" rel="noopener">Shiny</a>
、 <a href="https://github.com/golang-ui/nuklear" target="_blank" rel="noopener">nk</a>
、 <a href="https://github.com/fyne-io/fyne" target="_blank" rel="noopener">Fyne</a>
）。通过这些项目，作者探讨什么样的结构和代码更适合开发 Go GUI 程序。</p>
<p>通过 GTK+ 的 Go 绑定构建了一个电子邮件应用程序，界面如下图，看起来还可以？</p>
<p><p class="md__image">
  <img src="../imgs/go-gui-book02.png"
    alt=""  />
</p>
</p>
<p>另外有一个图片查看器，使用 Fyne 构建的，界面如下图：</p>
<p><p class="md__image">
  <img src="../imgs/go-gui-book03.png"
    alt=""  />
</p>
</p>
<p>在这本书中，作者还讨论了如何规划和构建一个 GUI 应用程序以及它所依赖的代码。此外还了如何使用单元测试、持续集成，以及在集成网络和云服务时如何保持可维护的代码。最后介绍了如何打包和分发跨平台应用程序，以便交付给最终用户。</p>
<p>该书在 <a href="https://www.amazon.com/Hands-GUI-Application-Development-cross-platform-ebook/dp/B07GYLYSCT/ref=sr_1_1" target="_blank" rel="noopener">Amazon</a>
 上可以买到，还有 Kindle 版，出版时间是 2019 年 2 月。</p>
<p><p class="md__image">
  <img src="../imgs/go-gui-book04.png"
    alt=""  />
</p>
</p>
<h2 id="02-一个-fyne-图书">02 一个 Fyne 图书</h2>
<p>通过上面那本书，我又发现了另外一本书：<a href="https://www.amazon.com/Building-Cross-Platform-Applications-Fyne-platform-agnostic-ebook/dp/B08PKTNVBQ/ref=pd_rhf_dp_s_ci_mcx_mr_hp_d_2" target="_blank" rel="noopener">《Building Cross-Platform GUI Applications with Fyne》</a>
，副标题是：Create beautiful, platform-agnostic graphical applications using Fyne and the Go programming language。</p>
<p>这也是 Andrew Williams 写的，出版时间是 2021 年 1 月底。</p>
<p>上一本书主要对比现存的 Go GUI 库，以及探索一个更合适的 Go GUI 开发方案，而这本书，主要讲述如何使用 Fyne 这个 Go GUI 工具包开发出漂亮的、跨平台的 GUI 应用程序。</p>
<p>该书主要让你：</p>
<ul>
<li>了解如何使用标准 widgets，dialogs 和 layouts 以及如何构建自己的以上组件</li>
<li>了解如何开发应用程序和包并将其分发到不同的操作系统和应用商店</li>
<li>探索 Fyne 工具包的设计原则和愿景以及你在项目中可以如何使用</li>
</ul>
<p>本书主要通过示例项目来讲解，一共有五个示例项目，你将学习如何有效构建应用程序，专注于每个主要区域，包括画布，布局，文件处理，小部件，数据绑定和主题。本书还将向你展示已完成的应用程序如何在桌面计算机，笔记本电脑和智能手机上运行。完成这些项目后，你还可以将它们分发各种应用商店中供别人下载使用。</p>
<p>如果你坚持学完该书，应该能够创建出漂亮的跨平台图形应用程序。</p>
<p>以下是该书目录：</p>
<ol>
<li>A Brief History of GUI Toolkits and Cross-Platform Development</li>
<li>The Future According to Fyne</li>
<li>Window, Canvas, and Drawing</li>
<li>Layout and File handling</li>
<li>Widget Library and Themes</li>
<li>Data Binding and Storage</li>
<li>Building Custom Widgets and Themes</li>
<li>Project Structure and Best Practices</li>
<li>Bundling Resources and Preparing for Release</li>
<li>Distribution - App Stores and Beyond</li>
<li>Appendix A: Developer Tool Installation</li>
<li>Appendix B: Installation of Mobile Build Tools</li>
<li>Appendix C: Cross-Compiling</li>
</ol>
<h2 id="03-总结">03 总结</h2>
<p>虽然 GUI 不是 Go 的主战场，但作为一门通用编程语言，一些第三方库证明，Go 也是可以进行 GUI 开发的。如果你对 Go 语言开发 GUI 感兴趣，可以看看本文介绍的这两本书，特别是 Fyne 这本。从 Fyne 的发展看，前途还是值得期待的。</p>
<p>当然，你也可以直接研究文章开头提到的国际象棋项目。</p>
<p>以后请别说 Go 不能开发 GUI 程序了~当然，我们可以将 Go GUI 开发作为自己的爱好，业余研究，不能指望通过它找工作啥的。</p>
<p>你会学习下 Go 的 GUI 开发吗？欢迎留言交流。</p>
]]></content>
		</item>
		
		<item>
			<title>Rust 劝退系列 04：基本数据类型</title>
			<link>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-04/</link>
			<pubDate>Sun, 25 Apr 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-04/</guid>
			<description>大家好，我是站长 polarisxu。 这是 Rust 劝退系列的第 4 个教程，探讨 Rust 中的基本数据类型，或叫标量类型（scalar type）。 Rust 和 Go 一样，都是静态类型语言，这表示每个变量的类型必须明确。和 Go 类似，大多数情况下，Rust 编译器能够推断出某个值的类型，不需要我们显示指定，写起来有点类似于弱类型似语言。但有些情况下，必须明确告知编译器我们使用什么类型，在 Rust 中，这叫</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这是 Rust 劝退系列的第 4 个教程，探讨 Rust 中的基本数据类型，或叫标量类型（scalar type）。</p>
<p>Rust 和 Go 一样，都是静态类型语言，这表示每个变量的类型必须明确。和 Go 类似，大多数情况下，Rust 编译器能够推断出某个值的类型，不需要我们显示指定，写起来有点类似于弱类型似语言。但有些情况下，必须明确告知编译器我们使用什么类型，在 Rust 中，这叫 「类型注解」（type annotations）。</p>
<p>对于类型注解，看一个常见的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;42&#34;</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Not a number!&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><p>这是将字符串 <code>&quot;42&quot;</code> 转为数字 42。在 Go 语言中，一般这么做：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">guess</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="s">&#34;42&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>但上面的 Rust 代码会报错：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">error<span class="o">[</span>E0282<span class="o">]</span>: <span class="nb">type</span> annotations needed
 --&gt; src/main.rs:2:9
  <span class="p">|</span>
<span class="m">2</span> <span class="p">|</span>     <span class="nb">let</span> <span class="nv">guess</span> <span class="o">=</span> <span class="s2">&#34;42a&#34;</span>.parse<span class="o">()</span>.expect<span class="o">(</span><span class="s2">&#34;Not a number!&#34;</span><span class="o">)</span><span class="p">;</span>
  <span class="p">|</span>         ^^^^^^ consider giving <span class="sb">`</span>guess<span class="sb">`</span> a <span class="nb">type</span>
</code></pre></div><p>这和 Go 还是不太一样。Go 中很多时候，数值类型会是 int。</p>
<p>为了修复这个问题，我们需要为 number 指定一个类型，比如 u32。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">guess</span>: <span class="kt">u32</span> <span class="o">=</span><span class="w"> </span><span class="s">&#34;42&#34;</span><span class="p">.</span><span class="n">parse</span><span class="p">().</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Not a number!&#34;</span><span class="p">);</span><span class="w">
</span></code></pre></div><blockquote>
<p>吐槽：在 Rust 中，类型注解和 Go 中一样，放在变量后面。但 Rust 中变量和类型直接非得加一个冒号（:），而且一般冒号紧跟着变量名（rustfmt 的建议）。不知道冒号有啥特殊需要？！</p>
</blockquote>
<p>Rust 内置如下基本数据类型：</p>
<ul>
<li>整数类型
<ul>
<li>有符号整数：i8、i16、i32、i64、i128、isize</li>
<li>无符号整数：u8、u16、u32、u64、u128、usize</li>
</ul>
</li>
<li>浮点类型：f32、f64</li>
<li>布尔型：bool</li>
<li>字符型：char</li>
</ul>
<h2 id="01-整数类型">01 整数类型</h2>
<p>将整数类型整理为一张表，如下：（用 Go 语言对应的类型作对比）</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号</th>
<th>无符号</th>
<th>Go 有符号</th>
<th>Go 无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
<td><code>int8</code></td>
<td><code>uint8</code></td>
</tr>
<tr>
<td>16-bit</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
<td><code>int16</code></td>
<td><code>uint16</code></td>
</tr>
<tr>
<td>32-bit</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
<td><code>int32</code></td>
<td><code>uint32</code></td>
</tr>
<tr>
<td>64-bit</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
<td><code>int64</code></td>
<td><code>uint64</code></td>
</tr>
<tr>
<td>128-bit</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>arch</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
<td><code>int</code></td>
<td><code>uint</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>吐槽：有时候 Rust 真的很节省，int、uint 直接省略为 i、u，function 省略为 fn。但有时候又很繁琐（不简洁），比如前面说到的变量和类型之间的冒号。。。</p>
<p>这里用 u、i 的形式，也需要一段时间适应。。。</p>
</blockquote>
<p>两点说明：</p>
<ul>
<li>Go 中没有 128 位长度的整数</li>
<li>isize 和 usize 对应 Go 中的 int 和 uint，它们的长度依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的</li>
</ul>
<p>在 Go 中，整型变量默认类型是 int，以下代码可以证明这一点：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">x</span> <span class="o">:=</span> <span class="mi">32</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
<span class="c1">// 输出：int
</span></code></pre></div><p>那 Rust 中默认是什么类型呢？</p>
<p>我想在 Rust 中找到一种办法，打印变量类型，网上找到了这样的办法（有点挫）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 打印变量类型的函数。该函数看不懂先放着。
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">print_type_of</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">		</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">any</span>::<span class="n">type_name</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">print_type_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w">  	</span><span class="c1">// 输出：i32
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>可见 Rust 中整型变量默认类型是 i32（即使在 64 位机器上，也是 i32）。这一定程度上说明，在 Go 中，整数一般建议用 int 类型；而 Rust 中，一般建议用 i32 类型。（所以，为什么开头的 parse 不能默认推断为 i32 类型呢？怕溢出？）</p>
<h3 id="更智能的类型推断">更智能的类型推断</h3>
<p>上文说 Rust 和 Go 一样，支持类型推断。不过 Rust 的推断更智能，怎么个智能法？看下面的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// 打印变量类型的函数
</span><span class="c1"></span><span class="k">fn</span> <span class="nf">print_type_of</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">std</span>::<span class="n">any</span>::<span class="n">type_name</span>::<span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">())</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i8</span> <span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">print_type_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">print_type_of</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>根据上面的讲解，x 应该是默认类型：i32。但实际上，x 和 y 的类型都是 i8。也就是说，因为 x 的类型没有显示的指定（类型注解），Rust 编译器会根据上下文（实际上是 <code>let y: i8 = x</code> 这句）推断出 x 的类型应该和 y 一致，即 i8。</p>
<p>在 Go 中，int8 和 int 是不会进行隐式转换的，Rust 也一样，必须进行显示转换。但 Rust 的智能类型推断，可以让开发者少写类型转换的代码。</p>
<p>比如上面代码，在 Go 语言中是行不通的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="o">:=</span> <span class="mi">32</span>
	<span class="kd">var</span> <span class="nx">y</span> <span class="kt">int8</span> <span class="p">=</span> <span class="nx">x</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%T\n&#34;</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>会报错：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">cannot use x <span class="o">(</span><span class="nb">type</span> int<span class="o">)</span> as <span class="nb">type</span> int8 in assignment
</code></pre></div><p>也就是说，Go 中的类型推断不会考虑上下文，因此没有 Rust 智能。</p>
<p>因为编译器的强大，VSCode 中（安装 rust-analyzer）会有类型提示，这样上面的 print_type_of 函数也不需要了。做了一个动图，注意上面 x 的类型变化：</p>
<p><p class="md__image">
  <img src="../imgs/tutorial04-01.png"
    alt=""  />
</p>
</p>
<p>此外，isize 和 usize 类型一般用作某些集合的索引，以后文章会看到。</p>
<blockquote>
<p>关于各种类型的表示范围我不列出了，因为这个系列不是为无编程经验的人准备的。这个系列更多是为 Go 爱好者准备的 Rust 教程，因此和 Go 一致的地方可能不会讲。</p>
</blockquote>
<h2 id="02-浮点类型">02 浮点类型</h2>
<p>和 Go 一样，Rust 也有两种浮点数类型：f32 和 f64，对应 Go 中的 float32 和 float64。和 Go 一样，默认类型是 f64，可以通过类型注解指定具体的浮点类型。（采用 IEEE-754 标准表示，关于浮点数知识，可以阅读<a href="https://mp.weixin.qq.com/s/BmXbChq3RVRmdGNgfxLyvw" target="_blank" rel="noopener">我之前写的文章</a>
。）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w">	</span><span class="c1">// 默认是 f64
</span></code></pre></div><p>一般地，整数类型和浮点类型都成为数值类型。</p>
<p>数值类型有一些共同的东西。比如都支持基本的数学运算。此外，除了通过类型注解指定类型，数值类型还可以在字面值后面带上类型后缀指定类型，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="k">f32</span><span class="p">;</span><span class="w">	</span><span class="c1">// f32 类型
</span><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="k">i64</span><span class="p">;</span><span class="w">	</span><span class="c1">// i64 类型
</span></code></pre></div><h2 id="03-布尔型">03 布尔型</h2>
<p>和 Go 语言一样，Rust 中的布尔类型使用 bool 表示（咋没用 b、bl 之类的缩写呢？哈哈哈）。有两个可能的值：true 和 false。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">f</span>: <span class="kt">bool</span> <span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 显式指定类型注解
</span><span class="c1"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="04-字符型">04 字符型</h2>
<p>Rust 中的 char 表示字符类型，是 Rust 的基本类型，字面值由单引号指定。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;中&#39;</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;🤣&#39;</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>可见，Rust 中的 char 类型和 Go 中的 rune 一样，表示的是 Unicode 码点，占 4 个字节。</p>
<p>因为 Rust 中的字符串很复杂，而且不是基本类型，因此留在以后讲解。</p>
<h2 id="05-小结">05 小结</h2>
<p>本文介绍了 Rust 中的四种基本数据类型：整型、浮点型、布尔型和字符型。其中，浮点型、布尔型和字符型分别对应 Go 中的浮点型、布尔型和 rune 类型，但整型，Go 和 Rust 有些许不一样，上文已经详细介绍了。此外，Go 中复数也是基本数据类型：complex64 和 complex128，而 Rust 中没有，复数通过第三方库实现，比如：<a href="https://crates.io/crates/easy_complex" target="_blank" rel="noopener">https://crates.io/crates/easy_complex</a>
。</p>
<p>此外，你可能会说 Go 中还有一个基本类型：byte，而 Rust 没有。其实 Go 中的 byte 只是 uint8 的别名。另外，string 在 Go 中是基本数据类型，而在 Rust 中不是。</p>
<p>本节内容就这些，你被劝退了吗？欢迎留言交流！</p>
]]></content>
		</item>
		
		<item>
			<title>我的 Go 语言书单</title>
			<link>https://polarisxu.studygolang.com/posts/go/book/20210423-go-book-list/</link>
			<pubDate>Fri, 23 Apr 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/book/20210423-go-book-list/</guid>
			<description>大家好，我是站长 polarisxu。 今天是 4 月 23 日，是世界读书日。当当有很大的优惠，而且我还要到了额外的优惠码，花 140 可以买到 400 块钱的书。借这个机会，我分享一份 Go 语言书单（实际上还有很多免费电子书单，但这里只说纸质版），需要的可以今天购买，超便宜！ 我认为不错的书，不代表你也认为好。所以，买不买自行判断哈。 01 入门级 以下排名不分先后。 Go 程序设计语言（俗称 Go 圣经） 本</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天是 4 月 23 日，是世界读书日。当当有很大的优惠，而且我还要到了额外的优惠码，花 140 可以买到 400 块钱的书。借这个机会，我分享一份 Go 语言书单（实际上还有很多免费电子书单，但这里只说纸质版），需要的可以今天购买，超便宜！</p>
<blockquote>
<p>我认为不错的书，不代表你也认为好。所以，买不买自行判断哈。</p>
</blockquote>
<h2 id="01-入门级">01 入门级</h2>
<p>以下排名不分先后。</p>
<h3 id="go-程序设计语言俗称-go-圣经">Go 程序设计语言（俗称 Go 圣经）</h3>
<p>本书由《C程序设计语言》的作者Kernighan和谷歌公司Go团队主管Alan Donovan联袂撰写，是学习Go语言程序设计的指南。本书共13章，主要内容包括：Go的基础知识、基本结构、基本数据类型、复合数据类型、函数、方法、接口、goroutine、通道、共享变量的并发性、包、go工具、测试、反射等。本书适合作为计算机相关专业的教材，也可供Go语言爱好者阅读。</p>
<p>这本书是翻译版，翻译水平自己鉴别。国内有大佬另外翻译了一版，并免费开源了，如果你喜欢电子书，可以<a href="https://books.studygolang.com/gopl-zh/" target="_blank" rel="noopener">在线阅读</a>
。</p>
<p>豆瓣评分：8.8</p>
<p><p class="md__image">
  <img src="../imgs/21go-book-list-01.png"
    alt=""  />
</p>
</p>
<h3 id="go-语言趣学指南">Go 语言趣学指南</h3>
<p>这是一本面向 Go 语言初学者的书，书中循序渐进地介绍了使用Go语言必需知道的知识，展示了非常多生动有趣的例子，并通过提供大量练习来加深读者对书中所述内容的理解。本书共分7个单元，分别介绍了变量、常量、分支和循环等基础语句，整数、浮点数和字符串等常用类型， 类型、函数和方法，数组、切片和映射，结构和接口，指针、nil 和错误处理方法，并发和状态保护，并且每个单元都包含相应的大章和单元测试。</p>
<p>这本书是国外的，这是中译本，译者有些人可能很熟悉，他出版过、翻译过挺多图书。</p>
<p>豆瓣评分：8.0</p>
<p><p class="md__image">
  <img src="../imgs/21go-book-list-02.png"
    alt=""  />
</p>
</p>
<h2 id="02-go实战或进阶">02 Go实战或进阶</h2>
<p>以下排名不分先后。</p>
<h3 id="go语言编程之旅一起用go做项目">Go语言编程之旅：一起用Go做项目</h3>
<p>本书分为6章，分别是命令行应用、HTTP应用、RPC应用、WebSocket 应用、进程内缓存和 Go语言中的大杀器，其中前5章是Go语言开发中最常见的项目类型，适合有一定Go语言基础的读者以及相关开发人员阅读。</p>
<p>作者是煎鱼和 polarisxu。</p>
<p>豆瓣评分：7.7，分数不高，应该是第一次印刷挺多编辑错误导致的，目前发现的错误都已改正，已完成第三次印刷。</p>
<p><p class="md__image">
  <img src="..//Users/xuxinhua/opensource/polarisxu/content/posts/go/book/imgs/21go-book-list-03.png"
    alt=""  />
</p>
</p>
<h3 id="go-语言学习笔记">Go 语言学习笔记</h3>
<p>本书经四年多逐步完善，内容覆盖了语言、运行时、性能优化、工具链等各层面知识。且内容经大量读者反馈和校对，没有明显的缺陷和错误。上卷细致解析了语言规范相关细节，便于读者深入理解语言相关功能的使用方法和注意事项。下卷则对运行时源码做出深度剖析，引导读者透彻了解语言功能背后的支持环境和运行体系，诸如内存分配、垃圾回收和并发调度等。本书不适合编程初学入门，可供有实际编程经验或正在使用Go 工作的人群参考。</p>
<p>作者雨痕，Go 圈大神！</p>
<p>豆瓣评分：8.2</p>
<p><p class="md__image">
  <img src="../imgs/21go-book-list-04.png"
    alt=""  />
</p>
</p>
<h3 id="go-web-编程">Go Web 编程</h3>
<p>该书围绕一个网络论坛 作为例子，教授读者如何使用请求处理器、多路复用器、模板引擎、存储系统等核心组件去构建一个 Go Web 应用，然后在该应用的基础上，构建出相应的 Web 服务。本书只会用到 Go 语言自带的标准库，而不会用到任何特定的 Web 框架：这使得读者学习到的知识不会受到特定的框架所限制，即使将来有需要用到现成的框架又或者自行构建框架，读者仍然会从本书介绍的知识中获益。</p>
<p>该书作者是新加坡人，由黄健宏翻译（上面 《Go语言趣学指南》也是他翻译的）。</p>
<p>豆瓣评分：8.1</p>
<p><p class="md__image">
  <img src="../imgs/21go-book-list-05.png"
    alt=""  />
</p>
</p>
<h3 id="go专家编程">Go专家编程</h3>
<p>本书首先介绍Go语言常见的数据结构及控制结构的实现原理，包括管道、切片、Hash表、select和for-range等，这部分内容大都以几个精心准备的测验题目开头，每个测验题目均对应一个知识点，读者可以借此测验自身对该知识点的掌握程度。接着介绍了Go语言最基础的概念，包括协程的概念、协程调度模型、协程调度策略，以及内存分配和垃圾回收相关的内容。本书还介绍了一些标准库、异常处理和依赖管理等非语法相关但非常重要的内容。最后结合作者的见闻，整理了一些发生在真实项目中的编程陷阱。</p>
<p>本书作者是华为云原生团队核心成员，开源爱好者，深度参与CNCF（云原生计算基金会）旗下Kubernetes、Prometheus等项目。</p>
<p>豆瓣评分：9.6</p>
<p><p class="md__image">
  <img src="../imgs/21go-book-list-06.png"
    alt=""  />
</p>
</p>
<h3 id="go语言实战go-in-action">Go语言实战（Go In Action）</h3>
<p>本书向读者提供一个专注、全面且符合语言习惯的视角。Go语言实战同时关注语言的规范和实现，涉及的内容包括语法、类型系统、并发、管道、测试，以及其他一些主题。</p>
<p>这是国外 In Action 系列（本书是中译本），很经典。相对来说，这个系列都不是入门系列。</p>
<p>豆瓣评分：7.7，分数不高。</p>
<p><p class="md__image">
  <img src="../imgs/21go-book-list-07.png"
    alt=""  />
</p>
</p>
<h3 id="go语言高级编程">Go语言高级编程</h3>
<p>本书从实践出发讲解Go语言编程的进阶知识。本书共6章，第1章简单回顾Go语言的发展历史；第2章和第3章系统介绍CGO编程和Go汇编语言的用法；第4章对RPC和Protobuf技术进行深入介绍，并讲述如何打造一个自己的RPC系统；第5章介绍工业级环境的Web系统的设计和相关技术；第6章介绍Go语言在分布式领域的一些编程技术。</p>
<p>作者是柴大和曹大。</p>
<p>豆瓣评分：8.1</p>
<p><p class="md__image">
  <img src="..//Users/xuxinhua/opensource/polarisxu/content/posts/go/book/imgs/21go-book-list-08.png"
    alt=""  />
</p>
</p>
<h2 id="03-小结">03 小结</h2>
<p>Go 的书越来越多，我这里做了一些精选。有一些书没有入选，有几方面原因：</p>
<ul>
<li>太老旧，比如 12、13 年出的</li>
<li>豆瓣评分很低。比如翻译太烂</li>
<li>有些豆瓣没有评分，而我又不了解</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Rust 劝退系列 03：变量</title>
			<link>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-03/</link>
			<pubDate>Mon, 19 Apr 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-03/</guid>
			<description>大家好，我是站长 polarisxu。 这是 Rust 劝退系列的第 3 个教程，探讨 Rust 中的变量。 01 变量和绑定 变量指定了某存储单元（Memory Location）的名称，该存储单元会存储特定类型的值。 Rust 是静态类型语言，不能在运行期改变变量类型。 和你熟悉的大部分编程语言不一样，Rust 中变量一般不叫声明，而叫做绑定（这是从函数式语言中借鉴的，使用关键字 let 绑定），那有什么区别呢？</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这是 Rust 劝退系列的第 3 个教程，探讨 Rust 中的变量。</p>
<h2 id="01-变量和绑定">01 变量和绑定</h2>
<p>变量指定了某存储单元（Memory Location）的名称，该存储单元会存储特定类型的值。</p>
<p>Rust 是静态类型语言，不能在运行期改变变量类型。</p>
<p>和你熟悉的大部分编程语言不一样，Rust 中变量一般不叫声明，而叫做绑定（这是从函数式语言中借鉴的，使用关键字 let 绑定），那有什么区别呢？</p>
<p>在 Go 语言中一般有下面几种声明变量的方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">age</span> <span class="p">=</span> <span class="mi">10</span>
<span class="kd">var</span> <span class="nx">age</span> <span class="kt">int</span>
<span class="kd">var</span> <span class="nx">age</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">10</span>
<span class="nx">age</span> <span class="o">:=</span> <span class="mi">10</span>	<span class="c1">// 只能在函数内部使用
</span><span class="c1">// 可以分组
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">age</span> <span class="p">=</span> <span class="mi">10</span>
  <span class="nx">birthday</span> <span class="p">=</span> <span class="s">&#34;01-01&#34;</span>
<span class="p">)</span>
</code></pre></div><p>Go 中声明变量，可以不指定类型（会进行类型推导），也可以不给初始值（会有默认初始值）。</p>
<p>而 Rust 中，形式比较少，主要有两种：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="kd">let</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">age</span>: <span class="kt">i32</span> <span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span></code></pre></div><p>和 Go 一样，大部分时候，Rust 也能够推导出类型。在显示指定类型时，需要加上 <code>:</code>。关于类型，后续讲解。</p>
<p>那为什么 Rust 中变量创建一般叫做绑定呢？</p>
<p>1）Rust 和 C 一样，变量创建后必须初始化后才能使用（未使用的变量会警告）。以下代码编译报错：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">age</span>: <span class="kt">i32</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;age is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="c1">// error[E0381]: borrow of possibly-uninitialized variable: `age`
</span></code></pre></div><p>2）Rust 中，通过 let 关键字，在标识符（如变量 age）与值（如 10）之间建立起一种关联关系。表明所有权关系。也就是说这块内存现在属于 age 了。</p>
<blockquote>
<p>熟悉 JS 的朋友，应该对 var 和 let 很亲切，不过两者的区别和 Go 中的 var 与 Rust 的 let 区别不一样。</p>
</blockquote>
<h2 id="02-可变性">02 可变性</h2>
<p>第一次看到下面的代码报错，你肯定特别的惊讶：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w">   	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;age is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;age is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="c1">// error[E0384]: cannot assign twice to immutable variable `age`
</span></code></pre></div><p>没错，Rust 中的变量默认是不可变的（好吧，变量不可变。。。但又不是常量）。这也是 Rust 中内存管理很重要的一个特性。</p>
<p>如果我想变量可变，怎么办？Rust 提供了关键字 mut，这叫做可变绑定：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w">   	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;age is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;age is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>通常，我们应该优先创建不可变变量，只有真的需要时，才使用可变变量。</p>
<h2 id="03-隐藏shadow">03 隐藏（shadow）</h2>
<p>因为变量默认不可变，Rust 中还存在这样「诡异」的情况。下面代码一切正常：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w">   	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;age is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;age is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在 Go 中，肯定报重复声明。</p>
<p>这种「重复」创建同名变量的语法，Rust 中叫做隐藏（Shadow）。也就是说上次创建的被这次创建的隐藏了。具体有什么用呢？</p>
<p>比如类似这样的代码，在 Go 中还是比较常见的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">ageStr</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">FormValue</span><span class="p">(</span><span class="s">&#34;age&#34;</span><span class="p">)</span>
<span class="nx">age</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">ageStr</span><span class="p">)</span>
</code></pre></div><p>也就是说，同样的数值，因为类型不同，需要用两个不同名称的变量表示。但 Rust 中可以这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;10&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="p">.</span><span class="n">parse</span>::<span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span><span class="w">   	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;age is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>不过这种语法有好处也有弊端。当涉及到作用域时，要特别注意隐藏的问题。这和 Go 中的简短声明（:=）的「坑」很像。类似下面这样的代码，最后的 age 依然是 10：（实际中的代码一般不会这么明显）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;abc&#34;</span><span class="p">;</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;age is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w">   	</span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;age is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">age</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="c1">// age is abc
</span><span class="c1">// age is 10
</span></code></pre></div><p>可见，隐藏只会其所属作用域内生效。</p>
<h2 id="04-小结">04 小结</h2>
<p>Rust 是静态类型语言，运行期间不能改变变量类型。</p>
<ul>
<li>通过 let 创建变量，Rust 中一般叫做变量绑定；</li>
<li>默认变量不可变，创建可变绑定，可以在变量名前加上 mut 关键字；</li>
<li>重复定义重名变量会隐藏（shadow）之前的变量，但要注意作用域问题；</li>
</ul>
<p>本节内容还是比较简单的，但要注意和你所学语言不同的点以及可能的坑。没被劝退吧~</p>
]]></content>
		</item>
		
		<item>
			<title>我又来推荐免费 Go 新书了：一本用 Go 讲架构的书</title>
			<link>https://polarisxu.studygolang.com/posts/go/book/go-with-the-domain/</link>
			<pubDate>Mon, 19 Apr 2021 08:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/book/go-with-the-domain/</guid>
			<description>大家好，我是站长 polarisxu。 我又来给大家推荐 Go 新书了，免费的哦。说明一点，这本书我只是浏览了下目录，看了下介绍，感觉应该还可以，值得读一读。书名是：《Go With The Domain》。 先介绍下该书的作者。Miłosz 和 Robert，他们是 Three Dots Labs 的创始人，这是一个什么组织呢？官网上是这么介绍的： Golang, Domain-Driven Design and Continuous Delivery. 关注 Go 领域驱动设计和持续交付，所以，这本书也是和这方面有</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>我又来给大家推荐 Go 新书了，免费的哦。说明一点，这本书我只是浏览了下目录，看了下介绍，感觉应该还可以，值得读一读。书名是：《Go With The Domain》。</p>
<p>先介绍下该书的作者。Miłosz 和 Robert，他们是 Three Dots Labs 的创始人，这是一个什么组织呢？官网上是这么介绍的：</p>
<blockquote>
<p>Golang, Domain-Driven Design and Continuous Delivery.</p>
</blockquote>
<p>关注 Go 领域驱动设计和持续交付，所以，这本书也是和这方面有关的，书的子标题是：Building Modern Business Software in Go。</p>
<p>注意，这里的 Business Software，我翻译成商务软件，不一定准确。该书开篇也解释了该词，认为企业任何应用开发或 Saas 产品，都算是 Business Software。</p>
<p>开篇还介绍了为什么使用 Go 语言来讲解。</p>
<p>此外，这本书最开始是他们发布在网站上的系列文章，写的多了，觉得应该整理下，更系统地进行讲解，于是有了该书。</p>
<p>阅读该书，要求你熟悉 Go 语言，并对某些项目的基本知识有所了解。最适合这样的你：正在寻找某种模式，希望这些模式帮助你在几个月内设计好的应用程序。</p>
<p>本书中的大多数想法在复杂的业务场景中可能出现。不过，如果在小项目中使用，看起来就会有点奇怪（简单问题复杂化的感觉）。所以，我们应该尽量务实，并选择最佳工具。</p>
<p>这是该书的目录：</p>
<p>1、Welcome on board!</p>
<p>2、Building a serverless application with Google Cloud Run and Firebase</p>
<p>3、gRPC communication on Google Cloud Run</p>
<p>4、Authentication using Firebase</p>
<p>5、When to stay away from DRY</p>
<p>6、Domain-Driven Design Lite</p>
<p>7、The Repository Pattern</p>
<p>8、High-Quality Database Integration Tests</p>
<p>9、Clean Architecture</p>
<p>10、Basic CQRS</p>
<p>11、Combining DDD, CQRS, and Clean Architecture</p>
<p>12、Tests Architecture</p>
<p>13、Repository Secure by Design</p>
<p>14、Setting up infrastructure with Terraform</p>
<p>15、Running integration tests in the CI/CD pipeline</p>
<p>16、Intermission</p>
<p>17、Event Storming (Coming soon)</p>
<p>18、Bounded Context (Coming soon)</p>
<p>19、Ubiquitous Language (Coming soon)</p>
<p>20、Aggregate (Coming soon)</p>
<p>21、Value Object (Coming soon)</p>
<p>22、Dependency Injection (Coming soon)</p>
<p>后面六章还没完成。</p>
<p>说了这么多，该书怎么获取？访问 <a href="https://threedots.tech/newsletter/" target="_blank" rel="noopener">https://threedots.tech/newsletter/</a>
，填写你的邮箱订阅，会收到该书的电子版，包括 PDF、EPUB 和 MOBI 三种格式。虽然我获取到了，但需要的还是从这里获取吧，上面会有你的名字，类似定制的感觉，比如我的：</p>
<p><p class="md__image">
  <img src="../imgs/go-with-the-domain.png"
    alt=""  />
</p>
</p>
]]></content>
		</item>
		
		<item>
			<title>注释竟然还有特殊用途？一文解惑 //go:linkname 指令</title>
			<link>https://polarisxu.studygolang.com/posts/go/go-linkname/</link>
			<pubDate>Thu, 15 Apr 2021 20:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/go-linkname/</guid>
			<description>大家好，我是站长 polarisxu。 我之前写过一篇文章：为什么 Go 标准库中有些函数只有签名，没有函数体？ ，其中有一点就是 //go:linkname 这个指令。 Go 中类似的指令挺多的，比如 Go1.16 中的 //go:embed。前些天有人问我，为什么它用 //go:embed 不起作用？我一看，它是这么写的：// go:embed，不知道你看到问题了没有？是的，指令是通过注释的方式，但有三点要求，要特别注意： // 后不能有空格。</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>我之前写过一篇文章：<a href="https://mp.weixin.qq.com/s/XPRj87YT3U6hJvyY11y8jA" target="_blank" rel="noopener">为什么 Go 标准库中有些函数只有签名，没有函数体？</a>
，其中有一点就是 <code>//go:linkname</code> 这个指令。</p>
<p>Go 中类似的指令挺多的，比如 Go1.16 中的 <code>//go:embed</code>。前些天有人问我，为什么它用 <code>//go:embed</code> 不起作用？我一看，它是这么写的：<code>// go:embed</code>，不知道你看到问题了没有？是的，指令是通过注释的方式，但有三点要求，要特别注意：</p>
<ul>
<li><code>//</code> 后不能有空格。有些人可能习惯 <code>//</code> 后不加空格。但一般认为，<code>//</code> 后应该加一个空格。不过 go 指令却要求不能有空格，这是一个小“坑”，得注意。所以上面那位朋友就是加了空格，导致出问题。（程序并不会报错，只是没有得到自己想要的结果）</li>
<li>代码和指令之间不能有空行或其他注释。这一点应该还好，很多人不会用错吧；</li>
<li>一般来说，使用指令需要导入相应的包。比如 <code>//go:linkname</code> 指令要求导入 unsafe 包，一般会 <code>import _ &quot;unsafe”</code>，<code>//go:embed</code> 指令，要求导入 embed 包。</li>
</ul>
<p>有另外一位 Go 朋友「橘中秘士」微信私聊我：</p>
<blockquote>
<p>大佬好，能不能写一篇 linkname 的文章。目前已经有了一些初步概念，但是尚有一些疑团不是特别清晰。</p>
<p>//go:linkname localname remotename，其中 local 作为占位符 remote 作为实现者或者 local 作为实现者 remote 作为占位符都是可以的。目前理解的就是给 Symbol 添加了一个 Linkname，查找 Symbo l的时候用 remote。</p>
<p>譬如 //go:linkname runtimeNano runtime.nanotime，runtimeNano 作为占位符 runtime.nanotime 提供实现，任何调用 runtimeNano 的地方实际替换为对 runtime.nanotime 的调用，这种场景比较容易接受。</p>
<p>譬如 //go:linkname runtime_cmpstring runtime.cmpstring，runtime_cmpstring 提供实现 runtime.cmpstring作为占位符，是不是这时符号表里不存在 runtime_cmpstring 只有 runtime.cmpstring？</p>
</blockquote>
<p>经过简单沟通，他写了一篇文章解决自己的困惑。希望对各位有帮助。以下是他写的关于 <code>//go:linkname</code> 的文章（我做了一些调整）。</p>
<hr>
<h2 id="01-格式">01 格式</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:linkname local remote
</span></code></pre></div><p>remote 可以没有，此时 remote 使用 local 的值，效果就是 local 被导出。</p>
<h2 id="02-local-和-remote-同时为函数">02 local 和 remote 同时为函数</h2>
<h3 id="local-作为占位符remote-作为实现者">local 作为占位符，remote 作为实现者</h3>
<p>标准库中的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 来自 time 包
</span><span class="c1">//go:linkname runtimeNano runtime.nanotime
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtimeNano</span><span class="p">()</span> <span class="kt">int64</span>

<span class="c1">// 来自 runtime 包
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">nanotime</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">nanotime1</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>此时二进制文件中并没有<code>runtimeNano</code>，直接转化为对<code>runtime.nanotime</code>的调用。</p>
<h3 id="local-作为实现者remote-作为占位符">local 作为实现者，remote 作为占位符</h3>
<p>同样来自标准库。这里存在函数没有函数体，但是被反向引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在标准库的一个 internal 中
</span><span class="c1">//go:linkname runtime_cmpstring runtime.cmpstring
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_cmpstring</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">l</span> <span class="p">{</span>
		<span class="nx">l</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">c1</span> <span class="p">&lt;</span> <span class="nx">c2</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">c1</span> <span class="p">&gt;</span> <span class="nx">c2</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">+</span><span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">+</span><span class="mi">1</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// 来自 runtime
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">cmpstring</span><span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span>
</code></pre></div><p>此时二进制文件中并没有<code>runtime_cmpstring</code>，对应的函数已经被命名为<code>runtime.cmpstring</code>。也就是说，实现在 internal 包，但最终通过 runtime.cmpstring 来引用。</p>
<h3 id="一个占位符一个汇编函数">一个占位符+一个汇编函数</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 在标准库的一个 internal 中
</span><span class="c1">//go:linkname abigen_runtime_memequal runtime.memequal
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">abigen_runtime_memequal</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></div><p>注意<code>runtime.memequal</code>的实现并不在<code>runtime</code>包中，使用汇编实现的话并不要求必须在相应的包中。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="c"># memequal(a, b unsafe.Pointer, size uintptr) bool
</span><span class="c"></span><span class="nf">TEXT</span> <span class="no">runtime</span><span class="err">·</span><span class="no">memequal</span><span class="p">(</span><span class="no">SB</span><span class="p">),</span><span class="no">NOSPLIT</span><span class="p">,</span><span class="no">$0-25</span>
	<span class="nf">MOVQ</span>	<span class="no">a</span><span class="err">+</span><span class="mi">0</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">SI</span>
	<span class="nf">MOVQ</span>	<span class="no">b</span><span class="err">+</span><span class="mi">8</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">DI</span>
	<span class="nf">CMPQ</span>	<span class="no">SI</span><span class="p">,</span> <span class="no">DI</span>
	<span class="nf">JEQ</span>	<span class="no">eq</span>
	<span class="nf">MOVQ</span>	<span class="no">size</span><span class="err">+</span><span class="mi">16</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">BX</span>
	<span class="nf">LEAQ</span>	<span class="no">ret</span><span class="err">+</span><span class="mi">24</span><span class="p">(</span><span class="no">FP</span><span class="p">),</span> <span class="no">AX</span>
	<span class="nf">JMP</span>	<span class="no">memeqbody</span><span class="err">&lt;&gt;</span><span class="p">(</span><span class="no">SB</span><span class="p">)</span>
<span class="nl">eq:</span>
	<span class="nf">MOVB</span>	<span class="no">$1</span><span class="p">,</span> <span class="no">ret</span><span class="err">+</span><span class="mi">24</span><span class="p">(</span><span class="no">FP</span><span class="p">)</span>
	<span class="nf">RET</span>
</code></pre></div><h2 id="03-local-和-remote-同时为变量">03 local 和 remote 同时为变量</h2>
<h3 id="两个常规变量">两个常规变量</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:linkname overflowError runtime.overflowError
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">overflowError</span> <span class="kt">error</span>

<span class="c1">//go:linkname divideError runtime.divideError
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">divideError</span> <span class="kt">error</span>

<span class="c1">//go:linkname zeroVal runtime.zeroVal
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">zeroVal</span> <span class="p">[</span><span class="nx">maxZero</span><span class="p">]</span><span class="kt">byte</span>

<span class="c1">//go:linkname _iscgo runtime.iscgo
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">_iscgo</span> <span class="kt">bool</span> <span class="p">=</span> <span class="kc">true</span>

<span class="c1">//go:cgo_import_static x_cgo_setenv
</span><span class="c1">//go:linkname x_cgo_setenv x_cgo_setenv
</span><span class="c1">//go:linkname _cgo_setenv runtime._cgo_setenv
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">x_cgo_setenv</span> <span class="kt">byte</span>
<span class="kd">var</span> <span class="nx">_cgo_setenv</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x_cgo_setenv</span>

<span class="c1">//go:cgo_import_static x_cgo_unsetenv
</span><span class="c1">//go:linkname x_cgo_unsetenv x_cgo_unsetenv
</span><span class="c1">//go:linkname _cgo_unsetenv runtime._cgo_unsetenv
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">x_cgo_unsetenv</span> <span class="kt">byte</span>
<span class="kd">var</span> <span class="nx">_cgo_unsetenv</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">x_cgo_unsetenv</span>
</code></pre></div><h3 id="一个占位符一个伪符号">一个占位符+一个伪符号</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:linkname runtime_inittask runtime..inittask
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">runtime_inittask</span> <span class="nx">initTask</span>

<span class="c1">//go:linkname main_inittask main..inittask
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">main_inittask</span> <span class="nx">initTask</span>
</code></pre></div><p>注意是<code>..inittask</code>不是<code>.inittask</code>，而且<code>.inittask</code>只存在于编译阶段，任何包中都无法声明该变量。</p>
<blockquote>
<p>这里额外解释下 ..inittask 为什么两个点。第一个点就是普通的 runtime. 这种调用方式，第二个点和 inittask 一起构成一个符号（变量）。注意，Go 中的变量是不允许以 . 开头的，所以，这个叫伪符号，只在不编译阶段存在。</p>
</blockquote>
<h2 id="04-一个例子">04 一个例子</h2>
<p>研究 <code>//go:linkname</code> 是因为如下的背景：</p>
<blockquote>
<p>Java 里有 InheritableThreadLocal，SpringWeb 在 ServletActionContext 里使用它，达到在任何地方都能方便的获取HttpServletRequest。</p>
<p>Go 并没有提供类似的机制，即使通过 stack 找到 goroutine id（99% 的文章都是这么介绍的），再配合 sync.Map，也只是实现了一个比较粗糙的 ThreadLocal，在子协程里仍然获取不到父协程的内容。</p>
<p>g.label 虽然不是给这种场景准备的，但它具备了 InheritableThreadLocal 的一切要求，只要我们能够访问到 label 私有字段，我们就有了完整版的 InheritableThreadLocal。</p>
</blockquote>
<p>下面这个例子是作者真实项目中用的。</p>
<p>在 runtime 和 runtime/pprof 包中有两个函数：runtime_setProfLabel 和  runtime_getProfLabel。其中，runtime 包中的提供了实现，而 pprof 中的没有提供实现。如果基于它们创建另外的函数，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:linkname SetPointer runtime/pprof.runtime_setProfLabel
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">SetPointer</span><span class="p">(</span><span class="nx">ptr</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span>

<span class="c1">//go:linkname GetPointer runtime/pprof.runtime_getProfLabel
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetPointer</span><span class="p">()</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</code></pre></div><p>根据前面的分析，虽然<code>runtime.runtime_setProfLabel</code>/<code>runtime.runtime_getProfLabel</code>提供了函数实现，但是二进制文件中并不会出现（见下方代码），此时想要调用必须通过<code>runtime/pprof.runtime_setProfLabel</code>/<code>runtime/pprof.runtime_getProfLabel</code>，这也是上面<code>linkname</code>到<code>pprof</code>而不是<code>runtime</code>的根本原因。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 来自 runtime 包
</span><span class="c1">//go:linkname runtime_setProfLabel runtime/pprof.runtime_setProfLabel
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_setProfLabel</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nf">racereleasemerge</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">labelSync</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nf">getg</span><span class="p">().</span><span class="nx">labels</span> <span class="p">=</span> <span class="nx">labels</span>
<span class="p">}</span>

<span class="c1">// 来自 runtime/pprof 包
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_setProfLabel</span><span class="p">(</span><span class="nx">labels</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span>

<span class="c1">// 来自 runtime 包
</span><span class="c1">//go:linkname runtime_getProfLabel runtime/pprof.runtime_getProfLabel
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_getProfLabel</span><span class="p">()</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">labels</span>
<span class="p">}</span>

<span class="c1">// 来自 runtime/pprof 包
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">runtime_getProfLabel</span><span class="p">()</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</code></pre></div><h2 id="05-总结">05 总结</h2>
<p>Go 中有不少指令，有些指令你可能不太需要关心，也不会用到。然而有些指令了解它们的意思，对阅读相关代码很有帮助。</p>
<p>这篇文章全面介绍了 <code>//go:linkname</code> 指令，不知道是否彻底解除了你的疑惑？欢迎留言交流！</p>
]]></content>
		</item>
		
		<item>
			<title>这个功能，公众号、微信群会不会被玩坏？</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/2021-04-wechat-changes/</link>
			<pubDate>Wed, 14 Apr 2021 18:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/2021-04-wechat-changes/</guid>
			<description>大家好，我是站长 polarisxu。 微信生态近期又有一些不错的变更，体验上有较大改进，我把看到的一些列举下。 01 公众号留言支持盖楼 什么意思？最开始，微信公众号的留言，作者回复后，留言者没法接着原来的留言盖楼，必须另起一个留言，前段时间做了改进。不过还存在这样一个问题：比如一楼问了一个问题，其他读者想回复他，没法直接回复，经常见到这样的：回复一楼。然而，微信留言</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>微信生态近期又有一些不错的变更，体验上有较大改进，我把看到的一些列举下。</p>
<h2 id="01-公众号留言支持盖楼">01 公众号留言支持盖楼</h2>
<p>什么意思？最开始，微信公众号的留言，作者回复后，留言者没法接着原来的留言盖楼，必须另起一个留言，前段时间做了改进。不过还存在这样一个问题：比如一楼问了一个问题，其他读者想回复他，没法直接回复，经常见到这样的：回复一楼。然而，微信留言目前的排序是按点赞数，按时间排序，一楼有可能不是一楼了，而且别的读者回复了，留言者也不会有提醒。</p>
<p>现在公众号在灰度测试完全盖楼功能，解决上面说到的问题，体验会更好。</p>
<p>这有种网易评论的感觉，相信公众号留言会更火。不过，任何留言都需要作者精选才能放出来，这也是安全性考虑。</p>
<p>目前我的号还不支持盖楼，支持盖楼是这样子的（点开后）：</p>
<p><p class="md__image">
  <img src="../imgs/wechat-200414-01.png"
    alt=""  />
</p>
</p>
<h2 id="02-公众号二维码转卡片">02 公众号二维码转卡片</h2>
<p>前段时间，公众号提供了一个插入公众号卡片的功能，不过卡片是不能复制的，而二维码方便复制。现在公众号编辑后台提供了一个功能，鼠标停留在公众号二维码上，会出现「转为公众号卡片」的字样，点击就可以转为公众号卡片，很贴心的小功能。</p>
<h2 id="03-新好友打标签更方便">03 新好友打标签更方便</h2>
<p>对于每天要处理较多微信好友请求的人来说，这个改进减少了好几步操作。一般地，为了方便管理为微信好友，会为好友打上标签，毕竟微信不像 QQ，支持好友分组。之前，通过一个好友请求，需要额外点击几步才能设置上标签，现在在好友通过页面直接放上了标签，可以一次性搞定。</p>
<h2 id="04-群更方便--所有人">04 群更方便 @ 所有人</h2>
<p>QQ 群 @ 所有人特别方便，但微信群一直很弱，群主想要 @ 所有人，必须通过群公告的形式发布。不过，现在可以直接 @ 所有人了。当然，这个功能比较打扰，建议一般别用，毕竟群主要用于交流，频繁打扰大家不合适。别被群主玩坏了。</p>
<p>输入 @ 会出现下面的对话框，可以选择所有人：</p>
<p><p class="md__image">
  <img src="../imgs/wechat-200414-02.png"
    alt=""  />
</p>
</p>
<p>此外还有一个比较有意思的改动，如果你的很好友同时也是你的手机通讯录好友，昵称（或备注名称）和通讯录里的不一致，在转发信息等给他时，名称后会有括号，里面是通讯录中的名称。通过这种方式可以快速的知道，某个好友是不是你手机通讯录好友。（在微信「通讯录」Tab 也是这种方式显示的）</p>
<p>另外，「我的」状态按钮改动多次后，终于好看些了。现在状态旁边加了三个点，可以查看哪些好友有状态，因为状态发布后几天会自动消失。</p>
<hr>
<p>最后介绍两个腾讯开发的微信小程序，也许用得到。</p>
<h2 id="05-腾讯电子签">05 腾讯电子签</h2>
<p>「腾讯电子签」目前包含两个功能：开收据和签合同。</p>
<p>之前都需要纸质，现在通过这个小程序可以线上处理。这也是腾讯在区块链上的应用，支付宝可能早就有类似的功能了。</p>
<p>按官方介绍，这个是有法律效力的，一方面，要求双方实名认证，有纠纷，可以找到人；另一方面，所有关键信息都上区块链。</p>
<p>这里有官方的介绍：<a href="https://mp.weixin.qq.com/s/nrFxj2kEtDOwaPmGgWW0JQ" target="_blank" rel="noopener">手写收据太麻烦，下回用微信开！</a>
</p>
<p>试用小程序：</p>
<p><p class="md__image">
  <img src="../imgs/wechat-200414-03.png"
    alt=""  />
</p>
</p>
<h2 id="06-微小号">06 微小号</h2>
<p>有些人可能听过阿里小号，我办理过一个，但目前阿里小号已经无法再购买了。</p>
<p>小号有什么用呢？我想不用过多介绍。</p>
<p>腾讯最近发布了一个「微小号」微信小程序，一人可以购买两个小号。不过一个号 10 元/月，而且目前只支持联通。相比较来说，阿里小号，不优惠一年才 40 元，优惠才 20 元/年。相比来说，微小号真心贵。如果你真有小号的需求，可以问问你的运营商可不可以办理副卡，可能会比这便宜。</p>
<hr>
<p>微信功能的更新，经常隐藏的很深，除了本文介绍的，你还发现了哪些有意思的更新？！</p>
]]></content>
		</item>
		
		<item>
			<title>一道 Go 闭包题，面试官说原来自己答错了：面别人也涨知识</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/go-closure/</link>
			<pubDate>Tue, 13 Apr 2021 18:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/go-closure/</guid>
			<description>大家好，我是站长 polarisxu。 通常，JS 面试，闭包应该是必考的题目。随着越来越多的语言对函数式范式的支持，闭包问题经常出现。在 Go 语言中也是如此。 本文从一道题引出 Go 中的闭包。这是 Go 语言爱好者周刊第 90 期的一道题目。以下代码输出什么？ package main import &amp;#34;fmt&amp;#34; func app() func(string) string { t := &amp;#34;Hi&amp;#34; c := func(b string) string { t = t + &amp;#34; &amp;#34; + b return t } return c } func main() { a := app() b := app() a(&amp;#34;go&amp;#34;) fmt.Println(b(&amp;#34;All&amp;#34;)) } 这道题目答对的人蛮多的：60%。不管你</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>通常，JS 面试，闭包应该是必考的题目。随着越来越多的语言对函数式范式的支持，闭包问题经常出现。在 Go 语言中也是如此。</p>
<p>本文从一道题引出 Go 中的闭包。这是 Go 语言爱好者周刊第 90 期的一道题目。以下代码输出什么？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">app</span><span class="p">()</span> <span class="kd">func</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="s">&#34;Hi&#34;</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">b</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
		<span class="nx">t</span> <span class="p">=</span> <span class="nx">t</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="nx">b</span>
		<span class="k">return</span> <span class="nx">t</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nf">app</span><span class="p">()</span>
	<span class="nx">b</span> <span class="o">:=</span> <span class="nf">app</span><span class="p">()</span>
	<span class="nf">a</span><span class="p">(</span><span class="s">&#34;go&#34;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">b</span><span class="p">(</span><span class="s">&#34;All&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>这道题目答对的人蛮多的：60%。不管你是答对还是答错，如果最后再加一行代码：<code>fmt.Println(a(&quot;All&quot;))</code>，它输出什么？想看看你是不是蒙对了。（提示：你可以输出 t 的地址，看看是什么情况。）</p>
<h2 id="01-什么是闭包">01 什么是闭包</h2>
<p>维基百科对<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29" target="_blank" rel="noopener">闭包的定义</a>
：</p>
<blockquote>
<p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持头等函数的编程语言中实现词法绑定的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。捕捉时对于值的处理可以是值拷贝，也可以是名称引用，这通常由语言设计者决定，也可能由用户自行指定（如 C++）。</p>
</blockquote>
<p>关于（函数）闭包，有几个关键点：</p>
<ul>
<li>函数是一等公民；</li>
<li>闭包所处环境，可以引用环境里的值；</li>
</ul>
<p>问到什么是闭包时，网上一般这么回答的：</p>
<blockquote>
<p>在支持函数是一等公民的语言中，一个函数的返回值是另一个函数，被返回的函数可以访问父函数内的变量，当这个被返回的函数在外部执行时，就产生了闭包。</p>
</blockquote>
<p>所以，上面题目中，函数 app 的返回值是另一个函数，因此产生了闭包。</p>
<h2 id="02-go-中的闭包">02 Go 中的闭包</h2>
<p>Go 中的函数是一等公民，之前写过一篇文章：<a href="https://mp.weixin.qq.com/s/H3iuhkvQWonZbi7AzmokSA" target="_blank" rel="noopener">函数是一等公民，这到底在说什么？</a>
</p>
<p>日常开发中，闭包是很常见的。举几个例子。</p>
<h3 id="标准库">标准库</h3>
<p>在 net/http 包中的函数 ProxyURL，实现如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ProxyURL returns a proxy function (for use in a Transport)
</span><span class="c1">// that always returns the same URL.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ProxyURL</span><span class="p">(</span><span class="nx">fixedURL</span> <span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fixedURL</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>它的返回值是另一个函数，签名是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">url</span><span class="p">.</span><span class="nx">URL</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>在返回的函数中，引用了父函数（ProxyURL）的参数 fixedURL，因此这是闭包。</p>
<h3 id="web-中间件">Web 中间件</h3>
<p>在 Web 开发中，中间件一般都会使用闭包。比如 Echo 框架中的一个中间件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// BasicAuthWithConfig returns an BasicAuth middleware with config.
</span><span class="c1">// See `BasicAuth()`.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">BasicAuthWithConfig</span><span class="p">(</span><span class="nx">config</span> <span class="nx">BasicAuthConfig</span><span class="p">)</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">MiddlewareFunc</span> <span class="p">{</span>
	<span class="c1">// Defaults
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">config</span><span class="p">.</span><span class="nx">Validator</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;echo: basic-auth middleware requires a validator function&#34;</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="o">...</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">next</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="c1">/// 省略很多代码
</span><span class="c1"></span>      <span class="o">...</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>首先，echo.MiddlewareFunc 是一个函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MiddlewareFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">HandlerFunc</span>
</code></pre></div><p>而 echo.HandlerFunc 也是一个函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></div><p>所以，上面的函数嵌套了几层，是典型的闭包。</p>
<h3 id="这是闭包吗">这是闭包吗？</h3>
<p>在 Go 中不支持函数嵌套定义，函数内嵌套函数，必须通过匿名函数的形式。匿名函数在 Go 中是很常见的，比如开启一个 goroutine，通常通过匿名函数。</p>
<p>现在有一个问题，以下代码是闭包吗？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>  
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="nx">a</span> <span class="o">:=</span> <span class="mi">5</span>
    <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;a =&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
    <span class="p">}()</span>
<span class="p">}</span>
</code></pre></div><p>如果按照上面网上一般的回答，这不是闭包，因为并没有返回函数。但按照维基百科的定义，这个属于闭包。有没有其他证据呢？</p>
<p>在 Go 语言规范中，关于函数字面值（匿名函数）有这么一句话：</p>
<blockquote>
<p>Function literals are <em>closures</em>: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.</p>
</blockquote>
<p>也就是说，函数字面值（匿名函数）是闭包，它们可以引用外层函数定义的变量。</p>
<p>此外，在官方 FAQ 中有这样的说明：</p>
<p><a href="https://docs.studygolang.com/doc/faq#closures_and_goroutines" target="_blank" rel="noopener">What happens with closures running as goroutines?</a>
</p>
<p>例子是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>

    <span class="nx">values</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
            <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kc">true</span>
        <span class="p">}()</span>
    <span class="p">}</span>

    <span class="c1">// wait for all goroutines to complete before exiting
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span> <span class="p">=</span> <span class="k">range</span> <span class="nx">values</span> <span class="p">{</span>
        <span class="o">&lt;-</span><span class="nx">done</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这是 Go 中很常见的代码（很容易写错的），FAQ 称开启 goroutine 的那个匿名函数是一个闭包。</p>
<h2 id="03-汇编看看实现">03 汇编看看实现</h2>
<p>回到开始的题目，我们通过汇编看看，Go 闭包的实现，是不是按照维基百科说的，「闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）」。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go tool compile -S main.go
</code></pre></div><p>看关键代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">TEXT</span>	<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nf">app</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">ABIInternal</span><span class="p">,</span> <span class="err">$</span><span class="mi">24</span><span class="o">-</span><span class="mi">8</span>
<span class="mh">0x0000</span> <span class="mo">00000</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nf">MOVQ</span>	<span class="p">(</span><span class="nx">TLS</span><span class="p">),</span> <span class="nx">CX</span>
<span class="mh">0x0009</span> <span class="mo">0000</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">CMPQ</span>	<span class="nx">SP</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
<span class="mh">0x000d</span> <span class="mo">00013</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">PCDATA</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="o">-</span><span class="mi">2</span>
<span class="mh">0x000d</span> <span class="mo">00013</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">JLS</span>	<span class="mi">96</span>
<span class="mh">0x000f</span> <span class="mo">00015</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">PCDATA</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="err">$</span><span class="o">-</span><span class="mi">1</span>
<span class="mh">0x000f</span> <span class="mo">00015</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">SUBQ</span>	<span class="err">$</span><span class="mi">24</span><span class="p">,</span> <span class="nx">SP</span>
<span class="mh">0x0013</span> <span class="mo">0001</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="nx">BP</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
<span class="mh">0x0018</span> <span class="mo">00024</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">LEAQ</span>	<span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>
<span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">FUNCDATA</span>	<span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">2</span><span class="nf">a5305abe05176240e61b8620e19a815</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
<span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">5</span><span class="p">)</span>	<span class="nx">FUNCDATA</span>	<span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="nx">gclocals</span><span class="err">·</span><span class="mi">33</span><span class="nf">cdeccccebe80329f1fdbee7f5874cb</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
<span class="mh">0x001d</span> <span class="mo">0002</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nx">LEAQ</span>	<span class="kd">type</span><span class="p">.</span><span class="nx">noalg</span><span class="p">.</span><span class="kd">struct</span> <span class="p">{</span> <span class="nx">F</span> <span class="kt">uintptr</span><span class="p">;</span> <span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">t</span> <span class="kt">string</span> <span class="p">}(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
<span class="mh">0x0024</span> <span class="mo">00036</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
<span class="mh">0x0028</span> <span class="mo">00040</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nx">PCDATA</span>	<span class="err">$</span><span class="mi">1</span><span class="p">,</span> <span class="err">$</span><span class="mi">0</span>
<span class="mh">0x0028</span> <span class="mo">00040</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="p">.</span><span class="nf">newobject</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
<span class="mh">0x002d</span> <span class="mo">00045</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>
<span class="mh">0x0032</span> <span class="mo">00050</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nx">LEAQ</span>	<span class="s">&#34;&#34;</span><span class="p">.</span><span class="nx">app</span><span class="p">.</span><span class="nf">func1</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">CX</span>
<span class="mh">0x0039</span> <span class="mo">00057</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="nx">CX</span><span class="p">,</span> <span class="p">(</span><span class="nx">AX</span><span class="p">)</span>
<span class="mh">0x003c</span> <span class="mo">00060</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span><span class="p">(</span><span class="nx">AX</span><span class="p">)</span>
<span class="mh">0x0044</span> <span class="mo">0006</span><span class="mi">8</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nx">LEAQ</span>	<span class="k">go</span><span class="p">.</span><span class="kt">string</span><span class="p">.</span><span class="s">&#34;Hi&#34;</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">CX</span>
<span class="mh">0x004b</span> <span class="mo">00075</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">7</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="nx">CX</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">AX</span><span class="p">)</span>
<span class="mh">0x004f</span> <span class="mo">0007</span><span class="mi">9</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">.</span><span class="err">~</span><span class="nx">r0</span><span class="o">+</span><span class="mi">32</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
<span class="mh">0x0054</span> <span class="mo">000</span><span class="mi">84</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>	<span class="nx">MOVQ</span>	<span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BP</span>
<span class="mh">0x0059</span> <span class="mo">000</span><span class="mi">89</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>	<span class="nx">ADDQ</span>	<span class="err">$</span><span class="mi">24</span><span class="p">,</span> <span class="nx">SP</span>
<span class="mh">0x005d</span> <span class="mo">000</span><span class="mi">93</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>	<span class="nx">RET</span>
<span class="mh">0x005e</span> <span class="mo">000</span><span class="mi">94</span> <span class="p">(</span><span class="nx">main</span><span class="p">.</span><span class="k">go</span><span class="p">:</span><span class="mi">10</span><span class="p">)</span>	<span class="nx">NOP</span>
</code></pre></div><p>其中 <code>LEAQ	type.noalg.struct { F uintptr; &quot;&quot;.t string }(SB), AX</code> 这行表明 Go 对闭包的实现和维基百科说的类似。</p>
<p>现在看看下面这种是不是这么实现的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>  
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>  
    <span class="nx">a</span> <span class="o">:=</span> <span class="mi">5</span>
    <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;a =&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
    <span class="p">}()</span>
<span class="p">}</span>
</code></pre></div><p>看看汇编</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go tool compile -S test.go
<span class="s2">&#34;&#34;</span>.main.func1 STEXT <span class="nv">size</span><span class="o">=</span><span class="m">215</span> <span class="nv">args</span><span class="o">=</span>0x8 <span class="nv">locals</span><span class="o">=</span>0x50 <span class="nv">funcid</span><span class="o">=</span>0x0
  0x0000 <span class="m">00000</span> <span class="o">(</span>test.go:9<span class="o">)</span>	TEXT	<span class="s2">&#34;&#34;</span>.main.func1<span class="o">(</span>SB<span class="o">)</span>, ABIInternal, <span class="nv">$80</span>-8
  0x0000 <span class="m">00000</span> <span class="o">(</span>test.go:9<span class="o">)</span>	MOVQ	<span class="o">(</span>TLS<span class="o">)</span>, CX
  0x0009 <span class="m">00009</span> <span class="o">(</span>test.go:9<span class="o">)</span>	CMPQ	SP, 16<span class="o">(</span>CX<span class="o">)</span>
  0x000d <span class="m">00013</span> <span class="o">(</span>test.go:9<span class="o">)</span>	PCDATA	<span class="nv">$0</span>, <span class="nv">$-</span><span class="m">2</span>
  0x000d <span class="m">00013</span> <span class="o">(</span>test.go:9<span class="o">)</span>	JLS	<span class="m">205</span>
  0x0013 <span class="m">00019</span> <span class="o">(</span>test.go:9<span class="o">)</span>	PCDATA	<span class="nv">$0</span>, <span class="nv">$-</span><span class="m">1</span>
  0x0013 <span class="m">00019</span> <span class="o">(</span>test.go:9<span class="o">)</span>	SUBQ	<span class="nv">$80</span>, SP
  0x0017 <span class="m">00023</span> <span class="o">(</span>test.go:9<span class="o">)</span>	MOVQ	BP, 72<span class="o">(</span>SP<span class="o">)</span>
  0x001c <span class="m">00028</span> <span class="o">(</span>test.go:9<span class="o">)</span>	LEAQ	72<span class="o">(</span>SP<span class="o">)</span>, BP
  0x0021 <span class="m">00033</span> <span class="o">(</span>test.go:9<span class="o">)</span>	FUNCDATA	<span class="nv">$0</span>, gclocals·69c1753bd5f81501d95132d08af04464<span class="o">(</span>SB<span class="o">)</span>
  0x0021 <span class="m">00033</span> <span class="o">(</span>test.go:9<span class="o">)</span>	FUNCDATA	<span class="nv">$1</span>, gclocals·9fb7f0986f647f17cb53dda1484e0f7a<span class="o">(</span>SB<span class="o">)</span>
  0x0021 <span class="m">00033</span> <span class="o">(</span>test.go:10<span class="o">)</span>	MOVQ	<span class="s2">&#34;&#34;</span>.a+88<span class="o">(</span>SP<span class="o">)</span>, AX
  0x0026 <span class="m">00038</span> <span class="o">(</span>test.go:10<span class="o">)</span>	MOVQ	AX, <span class="o">(</span>SP<span class="o">)</span>
  0x002a <span class="m">00042</span> <span class="o">(</span>test.go:10<span class="o">)</span>	PCDATA	<span class="nv">$1</span>, <span class="nv">$0</span>
  0x002a <span class="m">00042</span> <span class="o">(</span>test.go:10<span class="o">)</span>	CALL	runtime.convT64<span class="o">(</span>SB<span class="o">)</span>
  0x002f <span class="m">00047</span> <span class="o">(</span>test.go:10<span class="o">)</span>	MOVQ	8<span class="o">(</span>SP<span class="o">)</span>, AX
  0x0034 <span class="m">00052</span> <span class="o">(</span>test.go:10<span class="o">)</span>	MOVQ	AX, <span class="s2">&#34;&#34;</span>..autotmp_21+64<span class="o">(</span>SP<span class="o">)</span>
  0x0039 <span class="m">00057</span> <span class="o">(</span>test.go:10<span class="o">)</span>	LEAQ	type.<span class="o">[</span>2<span class="o">]</span>interface <span class="o">{}(</span>SB<span class="o">)</span>, CX
  0x0040 <span class="m">00064</span> <span class="o">(</span>test.go:10<span class="o">)</span>	MOVQ	CX, <span class="o">(</span>SP<span class="o">)</span>
  0x0044 <span class="m">00068</span> <span class="o">(</span>test.go:10<span class="o">)</span>	PCDATA	<span class="nv">$1</span>, <span class="nv">$1</span>
  0x0044 <span class="m">00068</span> <span class="o">(</span>test.go:10<span class="o">)</span>	CALL	runtime.newobject<span class="o">(</span>SB<span class="o">)</span>
  0x0049 <span class="m">00073</span> <span class="o">(</span>test.go:10<span class="o">)</span>	MOVQ	8<span class="o">(</span>SP<span class="o">)</span>, AX
  0x004e <span class="m">00078</span> <span class="o">(</span>test.go:10<span class="o">)</span>	LEAQ	type.string<span class="o">(</span>SB<span class="o">)</span>, CX
  0x0055 <span class="m">00085</span> <span class="o">(</span>test.go:10<span class="o">)</span>	MOVQ	CX, <span class="o">(</span>AX<span class="o">)</span>
  0x0058 <span class="m">00088</span> <span class="o">(</span>test.go:10<span class="o">)</span>	LEAQ	<span class="s2">&#34;&#34;</span>..stmp_1<span class="o">(</span>SB<span class="o">)</span>, CX
  0x005f <span class="m">00095</span> <span class="o">(</span>test.go:10<span class="o">)</span>	MOVQ	CX, 8<span class="o">(</span>AX<span class="o">)</span>
  0x0063 <span class="m">00099</span> <span class="o">(</span>test.go:10<span class="o">)</span>	LEAQ	type.int<span class="o">(</span>SB<span class="o">)</span>, CX
  0x006a <span class="m">00106</span> <span class="o">(</span>test.go:10<span class="o">)</span>	MOVQ	CX, 16<span class="o">(</span>AX<span class="o">)</span>
  0x006e <span class="m">00110</span> <span class="o">(</span>test.go:10<span class="o">)</span>	PCDATA	<span class="nv">$0</span>, <span class="nv">$-</span><span class="m">2</span>
  0x006e <span class="m">00110</span> <span class="o">(</span>test.go:10<span class="o">)</span>	CMPL	runtime.writeBarrier<span class="o">(</span>SB<span class="o">)</span>, <span class="nv">$0</span>
  0x0075 <span class="m">00117</span> <span class="o">(</span>test.go:10<span class="o">)</span>	JNE	<span class="m">189</span>
  0x0077 <span class="m">00119</span> <span class="o">(</span>test.go:10<span class="o">)</span>	MOVQ	<span class="s2">&#34;&#34;</span>..autotmp_21+64<span class="o">(</span>SP<span class="o">)</span>, CX
  0x007c <span class="m">00124</span> <span class="o">(</span>test.go:10<span class="o">)</span>	MOVQ	CX, 24<span class="o">(</span>AX<span class="o">)</span>
  0x0080 <span class="m">00128</span> <span class="o">(</span>test.go:10<span class="o">)</span>	PCDATA	<span class="nv">$0</span>, <span class="nv">$-</span><span class="m">1</span>
  0x0080 <span class="m">00128</span> <span class="o">(</span>test.go:10<span class="o">)</span>	PCDATA	<span class="nv">$1</span>, <span class="nv">$-</span><span class="m">1</span>
</code></pre></div><p>发现并没有这样的结构体，可见 Go 对这种情况做了特殊处理，因为它不是重复使用的匿名函数。</p>
<h2 id="04-总结">04 总结</h2>
<p>通过以上的讲解，对闭包应该有了更清晰的认识。如果面试中再被问到闭包，你可以这么回答：</p>
<blockquote>
<p>对闭包来说，函数在该语言中得是一等公民。一般来说，一个函数返回另外一个函数，这个被返回的函数可以引用外层函数的局部变量，这形成了一个闭包。通常，闭包通过一个结构体来实现，它存储一个函数和一个关联的上下文环境。但 Go 语言中，匿名函数就是一个闭包，它可以直接引用外部函数的局部变量，因为 Go 规范和 FAQ 都这么说了。</p>
</blockquote>
<p>面试官会不会被你惊到：原来如此，后一种说法我之前没有注意过。</p>
<blockquote>
<p>4 月 14 日更新：</p>
<p>来自<a href="https://mp.weixin.qq.com/s/gfyW0pBIHsf2oYluQNbP8A" target="_blank" rel="noopener">微信公众号</a>
的读者 **gopher **留言：</p>
<p>noalg 代表不会生成 equal 和 hash 函数，因为闭包的 struct 是匿名的，不存在比较或者作为 key 的场景。
F uintptr 更准确的说应该是 .F uintptr，编译器生成的符号大部分都是.开头的。
&ldquo;&quot;.t string 表示捕获了一个 string 类型的变量 t，而且是 by value 而不是 by reference，因为&quot;We use value capturing for values &lt;= 128 bytes that are never reassigned after capturing (effectively constant).&quot;。
通过 (func)(*struct) 的类型转换，即可通过 .F 找到对应的函数。
题外话：closure 通过 struct 实现只是为了 GC 更友好，另外匿名 struct 是为了不同的 package 共用 struct 的可能性。</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Rust 劝退系列 02：第一个 Rust 程序</title>
			<link>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-02/</link>
			<pubDate>Sun, 11 Apr 2021 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-02/</guid>
			<description>大家好，我是站长 polarisxu。 上节我们准备好了 Rust 环境，现在开始我们的第一个 Rust 程序。 01 Hello World 在终端执行如下命令，创建相关目录结构： $ mkdir ~/rust-learning $ cd ~/rust-learning $ mkdir hello $ cd hello 启动 VSCode，在 Welcome 页面选择打开文件夹：~/rust-learning，在 hello 目录下创建 main.rs 文件，输入如下代码： 细心的读者可能看到了 fn 下面的三个点，鼠标放上去提示： file not included in module tree rust-analyzer(unlinked-file) 这个提示的详细说明见链接：h</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>上节我们准备好了 Rust 环境，现在开始我们的第一个 Rust 程序。</p>
<h2 id="01-hello-world">01 Hello World</h2>
<p>在终端执行如下命令，创建相关目录结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ mkdir ~/rust-learning
$ <span class="nb">cd</span> ~/rust-learning
$ mkdir hello
$ <span class="nb">cd</span> hello
</code></pre></div><p>启动 VSCode，在 Welcome 页面选择打开文件夹：~/rust-learning，在 hello 目录下创建 main.rs 文件，输入如下代码：</p>
<p><p class="md__image">
  <img src="../imgs/tutorial02-01.png"
    alt=""  />
</p>
</p>
<p>细心的读者可能看到了 fn 下面的三个点，鼠标放上去提示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">file not included in module tree rust-analyzer<span class="o">(</span>unlinked-file<span class="o">)</span>
</code></pre></div><p>这个提示的详细说明见链接：<a href="https://rust-analyzer.github.io/manual.html#unlinked-file" target="_blank" rel="noopener">https://rust-analyzer.github.io/manual.html#unlinked-file</a>
。大意是，当前文件不在任何 crate 中。也就是说，rust-analyzer 插件要求标准的 cargo 目录。因此，编译运行该程序得通过终端：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ rustc main.rs
$ ./main
Hello World!
</code></pre></div><p>这就是你的第一个 Rust 程序。关于 rustc，目前我们只需要知道它是 Rust 的编译器即可，因为实际中很少直接使用它。</p>
<h2 id="02-cargo-版-hello-world">02 cargo 版 Hello World</h2>
<p>上文说，编译 Rust 项目，很少直接使用 rustc 这个 Rust 编译器，那应该用什么呢？</p>
<p>简单的程序（比如上面的单个文件）可能偶尔会用 rustc，但绝大部分时候，特别是项目中，我们应该一直使用 Rust 的生成工具和依赖管理器 Cargo。</p>
<p>现在就介绍下 Cargo 这个工具。</p>
<h3 id="cargo">Cargo</h3>
<p>在安装完 rustup 后，Rust 工具链会默认安装上，这包括 Cargo 这个工具。</p>
<p>因为这个工具很重要，官方直接提供了一个 Cargo 的手册：<a href="https://doc.rust-lang.org/cargo/index.html" target="_blank" rel="noopener">https://doc.rust-lang.org/cargo/index.html</a>
。</p>
<blockquote>
<p>Cargo 是 Rust 的包管理器。它能够下载 Rust 包的依赖，编译包，制作可分发的包，并将它们上传到 crates.io 上（这是 Rust 社区的包注册中心）。</p>
</blockquote>
<p>这个手册内容较多，有兴趣可以通读下，后续也可以用于查阅。我们这里只介绍经常使用的相关命令。先看一眼 Cargo 命令的相关帮助：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ cargo
Rust<span class="s1">&#39;s package manager
</span><span class="s1">
</span><span class="s1">USAGE:
</span><span class="s1">    cargo [+toolchain] [OPTIONS] [SUBCOMMAND]
</span><span class="s1">
</span><span class="s1">OPTIONS:
</span><span class="s1">    -V, --version           Print version info and exit
</span><span class="s1">        --list              List installed commands
</span><span class="s1">        --explain &lt;CODE&gt;    Run `rustc --explain CODE`
</span><span class="s1">    -v, --verbose           Use verbose output (-vv very verbose/build.rs output)
</span><span class="s1">    -q, --quiet             No output printed to stdout
</span><span class="s1">        --color &lt;WHEN&gt;      Coloring: auto, always, never
</span><span class="s1">        --frozen            Require Cargo.lock and cache are up to date
</span><span class="s1">        --locked            Require Cargo.lock is up to date
</span><span class="s1">        --offline           Run without accessing the network
</span><span class="s1">    -Z &lt;FLAG&gt;...            Unstable (nightly-only) flags to Cargo, see &#39;</span>cargo -Z help<span class="s1">&#39; for details
</span><span class="s1">    -h, --help              Prints help information
</span><span class="s1">
</span><span class="s1">Some common cargo commands are (see all commands with --list):
</span><span class="s1">    build, b    Compile the current package
</span><span class="s1">    check, c    Analyze the current package and report errors, but don&#39;</span>t build object files
    clean       Remove the target directory
    doc         Build this package<span class="s1">&#39;s and its dependencies&#39;</span> documentation
    new         Create a new cargo package
    init        Create a new cargo package in an existing directory
    run, r      Run a binary or example of the <span class="nb">local</span> package
    test, t     Run the tests
    bench       Run the benchmarks
    update      Update dependencies listed in Cargo.lock
    search      Search registry <span class="k">for</span> crates
    publish     Package and upload this package to the registry
    install     Install a Rust binary. Default location is <span class="nv">$HOME</span>/.cargo/bin
    uninstall   Uninstall a Rust binary

See <span class="s1">&#39;cargo help &lt;command&gt;&#39;</span> <span class="k">for</span> more information on a specific command.
</code></pre></div><p>常用的命令如下：</p>
<ul>
<li>使用 <code>cargo new</code> 创建新的 package（包），包括可执行的和普通包。</li>
<li>使用 <code>cargo build</code> 构建你的包。</li>
<li>使用 <code>cargo run</code> 生成和运行包。</li>
<li>使用 <code>cargo test</code> 测试你的包。</li>
<li>使用 <code>cargo check</code> 进行包分析，并报告错误。</li>
<li>使用 <code>cargo doc</code> 为你的包（以及依赖包）生成文档。</li>
<li>使用 <code>cargo publish</code> 将包发布到 crates.io。</li>
<li>使用 <code>cargo install</code> 安装 Rust 可执行程序。</li>
</ul>
<p>借助 VSCode，很多命令不需要我们手动输入执行。</p>
<p>注：帮助说明中，都是 package，你可以理解成项目，下文有时会用项目的说法。</p>
<h3 id="cargo-使用">Cargo 使用</h3>
<p>使用 Cargo 创建一个新项目：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/rust-learning
$ cargo new hello-cargo
     Created binary <span class="o">(</span>application<span class="o">)</span> <span class="sb">`</span>hello-cargo<span class="sb">`</span> package
</code></pre></div><p>生成了 hello-cargo 目录，其中包含如下文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ tree hello-cargo
hello-cargo
├── Cargo.toml
└── src
    └── main.rs
</code></pre></div><p>其中 Cargo.toml 是 Rust 的清单文件（toml 格式，这种格式和 ini 文件有点像，但更强大），用于保存项目和依赖的元数据信息，类似 Go Module 中的 go.mod 文件。看下其中的内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="nx">package</span><span class="p">]</span>
<span class="nx">name</span> <span class="p">=</span> <span class="s2">&#34;hello-cargo&#34;</span>
<span class="nx">version</span> <span class="p">=</span> <span class="s2">&#34;0.1.0&#34;</span>
<span class="nx">authors</span> <span class="p">=</span> <span class="p">[</span><span class="s2">&#34;xuxinhua &lt;polaris@studygolang.com&gt;&#34;</span><span class="p">]</span>
<span class="nx">edition</span> <span class="p">=</span> <span class="s2">&#34;2018&#34;</span>

<span class="c"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>

<span class="p">[</span><span class="nx">dependencies</span><span class="p">]</span>
</code></pre></div><p>其中，edition 字段目前可以是 2015 和 2018，默认是 2018，具体什么区别，可以认为 2018 是一个 Rust 大版本（虽然向下兼容）。</p>
<p>关于 authors 字段怎么获取的，可以参考 <a href="https://doc.rust-lang.org/cargo/commands/cargo-new.html" target="_blank" rel="noopener">https://doc.rust-lang.org/cargo/commands/cargo-new.html</a>
，里面有详细的解释。（也可以通过 cargo help new 帮助中查到）</p>
<p>因为我们的项目还没有依赖，所以 dependencies 项是空的。</p>
<p>除了看到的文件，Cargo 还生成了 git 相关的隐藏文件和文件夹：<code>.git</code> 和 <code>.gitignore</code>。也就是说，默认情况下，该项目就通过 git 进行版本控制，可以通过 <code>--vcs</code> 选项控制。</p>
<p>最后是 Rust 源代码。Cargo 要求，源代码必须在 src 目录下，现在 main.rs 中就是一个简单的 Hello World：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;Hello, world!&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>在 VSCode 中打开会发现顶部多出了两个按钮：</p>
<p><p class="md__image">
  <img src="../imgs/tutorial02-02.png"
    alt=""  />
</p>
</p>
<p>点就 「Run」，会在 VSCode 下方 Terminal 窗口输出类似如下信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">&gt; Executing task: cargo run --package hello-cargo --bin hello-cargo &lt;

   Compiling hello-cargo v0.1.0 <span class="o">(</span>/Users/xuxinhua/rust-learning/hello-cargo<span class="o">)</span>
    Finished dev <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> in 1.61s
     Running <span class="sb">`</span>target/debug/hello-cargo<span class="sb">`</span>
Hello, world!

Terminal will be reused by tasks, press any key to close it.
</code></pre></div><p>这里用的是 cargo run 这个命令：先编译，显示编译完成相关信息，然后运行。<code>--package</code> 指定要运行的目标包名， <code>--bin</code> 指定要运行的目标二进制文件名。（实际上，针对当前 hello-cargo 项目，执行运行 cargo run 效果是一样的）</p>
<p>这时，项目根目录会生成一个 target 目录，你可以 tree target 看看，里面的文件很多，具体每个文件的作用我现在也不知，一般也不用去知晓，别劝退~</p>
<p>你可以在终端输入如下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ cargo run --release

   Compiling hello-cargo v0.1.0 <span class="o">(</span>/Users/xuxinhua/rust-learning/hello-cargo<span class="o">)</span>
    Finished release <span class="o">[</span>optimized<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> in 1.28s
     Running <span class="sb">`</span>target/release/hello-cargo<span class="sb">`</span>
Hello, world!
</code></pre></div><p>生产环境运行的程序应该始终使用 <code>--release</code> 选项。这时，在 target 目录下会生成一个 release 目录，而不是 debug 目录。</p>
<blockquote>
<p>在上面和 「Run」一起的还有一个 「Debug」按钮。点击它会提示你需要安装  <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb" target="_blank" rel="noopener">CodeLLDB</a>
 或 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">MS C++ tools</a>
 扩展。本系列后续介绍调试相关知识。</p>
</blockquote>
<h2 id="03-小结">03 小结</h2>
<p>从上面的介绍中可以看到，cargo 命令很强大。Go 语言中，基本上一个 go 命令搞定一切（这也是很多人觉得 Go 工具链很强大的原因）。而 Rust 中，你基本上不需要知道 rustc 命令的存在，只需要掌握 cargo 即可。话说，为啥叫 cargo 呢？crate + go？让人以为和 Go 语言相关呢。。。</p>
<p>本节的 Hello World 应该不会劝退，而且可能会喜欢上它。不过我们没有对 Rust 语法做任何讲解，有些人看到 Hello World 的代码可能有一些奇怪，包括 fn、println!。下一节开始，就该讲解 Rust 的语法了。</p>
]]></content>
		</item>
		
		<item>
			<title>Rust 劝退系列 01：打造开发环境</title>
			<link>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-01/</link>
			<pubDate>Thu, 08 Apr 2021 10:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/rust-tutorial-01/</guid>
			<description>大家好，我是站长 polarisxu。 今天起正式 Rust “劝退”之旅。我也是在学习中，大家一起探讨交流，看谁先被劝退。在这个系列教程中，我通过和 Go 对比学习，同时只讲 Rust 最常用的特性，尽量避免入门就劝退。 工欲善其事必先利其器！本文我们先打造一个 Rust 的开发环境。 01 安装 Rust 打开 Rust 官网：https://rust-lang.org ，可以切换到简体中文界面。在顶部菜单有「安装」。 对于</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天起正式 Rust “劝退”之旅。我也是在学习中，大家一起探讨交流，看谁先被劝退。在这个系列教程中，我通过和 Go 对比学习，同时只讲 Rust 最常用的特性，尽量避免入门就劝退。</p>
<p>工欲善其事必先利其器！本文我们先打造一个 Rust 的开发环境。</p>
<h2 id="01-安装-rust">01 安装 Rust</h2>
<p>打开 Rust 官网：<a href="https://rust-lang.org" target="_blank" rel="noopener">https://rust-lang.org</a>
，可以切换到简体中文界面。在顶部菜单有「安装」。</p>
<p>对于类 Unix 系统（MacOS、Linux 等），官方推荐下载 Rustup 并安装 Rust（如果是 Windows，但使用 Linux 子系统，即 WSL，安装方式和 Linux 一样），在终端执行如下命令进行安装：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">curl --proto <span class="s1">&#39;=https&#39;</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class="p">|</span> sh
</code></pre></div><p>如果是 Windows 用户，会让你下载预编译好的 RUSTUP-INIT.exe 文件（32 位或 64 位），一步步操作即可。</p>
<p>安装完成后，在终端执行 <code>rustup --version</code>，看到了版本信息即表示安装成功。</p>
<p>也可以 <a href="https://rustup.rs" target="_blank" rel="noopener">https://rustup.rs</a>
 网站可以看到查看 rustup：</p>
<p><p class="md__image">
  <img src="../imgs/tutorial01-01.png"
    alt=""  />
</p>
</p>
<h3 id="rustup-是什么">rustup 是什么</h3>
<p>在终端执行 rustup，看到类似如下信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ rustup	
rustup 1.23.1 <span class="o">(</span>3df2264a9 2020-11-30<span class="o">)</span>
The Rust toolchain installer
...
</code></pre></div><p>这是一个 Rust 工具链安装器，专门用于安装 Rust，管理 Rust 很方便：安装、升级、卸载等，还可以切换版本，包括 nightly，beta 和 stable。</p>
<p>相比较而言，Go 语言的安装、卸载、更新，多版本管理就麻烦很多，所以 Go 社区出现了好几个 Go 自身版本管理的工具，比如我之前介绍的 <a href="https://mp.weixin.qq.com/s/yTblk9Js1Zcq5aWVcYGjOA" target="_blank" rel="noopener">goup</a>
。（我之前写过一篇文章：<a href="https://mp.weixin.qq.com/s/uqKl8u8Tyz1-d0Ew3dpVJQ" target="_blank" rel="noopener">《Go 官方应该搞一个类似 Rustup 的管理工具》</a>
）</p>
<p>Go 的安装，如果不用第三方工具，一般通过下载对应操作系统的预编译版本，然后跟普通软件一样安装即可。也可以通过对应系统的工具进行安装，比如 Mac 下的 homebrew，不过很可能安装的不是最新版本的 Go。此外，还可以通过源码安装 Go。</p>
<p>一般地，为了省事，我推荐使用类似 goup 这样的工具来安装、管理 Go 版本，就跟 Rust 自带的 rustup 工具一样。</p>
<p>回到 rustup 命令，看看帮助文档：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ rustup
rustup 1.23.1 <span class="o">(</span>3df2264a9 2020-11-30<span class="o">)</span>
The Rust toolchain installer

USAGE:
    rustup <span class="o">[</span>FLAGS<span class="o">]</span> <span class="o">[</span>+toolchain<span class="o">]</span> &lt;SUBCOMMAND&gt;

FLAGS:
    -v, --verbose    Enable verbose output
    -q, --quiet      Disable progress output
    -h, --help       Prints <span class="nb">help</span> information
    -V, --version    Prints version information

ARGS:
    &lt;+toolchain&gt;    release channel <span class="o">(</span>e.g. +stable<span class="o">)</span> or custom toolchain to <span class="nb">set</span> override

SUBCOMMANDS:
    show           Show the active and installed toolchains or profiles
    update         Update Rust toolchains and rustup
    check          Check <span class="k">for</span> updates to Rust toolchains
    default        Set the default toolchain
    toolchain      Modify or query the installed toolchains
    target         Modify a toolchain<span class="s1">&#39;s supported targets
</span><span class="s1">    component      Modify a toolchain&#39;</span>s installed components
    override       Modify directory toolchain overrides
    run            Run a <span class="nb">command</span> with an environment configured <span class="k">for</span> a given toolchain
    which          Display which binary will be run <span class="k">for</span> a given <span class="nb">command</span>
    doc            Open the documentation <span class="k">for</span> the current toolchain
    man            View the man page <span class="k">for</span> a given <span class="nb">command</span>
    self           Modify the rustup installation
    <span class="nb">set</span>            Alter rustup settings
    completions    Generate tab-completion scripts <span class="k">for</span> your shell
    <span class="nb">help</span>           Prints this message or the <span class="nb">help</span> of the given subcommand<span class="o">(</span>s<span class="o">)</span>

DISCUSSION:
    rustup installs The Rust Programming Language from the official
    release channels, enabling you to easily switch between stable,
    beta, and nightly compilers and keep them updated. It makes
    cross-compiling simpler with binary builds of the standard library
    <span class="k">for</span> common platforms.

    If you are new to Rust consider running <span class="sb">`</span>rustup doc --book<span class="sb">`</span> to
    learn Rust.
</code></pre></div><p>其中的具体选项和子命令不一一介绍，大概有一个印象即可，知道 rustup 是干嘛的后，有相应需求时，可以看看这个文档应该就知道怎么处理了。</p>
<p>值得一提的时候，安装 Rust 后，很多文档都在本地有一份，你可以通过 <strong>rustup doc</strong> 查看。</p>
<h2 id="02-编辑器">02 编辑器</h2>
<p>安装了 Rust，接下来需要搞定 Rust 的编辑器。目前还没有专门为 Rust 开发的 IDE，但主流的文本编辑器都有插件支持 Rust 开发。得益于微软发起的（很大程度因为 VSCode 的存在） Language Server Protocol，让文本编辑器拥有很多 IDE 的特性。（关于 LSP 相关知识可以阅读我<a href="https://mp.weixin.qq.com/s/vMWvSs2h3LwpghS27VQ9rg" target="_blank" rel="noopener">之前写的文章</a>
。）</p>
<p><p class="md__image">
  <img src="../imgs/tutorial01-02.png"
    alt=""  />
</p>
</p>
<p>（官方列表中没有直接列出 CLion，这是 JetBrains 专门为 C/C++ 打造的 IDE。据说很多 Rust 喜欢基于它，安装 Rust 插件进行开发）。</p>
<p>因为写 Go 一直使用 VSCode，因此写 Rust 也使用它了。</p>
<p>在 VSCode 中搜索 Rust，排在前面的两个插件：</p>
<ul>
<li>Rust：这是官方开发的；</li>
<li>rust-analyzer：这是社区开发的；</li>
</ul>
<p>官方的 Rust 插件截图：</p>
<p><p class="md__image">
  <img src="../imgs/tutorial01-03.png"
    alt=""  />
</p>
</p>
<p>社区的 rust-analyzer 截图：</p>
<p><p class="md__image">
  <img src="../imgs/tutorial01-04.png"
    alt=""  />
</p>
</p>
<p>官方的 4 星，社区的 5 星。</p>
<p>一般我们都会安装官方的。但我用了后，发现官方的有些功能缺失，比如没法在 VSCode 中直接运行 Rust。于是我换成社区的，发现可以。查了一些资料，目前看社区版本确实比官方的好。因此目前建议大家安装社区版的 rust-analyzer。该插件的完整手册地址：<a href="https://rust-analyzer.github.io/manual.html" target="_blank" rel="noopener">https://rust-analyzer.github.io/manual.html</a>
。（如果两个都安装了，记得把官方的 disabled，否则很可能冲突）</p>
<p>安装 rust-analyzer 后，如果提示你安装其他组件，按提示安装即可。</p>
<p>反观 Golang 开发工具，JetBrains 为其定制了 GoLand IDE，这一定程度也说明 Go 的欢迎程度，期待其为 Rust 定制 IDE 的那一天。而 Go 的 VSCode 插件：vscode-go，最开始并不是 Go 官方开发的，而是 VSCode 团队开发的，只是后来转给了 Go 官方维护。</p>
<p>和 Rust 插件不同的是，Go 安装完 VSCode 插件后，会提示用户安装一堆工具，因为很多的功能是通过一堆工具组装的。在安装这些工具过程中，很可能会安装失败，幸好有了 GOPROXY，让安装更顺畅。关于 VSCode 打造 Go 开发环境，可以参考我之前写的文章：<a href="https://mp.weixin.qq.com/s/J01LY7s6xMB8Lk10sxTFhg" target="_blank" rel="noopener">《VSCode 开发 Go 程序也可以和 GoLand 一样强大》</a>
。</p>
<h2 id="03-小结">03 小结</h2>
<p>环境是第一步，打造一个好的环境，对后面的学习会有极大的帮助。</p>
<p>在本节，安装完 Rust 后，我主要介绍了 rustup 工具，关于 Rust 工具链的其他工具，后面用到时再一一介绍。</p>
<p>准备好了吗？Rust “劝退”之旅，看你能坚持多久~</p>
]]></content>
		</item>
		
		<item>
			<title>答应我，这次一定彻底搞懂 Go 中的类型别名</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/type-and-alias/</link>
			<pubDate>Wed, 07 Apr 2021 17:20:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/type-and-alias/</guid>
			<description>大家好，我是站长 polarisxu。 有下面 3 行代码： // 32 位机器 1）var x int32 = 32.0 2）var y int = x 3）var z rune = x 它们是否能编译通过？为什么？ 如果面试时问这道题，你需要想想面试官想考察你什么。在往下看之前，建议你记下自己的答案。 01 数字字面量 在 Go 语言中，字面量是无类型（untyped）的。无类型是什么意思？无类型意味着可以赋值给类似类型的变量或常量。用上面例</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>有下面 3 行代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 32 位机器
</span><span class="c1"></span><span class="mi">1</span><span class="err">）</span><span class="kd">var</span> <span class="nx">x</span> <span class="kt">int32</span> <span class="p">=</span> <span class="mf">32.0</span>
<span class="mi">2</span><span class="err">）</span><span class="kd">var</span> <span class="nx">y</span> <span class="kt">int</span> <span class="p">=</span> <span class="nx">x</span>
<span class="mi">3</span><span class="err">）</span><span class="kd">var</span> <span class="nx">z</span> <span class="kt">rune</span> <span class="p">=</span> <span class="nx">x</span>
</code></pre></div><p>它们是否能编译通过？为什么？</p>
<p>如果面试时问这道题，你需要想想面试官想考察你什么。在往下看之前，建议你记下自己的答案。</p>
<h2 id="01-数字字面量">01 数字字面量</h2>
<p>在 Go 语言中，字面量是无类型（untyped）的。无类型是什么意思？无类型意味着可以赋值给类似类型的变量或常量。用上面例子，32.0 是无类型的浮点数字面量，因此它可以赋值给任意数字相关类型变量（或常量）。以下都是合法的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mf">32.0</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">int</span> <span class="p">=</span> <span class="mf">32.0</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">32.0</span>
<span class="kd">var</span> <span class="nx">d</span> <span class="kt">complex64</span> <span class="p">=</span> <span class="mf">32.0</span>
<span class="kd">var</span> <span class="nx">e</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mf">32.0</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="kt">rune</span> <span class="p">=</span> <span class="mf">32.0</span>
</code></pre></div><p>所以上题中 1）是正确的。</p>
<h2 id="02-不同类型">02 不同类型</h2>
<p>在目前 Go 1.16 版本中（实际上只有很早期的版本不是），int 类型在 32 位机器占 4 字节，64 位机器占 8 字节。所以，在 32 位机器上，int32 和 int 的内存占用和内存布局是完全一样的。但 Go 语言不会做隐式类型转换，int 和 int32 是不同的类型，因此上题中 2）编译不通过。</p>
<h2 id="03-类型别名">03 类型别名</h2>
<p>熟悉 C 语言的小伙伴，看到 Go 中以下定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myint</span> <span class="kt">int</span>
</code></pre></div><p>会以为 myint 和 int 是一样的，认为 myint 是 int 的别名。而实际上，myint 是和 int 完全不一样的类型，只不过 myint 的底层类型是 int，它们直接可以强制类型转换，却不会隐式转换。关于这点无需多讲，重点要讲的是类型别名。</p>
<p>从 Go1.9 开始引入了类型别名，定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">AliasDecl</span> <span class="p">=</span> <span class="nx">identifier</span><span class="p">,</span> <span class="s">&#34;=&#34;</span><span class="p">,</span> <span class="nx">Type</span> <span class="p">.</span>
</code></pre></div><p>具体例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">intalias</span> <span class="p">=</span> <span class="kt">int</span>
</code></pre></div><p>myint 是新类型，和 int 不一样；而 intalias 却和 int 一样，它只是 int 的别名：所有使用 intalias 的地方都可以使用 int。</p>
<p>那为什么 Go 中会引入类型别名呢？Russ Cox 的论文 <a href="https://talks.golang.org/2016/refactor.article" target="_blank" rel="noopener">Codebase Refactoring (with help from Go)</a>
 介绍了它的背景。总结一下类型别名的用途，主要有两点：</p>
<ul>
<li>在大规模重构项目代码的时候，尤其是将一个类型从一个包移动到另一个包中的时候，有些代码会使用新包中的类型，有些代码使用旧包中的类型， 最典型的是 <code>context</code> 包。最开始，context 包名是 <code>golang.org/x/net/context</code>，1.7 开始，引入标准库，这样一来，存在两份。Go 1.9 开始采用别名重构了它；</li>
<li>允许一个庞大的包分解成内部的几个小包，但是小包中的类型需要集中暴漏在上层的大包中；</li>
</ul>
<p>在 Go 中，你可以为任意类型定义别名，比如数组、结构体、指针、函数、接口、Slice、Map、Channel 等，包括为自定义类型定义别名。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">F</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span>
<span class="kd">type</span> <span class="nx">I</span> <span class="p">=</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="o">...</span>
</code></pre></div><p>此外，还可以为其他包中的类型定义别名，比如为标准库类型定义别名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MyReader</span> <span class="p">=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span>
</code></pre></div><p>关于类型别名的一些注意事项：</p>
<ul>
<li>别名和原类型是一样的，因此 switch-type 结构中，不能存在两个 case，一个是原类型，一个是别名；</li>
<li>类型别名不能循环定义，比如以下是不允许的：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="p">=</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">T1</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">T1</span> <span class="p">=</span> <span class="nx">T</span>
</code></pre></div><ul>
<li>因为别名和原类型是一样的，因此共享同样的方法集，不论这个方法是定义在原类型还是别名上；</li>
<li>别名的导出性可以和原类型不一样；</li>
<li>不能为别的包的类型通过定义别名来增加方法。以下行为是不允许的：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MyReader</span> <span class="p">=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nx">Reader</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">MyReader</span><span class="p">)</span> <span class="nf">AliasMethod</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;This is alias method&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>编译报错：<code>cannot define new methods on non-local type bufio.Reader</code>。</p>
<p>回到开头题目的 3），rune 是什么类型？定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="kt">rune</span> <span class="p">=</span> <span class="kt">int32</span>
</code></pre></div><p>很显然，rune 是 int32 的别名，因此题目中 3）也能编译通过。</p>
<p>除了 rune，Go 内置类型中，还有 byte 是 uint8 的别名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="kt">byte</span> <span class="p">=</span> <span class="kt">uint8</span>
</code></pre></div><p>需要说明的是，在 Go1.9 之前，rune 和 byte 的别名性质就存在，是编译器负责处理的。只是 Go1.9 之后，别名可以用于其他类型了。</p>
<h2 id="04-总结">04 总结</h2>
<p>一道看似简单的题目，如果你能够分析透彻，把语言的变化都说出来，我相信面试官会给你加分。</p>
<p>今天的题目，你做对了吗？</p>
]]></content>
		</item>
		
		<item>
			<title>【灵魂拷问】为什么假期回老家，计划总是泡汤？</title>
			<link>https://polarisxu.studygolang.com/posts/talk/holiday-20210405/</link>
			<pubDate>Mon, 05 Apr 2021 11:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/holiday-20210405/</guid>
			<description>大家好，我是站长 polarisxu。 今天这个话题，我相信很多人都深有体会。清明假期又结束了，我的计划也如往常一样泡汤了！但这次，我想复盘一下，为什么会这样？！ 先讲讲我之前的一些经历。 01 学生时代 学生时代，大学和大学之前还是有些不一样的。 高三之前，每次放假回家，除了老师布置的作业，其他计划的学习计划基本泡汤，书怎么带回去的就怎么带回来，每次内心都充满“罪恶感”，</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天这个话题，我相信很多人都深有体会。清明假期又结束了，我的计划也如往常一样泡汤了！但这次，我想复盘一下，为什么会这样？！</p>
<p>先讲讲我之前的一些经历。</p>
<h2 id="01-学生时代">01 学生时代</h2>
<p>学生时代，大学和大学之前还是有些不一样的。</p>
<p>高三之前，每次放假回家，除了老师布置的作业，其他计划的学习计划基本泡汤，书怎么带回去的就怎么带回来，每次内心都充满“罪恶感”，觉得自己堕落了，同时指天发誓，下个假期一定：「下次一定」。。。如此周而复始。</p>
<p>但高三那个寒假，家人围着火盆烤火、聊天，看电视，打麻将，我自己单独到另外一个房间学习。很显然，高考的压力，让计划落实的较好。</p>
<p>大学时，印象中特别深的是大一寒假，我从图书馆借了厚厚的一本《红楼梦》，从北京背回江西，发誓寒假认真看完。结果，就在坐火车时看了十来回，在家里书都没拿出来。。。</p>
<p>虽然「历史经验教训」历历在目，但每一次假期，依然告诉自己：这次一定要改变，要执行。。。正如德国哲学家说的：人类唯一能从历史中吸取的教训就是，人类从来都不会从历史中吸取教训。对待假期的学习计划，又何尝不是如此？！</p>
<h2 id="02-工作之后">02 工作之后</h2>
<p>2014 年国庆，家人回老家，我选择了留在北京，因为我想做点事情。那个假期，我一直宅在家里，我为「Go语言中文网」增加了一个大功能，之后流量有了大幅提升。</p>
<p>2020 年国庆，家人回老家，我原计划一个人留北京的，最后还是跟着回了。领导跟我说，回家也不需要你做什么，你一样可以做你的事情，只是路上帮照看下孩子，说的挺有道理。结果，我的计划完全落空了，虽然确实没让给做什么事情，但我大部分时间都在看电视和玩游戏。。。</p>
<p>这个清明假期，又回老家了！回老家之前，我没有做很多计划，但至少计划了两件事情：答应了别人做一个视频，和煎鱼说考虑下「一件大事」。结果。。。</p>
<h2 id="03-复盘反思">03 复盘&amp;反思</h2>
<p>这也许是运营公众号的好处：这么多年，从来没想过复盘下「为什么回老家，计划总会泡汤」，但现在做了这件事，因为我经常在思考，公众号发什么文章。</p>
<p>在知乎上有人问了类似的问题：「每次下决心学习，制定好计划，但回家后根本做不到，怎么办？」、「为什么我一放假回家就变得很懒一点都不想学习？」等。可见这是大部分人都会遇到的问题。</p>
<p>从我的经历看，在极端压力情况下，是可能做到充分利用假期时间的，比如高三寒假。但这样的状态不可持续，没有借鉴价值，人不可能长期处在那样的状态。其他情况，之所以有这样的感觉，我认为存在如下的因素。</p>
<h3 id="1环境因素">1）环境因素</h3>
<p>网上看到这么一个软文故事：</p>
<blockquote>
<p>A 是一个创业者，准确的说是一个准备开始创业的人。</p>
<p>B 是共享办公室的销售，向 A 推销，去共享办公室工作，那里有座位、有免费咖啡，还有健身器材，总之是创业者初创期的不二选择！</p>
<p>但是 A 不以为然，他说自己的家里也有书桌，也有咖啡，也有跑步机，我为什么要来你这里呢？</p>
<p>B 说出了一句看起来很粗俗，但想想极有道理的一句话：“以我见过的大多数人来看，通常在家工作，只会变成在家里玩游戏和自嗨！”</p>
</blockquote>
<p>这就是环境的力量。</p>
<p>回到老家，不同的生活环境，不同的人，还有不同的气候，特别是冬天，南方冷的让你不想动。和人聊聊天、看看电视、玩玩游戏，一天很快就过去了。</p>
<h3 id="2心理因素">2）心理因素</h3>
<p>这个包括心理预期。你可以这么想：平时节假日，你没有回老家，也没出去浪，只是宅在家里，你有计划吗？计划落实了吗？为什么放假回老家就应该计划学习，就应该落实学习计划呢？回家多了，多陪陪家人不是更好吗？放假了，适当放松下不也应该的吗？</p>
<p>很可能，我们平时就没有好好学习、读书，总指望着放假了，觉得有大段时间，应该会好好学习。凭什么？</p>
<hr>
<p>为此，我做了以下总结：</p>
<h3 id="1保持学习的习惯">1）保持学习的习惯</h3>
<p>大学时代，我相信很多人都没有学习、读书的习惯，凭什么指望放假回家了就有这样的习惯？！工作了，如果你平常、节假日基本不读书、学习，凭什么指望放假回老家了就能读书、学习？！更何况回老家还有环境的影响。所以，我们平时得养成好的读书、学习习惯。</p>
<p>习惯的力量是很大的，通过也是一份坚持。比如昨天（周日），我依然找时间整理了「Go语言爱好者周刊」。</p>
<h3 id="2兴趣是最好的老师">2）兴趣是最好的老师</h3>
<p>如果你有读书、学习的习惯，但回到老家，环境影响较大，如何能够做到适当读书和学习呢？找自己感兴趣的学习。</p>
<p>就我个人习惯，拿着实体书阅读不太方便，我更偏向手机阅读。虽然这个清明假期，有些事情我没有做，但近期对「理财」很感兴趣，所以有空就通过手机看这方面的文章，同时也听这方面的音频，这也是一种学习。因为兴趣，学习受环境的影响就小很多。</p>
<h3 id="3降低心理预期">3）降低心理预期</h3>
<p>如果是学生，有条件的话，假期找一个适合学习的环境，尽可能降低环境的干扰。</p>
<p>对所有人来说，假期，我们应该降低心理预期，别指望假期能够比平时花更多时间在读书、学习上。计划做的满满的，每次都实现不了，就会变得无所谓。也许我们可以先让自己实现平时学习的五分之一。</p>
<hr>
<p>总结下来，就是：保持学习、读书的习惯，找到自己感兴趣的方向，降低心理预期，一个假期结束，可能会发现自己收获不小。共勉！</p>
<p>清明假期，你的「计划」落实了吗？欢迎留言交流。</p>
]]></content>
		</item>
		
		<item>
			<title>那些想替代 C 的语言怎么样？Go、Rust、C&#43;&#43; 和 Zig 生产力对比</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/better-c-benchmark/</link>
			<pubDate>Thu, 01 Apr 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/better-c-benchmark/</guid>
			<description>C 已经快 50 岁了。对于一瓶葡萄酒来说，这个年龄很棒，但对于快速发展的行业中的编程语言而言，它就不同了。在过去的十年中，出现了许多具有不同风格的新语言，所有这些语言都试图在某种程度上成为 C 语言的替代者。 当一种新语言或多或少变得流行时 —— 开发人员开始编写基准测试，以展示该语言编写的软件性能，CPU 利用率和内存使用量以及二进制文件的大小等等。 在这里，我想在不同的层面</description>
			<content type="html"><![CDATA[<p>C 已经快 50 岁了。对于一瓶葡萄酒来说，这个年龄很棒，但对于快速发展的行业中的编程语言而言，它就不同了。在过去的十年中，出现了许多具有不同风格的新语言，所有这些语言都试图在某种程度上成为 C 语言的替代者。</p>
<p>当一种新语言或多或少变得流行时 —— 开发人员开始编写基准测试，以展示该语言编写的软件性能，CPU 利用率和内存使用量以及二进制文件的大小等等。</p>
<p>在这里，我想在不同的层面上进行一些实验 —— 编程语言的 UX（用户体验），使用这种语言时开发人员的效率，使用它们的容易程度，常见的挫败感，阅读代码的感受。我相信编程语言的 UX 与它们的技术特征一样重要，并且对语言的成功做出了很大的贡献。</p>
<p>注意：该文章的其余部分带有很多主观色彩。</p>
<h2 id="实验">实验</h2>
<p>让我们编写一个应用程序，该程序以递归方式扫描当前目录中的所有文件，并在与给定通配符匹配的文件中打印这些行。类似于 <code>ag</code> 或 <code>grep</code>，但使用通配符而不是正则表达式。二进制文件应被忽略。</p>
<p>我发现这个问题是一个很好的练习，因为它展示了如何实现非常简单的通配符匹配算法（该算法可用于字符串和数字之类的纯数据，无需学习任何库或 API）。该算法应通过一些非常简单的测试。然后，它需要一些非常通用的底层 API，例如递归扫描目录或逐行读取文件。问题的所有部分都非常简单，小巧且范围广泛。这个小程序当然也可以用其他任何语言实现。</p>
<p>我想测试该语言与常规的 “write-compile-run-debug” 循环的“友好”程度，为匹配算法编写测试的复杂度，找到与文件一起使用所需的 API、系统和基本 I/O 的难易度，指出错误时编译器的友好程度，语言的“直观性”等等。</p>
<p>我的样本量相当谦逊 —— 仅我本人。但是为了避免偏见，建议你自己做（不要花太长时间）并比较结果。用不同的语言编写小程序后，我让同行的开发人员（约 20 人）阅读并给我反馈，哪些界限不清楚，哪些阅读和理解起来“更容易”。这些开发人员没有使用这种语言的经验，但是能熟练使用其他语言，例如 Java，C＃，JavaScript，Kotlin 和 Swift 等。</p>
<p>我在这里测试的语言是 C++，Go，Rust 和 Zig。我得到的结果程序可以在 GitHub 找到： <a href="https://github.com/zserge/glob-grep" target="_blank" rel="noopener">https://github.com/zserge/glob-grep</a>
，请随时批评。</p>
<h2 id="zig">Zig</h2>
<p>从 Zig 开始，因为我想看看 Zig 是什么类型的语言。之前听到过这个语言有不错的反馈，但是一直没用过。没有经验可谈，我打开了 Vim 并开始编写代码。</p>
<p>我花了大约 1 个小时来完成程序。通配符匹配算法（我以前知道，只需要在 Zig 中实现）花了我大约 20 分钟的时间。其余主要在寻找 API 来进行目录扫描和文件读取。</p>
<p>TLDR：出色，直观的小语言，较差的是 stdlib 和 docs。</p>
<p>我喜欢的是：对于 C 程序员，该语言出奇的直观。感觉很简单，关于语言的文档（而不是 stdlib）非常清晰和友好。</p>
<p>对于年轻的语言而言，Vim 集成也相当不错（在启用 Vim 插件之前 —— 格式化错误（编译器错误）使我很郁闷）。</p>
<p>我喜欢错误处理方法。喜欢该语言附带的测试工具。甚至喜欢字符串只是字节数组，就像在 C 中一样。</p>
<p>我对附带分配器的第一个反应是震惊，但实际上它甚至没有引起注意。它给人以极简主义的感受，即该语言的核心是如此简单，以至于它甚至不使用动态内存。同样，非常接近 C。</p>
<p>在编写此代码时，我必须阅读许多 Zig 编译器和 stdlib 源代码，并且代码非常简洁明了。</p>
<p>我不喜欢的东西：stdlib 文档太糟糕了。我从目录扫描和文件 I/O 中学到的所有知识–我都是从 GitHub 搜索结果中获得的，这也非常稀缺。</p>
<p>编译器提示消息也不是很友好，但是对于熟悉 C 的人来说，这没什么大不了的。</p>
<p>在 stdlib 中缺少字符串处理例程是出乎意料的，要连接字符串，必须手动做所有事情 —— 分配缓冲区，将字符串放在那里。或者使用格式化程序和分配器来同时打印两个字符串，然后释放缓冲区。但这仍然和 <code>s1+s2</code> 有很大不同。</p>
<p>总的来说，核心语言很简单，我很喜欢它，但是 stdlib 比 libc 更受限制。我希望这只是该语言早期的标志。</p>
<p>实际上，读 Zig 代码的人都提到了这点。它有点冗长，但明确，可预测且易于理解。毫不奇怪，因为该语言在设计时考虑了可读性（没有隐藏的控制流，没有隐藏的分配，没有宏，没有运算符重载，没有元编程等）。</p>
<h2 id="rust">Rust</h2>
<p>我尝试学习 Rust，但失败了。我花了 2 个多小时才完成此程序，完成后我感到失望。</p>
<p>TLDR：复杂。</p>
<p>我喜欢的东西：编译器提示消息友好。该语言的文档也不错。但仅此而已，我这次并没有了解生命周期、错误处理等。围绕该语言的工具既现代又不错。</p>
<p>我不喜欢的东西：编译器消息太冗长，占据了整个屏幕。我可不想 <code>rustc --explain</code> 为每个错误而奔波。求求你，不要惩罚我。文档有时也太冗长。我的意思是，最好有更多的文档而不是更少的文档，但是先拥有 TLDR 版本会更好。对于 stdlib 来说，也是如此，一小段功能及其用一句话即可完成的工作将更容易阅读。有 <code>&amp;str</code>，<code>Str</code> 和 <code>[u8]</code>，让新手感到惊讶。</p>
<p>总体而言，Rust 中的编码对我来说就像是解决难题。可能会很有趣和令人兴奋的地方，尤其是在将 Rust 用作一种业余语言时，但是对于大多数任务，我宁愿使用一种“人机工程学”的语言，这种语言几乎不会引起注意。</p>
<p>读 Rust 代码过程中，经常会骂出至少两个 “wtf”。他们经常抱怨语法不清楚，需要注意细节。而且，模式匹配对于“主流”开发人员仍然是陌生的事情。</p>
<h2 id="go">Go</h2>
<p>这是作弊。我曾经使用 Go，但是我还是想在这个实验中尝试一下。正如我期望的那样，我花了大约 15 分钟就能使我的完整 “glob” 实用程序正常工作。</p>
<p>TLDR：富有成效，但固执己见。</p>
<p>我喜欢的东西：感觉非常有用，文档对我来说很神奇 ——简短但有用，可以立即打开相关的 stdlib 函数源码并进行进一步研究。根据过去的经验，在编写应用程序时，我已经设想了如何使其成为多线程并提高性能（简单的 fan-out）。</p>
<p>我不喜欢的东西：太多东西（缓冲 I/O，GC）存在。你不会觉得自己可以控制一切（就像在 Zig 中一样）。太自以为是 —— 这是列表中唯一需要我创建 3 个单独的文件才能使其起作用的语言。仍然会犯一些低级错误，例如意外的变量 shadow 或在循环内使用 defer。</p>
<p>读 Go 代码，会发现它很清楚，有些人对内联 walker 函数感到好奇（它们不一定是内联的，他们是正确的）。一些人想知道多重分配，比如<code>a, b = c, d</code>，这种写法感觉更混乱了。具有讽刺意味的是，如果我是 Go 语言的新手，我会写出更直接的 Go 代码。</p>
<h2 id="c">C++</h2>
<p>尽管我有一定的 C 经验，但是与现代 C++ 却相去甚远，因此我决定尝试一下。我花了大约 20 分钟才能完成，这是出乎意料的。</p>
<p>TLDR：好老的“朋友”。</p>
<p>我喜欢的东西：感觉很熟悉，就像认识一个过去的老朋友一样。我喜欢这些文档，并提供了许多示例和良好的可读性。看到如今的 stdlib 这么强大，我感到很惊讶。文本编辑器和 IDE 中的支持也非常可靠。</p>
<p>我不喜欢的东西：不良的工具 —— 没有构建系统，没有测试工具，没有 linter。我们过去习惯使用它，但这并不是现代开发人员所期望的。太强大了 —— 对于这项任务，C++ 感觉非常有生产力，但是我可以想象自己在某个时候处于决策瘫痪状态，这时有许多不同的方式来做某事，而所有事情都是一样的（或不好的）。</p>
<p>读 C++ 代码的人实际上过去至少已经读过 C 或 C++，这是他们大学课程的一部分。我猜很多人抱怨使用 <code>::</code>，所以我应该正确使用名称空间。总的来说，由于我在 C++ 代码中没有“品味”  —— 我敢肯定它可以写得更清楚，但是我也看到在没有注意到的情况下它可能写得更糟。</p>
<h2 id="其他基准">其他基准</h2>
<p>所有语言均生成静态可执行文件，大小均相同（2 ~ 5MB）。最小的是 Zig，最大的是 Rust。扫描整个 <code>/usr/include</code> 文件树时，它们的性能几乎相同。这就是为什么我要强调技术特性（主要指性能）通常不如开发人员体验那么重要。</p>
<p>我想另外提一下构建时间。我运行了整个 build + test + clean 循环一百次。Go 最快（如预期的那样），其他三个都是基于 LLVM 的，速度要慢 3 到 4 倍。</p>
<p>这意味着什么？这个结果并不令人惊讶，并且经常有关于语言的陈词滥调：Go 易于阅读，Rust 复杂，C++ 熟悉，Zig 看起来很有希望，但还太年轻而无法判断。</p>
<p>如果我必须编写与 C 代码没有进行大量交互的新服务/实用程序 —— 我肯定会选择 Go。如果必须调用某些 C 或 C++ 库 —— 不幸的是，我会坚持使用 C++。Rust 和 Zig 在现代编程世界中将占据什么位置 —— 只有时间会证明一切。我希望 Zig 有更好的文档，这样可能在它变得过于小众和淹没之前获得流行。我一定会更加关注它，到目前为止，这是我遇到的第一个真正的 C 替代品，尤其是在涉及低级编码时。</p>
<p>当然，尽管年代久远，C 仍然存在。在很多地方，C 是唯一的实际选择。我很高兴 C 还保持青春。</p>
<blockquote>
<p>原文链接：https://zserge.com/posts/better-c-benchmark/</p>
<p>本文作者：zsergo</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>我无语了，Go 中 &#43;-*/ 四个运算符竟然可以连着用</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/operator/</link>
			<pubDate>Wed, 31 Mar 2021 20:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/operator/</guid>
			<description>大家好，我是站长 polarisxu。 我计划把类似这样的文章归为：奇淫技巧，你认同吗？ 看到 Go101（玩 twtter 的可以关注他） 发了一条消息，+-*/ 这四个竟然可以连着写： package main func main() { v := new(int) *v = 2 println(5/+-*v) } 我看到后，试着运行了一下，竟然输出了 -2 。。。我忍不住“卧槽”。。。 我不得不说，Go101 扣的真细节。 于是我尝试着找一些线索，看看为什么可以这样写。 01 直接看汇编 遇到一些不解的</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>我计划把类似这样的文章归为：奇淫技巧，你认同吗？</p>
<p>看到 Go101（玩 twtter 的可以关注他） 发了一条消息，<code>+-*/</code> 这四个竟然可以连着写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">v</span> <span class="p">=</span> <span class="mi">2</span>
    <span class="nb">println</span><span class="p">(</span><span class="mi">5</span><span class="o">/+-*</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我看到后，试着运行了一下，竟然输出了 -2 。。。我忍不住“卧槽”。。。</p>
<p>我不得不说，Go101 扣的真细节。</p>
<p>于是我尝试着找一些线索，看看为什么可以这样写。</p>
<h2 id="01-直接看汇编">01 直接看汇编</h2>
<p>遇到一些不解的地方，有时候借助汇编也许能得到答案：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">go tool compile -S main.go
</code></pre></div><p>看关键的几行汇编：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">	0x001d <span class="m">00029</span> <span class="o">(</span>main.go:6<span class="o">)</span>	PCDATA	<span class="nv">$1</span>, <span class="nv">$0</span>
	0x001d <span class="m">00029</span> <span class="o">(</span>main.go:6<span class="o">)</span>	NOP
	0x0020 <span class="m">00032</span> <span class="o">(</span>main.go:6<span class="o">)</span>	CALL	runtime.printlock<span class="o">(</span>SB<span class="o">)</span>
	0x0025 <span class="m">00037</span> <span class="o">(</span>main.go:6<span class="o">)</span>	MOVQ	<span class="nv">$-</span>2, <span class="o">(</span>SP<span class="o">)</span>
	0x002d <span class="m">00045</span> <span class="o">(</span>main.go:6<span class="o">)</span>	CALL	runtime.printint<span class="o">(</span>SB<span class="o">)</span>
	0x0032 <span class="m">00050</span> <span class="o">(</span>main.go:6<span class="o">)</span>	CALL	runtime.printnl<span class="o">(</span>SB<span class="o">)</span>
	0x0037 <span class="m">00055</span> <span class="o">(</span>main.go:6<span class="o">)</span>	CALL	runtime.printunlock<span class="o">(</span>SB<span class="o">)</span>
</code></pre></div><p>从 <code>MOVQ	$-2, (SP)</code> 看出，直接编译器直接计算出 -2 了。。。（可以进一步加上 -N 来禁止优化，但没有没有看出额外特别的）</p>
<h2 id="02-看规范">02 看规范</h2>
<p>之前的一些题解，我总是在 Go 语言规范中找到解释，因此这次也不例外。</p>
<p>在运算符章节，Go 中有如下几个一元运算符：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">unary_op</span> <span class="p">=</span> <span class="s">&#34;+&#34;</span> <span class="p">|</span> <span class="s">&#34;-&#34;</span> <span class="p">|</span> <span class="s">&#34;!&#34;</span> <span class="p">|</span> <span class="s">&#34;^&#34;</span> <span class="p">|</span> <span class="s">&#34;*&#34;</span> <span class="p">|</span> <span class="s">&#34;&amp;&#34;</span> <span class="p">|</span> <span class="s">&#34;&lt;-&#34;</span> <span class="p">.</span>
</code></pre></div><p>其中，+、- 和 * 同时也是算术运算符中的加、减和乘。</p>
<p>接着，在运算符优先级处提到：一元运算符有最高的优先级。</p>
<p>我们分析题目中的表达式：<code>5/+-*v</code>。5 后面 /，很显然，这是除法。而 + 前面没有操作数，因此是一个一元运算符；同理 - 和 <code>*</code> 也是一元运算符。而一元运算符有最高的优先级，因此这个表达式优先计算 <code>+-*v</code> 的值。那这个东西为什么又合法呢？</p>
<p>在规范中有这么一句话：</p>
<blockquote>
<p>对于整数操作数，一元运算符 <code>+</code> , <code>-</code> 和 <code>^</code> 有如下定义：（省略了 ^ 的解释）</p>
<p>+x    　　　　              是 0 + x
-x    取其负值               是 0 - x</p>
</blockquote>
<p>也就是说，<code>+-*v</code> 相当于：<code>0+(0-(*v))</code>。（为什么一元运算符左结合，因为一元，必须得有运算数，得跟着运算数走）</p>
<p>这样一来，结果变成了求 5/-2 的值，结果自然是 -2（别跟我说应该是 2.5）。</p>
<p>（规范参考 Bekcpear 翻译版：<a href="https://hao.studygolang.com/golang_spec.html" target="_blank" rel="noopener">https://hao.studygolang.com/golang_spec.html</a>
）</p>
<h2 id="03-其他语言的行为">03 其他语言的行为</h2>
<p>看到这，我不禁想看看其他语言怎么实现的。（没有指针的语言，就只能包含 /+- 了）</p>
<p><strong>C 语言</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  	<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
  	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mi">5</span><span class="o">/+-*</span><span class="n">p</span><span class="p">);</span>
  	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>结果也是 -2。</p>
<p><strong>Java</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span> <span class="o">[]</span><span class="n">args</span><span class="o">)</span> <span class="o">{</span>
       <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">5</span><span class="o">/+-</span><span class="n">2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>结果也是 -2。</p>
<p><strong>PHP</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="o">&lt;?</span><span class="nx">php</span>
<span class="k">echo</span> <span class="mi">5</span><span class="o">/+-</span><span class="mi">2</span><span class="p">;</span>
</code></pre></div><p>结果是 -2.5。（弱类型语言嘛）</p>
<p><strong>Python</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="mi">5</span><span class="o">/+-</span><span class="mi">2</span>
</code></pre></div><p>结果是 -3。（Python 对 / 的处理和别的语言还是不太一样）</p>
<p><strong>JS</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="mi">5</span><span class="o">/+-</span><span class="mi">2</span>
</code></pre></div><p>结果和 PHP 一样，-2.5。</p>
<p>最后看看 <strong>Rust</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="mi">5</span><span class="o">/+-</span><span class="mi">2</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>编译器告诉我：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">error: expected expression, found <span class="sb">`</span>+<span class="sb">`</span>
</code></pre></div><p>Rust 果然不一样！我们不一样、不一样。。。</p>
<h2 id="04-总结">04 总结</h2>
<p>奇淫技巧，如果能顺便学一点知识，那是极好的。当然，最关键的是希望有探索精神，找到其中的原因，举一反三，也许这点比较重要。</p>
]]></content>
		</item>
		
		<item>
			<title>Go周刊题解：切片的另类初始化 — 该题正确率出奇的低</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/weekly-question-88/</link>
			<pubDate>Tue, 30 Mar 2021 12:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/weekly-question-88/</guid>
			<description>大家好，我是站长 polarisxu。 我在 Go 语言爱好者周刊第 87 和 88 期 刊首出了两道题，这两道题有点类似，都是和切片初始化有关。但这两道的题正确率比较低，特别是 88 期的题。 第 87 期题目如下： package main import ( &amp;#34;fmt&amp;#34; ) func main() { a := []int{2: 1} fmt.Println(a) } 正确答案是：C，正确率 52%。这道题相对简单，但依然有近一半的人答错了。 第 88 期题目和 87 期类似，但难度高一些，题目如下： package main func main() { var x = []int{4: 44, 55, 66, 1: 77, 88} println(len(x),</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>我在 Go 语言爱好者周刊<a href="https://mp.weixin.qq.com/s/4HI78Yd1ENVFCWHCESlPBg" target="_blank" rel="noopener">第 87</a>
 和 <a href="https://mp.weixin.qq.com/s/pgIoGnOd0CMPHFc4HD0xFA" target="_blank" rel="noopener">88 期</a>
刊首出了两道题，这两道题有点类似，都是和切片初始化有关。但这两道的题正确率比较低，特别是 88 期的题。</p>
<p>第 87 期题目如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>正确答案是：C，正确率 52%。这道题相对简单，但依然有近一半的人答错了。</p>
<p><p class="md__image">
  <img src="../imgs/weekly-question-88-01.png"
    alt=""  />
</p>
</p>
<p>第 88 期题目和 87 期类似，但难度高一些，题目如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">x</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">88</span><span class="p">}</span>
	<span class="nb">println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div><p>正确答案是：C，正确率很低，只有 25%。</p>
<p><p class="md__image">
  <img src="../imgs/weekly-question-88-02.png"
    alt=""  />
</p>
</p>
<p>为了更全面，我们讲解下 array/slice 的一些相关知识。</p>
<h2 id="01-数组和切片">01 数组和切片</h2>
<p>关于两者，Go 语言规范中都有明确定义。</p>
<p><a href="https://hao.studygolang.com/golang_spec.html#ruby-rb-rb-rp-rp-rt-array-types-rt-rp-rp-ruby" target="_blank" rel="noopener">数组</a>
是这么说明的：</p>
<blockquote>
<p>数组是单一类型元素的有序序列，该单一类型称为元素类型。元素的个数被称为数组长度，并且不能为负值。长度是数组类型的一部分；它必须为一个可以被 int 类型的值所代表的非负常量。</p>
</blockquote>
<p>这里一个关键点就是，长度是数组的一部分，因此 [3]int 和 [4]int 是不同类型。</p>
<p>再看看<a href="https://hao.studygolang.com/golang_spec.html#ruby-rb-rb-rp-rp-rt-slice-types-rt-rp-rp-ruby" target="_blank" rel="noopener">切片</a>
：</p>
<blockquote>
<p>切片是针对一个底层数组的连续段的描述符，它提供了对该数组内有序序列元素的访问。切片类型表示其元素类型的数组的所有切片的集合。元素的数量被称为切片长度，且不能为负。未初始化的切片的值为 <code>nil</code> 。</p>
</blockquote>
<p>从 EBNF 的表示可以看出区别：</p>
<pre tabindex="0"><code>ArrayType   = &quot;[&quot;, ArrayLength, &quot;]&quot;, ElementType .
SliceType = &quot;[&quot;, &quot;]&quot;, ElementType .
</code></pre><p>也就是说，长度不是切片类型的一部分，切片长度可变。</p>
<h2 id="02-常见字面量初始化">02 常见字面量初始化</h2>
<p>我不打算讲解数组/切片初始化的各种情况，主要介绍常见的字面量初始化，以及和上面题目相关的部分。</p>
<p>通常我们会这么初始化一个数组：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">intSet</span> <span class="p">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
</code></pre></div><p>注意 <code>[]</code> 中的 6，它表示数组的长度。因为初始化时，我们只给定了 3 个数，因此后 3 个元素是 0：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="o">[</span><span class="m">2</span> <span class="m">4</span> <span class="m">6</span> <span class="m">0</span> <span class="m">0</span> 0<span class="o">]</span>
</code></pre></div><p>注意和这种写法的区别：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">intSet</span> <span class="p">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>
</code></pre></div><p>对于切片来说，一般这样初始化：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">intSlice</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">}</span>

<span class="c1">// 或基于 intSet 进行初始化
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">intSlice</span> <span class="p">=</span> <span class="nx">intSet</span><span class="p">[:]</span>
</code></pre></div><p>当然，针对 Slice，更多时候是通过 make 创建，然后其他方式初始化，这里不展开了。</p>
<h2 id="03-特殊的初始化">03 特殊的初始化</h2>
<p>在 Go语言规范「<a href="https://hao.studygolang.com/golang_spec.html#ruby-rb-rb-rp-rp-rt-composite-literals-rt-rp-rp-ruby" target="_blank" rel="noopener">Composite literals</a>
」部分对数组和切片的字面值初始化进行了规定，因为数组和切片类似，我们这里只说切片的情况。</p>
<p>先看组合字面值的 EBNF 表示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">CompositeLit</span>  <span class="o">=</span> LiteralType, LiteralValue .
<span class="nv">LiteralType</span>   <span class="o">=</span> StructType <span class="p">|</span> ArrayType <span class="p">|</span> <span class="s2">&#34;[&#34;</span>, <span class="s2">&#34;...&#34;</span>, <span class="s2">&#34;]&#34;</span>, ElementType <span class="p">|</span>
                SliceType <span class="p">|</span> MapType <span class="p">|</span> TypeName .
<span class="nv">LiteralValue</span>  <span class="o">=</span> <span class="s2">&#34;{&#34;</span>, <span class="o">[</span> ElementList, <span class="o">[</span> <span class="s2">&#34;,&#34;</span> <span class="o">]</span> <span class="o">]</span>, <span class="s2">&#34;}&#34;</span> .
<span class="nv">ElementList</span>   <span class="o">=</span> KeyedElement, <span class="o">{</span> <span class="s2">&#34;,&#34;</span>, KeyedElement <span class="o">}</span> .
<span class="nv">KeyedElement</span>  <span class="o">=</span> <span class="o">[</span> Key, <span class="s2">&#34;:&#34;</span> <span class="o">]</span>, Element .
<span class="nv">Key</span>           <span class="o">=</span> FieldName <span class="p">|</span> Expression <span class="p">|</span> LiteralValue .
<span class="nv">FieldName</span>     <span class="o">=</span> identifier .
<span class="nv">Element</span>       <span class="o">=</span> Expression <span class="p">|</span> LiteralValue .
</code></pre></div><p>从上到下看，简单解释一下：</p>
<ul>
<li>第 1 行，表示组合字面值由 LiteralType 和 LiteralValue 构成，其中 LiteralType 表示组合字面值的类型，LiteralValue 表示值；</li>
<li>第 2 行，解释 LiteralType，它可以是 <code>=</code> 后面的类型。允许的类型有：结构体、数组、切片、map 等，其中还可以是类似 <code>[…]int</code> 的形式；</li>
<li>第 4 行，解释 LiteralValue，它由一对 <code>{}</code> 包裹，其中包含可选的 ElementList；</li>
<li>第 5 行，解释 ElementList，它由若干 KeyedElement 组成；</li>
<li>第 6 行，解释 KeyedElement，这是<strong>该篇题目的重点之处</strong>。在 EBNF 中，<code>[]</code> 表示这部分是可选的，因此表示具体元素时，一般 Key 可以省略（map 不能省略），这就是通常数组和切片的初始化语法；</li>
</ul>
<p>在这个之后，规范上给出了针对数组和切片字面值的应用规则：</p>
<ol>
<li>数组中的每个元素有一个关联的标记其位置的整数索引。</li>
<li><strong>带键的元素使用该键作为其索引</strong>。这个键必须是可被类型 int 所表示的一个非负常量；而且如果其被赋予了类型的话则必须是整数类型。</li>
<li><strong>不带键的元素使用之前元素的索引加一</strong>。如果第一个元素没有键，则其索引为零。</li>
</ol>
<p>根据以上 3 点，我们很容易知道，在 <code>a := []int{2: 1}</code> 中，我们指定了第 3 个元素（注意索引是从 0 开始的）的值为 1，根据数组/切片的特性，自然存在第 1、2 个元素，没有指定值时，Go 会为其设置默认值。因此这个写法和下面的写法等价：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
</code></pre></div><p>对于第 88 期的题目：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">x</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">88</span><span class="p">}</span>
</code></pre></div><p>指定了第 5 个元素（对应索引是 4），值是 44。根据上面规则的第三点，55、66 都没有指定索引，因此它们的索引是前一个元素的索引加一，即：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="mi">5</span><span class="p">:</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="mi">66</span>
</code></pre></div><p>下一个元素是 <code>1: 77</code>，为其指定了索引 1，因此它的下一元素 88 的索引就是 2 了，因此这个定义相当于如下的定义：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">x</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">88</span><span class="p">}</span>
</code></pre></div><p>同样，因为数组/切片的特性，缺少的元素（索引 0 和 3）值是 0，而整个切片的长度是最大索引加一，即 7。</p>
<h2 id="04-总结">04 总结</h2>
<p>别觉得这道题目恶心，实际中这么写代码可能也确实会被打（当然，第 87 题的写法还是很有可能的）。这里主要是希望大家多掌握一些规范、细节，我想不少人不清楚，原来数组（切片）也可以指定索引进行初始化。语言语法毕竟必须严谨，而这些都在 Go 语言规范里。</p>
<p>延伸思考：第 88 期的题目，如果改为这样结果又如何？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">x</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">4</span><span class="p">:</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">88</span><span class="p">}</span>
</code></pre></div><p>欢迎大胆的留言说出你的答案！</p>
]]></content>
		</item>
		
		<item>
			<title>GoLand 也可以远程开发了：试用报告</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/goland-remote-projector/</link>
			<pubDate>Sat, 27 Mar 2021 15:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/goland-remote-projector/</guid>
			<description>大家好，我是站长 polarisxu。 JetBrains 官方今天发了一篇文章：《使用 Projector 远程访问 IDE》 ，了解到 JetBrains 搞了一个远程开发 IDE。很多人知道 VSCode 可以进行远程开发，现在 JetBrains 系列 IDE 也支持了（自然 GoLand 也支持），于是安装试用了下，给大家做一个汇报。 01 Projector 是什么 Projector 是一种远程运行和访问 Swing GUI 应用程序的技术（Swing 是 Java 的 GUI API，JetBrains 系列 IDE 都是使用 Swing 绘制的 UI），目前 1.0 版本可</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>JetBrains 官方今天发了一篇文章：<a href="https://mp.weixin.qq.com/s/cb8lHQlctpbFTrPKW5YCFA" target="_blank" rel="noopener">《使用 Projector 远程访问 IDE》</a>
，了解到 JetBrains 搞了一个远程开发 IDE。很多人知道 VSCode 可以进行远程开发，现在 JetBrains 系列 IDE 也支持了（自然 GoLand 也支持），于是安装试用了下，给大家做一个汇报。</p>
<h2 id="01-projector-是什么">01 Projector 是什么</h2>
<p>Projector 是一种远程运行和访问 Swing GUI 应用程序的技术（Swing 是 Java 的 GUI API，JetBrains 系列 IDE 都是使用 Swing 绘制的 UI），目前 1.0 版本可用，不过还是预览版（初始版本）。</p>
<p><p class="md__image">
  <img src="../imgs/projector01.png"
    alt="图片来自官方"  />
</p>
</p>
<p>也就是说，Projector  可以通过网络远程运行 JetBrains IDE 和 Swing 应用。</p>
<p>Projector 还是一种自托管技术，可在服务器上运行基于 IntelliJ 的 IDE 和基于 Swing 的应用，让您可以使用浏览器和本机应用从任何位置进行访问。</p>
<p>为什么要开发 Projector 呢？官方解释，在有些特殊情况下，比如瘦客户端，需要采用特殊的方法。具体来说有如下应用场景：</p>
<ul>
<li>高度安全的企业环境。</li>
<li>真正的大型项目。</li>
<li>禁止源代码本地复制。</li>
<li>用户硬件约束。</li>
<li>瘦客户端。</li>
<li>需要在 Windows 机器甚至是 ChromeOS 等非传统操作系统上的 GNU/Linux 环境中运行 IDE。</li>
<li>需要在关闭计算机后让应用在服务器上继续运行。</li>
<li>远程调试服务器端（devtest、devprod）。</li>
<li>具有调试源和预配置 IDE 的 VM 或 Docker 映像。</li>
<li>需要远程访问的配置。</li>
</ul>
<p>可见，有些时候如果能远程开发，确实还挺方便的。</p>
<p>注意，Projector 目前不支持协作开发。</p>
<p>特别值得一提的是，Projector 是开源的，它采用 C-S 架构（其实也支持 B-S 架构），IDE 运行在服务器，客户端通过网络链接到服务器上的 IDE，有点远程桌面的感觉。</p>
<p>因此，Projector 至少包含两部分：</p>
<ul>
<li>服务端，即 projector-server，地址：<a href="https://github.com/JetBrains/projector-server" target="_blank" rel="noopener">https://github.com/JetBrains/projector-server</a>
</li>
<li>客户端，即 projector-client，地址：<a href="https://github.com/JetBrains/projector-client" target="_blank" rel="noopener">https://github.com/JetBrains/projector-client</a>
</li>
</ul>
<p>现在是容器时代，为了方便，官方提供了 Server 的 Docker 版本，地址：<a href="https://github.com/JetBrains/projector-docker" target="_blank" rel="noopener">https://github.com/JetBrains/projector-docker</a>
，我试用就基于 Docker 进行的。</p>
<h2 id="02-安装">02 安装</h2>
<p>关于服务器端安装有多种方式，但这里我只介绍我采用的基于 Docker 的方式。毕竟 Docker 是在云环境中运行 Projector 的最简单的方法。</p>
<p>官方构建好了可以直接使用的镜像，不过没有发布到 DockerHub，而是使用自定义 Docker Registry。因为我使用 GoLand，所以执行如下命令：（记得先安装好 Docker）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker pull registry.jetbrains.team/p/prj/containers/projector-goland
</code></pre></div><p>其他 IDE 怎么安装，官方在 GitHub 上有列出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">docker pull registry.jetbrains.team/p/prj/containers/projector-clion
docker pull registry.jetbrains.team/p/prj/containers/projector-datagrip
docker pull registry.jetbrains.team/p/prj/containers/projector-goland
docker pull registry.jetbrains.team/p/prj/containers/projector-idea-c
docker pull registry.jetbrains.team/p/prj/containers/projector-idea-u
docker pull registry.jetbrains.team/p/prj/containers/projector-phpstorm
docker pull registry.jetbrains.team/p/prj/containers/projector-pycharm-c
docker pull registry.jetbrains.team/p/prj/containers/projector-pycharm-p
docker pull registry.jetbrains.team/p/prj/containers/projector-webstorm
</code></pre></div><p>安装完成后，可以通过下面命令运行 Server：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">docker run --rm -p 8887:8887 -it registry.jetbrains.team/p/prj/containers/projector-goland
</code></pre></div><p>打开浏览器，访问 <code>http://localhost:8887/</code> 即可试用了。这是将 Server 安装在了本地，如果将 Server 安装在性能更好的服务器上，该怎么访问呢？</p>
<p>简单的，可以通过 Nginx 做反向代理，配置好域名。我进行了相关尝试，将 Server 安装在 Linux 服务器，本地使用 Mac。Nginx 的配置如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nginx" data-lang="nginx"><span class="k">server</span> <span class="p">{</span>
        <span class="kn">listen</span> <span class="mi">80</span><span class="p">;</span>
        <span class="kn">server_name</span> <span class="s">goland.studygolang.com</span><span class="p">;</span>

        <span class="kn">location</span> <span class="s">/</span> <span class="p">{</span>
                <span class="kn">proxy_pass</span> <span class="s">http://127.0.0.1:8887</span><span class="p">;</span><span class="c1">#必须
</span><span class="c1"></span>                <span class="kn">proxy_set_header</span> <span class="s">X-Real-IP</span> <span class="nv">$remote_addr</span><span class="p">;</span>
                <span class="kn">proxy_set_header</span> <span class="s">Host</span> <span class="nv">$host</span><span class="p">;</span>
                <span class="kn">proxy_set_header</span> <span class="s">X-Forwarded-For</span> <span class="nv">$proxy_add_x_forwarded_for</span><span class="p">;</span>
                <span class="kn">proxy_http_version</span> <span class="mi">1</span><span class="s">.1</span><span class="p">;</span><span class="c1">#必须
</span><span class="c1"></span>                <span class="kn">proxy_set_header</span> <span class="s">Upgrade</span> <span class="nv">$http_upgrade</span><span class="p">;</span><span class="c1">#必须
</span><span class="c1"></span>                <span class="kn">proxy_set_header</span> <span class="s">Connection</span> <span class="s">&#34;upgrade&#34;</span><span class="p">;</span><span class="c1">#必须
</span><span class="c1"></span>                <span class="kn">proxy_send_timeout</span> <span class="s">30s</span><span class="p">;</span><span class="c1">#send 超时时间 记得一定要按需配置这个 否则默认60s就断开了
</span><span class="c1"></span>                <span class="kn">proxy_read_timeout</span> <span class="s">30s</span><span class="p">;</span><span class="c1">#read 超时时间
</span><span class="c1"></span>        <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>server_name 可以随便配置一个，但不进行实际的解析，而是在本地配置 host；</li>
<li>因为和服务器通讯使用的是 WebSocket，因此需要做 WebSocket 的代理；</li>
</ul>
<p>关于安全问题，可以在 <a href="https://github.com/JetBrains/projector-docker#faq" target="_blank" rel="noopener">https://github.com/JetBrains/projector-docker#faq</a>
 查看，因为我只是试用，所以没有考虑安全问题。</p>
<p>这样在本地通过 <code>http://goland.studygolang.com</code> 就可以打开 GoLand IDE 了。</p>
<h2 id="03-试用">03 试用</h2>
<p>浏览器打开后，会出现如下安全提示，点击确认即可。</p>
<p><p class="md__image">
  <img src="../imgs/projector02.png"
    alt=""  />
</p>
</p>
<p>等待链接建立后，出现用户须知：</p>
<p><p class="md__image">
  <img src="../imgs/projector03.png"
    alt=""  />
</p>
</p>
<p>勾选后，继续。接着提示你是否发送给它们统计数据，你决定即可。</p>
<p>之后出现这个定制界面，默认选中暗黑模式，你可以选择左下角跳过，保留默认。</p>
<p><p class="md__image">
  <img src="../imgs/projector04.png"
    alt=""  />
</p>
</p>
<p>最开始，我以为这种方式可以免费使用 GoLand 了，当看到这一步，嗯，我想多了：</p>
<p><p class="md__image">
  <img src="../imgs/projector05.png"
    alt=""  />
</p>
</p>
<p>这里我们选择免费试用，可以试用 30 天。</p>
<p>接下来的步骤和原生版本的 GoLand 是一样的。</p>
<p>不过有一点尴尬的是，这个镜像中并没有安装 Go，怎么办？我目前的办法是通过 Docker 和宿主机进行目录映射，使用宿主机上的 Go，即这样启动 Docker：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ docker run --rm -p 8887:8887 -it -v xxx:/usr/local/go  registry.jetbrains.team/p/prj/containers/projector-goland
</code></pre></div><p>其中，-v 后面的 xxx 替换为宿主机上的 Go 安装目录，重启启动后，配置好 GOROOT（选择 /usr/local/go），可以正常写代码了：</p>
<p><p class="md__image">
  <img src="../imgs/projector06.png"
    alt=""  />
</p>
</p>
<p>然后可以运行、调试了。</p>
<p>不过浏览器使用感觉不是太爽，官方还提供了原生客户端，即上面说的 client，我们通过这个地址下载一个：<a href="https://github.com/JetBrains/projector-client/releases/tag/launcher-v1.0.1" target="_blank" rel="noopener">https://github.com/JetBrains/projector-client/releases/tag/launcher-v1.0.1</a>
，记得选择适合你操作系统的版本。</p>
<p>安装启动后，长这样：</p>
<p><p class="md__image">
  <img src="../imgs/projector07.png"
    alt=""  />
</p>
</p>
<p>就是一个空壳子。跟浏览器中类似，我们输入地址，然后 Connect。之后的过程和浏览器是一样的。</p>
<p>如果之前在浏览器打开过，这个客户端会直接记忆上次的位置，而不是第一次访问的那些界面，现在看起来是不是跟本地的 GoLand 差不多了：</p>
<p><p class="md__image">
  <img src="../imgs/projector08.png"
    alt=""  />
</p>
</p>
<h2 id="04-感受">04 感受</h2>
<p>试用后，感觉目前还不是太成熟：</p>
<ul>
<li>启动时，有时候会莫名报错，需要重新运行 Server；</li>
<li>用起来不是很流畅；</li>
<li>Mac 下，没有应用全局菜单，设置在 File 菜单下；而且 Command 相关快捷键没作用，必须改用 Control，这会很不习惯；</li>
</ul>
<p>也许还有其他问题，我没有深入使用，毕竟使用起来体验不太好。</p>
<p>不过，JetBrains 说 Projector 是一种技术，而不是最终用户解决方案。你可以使用它来自定义架构，满足您的业务需求。Ansible？Kubernetes？都是没有问题的。</p>
<p>Projector 毕竟刚起步，是一项非常年轻的技术，需要给它一些时间，而且相信开源的力量。JetBrains 有信心，认为它有潜力成为远程 IDE 访问的最佳解决方案之一。</p>
<p>期待 Projector 更好的那一天！！</p>
]]></content>
		</item>
		
		<item>
			<title>送 gRPC 书后续：自我反思和人性的思考</title>
			<link>https://polarisxu.studygolang.com/posts/talk/double-win-after-grpc/</link>
			<pubDate>Thu, 25 Mar 2021 11:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/double-win-after-grpc/</guid>
			<description>大家好，我是站长 polarisxu。 上周在公众号搞了一个送书活动 ，感谢大家的参与，留言数 170+，而微信公众号最多只能放出来 100 个留言，因此有些晚留言的，可能留言没放出来，下次再有活动，大家可以早点参与，我公众号发文时间一般是 18:12。 根据文中的相关规则，第二天就开奖了，中奖的用户一一留言回复了，他们的书也已经收到了。 不过陆续还有人问：这个开奖了吗？据说还有</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>上周在公众号搞了一个<a href="https://mp.weixin.qq.com/s/sWDeK2de5pTLU1wrXYGAIA" target="_blank" rel="noopener">送书活动</a>
，感谢大家的参与，留言数 170+，而微信公众号最多只能放出来 100 个留言，因此有些晚留言的，可能留言没放出来，下次再有活动，大家可以早点参与，我公众号发文时间一般是 <strong>18:12</strong>。</p>
<p>根据文中的相关规则，第二天就开奖了，中奖的用户一一留言回复了，他们的书也已经收到了。</p>
<p>不过陆续还有人问：这个开奖了吗？据说还有群里讨论这个抽奖的公平性。我做了一些解释，但想想还是写篇文章聊聊这件事。</p>
<h2 id="01-自我反思">01 自我反思</h2>
<p>首先，有人询问、有人质疑，说明我有做的不足之处，至少考虑不周，这也算是积累经验。</p>
<p>关于规则，那篇文章说，点赞排行前 20 中抽取 10 位，具体怎么抽，会考虑对我的支持，比如阅读文章、打赏、点赞、转发等。这没有什么大问题，但有一点，开奖后，没有留言置顶，导致没有中奖的人不清楚有没有抽奖，担心是不是我忘记了。</p>
<p>此外，对中奖的用户，我回复留言后，没有将我的留言公开，所以，没中奖的看不到谁中奖了。</p>
<p>所以导致大家有疑问、有质疑。透明公开会更好。</p>
<p>但任何事情，要有心理预期，不可能让所有人满意，尽自己努力做到最好即可，因为。。。</p>
<h2 id="02-人性">02 人性</h2>
<p>最近在学习理财相关的知识，有这么一个小故事，我稍微改了一下：</p>
<blockquote>
<p>比如土拨鼠有一个书：《Go语言编程之旅》，他卖给大象，报价 60 元，大象会觉得贵；但如果这本书是大象的，他卖给土拨鼠，大概率觉得 60 有点便宜，至少不会认为 60 贵。。。</p>
</blockquote>
<p>相信大家明白其中意思了。</p>
<p>对于任何抽奖，大家普遍会有这样的心理：</p>
<blockquote>
<p>中奖者，自然觉得自己很幸运，没啥说的；但未中奖者，多半会怀疑抽奖的公平性，怀疑是不是有内幕？！</p>
</blockquote>
<p>上周我这个抽奖，完全无任何套路，不需要关注一堆公众号，留言就有相当于参与了，就有可能中，完全是给粉丝的福利，所以我没有搞内幕的必要。</p>
<p>但人性使然，所以也无可厚非。更何况有些人可能努力了，比如让朋友帮点赞，结果却没中，内心肯定会失落，很理解。我只能说，以后我还会送书，也许还有机会，但我送书，肯定是希望送给忠实读者的。这就是另外一点。。。</p>
<h2 id="03-双赢">03 双赢</h2>
<p>所谓公平，这个很难说。这就好比上文讲的那个小故事，每个人对公平也会有自己的看法。不说别的，子女们还总是认为父母对自己不公平。</p>
<p>至于抽奖的公平性，我更想通过「双赢」来谈。</p>
<p>首先，我做这个抽奖的初衷或目的是什么？实话说，搞这么一次抽奖（特别是牛年 Go 春晚的抽奖），其实挺费神的。不说别的，联系中奖者，让他们提供收货地址都挺费劲：</p>
<p><p class="md__image">
  <img src="../imgs/double-win-01.png"
    alt=""  />
</p>
</p>
<p>而且回复他后，一天过去了也没后续，我只能想办法通过其他方式提醒他。10 个中奖的，不止一个有这种问题你。。。</p>
<p>我花费时间和精力做这些，自然希望中奖者是我的忠实读者，真正支持我的读者。这是互惠互利的事情，任何「赢输」或「输赢」模式肯定都不合适，而应该是「<strong>双赢</strong>」。这也是我在中奖规则中着重说明的，你经常看我的文章，点个赞，点个在看，留个言，觉得不错转发一下，都是对我最好的支持，我自然更可能把福利给到你。比如这位读者：</p>
<p><p class="md__image">
  <img src="../imgs/double-win-02.png"
    alt=""  />
</p>
</p>
<p>包括 Go 语言中文网站的活跃用户，有福利，我也会优先想到他们：</p>
<p><p class="md__image">
  <img src="../imgs/double-win-03.png"
    alt=""  />
</p>
</p>
<p>所以，我认为的公平是建立在「<strong>双赢</strong>」基础上的。<strong>双赢思维</strong>，这也是高效能人士的七个习惯之一。</p>
<p>欢迎大家「点赞」、「在看」、「转发」和「留言」，<strong>四连的是真爱</strong>。</p>
]]></content>
		</item>
		
		<item>
			<title>阿里云盘公测随想：如何看待竞争</title>
			<link>https://polarisxu.studygolang.com/posts/talk/competition-aliyundriver/</link>
			<pubDate>Mon, 22 Mar 2021 18:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/competition-aliyundriver/</guid>
			<description>大家好，我是站长 polarisxu。 昨天（2021 年 3 月 22 日）阿里云盘公测，声称下载速度 50-100 M/s，网友测试，5G 下确实能达到。而且官方表示，“无论免费收费，未来都不限速”。 朋友圈有人发了这么一段话： 阿里云盘今天公测，下载速度 50-100 MB/s，官方表示：“无论免费收费，未来都不限速” 百度网盘目前用户数已超 7 亿，阿里云盘目前用户数不足千万 阿里云平台目前有 2800+ 的 CDN 节点，全</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>昨天（2021 年 3 月 22 日）阿里云盘公测，声称下载速度 50-100 M/s，网友测试，5G 下确实能达到。而且官方表示，“无论免费收费，未来都不限速”。</p>
<p>朋友圈有人发了这么一段话：</p>
<blockquote>
<p>阿里云盘今天公测，下载速度 50-100 MB/s，官方表示：“无论免费收费，未来都不限速”</p>
<p>百度网盘目前用户数已超 7 亿，阿里云盘目前用户数不足千万</p>
<p>阿里云平台目前有 2800+ 的 CDN 节点，全网带宽传输能力有 150 Tbps</p>
<p>………………</p>
<p>简单算了算，阿里云盘在骗人，就不信未来他们会不限速。。。</p>
<p>不过腾讯不争气已经打输了网盘战，国内现在也只能把屠龙大业寄托在阿里身上了…</p>
</blockquote>
<p>针对不限速，不知道读者朋友们信吗？</p>
<p>想当年，云盘大战时，焦点在容量上。因为竞争异常激烈，各大云盘相互通过加大容量来争夺用户，老周一气之下，直接宣布 360 云盘率无限容量。。。一下把竞争终结了，都无限容量，容量竞争已经无任何意义了。</p>
<p>结果，各大云盘都死了，唯独百度云盘存活。没有了竞争，百度推出了各种付费服务，其中一个关键的点是付费用户和免费用户速度上的差别。前段时间，据说百度云盘在国外免费用户不限速，引起了很多人的不满。。。借此，阿里云一直酝酿着推出阿里云盘。</p>
<p>阿里云盘内测挺长时间了，内测期间，送了内测用户很多容量，有些人容量已经几个 T 了。截止 3 月 17 日内测结束，22 日公测，目前参与公测的用户，默认 100G 的空间，通过做任务还可以获得一年的 300G 使用空间。其中 300G 空间中，有 200G 容量的有效期是一年。我下载试用了，功能比较单一，界面简洁，对我来说挺好的。其实我曾经有过担忧：只有百度云，万一哪天。。。现在多了一个备份。哈哈哈！</p>
<h2 id="01">01</h2>
<p>国内企业之间的竞争，我们普通网民总是会获得一些好处，大家印象特别深的当属当年打车大战和 O2O 大战：几乎免费打车、免费按摩、喝饮料等。</p>
<p>为了圈用户，竞争者们会想尽各种办法。站在用户角度，通常企业有竞争者，对用户是利好的，一家独大，用户没得选，比较被动。</p>
<h2 id="02">02</h2>
<p>国内企业，有些竞争，很难理解。比如之前 360 手机助手会把竞对的应用全部下线，91 助手也会把 360 的应用都下线。我当时一直不理解：用户如果想要使用某个软件，你这里没有，对用户体验是一种伤害，用户会想其他办法下载，甚至会直接不用你这个应用市场了。</p>
<p>但仔细想想，有时候这种做法并非绝对一无是处。也许不清楚是利大于弊还是弊大于利。给大家说两个真实的事情：</p>
<blockquote>
<p>有一年我回老家，看到一个朋友用电脑上网。他打开浏览器，打开百度，然后点击 hao123，接着点击网易，然后找到体育。。。</p>
</blockquote>
<p>你看，普通网名，根本不记得任何网址。你能想到，为什么 hao123 能那么值钱了吧？！</p>
<blockquote>
<p>还有一次，我还在 360 时，我去打印，忘记什么原因聊起来了，我印象中只记得他抱怨说，这个好难用过（是指浏览器，我不说是哪个了，但不是 360）；我问为什么不换一个？原来他根本知道这是什么，只知道这可以用来上网，更别说换一个浏览器了。。。</p>
</blockquote>
<p>大部分人都是小白，你给他用什么，他就会用什么，根本没有到自己主动选择的地步。</p>
<p>所以，可能大部分用户，发现搜不到那个，他不会想着换一个（手机助手），很可能找一个类似的下载了。</p>
<p>不过，我觉得出于对用户负责的角度，应该在下线竞对时，推荐一个和竞对类似的、靠谱的给用户，不能因为小白不懂，就不重视他。</p>
<p>国内的大环境似乎就是如此，你屏蔽我，我屏蔽你。。。</p>
<h2 id="03">03</h2>
<p>这一两年运营公众号，发现也会存在一些竞争的情况。但竞争不总是坏事，公平竞争，不损害别人，我觉得是有利于共同发展的。</p>
<p>大家应该听说过得到，也听说过樊登读书也喜马拉雅。好很多人都说他们是竞争关系，但樊登和罗振宇不这么认为（至少对外是这么说的）。他们认为真正的竞争对手是王者荣耀、抖音等，因为用户的时间是有限的，哪些游戏、短视频抢占了用户时间，让用户没有时间读、听书了。所以，他们一致「对外」，和王者、抖音等抢占用户时间，让读书、听书的盘子越来越大。</p>
<p>到这，我不禁为当年 360 手机助手、91 手机助手等嘘嘘。当年把对方当做竞争对手，殊不知，智能生产商才是他们真正的竞争对手：因为小米、华为等手机，都预装了自己的应用市场，你还有啥存在的必要？！</p>
<p>如果说，经营 Go 圈公众号，谁是竞争对手？当然不应该是 Go 相关公众号号主们，而应该是非 Go 语言的公众号。更进一步，应该是视频号、抖音等非图文消息内容。当然，短视频是大势所趋，但图文消息相信一定有其一席之地。所以，Go 公众号号主们需要的是拓宽自己的粉丝范围，而不只是盯着 Go 已有的粉丝存量，需要做增量，增长永远是第一位的！</p>
<p>从小到大，我们一直在「比」，在竞争：比谁更会吃饭，谁更乖，谁长的更高，谁成绩更好。。。也许，我们应该更多关注共赢，世间很多事情，并非零和博弈，共赢也许常在，关键看你怎么选择！共勉！</p>
]]></content>
		</item>
		
		<item>
			<title>发现 go version 的一个另类用法：你肯定想不到</title>
			<link>https://polarisxu.studygolang.com/posts/go/go-version-detail/</link>
			<pubDate>Fri, 19 Mar 2021 17:50:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/go-version-detail/</guid>
			<description>大家好，我是站长 polarisxu。 对于 go version，大家应该不陌生。在很多入门教程，安装 Go 后，一般会建议执行 go version 看看是否安装成功；亦或遇到问题，别人会问你 Go 哪个版本，你也会通过 go version 命令查看。所以，go version 的一个作用是查看本地使用的 Go 版本。 但实际上，go version 还有其他用途，甚至可以说，输出本地 Go 版本号只是它功能的一个特例。先 go help version 看看： $ go help version usage: go version [-m] [-v] [file ...] Version</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>对于 go version，大家应该不陌生。在很多入门教程，安装 Go 后，一般会建议执行 go version 看看是否安装成功；亦或遇到问题，别人会问你 Go 哪个版本，你也会通过 go version 命令查看。所以，go version 的一个作用是查看本地使用的 Go 版本。</p>
<p>但实际上，go version 还有其他用途，甚至可以说，输出本地 Go 版本号只是它功能的一个特例。先 go help version 看看：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go <span class="nb">help</span> version
usage: go version <span class="o">[</span>-m<span class="o">]</span> <span class="o">[</span>-v<span class="o">]</span> <span class="o">[</span>file ...<span class="o">]</span>

Version prints the build information <span class="k">for</span> Go executables.

Go version reports the Go version used to build each of the named
executable files.

If no files are named on the <span class="nb">command</span> line, go version prints its own
version information.

If a directory is named, go version walks that directory, recursively,
looking <span class="k">for</span> recognized Go binaries and reporting their versions.
By default, go version does not report unrecognized files found
during a directory scan. The -v flag causes it to report unrecognized files.

The -m flag causes go version to print each executable<span class="err">&#39;</span>s embedded
module version information, when available. In the output, the module
information consists of multiple lines following the version line, each
indented by a leading tab character.

See also: go doc runtime/debug.BuildInfo.
</code></pre></div><p>可见这个命令主要是用于输出 Go 可执行文件的编译信息的，只是如果没有提供可执行文件，则输出当前安装的 Go 版本信息。</p>
<p>我们通过一个具体例子来看看 -v、-m 的作用。</p>
<h2 id="01-初始化例子">01 初始化例子</h2>
<p>创建一个 go module 和如下目录结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go mod init github.com/polaris1119/gopher

$ tree .
.
├── cmd
│   ├── bar
│   │   └── main.go
│   └── foo
│       └── main.go
└── go.mod
</code></pre></div><p>其中 main.go 就是一个简单的 Hello World。执行 go install 安装。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">export</span> <span class="nv">GOBIN</span><span class="o">=</span>~/gopher/bin
$ go install github.com/polaris1119/gopher/cmd/...
</code></pre></div><ul>
<li>export GOBIN 是为了将编译的结果放在当前目录的 bin 目录下，而不是默认的 <code>$GOPATH/bin</code> 下</li>
</ul>
<p>成功后，执行 go version bin：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go version bin
bin/bar: go1.16.2
bin/foo: go1.16.2
</code></pre></div><p>而我本地的版本是 1.16.2。可见 <code>go version [file …]</code> 后的 file 可以是目录，这时会递归输出里面的文件的 Go 版本信息。</p>
<h2 id="02--v-选项">02 -v 选项</h2>
<p>我们在 bin 目录下增加一个文本文件 api.txt 和一个可执行文件（php）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ tree bin
bin
├── api.txt
├── bar
├── foo
└── php
</code></pre></div><p>再次运行 go version：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go version bin
bin/bar: go1.16.2
bin/foo: go1.16.2
</code></pre></div><p>结果一样。试试加上 -v 参数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go version -v bin
bin/api.txt: not executable file
bin/bar: go1.16.2
bin/foo: go1.16.2
bin/php: go version not found
</code></pre></div><p>可见 -v 参数能够输出无法识别的文件。</p>
<h2 id="03--m-选项">03 -m 选项</h2>
<p>加上 -m 选项执行：（只看单个二进制文件，也可以跟上面一样是目录）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go version -m bin/foo
bin/foo: go1.16.2
	path	github.com/polaris1119/gopher/cmd/foo
	mod	github.com/polaris1119/gopher	<span class="o">(</span>devel<span class="o">)</span>
</code></pre></div><p>显示出当前二进制包路径和 mod 信息：包名和 devel。devel 表示这个二进制是开发版本。比如我们安装了 dlv，可以看看它的 Go 版本信息：（以下是我本地之前安装的）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go version -m ~/go/bin/dlv
/Users/xuxinhua/go/bin/dlv: go1.16beta1
	path	github.com/go-delve/delve/cmd/dlv
	mod	github.com/go-delve/delve	v1.6.0	h1:NImdy7K9essqNU8sazLhbX/oCicpmlapmjgA3qL1LZM<span class="o">=</span>
	。。。
</code></pre></div><p>它没有 devel，而是具体的版本号（这里是 v1.6.0），<code>h1:NImdy7K9essqNU8sazLhbX/oCicpmlapmjgA3qL1LZM=</code> 这一串和 go.sum 中是一样的，<code>h1:</code> 是固定的，后面一串是 hash，是 Go modules 将目标模块版本的 zip 文件解包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法生成总的 hash 值。</p>
<p>下面，我们修改一下 cmd/foo/main.go 文件：（如果没有引入依赖，可以 go mod tidy 引入下）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;github.com/polaris1119/foo&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nf">Bar</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><p>然后 go install 安装：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go install github.com/polaris1119/gopher/cmd/...
</code></pre></div><p>再次 -m 选项看看：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go version -m bin/foo
bin/foo: go1.16.2
	path	github.com/polaris1119/gopher/cmd/foo
	mod	github.com/polaris1119/gopher	<span class="o">(</span>devel<span class="o">)</span>
	dep	github.com/polaris1119/foo	v0.4.0	h1:fgXsULdtXQmElR8Qor10s29CQbeA1pjSa/Cj0kB2Aas<span class="o">=</span>
</code></pre></div><p>dep 表明该二进制程序依赖了 github.com/polaris1119/foo 这个包，版本是 v0.4.0 ，h1 hash 是 fgXsULdtXQmElR8Qor10s29CQbeA1pjSa/Cj0kB2Aas=，这个信息和 go.mod 中是一致的。</p>
<h2 id="04-总结">04 总结</h2>
<p>现在如果有一个 Go 语言实现的二进制程序，我们可以通过 go version 命令分析出它使用的 Go 版本信息，以及依赖包的信息。有些时候也许需要了解这些信息。</p>
]]></content>
		</item>
		
		<item>
			<title>map 和 switch 如何选？match 又是什么？</title>
			<link>https://polarisxu.studygolang.com/posts/go/choose-map-or-switch/</link>
			<pubDate>Wed, 17 Mar 2021 23:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/choose-map-or-switch/</guid>
			<description>大家好，我是站长 polarisxu。 看到标题别惊讶，虽然 map 和 switch 似乎没啥关系，但有些场景它们俩都可以用。 场景一：根据不同的错误码显示对应错误消息，比如 200 -&amp;gt; 正常。 场景二：根据不同状态显示对应的文案。这个场景很常见，比如数据库保存状态，用的 tinyint 类型，显示给用户的是文本，所以需要进行转换。 具体怎么选？我们看一下代码，怎么选择应该一目了然。 const ( UnPay = iota HadPay Delivery Finish ) var orderState = map[int]string{ UnPay: &amp;</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>看到标题别惊讶，虽然 map 和 switch 似乎没啥关系，但有些场景它们俩都可以用。</p>
<p>场景一：根据不同的错误码显示对应错误消息，比如 200 -&gt; 正常。</p>
<p>场景二：根据不同状态显示对应的文案。这个场景很常见，比如数据库保存状态，用的 tinyint 类型，显示给用户的是文本，所以需要进行转换。</p>
<p>具体怎么选？我们看一下代码，怎么选择应该一目了然。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">UnPay</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">HadPay</span>
	<span class="nx">Delivery</span>
	<span class="nx">Finish</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">orderState</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
	<span class="nx">UnPay</span><span class="p">:</span>    <span class="s">&#34;未支付&#34;</span><span class="p">,</span>
	<span class="nx">HadPay</span><span class="p">:</span>   <span class="s">&#34;已支付&#34;</span><span class="p">,</span>
	<span class="nx">Delivery</span><span class="p">:</span> <span class="s">&#34;配送中&#34;</span><span class="p">,</span>
	<span class="nx">Finish</span><span class="p">:</span>   <span class="s">&#34;已完成&#34;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// map 实现
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">OrderStateMap</span><span class="p">(</span><span class="nx">state</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">orderState</span><span class="p">[</span><span class="nx">state</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// switch 实现
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">OrderStateSwitch</span><span class="p">(</span><span class="nx">state</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">stateDesc</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>

	<span class="k">switch</span> <span class="nx">state</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">UnPay</span><span class="p">:</span>
		<span class="nx">stateDesc</span> <span class="p">=</span> <span class="s">&#34;未支付&#34;</span>
	<span class="k">case</span> <span class="nx">HadPay</span><span class="p">:</span>
		<span class="nx">stateDesc</span> <span class="p">=</span> <span class="s">&#34;已支付&#34;</span>
	<span class="k">case</span> <span class="nx">Delivery</span><span class="p">:</span>
		<span class="nx">stateDesc</span> <span class="p">=</span> <span class="s">&#34;配送中&#34;</span>
	<span class="k">case</span> <span class="nx">Finish</span><span class="p">:</span>
		<span class="nx">stateDesc</span> <span class="p">=</span> <span class="s">&#34;已完成&#34;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">stateDesc</span>
<span class="p">}</span>
</code></pre></div><p>“大人，有结果了吗？”</p>
<p>从这个例子看，用 map 代码更少，可读性更好，而且用 map 管理这个映射关系语义上也更符合实际。</p>
<p>所以，我为什么写文章提这一点呢？</p>
<p>别急，我们先对以上两种实现做一下基准测试。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BenchmarkSwitch</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">OrderStateSwitch</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="nf">OrderStateSwitch</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nf">OrderStateSwitch</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
		<span class="nf">OrderStateSwitch</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BenchmarkMap</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">N</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
		<span class="nf">OrderStateMap</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="nf">OrderStateMap</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="nf">OrderStateMap</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
		<span class="nf">OrderStateMap</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>结果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go <span class="nb">test</span> -bench<span class="o">=</span>.
goos: darwin
goarch: amd64
pkg: test/map
cpu: Intel<span class="o">(</span>R<span class="o">)</span> Core<span class="o">(</span>TM<span class="o">)</span> i5-8259U CPU @ 2.30GHz
BenchmarkSwitch-8   	1000000000	         0.2868 ns/op
BenchmarkMap-8      	70925238	        16.91 ns/op
PASS
ok  	test/map	2.153s
</code></pre></div><p>switch 版本比 map 版本快了近 60 倍。此外，要较真的话，map 版本还用了一个 map 数据结构，占用额外的空间。</p>
<p>性能差别这么大，其实通过汇编可以看到 map 版本调用了一个 runtime.mapaccess2 _ fast64(SB) 函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">0x001d <span class="m">00029</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	MOVQ	<span class="s2">&#34;&#34;</span>.orderState<span class="o">(</span>SB<span class="o">)</span>, AX
0x0024 <span class="m">00036</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	LEAQ	type.map<span class="o">[</span>int<span class="o">]</span>string<span class="o">(</span>SB<span class="o">)</span>, CX
0x002b <span class="m">00043</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	MOVQ	CX, <span class="o">(</span>SP<span class="o">)</span>
0x002f <span class="m">00047</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	MOVQ	AX, 8<span class="o">(</span>SP<span class="o">)</span>
0x0034 <span class="m">00052</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	MOVQ	<span class="s2">&#34;&#34;</span>.state+48<span class="o">(</span>SP<span class="o">)</span>, AX
0x0039 <span class="m">00057</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	MOVQ	AX, 16<span class="o">(</span>SP<span class="o">)</span>
0x003e <span class="m">00062</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	PCDATA	<span class="nv">$1</span>, <span class="nv">$0</span>
0x003e <span class="m">00062</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	NOP
0x0040 <span class="m">00064</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	CALL	runtime.mapaccess1_fast64<span class="o">(</span>SB<span class="o">)</span>
0x0045 <span class="m">00069</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	MOVQ	24<span class="o">(</span>SP<span class="o">)</span>, AX
0x004a <span class="m">00074</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	MOVQ	<span class="o">(</span>AX<span class="o">)</span>, CX
0x004d <span class="m">00077</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	MOVQ	8<span class="o">(</span>AX<span class="o">)</span>, AX
0x0051 <span class="m">00081</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	MOVQ	CX, <span class="s2">&#34;&#34;</span>.~r1+56<span class="o">(</span>SP<span class="o">)</span>
0x0056 <span class="m">00086</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	MOVQ	AX, <span class="s2">&#34;&#34;</span>.~r1+64<span class="o">(</span>SP<span class="o">)</span>
0x005b <span class="m">00091</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	MOVQ	32<span class="o">(</span>SP<span class="o">)</span>, BP
0x0060 <span class="m">00096</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	ADDQ	<span class="nv">$40</span>, SP
0x0064 <span class="m">00100</span> <span class="o">(</span>main_test.go:22<span class="o">)</span>	RE
</code></pre></div><p>而 switch 版本只是普通的指令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">0x0000 <span class="m">00000</span> <span class="o">(</span>main_test.go:28<span class="o">)</span>	MOVQ	<span class="s2">&#34;&#34;</span>.state+8<span class="o">(</span>SP<span class="o">)</span>, AX
0x0005 <span class="m">00005</span> <span class="o">(</span>main_test.go:28<span class="o">)</span>	CMPQ	AX, <span class="nv">$1</span>
0x0009 <span class="m">00009</span> <span class="o">(</span>main_test.go:28<span class="o">)</span>	JGT	<span class="m">66</span>
0x000b <span class="m">00011</span> <span class="o">(</span>main_test.go:29<span class="o">)</span>	TESTQ	AX, AX
0x000e <span class="m">00014</span> <span class="o">(</span>main_test.go:29<span class="o">)</span>	JNE	<span class="m">39</span>
0x0010 <span class="m">00016</span> <span class="o">(</span>main_test.go:29<span class="o">)</span>	MOVL	<span class="nv">$9</span>, AX
0x0015 <span class="m">00021</span> <span class="o">(</span>main_test.go:29<span class="o">)</span>	LEAQ	go.string.<span class="s2">&#34;未支付&#34;</span><span class="o">(</span>SB<span class="o">)</span>, CX
0x001c <span class="m">00028</span> <span class="o">(</span>main_test.go:39<span class="o">)</span>	MOVQ	CX, <span class="s2">&#34;&#34;</span>.~r1+16<span class="o">(</span>SP<span class="o">)</span>
0x0021 <span class="m">00033</span> <span class="o">(</span>main_test.go:39<span class="o">)</span>	MOVQ	AX, <span class="s2">&#34;&#34;</span>.~r1+24<span class="o">(</span>SP<span class="o">)</span>
0x0026 <span class="m">00038</span> <span class="o">(</span>main_test.go:39<span class="o">)</span>	RET
0x0027 <span class="m">00039</span> <span class="o">(</span>main_test.go:28<span class="o">)</span>	CMPQ	AX, <span class="nv">$1</span>
0x002b <span class="m">00043</span> <span class="o">(</span>main_test.go:31<span class="o">)</span>	JNE	<span class="m">59</span>
0x002d <span class="m">00045</span> <span class="o">(</span>main_test.go:31<span class="o">)</span>	MOVL	<span class="nv">$9</span>, AX
0x0032 <span class="m">00050</span> <span class="o">(</span>main_test.go:31<span class="o">)</span>	LEAQ	go.string.<span class="s2">&#34;已支付&#34;</span><span class="o">(</span>SB<span class="o">)</span>, CX
0x0039 <span class="m">00057</span> <span class="o">(</span>main_test.go:32<span class="o">)</span>	JMP	<span class="m">28</span>
0x003b <span class="m">00059</span> <span class="o">(</span>main_test.go:32<span class="o">)</span>	XORL	AX, AX
0x003d <span class="m">00061</span> <span class="o">(</span>main_test.go:32<span class="o">)</span>	XORL	CX, CX
0x003f <span class="m">00063</span> <span class="o">(</span>main_test.go:32<span class="o">)</span>	NOP
0x0040 <span class="m">00064</span> <span class="o">(</span>main_test.go:28<span class="o">)</span>	JMP	<span class="m">28</span>
0x0042 <span class="m">00066</span> <span class="o">(</span>main_test.go:33<span class="o">)</span>	CMPQ	AX, <span class="nv">$2</span>
0x0046 <span class="m">00070</span> <span class="o">(</span>main_test.go:33<span class="o">)</span>	JNE	<span class="m">86</span>
0x0048 <span class="m">00072</span> <span class="o">(</span>main_test.go:33<span class="o">)</span>	MOVL	<span class="nv">$9</span>, AX
0x004d <span class="m">00077</span> <span class="o">(</span>main_test.go:33<span class="o">)</span>	LEAQ	go.string.<span class="s2">&#34;配送中&#34;</span><span class="o">(</span>SB<span class="o">)</span>, CX
0x0054 <span class="m">00084</span> <span class="o">(</span>main_test.go:34<span class="o">)</span>	JMP	<span class="m">28</span>
0x0056 <span class="m">00086</span> <span class="o">(</span>main_test.go:35<span class="o">)</span>	CMPQ	AX, <span class="nv">$3</span>
0x005a <span class="m">00090</span> <span class="o">(</span>main_test.go:35<span class="o">)</span>	JNE	<span class="m">59</span>
0x005c <span class="m">00092</span> <span class="o">(</span>main_test.go:35<span class="o">)</span>	MOVL	<span class="nv">$9</span>, AX
0x0061 <span class="m">00097</span> <span class="o">(</span>main_test.go:35<span class="o">)</span>	LEAQ	go.string.<span class="s2">&#34;已完成&#34;</span><span class="o">(</span>SB<span class="o">)</span>, CX
0x0068 <span class="m">00104</span> <span class="o">(</span>main_test.go:36<span class="o">)</span>	JMP	<span class="m">28</span>
</code></pre></div><p>“大人，有结果了吗？”</p>
<p>似乎应该使用 switch，它性能好呀！这就需要在可读性和性能之间做一个权衡。看到一篇文章说，<a href="https://mp.weixin.qq.com/s/jJM0N5yk9kk4w92yI8jjoQ" target="_blank" rel="noopener">优化 Go 程序的性能就是浪费时间</a>
，通常更应该优化的是可读性。不管这个观点如何，但程序的可读性确实很重要。如果性能没那么关键，或提升对整个程序性能作用不大，我们通常应该先考虑可读性。</p>
<p>很显然这种场景，map 会是更好的选择。</p>
<p>其实在 Go 标准库中有类似这样的使用场景，比如 net/http 包中的 <a href="https://docs.studygolang.com/src/net/http/status.go?s=7372:7404#L150" target="_blank" rel="noopener">StatusText</a>
 函数，它根据状态码获得对应的说明；还有连接状态对应 <a href="https://docs.studygolang.com/src/net/http/server.go?s=90775:90809#L2859" target="_blank" rel="noopener">ConnState</a>
 的说明：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">stateName</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="nx">ConnState</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
	<span class="nx">StateNew</span><span class="p">:</span>      <span class="s">&#34;new&#34;</span><span class="p">,</span>
	<span class="nx">StateActive</span><span class="p">:</span>   <span class="s">&#34;active&#34;</span><span class="p">,</span>
	<span class="nx">StateIdle</span><span class="p">:</span>     <span class="s">&#34;idle&#34;</span><span class="p">,</span>
	<span class="nx">StateHijacked</span><span class="p">:</span> <span class="s">&#34;hijacked&#34;</span><span class="p">,</span>
	<span class="nx">StateClosed</span><span class="p">:</span>   <span class="s">&#34;closed&#34;</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">ConnState</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">stateName</span><span class="p">[</span><span class="nx">c</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p>特别是当需要映射的内容很多时，更应该使用的 map 方式，毕竟看到一大堆 case 会疯掉。</p>
<p>题外话：可能正是因为类似的需求很常见，而 switch 似乎太繁琐，于是 Rust 中没有 switch，而是提供了 match 表达式，Rust 代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">enum</span> <span class="nc">State</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">	</span><span class="n">Unpay</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">HadPay</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">Delivery</span><span class="p">,</span><span class="w">
</span><span class="w">	</span><span class="n">Finish</span><span class="p">,</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">OrderState</span><span class="p">(</span><span class="n">state</span>: <span class="nc">State</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="kt">str</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">State</span>::<span class="n">Unpay</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;未支付&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">State</span>::<span class="n">HadPay</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;已支付&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">State</span>::<span class="n">Delivery</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;配送中&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">State</span>::<span class="n">Finish</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s">&#34;已完成&#34;</span><span class="p">,</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">OrderState</span><span class="p">(</span><span class="n">State</span>::<span class="n">Unpay</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>PHP 在 8.0 也提供了 match 表达式，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="nv">$orderState</span> <span class="o">=</span> <span class="nx">match</span><span class="p">(</span><span class="nv">$state</span><span class="p">)</span> <span class="p">{</span>
  <span class="mi">0</span> <span class="o">=&gt;</span> <span class="s1">&#39;未支付&#39;</span><span class="p">,</span>
  <span class="mi">1</span> <span class="o">=&gt;</span> <span class="s1">&#39;已支付&#39;</span><span class="p">,</span>
  <span class="mi">2</span> <span class="o">=&gt;</span> <span class="s1">&#39;配送中&#39;</span><span class="p">,</span>
  <span class="mi">3</span> <span class="o">=&gt;</span> <span class="s1">&#39;已完成&#39;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>match 表达式是不是很 map 的方式很像？！</p>
<p>总结一下：开发时，尽量优先考虑可读性，在必要时才进行性能优化，而且要保证优化确实是能带来较大收益的。</p>
]]></content>
		</item>
		
		<item>
			<title>优化Go应用性能就是在浪费时间？</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/golang-slower/</link>
			<pubDate>Wed, 17 Mar 2021 20:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/golang-slower/</guid>
			<description>原文标题：Writing slower Go programs。作者认为应该优化可读性，而不是优化性能。你认可吗？一起看下该文。本文不代表 Go语言中文网 的观点。 什么？写更慢的 Go 程序？难道我们不应该关注如何让 Go 程序更快吗？ 实际不是的。为了性能而优化 Go 代码几乎肯定在浪费你的时间，原因有以下几点： 性能并不重要（Performance doesn&amp;rsquo;t matter）； Go 本身就够快； 可读性胜过速度； 以</description>
			<content type="html"><![CDATA[<blockquote>
<p>原文标题：Writing slower Go programs。作者认为应该优化可读性，而不是优化性能。你认可吗？一起看下该文。本文不代表 Go语言中文网 的观点。</p>
</blockquote>
<p><p class="md__image">
  <img src="../imgs/slower.png"
    alt=""  />
</p>
</p>
<p>什么？写更慢的 Go 程序？难道我们不应该关注如何让 Go 程序更快吗？</p>
<p>实际不是的。为了性能而优化 Go 代码几乎肯定在浪费你的时间，原因有以下几点：</p>
<ul>
<li>性能并不重要（Performance doesn&rsquo;t matter）；</li>
<li>Go 本身就够快；</li>
<li>可读性胜过速度；</li>
</ul>
<p>以上几个简短的陈述，有些人可能不服，所以需要做一些阐述。需要说明的是，并非全部如此，肯定存在例外情况，这里只说大部分时候。而且，这三点很难在工程师中达成共识。所以，你可以随意发表你的看法，甚至可以说这是有史以来最垃圾的文章，但还是继续读下去吧。</p>
<h2 id="性能并不重要">性能并不重要</h2>
<p>对于我们大多数人编写的大多数程序来说，它们执行的速度到底有多快并不重要。例如，以下是我最近参与的一些项目：</p>
<ul>
<li>网站链接检查器（抓取网站，以找到和报告中断的链接）</li>
<li>Terraform 提供程序（通过 Terraform 代码管理站点监视检查）</li>
<li>数据分析器（下载和计算监测数据的统计表）</li>
<li>站点迁移工具（在服务器之间移动网站文件和数据库）</li>
</ul>
<p>所有这些程序运行相对较少（可能一天一到两次），运行时间很短（一到两分钟）。这样的情况，值得花费任何工程上的努力让它们变得更快吗？几乎可以肯定不值得。（如果你已经被说服了，你可以停止阅读，但我觉得我可能需要再多说一点。）</p>
<p>即使在我们关心程序快速运行的极少数情况下，问题也不在于 Go 代码。例如，链接检查器 99% 的时间都花在等待 HTTP 请求上。Terraform 提供者将大部分时间用于对远程 API 进行通信和监听。站点迁移工具的瓶颈是通过网络复制数千兆字节的 tarballs。</p>
<p>因此，如果我们确实需要对这些程序进行性能优化，我们不会在 Go 级别进行这种优化。CPU 比内存访问快得离谱，内存访问比磁盘访问快得多，磁盘访问比网络访问快得多，网络访问比交互式用户快得多。因此，代码的执行速度可能是我们最不需要担心的事情。</p>
<h3 id="当每个-nsop-都很重要时">当每个 ns/op 都很重要时</h3>
<p>“等一下，伙计，我正在编写 3D 游戏，而且我的预算非常紧张。每十亿分之一秒都很重要，而你却说我不用担心性能？你是大笨蛋吧？”</p>
<p>没有。游戏是这个规则的一个合理的例外，因为游戏代码的某些小部分（例如着色器）是速度的关键。不过，请注意，即使在这里我们也引入了一个警告：性能只对游戏代码的一个小子集有影响。除非您从头开始编写 3D 引擎（不要这样做)），否则您自己的代码不太可能成为框架绘制的瓶颈。</p>
<h3 id="你不是谷歌也不是太空人">你不是谷歌，也不是太空人</h3>
<p>但是大多数 Go 程序不是游戏。还有其他例外吗？是的：网络服务器，如 web 服务器和 api 有性能关键部分。在一个大型、复杂的分布式系统中，总体请求延迟非常重要，因此每个子系统的延迟可以下降到纳秒。再说一次，你和我都不太可能编写这样的程序，当我们这样做的时候，我们最好知道我们在做什么。（polarisxu 译注：但 Web 和 API 开发可是 Go 目前主要的战场）</p>
<p>当然，还有很多特殊用途的嵌入式系统需要速度，比如 i/o 驱动程序，实时硬件，比如卫星和工业控制系统，我允许你对所有这些进行例外处理，但是我坚定地认为它们并不代表典型的 Go 程序员的 Go 程序。（polarisxu 译注：我无言以对）</p>
<h2 id="go-本身够快">Go 本身够快</h2>
<p>即使性能不是大多数程序的主要考虑因素，但这并不意味着我们不应该考虑它。作为程序员，您所做的选择会影响程序的性能，包括内存和磁盘使用以及原始速度。有可能编写的程序执行得非常糟糕，以至于它们使用起来很慢，令人恼火，或者浪费资源，比如一次性将整个文件读入内存，而不是一行一行地处理它。</p>
<p>然而，一般来说 Go 程序是相当快速和高效的。如果你是从 Ruby、 PHP 或 Python 这样的解释性语言开始转向 Go 的，那么 Go 可以简单地快速运行。这主要是因为它是一门编译语言。任何解释器，无论多么聪明或多么经过优化，都无法与编译成纯机器代码的某些东西的性能相匹配。</p>
<h3 id="轻装上阵">轻装上阵</h3>
<p>编译后的 Go 程序也很小。解释器又大又复杂，在开始执行程序之前，它们需要做大量的工作来解释程序。您需要将解释器与程序一起分发。</p>
<p>相比之下，Go 二进制文件只包含程序本身的机器代码，加上 Go 运行时，后者提供了 goroutine 和垃圾收集等功能。这使得 Go 程序在内存和磁盘使用方面更轻松，执行更快，并且易于构建、打包和分发。</p>
<h3 id="首选需要优化的是选择合适的语言">首选需要优化的是选择合适的语言</h3>
<p>因此，我们通常不需要太担心我们的代码在 Go 中的性能，因为我们从一个非常快的基线开始，感谢 Go 的编译本质。当然，有更快的编译语言，但这不是重点。如果性能对您的应用程序非常重要，那么不要浪费时间调整和优化您的 Go 代码: 只要使用不同的语言就可以了。我听说 C++ 很不错。</p>
<h2 id="可读性胜过速度">可读性胜过速度</h2>
<p>是这样的。大多数程序花在阅读上的时间比执行上的时间要多得多。而且程序员花费的时间比 CPU 花费的时间要多得多（祝你好运找到一个每小时 5 美分的开发人员）。那么，为了可读性而不是为了原始速度而优化程序是否有意义呢？</p>
<p>当然，我们希望我们的程序可读性和速度快一样好，而这通常是可能的。但是，当我们的工程师告诉我们：“嘿，我可以通过使用数组而不是 map，并使用键的低阶位计算索引，使每通电话的速度提高几纳秒” 时，重要的是要考虑我们放弃了什么来换取这几纳秒。</p>
<h3 id="一切的成本一无所有的价值">一切的成本，一无所有的价值</h3>
<p>每一次优化都是一次权衡。当我们权衡速度和内存时，我们失去的通常是：</p>
<ul>
<li>简洁。有更多的代码，所以很难阅读</li>
<li>清晰。这是如何工作的不再明显</li>
<li>简单。更多的功能，更多的抽象，更多的数据结构读取和理解</li>
</ul>
<p>教会自己可读性价值的一个很好的方法是尝试阅读别人的代码。作为开发人员，我们通常不会做很多这样的事情，我们可能要么自己编写代码，要么深度参与这些代码，所以我们很清楚这一切是为了什么，以及它们是如何组合在一起的。我们甚至可以感觉到随着时间的推移，由于需求和特性更新的变化，它是如何变化的。</p>
<h3 id="黑暗中一座陌生的房子">黑暗中一座陌生的房子</h3>
<p>当您第一次查看代码时，您不会有任何上下文。这就像在黑暗的房间里跌跌撞撞，被电线绊倒，脚趾被意想不到的家具绊到。“那是什么鬼东西?” 在 GitHub 上浏览任何大型的 Go 项目，你就会明白我的意思。（你从哪个文件开始读？一个重要的程序有开头吗?）</p>
<p>现在，如果一个程序不能做很多事情，就很容易让它变得简单。有些程序是复杂的，因为问题域是复杂的（Kubernetes）。我们写的任何东西都有一定的不可避免的复杂性。但这并不意味着要用聪明的、狡猾的、超优化的代码进一步模糊它。相反，它建议我们应该尽一切可能使我们的代码尽可能简单、直接和明显。</p>
<h3 id="写更好的代码更少的注释">写更好的代码，更少的注释</h3>
<p>对于一般的 Go 程序员来说，在任何级别都可以进入你的任何函数，并且或多或少地了解这些代码的用途和工作原理。我这么说并不是说你应该在上面写上大量的注释。只有当我们已经做了所有可能的事情来使代码变得简单和明显，并且在某种程度上写注释就是承认失败时，我们才应该使用注释。它在说: “我知道你不会理解我写的东西，所以我试图用另一种方式来解释它。”</p>
<p>我是第一个承认说起来容易做起来难的人。编写简单的代码很难。首先，为了向任何人解释一个概念，你需要自己理解它。要向计算机解释它，你需要彻底地了解它。事实往往并非如此。</p>
<h3 id="你为什么讨厌乐趣">你为什么讨厌乐趣？</h3>
<p>另一方面，针对性能的调优代码既有趣又简单。我们都很享受。很多时候，我们就像醉汉在灯柱下面找钥匙，尽管他实际上把钥匙掉在了别的地方: 这里的光线比较好。我们看到一些东西可以很容易地优化和制造得更快，所以我们就这么做了。就像《侏罗纪公园》里的科学家们一样，我们总是全神贯注于我们是否能做到，我们不会停下来思考我们是否应该做到。</p>
<p>其次，我们之所以成为工程师，是因为我们喜欢聪明，喜欢做别人想不到的聪明、狡猾、巧妙的事情。在我们自己的私人项目和游戏时间里这样做是完全合法的。商业软件工程是完全不同的。“清晰比聪明更好（Clear is better than clever）”，Go 谚语如是说，这句话很好地概括了我的整个信息。</p>
<h3 id="禅心初心">禅心，初心</h3>
<p>作为<a href="https://bitfieldconsulting.com/golang/learn" target="_blank" rel="noopener">一个 Go 导师和老师</a>
，我发现那些刚接触编程的人对这个想法没有任何困难。所有的代码一开始对他们来说都是莫名其妙的，所以他们完全同意这个想法，认为这对其他人来说可能也是困难的。他们不会被自己的聪明才智或者作为一个热门程序员的身份所束缚，所以他们乐于编写简单、优雅、直截了当的代码来实现自己的目标。</p>
<p>相比之下，对其他语言有丰富经验的人有时会很难掌握 Go 的简单性。如果它们来自像 Ruby 这样的解释性语言，它们倾向于以复杂的、不明显的、高度个性化的方式表达自己，而这些语言是允许的。如果他们来自 C++ 和 Java 的世界，他们编写的代码在一般的 Gopher 看来是荒谬的过度工程化。那边就是这么办事的。在许多情况下，当他们知道这不是 Go 的方式时，他们实际上松了一口气。</p>
<h2 id="结论放慢你的脚步兄弟">结论：放慢你的脚步，兄弟</h2>
<p>“慢行”运动，如果我可以把这句话换成一个词的话，就是做得更少，更简单，做得更慢。</p>
<p>当然，我并不主张让程序不必要地慢下来。我想说的是，首先，你不需要像你想的那样担心性能问题。当你这样做的时候，通常有比编写晦涩难懂的代码更容易的方法来改进它。</p>
<p>其次，您应该比现在更多地关注简单性和可读性。当你考虑优化的时候，这就是你应该优化的。花一个小时来提高可读性。</p>
<p>第三，愿意在可读性上投资。如果你可以重构你的程序，让它显著地更清晰，代价是让它稍微慢一点，那么就去做吧。当性能很重要的时候，记住它不是免费的。如果您考虑为代码增加额外的复杂性以追求纯粹的速度（这里是一个特例，那里是一个聪明的位旋转技巧），那么请再考虑一下。你总是可以买到一台更快的电脑，但是你很难买到一个更快的大脑。</p>
<blockquote>
<p>原文链接：https://bitfieldconsulting.com/golang/slower</p>
<p>作者：John Arundel</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>周末看完这本 gRPC 的书后，我决定送 10 本给读者</title>
			<link>https://polarisxu.studygolang.com/posts/grpc/grpc-cncf-with-go-and-java/</link>
			<pubDate>Tue, 16 Mar 2021 10:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/grpc/grpc-cncf-with-go-and-java/</guid>
			<description>大家好，我是站长 polarisxu。 牛年春晚，Go语言中文网组织的活动，送了 10 本 《gRPC与云原生应用开发：以Go和Java为例》。上周末，我翻了下这本书，决定对该书做一个介绍，同时再送 10 本给我的读者。 01 gRPC 是什么？ 这是一本关于 gRPC 的书，所以简单介绍下 gRPC 是什么，相信很多人不陌生。 2015 年 2 月 26 日，谷歌宣布开源 gRPC，并称其「基于公司多年的分布式系统构建经验」。因为</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>牛年春晚，Go语言中文网组织的活动，送了 10 本 《gRPC与云原生应用开发：以Go和Java为例》。上周末，我翻了下这本书，决定对该书做一个介绍，同时再送 10 本给我的读者。</p>
<p><p class="md__image">
  <img src="../imgs/grpc-book.png"
    alt=""  />
</p>
</p>
<h2 id="01-grpc-是什么">01 gRPC 是什么？</h2>
<p>这是一本关于 gRPC 的书，所以简单介绍下 gRPC 是什么，相信很多人不陌生。</p>
<p>2015 年 2 月 26 日，谷歌宣布开源 gRPC，并称其「基于公司多年的分布式系统构建经验」。因为在这之前，谷歌使用一个名为 Stubby 的通用 RPC 基础设施连接其数据中心内部和跨中心运行的大量微型服务已有十多年，可以认为 gRPC 是 Stubby 的下一个版本。自那之后，人们给 gRPC 贴上了许多漂亮的「标签」：<strong>极速、高性能、微服务间通信首选、多语言支持、双向流模式、protobuf、HTTP/2 等等。</strong></p>
<p>借用官方的一张图展示 gRPC 多端交互：</p>
<p><p class="md__image">
  <img src="../imgs/grpc-diagram.svg"
    alt="Concept Diagram"  />
</p>
</p>
<p>关于 gRPC，官方一句话描述是：</p>
<blockquote>
<p>A high performance, open source universal RPC framework</p>
</blockquote>
<p>gRPC 官网：<a href="https://grpc.io/" target="_blank" rel="noopener">https://grpc.io/</a>
，目前已经是 CNCF 的孵化项目。</p>
<h2 id="02-grpc-的应用场景">02 gRPC 的应用场景</h2>
<p>总的来说，gRPC 可以高效地连接数据中心内部和跨数据中心的服务，并为负载平衡、跟踪、健康检查和身份验证提供可插拔的支持。它也适用于最后一英里的分布式计算连接设备，移动应用程序和浏览器的后端服务。主要使用场景有：</p>
<ul>
<li>在微服务风格的体系结构中有效连接多语言服务；</li>
<li>连接移动设备、浏览器客户端和后端服务；</li>
<li>开发与云服务器通信的移动客户端；</li>
<li>构建高可扩展、低延迟的分布式系统和微服务；</li>
<li>设计一个新的协议，需要准确，高效和语言独立；</li>
<li>分层设计，以支持扩展，例如身份验证、负载平衡、日志记录和监控等；</li>
<li>。。。</li>
</ul>
<h2 id="03-grpc-的主要优点">03 gRPC 的主要优点</h2>
<p>相比 RESTful 服务或其他 RPC 框架，gRPC 有哪些突出的优点？</p>
<p>1）极速</p>
<p>gRPC 使用 protocol buffers（简称 protobuf）作为消息编码格式。protobuf 的特点是语言中立、平台无关、高可扩展，它可以序列化和反序列化结构化数据。</p>
<p>与采用文本格式的 JSON 相比，采用二进制格式的 protobuf 在速度上可以达到<strong>前者的 5 倍</strong>！</p>
<p>2）使用 HTTP/2</p>
<p>gRPC 使用 HTTP/2 作为传输协议。我们来看看 HTTP/2 与 HTTP/1.X 相比有何优势。</p>
<ul>
<li>二进制传输</li>
<li>多路复用，即可以在一个 TCP 连接上并行发送多个数据请求</li>
<li>双向同时通信，即可以同时发送客户端请求和服务器端响应</li>
<li>头部压缩技术，降低网络使用率</li>
</ul>
<p>3）多语言支持、社区活跃</p>
<p>目前，gRPC 支持 11 种语言，GitHub 项目总星数近 6 万，其中 Go 实现和J ava 实现的星数最多。</p>
<ul>
<li>Go</li>
<li>Java</li>
<li>C#</li>
<li>C++</li>
<li>Dart</li>
<li>Kotlin/JVM</li>
<li>Node</li>
<li>Objective-C</li>
<li>PHP</li>
<li>Python</li>
<li>Ruby</li>
</ul>
<p>此外，gRPC 还支持多平台，比如 Web、Android，以及 Flutter、iOS 等。</p>
<h2 id="04-grpc-与云原生应用开发">04 gRPC 与云原生应用开发</h2>
<p>拿到这本书时，我是有点吃惊的：我去，这么薄呢！？翻开一看，才 160 页，而实际正文大概 150 也左右。但当我阅读该书时，发现虽然篇幅不长，但包含的内容还是挺多的。</p>
<p>本书一共 8 章，章节内容如下：</p>
<p><strong>第 1 章 gRPC 入门</strong></p>
<p>介绍 gRPC 的基础知识，并将它与 REST、GraphQL 和其他 RPC 技术等类似的进程间通信风格进行对比。</p>
<p><strong>第 2 章 开始使用 gRPC</strong></p>
<p>通过一个具体例子，完整的体验 gRPC 应用程序，而且是同时使用 Go 和 Java 实现。</p>
<p><strong>第 3 章 gRPC 的通信模式</strong></p>
<p>通过真实的示例探索 gRPC 的通信模式，包括一元 RPC 模式、服务器端流 RPC 模式、客户端流 RPC 模式、双向流 RPC 模式。</p>
<p><strong>第 4 章 gRPC 的底层原理</strong></p>
<p>作为一个合格的码农，我们不能停留在简单使用上，否则换工作面试后怎么办？！即使不面试，作为一个“上进”的码农，我们也应该了解了解 gRPC 的底层原理，而这章就设计相关知识。</p>
<p><strong>第 5 章 超越基础知识</strong></p>
<p>这一章属于应用的进阶。讲解了 gRPC 的一些非常重要的高级特性，如拦截器、截止时间、元数据、多路复用、负载均衡等。</p>
<p><strong>第 6 章 安全的 gRPC</strong></p>
<p>互联网时代，安全是很重要的。本章带你全面理解如何保护通信通道、如何认证以及如何控制用户对 gRPC 应用程序的访问。</p>
<p><strong>第 7 章 在生产环境中运行 gRPC</strong></p>
<p>学习完前面的章节，你大概已经搞定了 gRPC 服务。接下来就该测试、上线部署了。本周讲解 gRPC 应用程序的整个开发生命周期，包括测试 gRPC 应用程序、与 CI/CD 集成、在 Docker 和 Kubernetes 上部署与运行。</p>
<p><strong>第 8 章 gRPC 的生态系统</strong></p>
<p>最后一章介绍 gRPC 相关的支撑组件，得益于 gRPC 的可扩展性，社区有很不错的组件可用，这些构成了 gRPC 的生态。在实际项目中，这些生态组件会很有用哦。</p>
<p>附上一张我整理的评价微服务框架好坏的思维导图，供参考：</p>
<p><p class="md__image">
  <img src="../imgs/microserivce-framework-is-goods.png"
    alt=""  />
</p>
</p>
<h2 id="05-重点来了送书">05 重点来了：送书</h2>
<p>相信你是冲着白嫖来的，但我希望你看了上面我啰嗦的内容。</p>
<p>如何得到该书？借用书中的一个小点：<strong>留言说说 gPRC 中的 g 代表什么</strong>。2021 年 3 月 17 日 22 点前，从留言点赞最多的 20 位中随机选 10 位幸运小伙伴。（我会<strong>优先送给本公众号的忠实读者</strong>，包括经常阅读我的文章，转发、点赞、在看、留言、打赏等互动行为，因为后台是可以看到的哦！所以，<strong>对本文来个四连吧，很可能中奖的就是你了</strong>！）</p>
<p>（注意：以上只针对 「polarisxu」公众号，其他渠道无效）</p>
<p>最后也欢迎大家直接通过扫码购买本书。支持本书，支持中文翻译者。</p>
<p><p class="md__image">
  <img src="../imgs/grpc-dangdang.jpeg"
    alt=""  />
</p>
</p>
]]></content>
		</item>
		
		<item>
			<title>微信 Mac 版 3.0 支持浏览朋友圈：划水更方便了</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/mac-wechat-3.0/</link>
			<pubDate>Fri, 12 Mar 2021 00:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/mac-wechat-3.0/</guid>
			<description>大家好，我是站长 polarisxu。 有些人应该已经知晓，微信流出了 Mac 的 3.0 Beta 版本。为什么说流出呢？因为微信官网并没有提供下载。访问：https://mac.weixin.qq.com/ ，发现测试版本还是 2.6.1。 01 简单介绍下 3.0 版本的新功能。 Mac 的 3.0 版本安装后会显示一个弹窗，可以看到更新信息： 其中第一条就是：可以浏览朋友圈。在主窗口的左侧有一个朋友圈入口，如下图</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>有些人应该已经知晓，微信流出了 Mac 的 3.0 Beta 版本。为什么说流出呢？因为微信官网并没有提供下载。访问：<a href="https://mac.weixin.qq.com/" target="_blank" rel="noopener">https://mac.weixin.qq.com/</a>
，发现测试版本还是 2.6.1。</p>
<p><p class="md__image">
  <img src="../imgs/wexin-guanwang.png"
    alt=""  />
</p>
</p>
<h2 id="01">01</h2>
<p>简单介绍下 3.0 版本的新功能。</p>
<p>Mac 的 3.0 版本安装后会显示一个弹窗，可以看到更新信息：</p>
<p><p class="md__image">
  <img src="../imgs/wechat-3.0.0-changes.png"
    alt=""  />
</p>
</p>
<p>其中第一条就是：可以浏览朋友圈。在主窗口的左侧有一个朋友圈入口，如下图：</p>
<p><p class="md__image">
  <img src="../imgs/wechat-3.0.0-pengyouquan.png"
    alt=""  />
</p>
</p>
<p>点击后会弹出一个新的窗口：</p>
<p><p class="md__image">
  <img src="../imgs/wechat-3.0.0-ppengyouquan2.png"
    alt=""  />
</p>
</p>
<p>这就是你的朋友圈。在这里可以浏览，可以评论、点赞。。。</p>
<p>新版本是不是大大方便了大家上班划水？！不过，微信这么做目的肯定不是为了方便大家划水，我感觉目的主要是为了进一步推广它的视频号。因为在朋友圈中，别人发布的视频号视频，点击会直接进入视频号播放其视频，可以点赞、评论等。</p>
<p>关于推广视频号，还有一个重要的更新，那就是可以浏览聊天中的视频号视频，甚至可以参与视频号直播。你喜欢吗？不过实话说，我更在意，啥时候解决下电脑端微信抢红包呀，因为上班都损失好几个亿了。。。</p>
<p>此外，这次更新还实现了暗黑模式，可以根据需要自己设置。</p>
<h2 id="02">02</h2>
<p>说起视频号，2020 年，微信的推广力度是真的大。以上介绍的更新再一次说明对视频号支持的力度。除此之外，不知道大家是否注意到，在订阅号消息列表页顶部左侧，增加了一个提醒：有时候是朋友在看，有时候是朋友赞过。。。我开始后以为是曝光一些公众号呢，仔细一看，原来是曝光视频号，在订阅号列表都不放过曝光视频号，可见。。。不知道这个入口有多少人点击过！</p>
<p><p class="md__image">
  <img src="../imgs/wechat-3.0.0-mp.png"
    alt=""  />
</p>
</p>
<p>说这么多，我想说的是，如果你对做视频感兴趣，可以尝试尝试视频号，说不定能收获一大票粉丝哦！</p>
<h2 id="03">03</h2>
<p>如果你想尝试 Mac 3.0，可以关注本公众号，回复 wechat 获取安装包。</p>
]]></content>
		</item>
		
		<item>
			<title>快一个月，Go1.16 才发现了比较严重的 Bug，但这个 Bug 有点 Low。。。</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go1.16.1-release/</link>
			<pubDate>Thu, 11 Mar 2021 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go1.16.1-release/</guid>
			<description>大家好，我是站长 polarisxu。 Go 1.16 是 2021 年 2 月 16 日发布的。新版本发布，大家一般会等等，坐等 1.16.1 发布。没想到快一个月了才等到。 和之前一样，小版本是修复 Bug，会同时发布两个版本，这次是 Go1.16.1 和 Go1.15.9。那具体什么 Bug 呢？ Bug 1：encoding/xml 包相关 这个 Bug 不是 1.16 引入的，而是之前版本就存在。所以，Go 1.15.9 也修复了该 Bug。 具体是：在通过 xml.NewTokenDecoder 获得一个 Decoder 指针时</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>Go 1.16 是 2021 年 2 月 16 日发布的。新版本发布，大家一般会等等，坐等 1.16.1 发布。没想到快一个月了才等到。</p>
<p>和之前一样，小版本是修复 Bug，会同时发布两个版本，这次是 Go1.16.1 和 Go1.15.9。那具体什么 Bug 呢？</p>
<h2 id="bug-1encodingxml-包相关">Bug 1：encoding/xml 包相关</h2>
<p>这个 Bug 不是 1.16 引入的，而是之前版本就存在。所以，Go 1.15.9 也修复了该 Bug。</p>
<p>具体是：在通过 xml.NewTokenDecoder 获得一个 Decoder 指针时，如果参数 TokenReader 是自定义的，可能会出现死循环。</p>
<blockquote>
<p>The Decode, DecodeElement, and Skip methods of an xml.Decoder provided by xml.NewTokenDecoder may enter an infinite loop when operating on a custom xml.TokenReader which returns an EOF in the middle of an open XML element.</p>
</blockquote>
<p>详情见 issue：<a href="https://github.com/golang/go/issues/44915" target="_blank" rel="noopener">https://github.com/golang/go/issues/44915</a>
。</p>
<h2 id="bug-2archivezip-包相关">Bug 2：archive/zip 包相关</h2>
<p>当调用该包中的 Render.Open 方法时，如果 zip 包含以 <code>../</code> 开头的文件，该方法会 panic。这个方法是 Go1.16 新增的，因为返回了 io/fs.File 类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reader</span><span class="p">)</span> <span class="nf">Open</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>当跟踪修复该 Bug 的代码时，有点掉价。。。（见：<a href="https://github.com/golang/go/commit/634d28d78ccbeb6e86f8bfeba030ea8be518f8fa" target="_blank" rel="noopener">https://github.com/golang/go/commit/634d28d78ccbeb6e86f8bfeba030ea8be518f8fa</a>
）</p>
<p><p class="md__image">
  <img src="..//Users/xuxinhua/opensource/polarisxu/content/posts/go/dynamic/imgs/go1.16.1.png"
    alt=""  />
</p>
</p>
<p>完整的修复前的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">toValidName</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">ReplaceAll</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="s">`\`</span><span class="p">,</span> <span class="s">`/`</span><span class="p">)</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Clean</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">):]</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;../&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="p">=</span> <span class="nx">p</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="s">&#34;../&#34;</span><span class="p">):]</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>
</code></pre></div><p>通过 for 循环处理 p 中的 <code>../</code>，结果 for 里面用的却是 name 变量，这个 bug 有点 low。。。可见大神们也有犯低级错误的时候。所以，如果你团队成员偶尔犯了低级错误，别太责备，让他抄写对应 Bug 100 遍即可，哈哈哈哈！</p>
<p>以上两个 Bug 都定义为安全问题。Go Team 正在为 Go 版本中的漏洞提出一个新的安全策略。有兴趣的可以参与讨论：<a href="https://github.com/golang/go/issues/44918" target="_blank" rel="noopener">https://github.com/golang/go/issues/44918</a>
。</p>
<hr>
<p>如果你使用了 Go1.16，而且可能用了 zip 包，建议大家升级到 Go1.16.1 版本。而 xml，可能很多人都没用到？！Go 语言中文网已经为你准备好了下载地址：<a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a>
，当然也可以使用喜欢的方式升级。</p>
]]></content>
		</item>
		
		<item>
			<title>RedMonk 编程语言排行榜，说 Go 正走向衰退，你认可吗？</title>
			<link>https://polarisxu.studygolang.com/posts/go/language-rankings-1-21/</link>
			<pubDate>Wed, 10 Mar 2021 14:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/language-rankings-1-21/</guid>
			<description>大家好，我是站长 polarisxu。 2021 年 3 月 1 日，RedMonk 发布了 2021 年 1 月 编程语言排行榜（实际是 1 月 和 2 月的数据）。 先介绍下这个排名的依据。RedMonk 从 GitHub 和 Stack Overflow 中提取语言排名，并将它们合并为一个排名，试图反映代码（GitHub）和问答（Stack Overflow）的吸引力。这个想法并不是为了提供一个统计上有效的当前使用情况的表示，而是为了将语言的问答</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>2021 年 3 月 1 日，RedMonk 发布了 2021 年 1 月 编程语言排行榜（实际是 1 月 和 2 月的数据）。</p>
<p>先介绍下这个排名的依据。RedMonk 从 GitHub 和 Stack Overflow 中提取语言排名，并将它们合并为一个排名，试图反映代码（GitHub）和问答（Stack Overflow）的吸引力。这个想法并不是为了提供一个统计上有效的当前使用情况的表示，而是为了将语言的问答和使用联系起来，努力提取对潜在的未来使用趋势的洞察。</p>
<h2 id="01">01</h2>
<p>那这个排名具体是怎么得来的呢？</p>
<p>对于 GitHub，使用的数据源是 GitHub Archive（即某个具体归档点，参考：<a href="https://archiveprogram.github.com/" target="_blank" rel="noopener">https://archiveprogram.github.com/</a>
）。</p>
<ul>
<li>基于仓库的主语言；</li>
<li>排除了 fork；</li>
<li>使用聚合历史来确定排名；</li>
</ul>
<p>对于 Stack Overflow，使用其有用的数据浏览器工具收集所需的指标。</p>
<p>一些注意事项：</p>
<ul>
<li>要包含在这个分析中，必须是 GitHub 和 Stack Overflow 中都有的语言；</li>
<li>这里没有说这些排名代表了它的广泛使用程度。它们只不过是对两个人群之间相互关系的检验，相信这两个人群可以预测未来的使用情况，因此它们具有一定价值；</li>
<li>有许多潜在的社区可以被用来进行这种分析。选择使用 GitHub 和 Stack Overflow 是因为它们的规模，其次是因为它们公开了分析所需的数据。然而，RedMonk 鼓励有关各方使用其他数据来源进行自己的分析；</li>
<li>所有的数字排名都应该加了一些盐值。在这里严格按照数字排名是为了引起兴趣。一般来说，数字排名和语言的层次或分组无关。在许多情况下，列表中的一个点与下一个点是无法区分的。</li>
<li>排名越下降，可用于语言排名的数据就越少。</li>
<li>那些在 Stack Overflow 之外拥有社区的语言，如 Mathematica，在这个轴上的代表性不足。衡量 100 个不同社区站点的过程是不可能的，一方面是因为许多站点没有可用的公共指标，另一方面是因为不同社区站点之间的相互衡量在统计学上是不正确的；</li>
</ul>
<h2 id="02">02</h2>
<p>RedMonk 提供了一个图表：</p>
<p><p class="md__image">
  <img src="../imgs/redmonk-rank.png"
    alt=""  />
</p>
</p>
<p>但这张图，看起来挺费劲的。于是 RedMonk 提供了一份数字排名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="m">1</span> JavaScript
<span class="m">2</span> Python
<span class="m">3</span> Java
<span class="m">4</span> PHP
<span class="m">5</span> C#
<span class="m">5</span> C++
<span class="m">5</span> CSS
<span class="m">8</span> TypeScript
<span class="m">9</span> Ruby
<span class="m">10</span> C
<span class="m">11</span> Swift
<span class="m">12</span> R
<span class="m">13</span> Objective-C
<span class="m">14</span> Shell
<span class="m">14</span> Scala
<span class="m">16</span> Go
<span class="m">17</span> PowerShell
<span class="m">18</span> Kotlin
<span class="m">19</span> Rust
<span class="m">19</span> Perl
</code></pre></div><p>接着 RedMonk 对这个排名和上次的变化做了分析。这里着重看看对 Go 语言的分析：</p>
<blockquote>
<p>首先，Go 语言相比上次下降了一位。RedMonk 提到，Go 的排名不如它的发展轨迹重要，也就是说，Go 的排名没那么重要，关键在于它的发展轨迹。RedMonk 认为，在经历了最初的快速增长期，并在 2018 年以第 14 位的排名达到顶峰之后，Go 语言充其量只是一种静止的语言，可以说<strong>正在走向衰落</strong>。</p>
</blockquote>
<p>这结论也太草率了吧？排名降了一点，就说它走向衰退了？RedMonk 进一步解释：</p>
<blockquote>
<p>这其中的一些原因可以 Go 的应用市场相对于其他语言来说更窄。Red Monk 认为，Java 是后端应用程序的主要竞争对手，在经历了这么多年的服务之后，它仍然是一种非常重要且被广泛使用的语言，而不是逐渐消失。</p>
</blockquote>
<p>用 Java 做对比，似乎无法反驳？然而，毕竟 Java 这么多年了，体量和生态在那摆着。想想世界上最好的语言 PHP，在这个名单中依然排在第 4，但国内普遍还是认为 PHP 在走下坡路。很多 PHPer 都在学习 Go。</p>
<p>RedMonk 进一步提到说，如果 Go 希望成为真正的行业力量，必须做一些改变。文中提到要在 path 和 structure 上改变。实话说，不知道这指的是什么。</p>
<p>不可否认，世界上没有银弹，Go 自然也有它的不足，哪门语言不是呢？！但 Go 这几年越来越受欢迎，肯定由它的原因。我从 Go 语言中文网的流量数据以及这几年国内大厂的招聘情况，很明显的感觉到，Go 在国内热度持续上升，甚至上升的速度比之前更快！</p>
<h2 id="03">03</h2>
<p>此外 RedMonk 还有对其他一些语言的分析、评价，整体上，我很不认可通过这个排名做出的一些判断（哈哈哈，不知道有没有个人情感因素在里面）。你怎么认为？欢迎交流！</p>
<blockquote>
<p>详细排名和分析见 <a href="https://redmonk.com/sogrady/2021/03/01/language-rankings-1-21/" target="_blank" rel="noopener">https://redmonk.com/sogrady/2021/03/01/language-rankings-1-21/</a>
</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>polarisxu 对话无闻</title>
			<link>https://polarisxu.studygolang.com/posts/dialogue/vs-wuwen/</link>
			<pubDate>Mon, 08 Mar 2021 15:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/dialogue/vs-wuwen/</guid>
			<description>大家好，我是站长 polarisxu。 今天起，我计划起一个系列，叫做「对话 xxx」，主要访谈、撰写一些圈里人的成长故事，希望他们的故事对大家有一些启发。 今天要对话的这位是国内 Go 开源界的名人，GitHub followers 有 11.1k+，主导了开发了好几个 Go 开源项目，它就是无闻，昵称 unknwon（注意，不是 unknown）。早期学习 Go 的小伙伴，知道他可能更多是来自他的视频教程</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天起，我计划起一个系列，叫做「对话 xxx」，主要访谈、撰写一些圈里人的成长故事，希望他们的故事对大家有一些启发。</p>
<p>今天要对话的这位是国内 Go 开源界的名人，GitHub followers 有 11.1k+，主导了开发了好几个 Go 开源项目，它就是无闻，昵称 unknwon（注意，不是 unknown）。早期学习 Go 的小伙伴，知道他可能更多是来自他的视频教程。不管什么方式，希望本文对有些读者有帮助。</p>
<h2 id="01-与-go-结缘">01 与 Go 结缘</h2>
<p>早在无闻读高中时，我们就认识了（没见过面，网上认识）。因为我接触 Go 比较早，2012~2013 年就创建了 Go 社区。具体怎么联系上的，不记得了。</p>
<p>2013 年上半年，他开始制作 Go 语言视频教程，我印象特别深的是，那年清明节左右，我在度蜜月，还每天和他交流 Go 语言，主要探讨视频制作的知识点，他很严谨，怕知识点讲解有误，和我交流、探讨确认。一口气，他制作了 <a href="https://github.com/Unknwon/go-fundamental-programming" target="_blank" rel="noopener">《Go编程基础》</a>
、<a href="https://github.com/Unknwon/go-rock-libraries-showcases" target="_blank" rel="noopener">《Go 名库讲解》</a>
、<a href="https://github.com/Unknwon/go-web-foundation/tree/v1" target="_blank" rel="noopener">《Go Web基础》</a>
等视频教程。所以早期学习 Go 的小伙伴，很多都是看无闻的视频入门的。</p>
<p>但很多人也许不知道，他的这些视频是边学 Go 边制作的，这就是所谓的通过输出做到更好的输入，教别人是最有效的学习方法。</p>
<p>当然在这背后还隐藏着其他不为人知的故事。</p>
<h3 id="其一vba-起家">其一：VBA 起家</h3>
<p>无闻是一个文科生，是不是很惊讶？2010 年就出国，在国外读的高中。因为 2 点半就放学，很无聊，然后研究 Excel。有些人也许不知道，Excel 是支持编程的，那就是 VBA（Visual Basic for Applications），这是一种宏语言。基于 VBA 做了一个简单的账本。这算是编程的入门。</p>
<p>学了 VBA 后，不满足于它，可能也对编程产生了兴趣，同时由于 VBA 算是 VB 的子集，所以又去学习了 VB 6.0。用 VB 6.0 做了一些工具，在网上也得到了一些前辈友善的指导，这让他拓展了很大的知识面。</p>
<p>接着，无闻还学习了易语言，对，没错，就是那个中文语言。易语言是 C++ 实现的，但它和 VB 一样，提供了很多方便的编程接口，包括提供方便的图形化编辑环境，使得有 VB 基础的学习易语言比较容易。</p>
<h3 id="其二做视频教程学习-go">其二：做视频教程，学习 Go</h3>
<p>2011 年开始学习 C#，在学习 C# 的过程中，就一边学习一边做视频教程。所以，Go 视频教程才会做的比较好。</p>
<p>那时正是 Web 2.0 比较火的时候，Web 开发是比较受欢迎的。无闻发现，PHP 是那时候 Web 开发最欢迎的。于是准备学习 PHP，相关图书都买好了（寄到国外的哦）。但无意中，他在 GitHub 上看到了 <a href="https://github.com/astaxie/build-web-application-with-golang" target="_blank" rel="noopener">https://github.com/astaxie/build-web-application-with-golang</a>
 这本书，捣鼓了一下 Go，发现它的运行方式和易语言很像（都是编译为二进制文件）。因为自己有强迫症，而 Go 语言的工具链很好的解决了这些问题，不再有选择的痛苦，大家写的代码风格几乎一样。</p>
<p>于是 2013 年无闻开始学 Go 语言，并做了上面的视频教程和翻译一些 Go 资料，比如国外另外一本讲解很全面的 Go 语言图书：《The Way to Go》，无闻向作者要到了授权，翻译成中文，在 GitHub 上免费提供给大家阅读，目前已经有 25.1k+ Star：<a href="https://github.com/unknwon/the-way-to-go_ZH_CN" target="_blank" rel="noopener">https://github.com/unknwon/the-way-to-go_ZH_CN</a>
。</p>
<p>我总结一下无闻的 Go 学习之路：</p>
<ul>
<li>通过 VBA 进入编程世界；</li>
<li>因为易语言和 C# 的视频制作经验，爱上 Go 并制作了优秀的视频教程；</li>
<li>通过制作更多的 Go 视频教程，翻译优秀教程以及名库讲解，打好自己的 Go 基础，同时回馈 Go 社区；</li>
</ul>
<h2 id="02-开源之旅">02 开源之旅</h2>
<p>做开源可能是一种巧合，因为对 Git 的喜爱，加上 GitHub 私有库是收费的（现在他已经是 GitHub PRO，而且在 GitHub 上赞助其他人），同时 Go 语言的生态都是基于 GitHub。所以，那时候只是知道将自己的代码放在 GitHub 上公开，并不知晓这原来就是开源。</p>
<p>后来对开源接触越来越多，发现开源项目都比较优秀，有一些管理相关的模板。</p>
<p>对于 <a href="https://github.com/gogs/gogs" target="_blank" rel="noopener">gogs</a>
 这个开源项目，主要对 Ruby 不太喜欢，不太喜欢笨重的环境，虽然有 GitLab，但想要用 Go 实现一个。因此和朋友一起开始搞 gogs。</p>
<p>在做 gogs 时，无闻对数据库还是一无所知的状态。有着强烈学习的意愿，开发 gogs 的过程中，涉及到很多的基础东西，都从头实现了一遍。比如：</p>
<ul>
<li>github.com/go-macaron/macaron：一个 Web 框架，以及其他一些框架的设施，都是自己从头实现；</li>
<li>github.com/go-ini/ini：超赞的 Go 语言 INI 文件操作库；</li>
<li>github.com/go-macaron/i18n：gogs 是一个国际项目，自然需要国际化；</li>
<li>github.com/unknwon/cae：类似 PHP 风格的压缩和归档库；</li>
<li>github.com/unknwon/com：一些经常使用的便利函数；</li>
<li>github.com/go-clog/clog：基于 channel 的日志库；</li>
<li>。。。</li>
</ul>
<p>除了 gogs，还有其他一些知名的项目，比如 <a href="https://gowalker.org/" target="_blank" rel="noopener">gowalker</a>
、gopm（已关停）等。所有这些，都是它在学习、实践过程中遇到了问题，然后自己将它解决掉。可能解决方案不是最好的，甚至市面上已经有其他解决方案了，但自己实现它，给无闻带来的收益是巨大的。</p>
<p>大家可能没有注意，他的开源项目，很多都有漂亮的网站或独立文档站，而且基本这些站也是自己实现的。因为开源项目，文档很重要，于是他用 Go 实现了一个，这就是 <a href="https://github.com/peachdocs/peach" target="_blank" rel="noopener">peach</a>
：一个用于多语言，实时同步和可搜索文档的 Web 服务器。</p>
<p><p class="md__image">
  <img src="../imgs/peach.png"
    alt=""  />
</p>
</p>
<p>他实现这些，顺便把前端相关技术也学习了。</p>
<p>参与开源，不一定一上来就是参与者，也可以是反馈者，通过反馈慢慢融入这个项目，实际上将问题反馈清楚也是一种挑战。</p>
<p>无闻的理念：自己学习阶段，通过造轮子，把自己往“死”里整，什么新技术都尽量用上，多想想这项技术解决了什么问题，通过项目提升自己能力。</p>
<h2 id="03-划重点">03 划重点</h2>
<p>通过对无闻步入编程世界，回顾了他学习 Go 语言的经历，以及进行 Go 开源的心得体会，我认为有以下几点值得大家借鉴，特别是对于后浪们，比如还是在校学生。</p>
<h3 id="一越早学习越好">一、越早学习越好</h3>
<p>在股票基金投资中，很强调时间，因为复利效应很可怕。学习也是一样。对于编程学习来说，你开始的越早，就越早的走在同辈的前列，比如无闻，虽然是文科生，但高中就开始接触编程，并自发的进行各种学习、研究，做视频、做项目，进行主动学习。我特别欣赏那些还在读书的人能够积极融入各种社区的圈子。不管是开源项目，还是社区的一些活动、群等，其中有大学生的话，我会特别注意他，觉得他前途无量。</p>
<p>想想我的大学生活，只是沉浸在校园生活中，对业界发生的事情一无所知。这注定起点就比那些早早接触外界的人低。所以，我强烈建议你现在就开始认真学习，无闻经历也许可以借鉴。</p>
<p>而且，你越早学习，越早了解外界，越早工作，你的能力、薪资等大概率会比同龄人强。何况都说程序员吃青春饭，所以更应该提前学习。尽早多接触外界，外界的人和事。</p>
<h3 id="二兴趣是最好的老师">二、兴趣是最好的老师</h3>
<p>工作很多时候是为了生活，但你不能全无兴趣。而且，我认为兴趣也是可以培养的，要善于发现生活的美。只要你不讨厌它，慢慢的，你大概率可以喜欢它。大家可以想想生活中，你看到一个女生，觉得一般，时间长了，接触多了，有没有觉得还挺好看的，属于耐看型？哈哈哈哈，对吧，需要培养！</p>
<p>无闻能够做这么多项目，我相信一定是对这些事情是有兴趣的，而且做成了很有成就感，更进一步增加了兴趣。抱着喜欢它去学习，而不是太功利的，目标就是通过它找到一个好工作。其实只要你学好了，学透了，好工作是自然的。</p>
<h3 id="三通过输出倒逼输入">三、通过输出倒逼输入</h3>
<p>学习别只是看。无闻的经历很明显，他通过边学习边做视频，进步很快。你不一定非得做视频，但至少应该做做笔记，写写文章。写出来的东西，一定通过网络发布，比如微信公众号，这样督促自己更严谨。</p>
<p>其次，一定要实践。你别跟我说：不知道用 Go 写点什么。那是你根本没有思考，对自己不够狠。能写的东西很多。再不济，参与一些你喜欢的开源项目也可以，比如提提 typo 也是可以的，关键要迈出第一步。</p>
<p>认清自己，看自己的长处。通过输出，倒逼自己输入，让输入更高效！</p>
<p>希望通过「对话无闻」能够对大家有帮助！</p>
]]></content>
		</item>
		
		<item>
			<title>妹子你是认真的吗？.sh 文件只能在 Shanghai 机器跑</title>
			<link>https://polarisxu.studygolang.com/posts/talk/sh-is-shanghai/</link>
			<pubDate>Wed, 03 Mar 2021 11:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/sh-is-shanghai/</guid>
			<description>大家好，我是 polarisxu。 看到这样一条消息： 妹子你太有才了，想象力一流呀~网友纷纷评论：今日最佳。 基于此，网友们脑洞大开，说出来只有程序员才能听懂的“段子”： 压缩一下可以放在广州或兰州跑； .bat 文件大概率是 BAT 出身的程序员写的吧；亦或是只有 BAT 公司才能用？ 如果 .py 文件该作何解释？ .php 文件呢？ .rb 果然是日本人发明的，只能在日本才能打开； 。。。 当然，也有人说妹子就是故意</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>看到这样一条消息：</p>
<p><p class="md__image">
  <img src="../imgs/sh-joke.png"
    alt=""  />
</p>
</p>
<p>妹子你太有才了，想象力一流呀~网友纷纷评论：今日最佳。</p>
<p>基于此，网友们脑洞大开，说出来只有程序员才能听懂的“段子”：</p>
<ul>
<li>压缩一下可以放在广州或兰州跑；</li>
<li>.bat 文件大概率是 BAT 出身的程序员写的吧；亦或是只有 BAT 公司才能用？</li>
<li>如果 .py 文件该作何解释？</li>
<li>.php 文件呢？</li>
<li>.rb 果然是日本人发明的，只能在日本才能打开；</li>
<li>。。。</li>
</ul>
<p>当然，也有人说妹子就是故意卖个萌，活跃下群气氛，如果你这都不懂，注定单身。。。</p>
<p>其实，隔行如隔山，一个运营，对于程序员的那些细节，不懂很正常。其实我们碰到一些行外的东西，也可能出现第一反应，以为是那个。</p>
<p>其中有一个哥们说，一直以为 jpg 是 japanese girl 的缩写。。。我只能说：老哥，你的英语学的真好。</p>
<p>这年头，缩写满天飞，让人琢磨不透，难怪前些人国家国定不能用缩写，必须全称。现在社交软件是我们每天都需要用的交流工具，各种缩写让人无语，不知道都怀疑自己是不是 out 了。</p>
<p>你不信？随便给你几个，看你知道什么意思不？</p>
<ul>
<li>hgr</li>
<li>gc</li>
<li>gzs</li>
<li>rnb</li>
<li>。。。</li>
</ul>
<p>面对这样乱七八糟的缩写怎么办？程序员真是一个伟大的群体，遇到问题总会想着用程序解决。这不，有网友写了一个工具，叫：「能不能好好说话？」，GitHub 地址：<a href="https://github.com/itorr/nbnhhsh" target="_blank" rel="noopener">https://github.com/itorr/nbnhhsh</a>
（项目名称也是有点意思），还提供了一个可以直接查询的界面：<a href="https://lab.magiconch.com/nbnhhsh/" target="_blank" rel="noopener">https://lab.magiconch.com/nbnhhsh/</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/nbnhhsh.png"
    alt=""  />
</p>
</p>
<p>今天你有好好说话吗？dddd~</p>
]]></content>
		</item>
		
		<item>
			<title>构建微服务的 10 大 Go 框架/库</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/top-10-framework-golang-library-to-build-microservice/</link>
			<pubDate>Tue, 02 Mar 2021 22:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/top-10-framework-golang-library-to-build-microservice/</guid>
			<description>现在，很多开源库都支持构建应用程序。我应该向你推荐一些库，它们可以帮助启动具有简单设计、干净代码和良好性能的项目。 01 CLI 命令(spf13/cobra) 你想要构建一些 CLI 命令吗？ Cobra 既是一个用于创建强大的现代 CLI 应用程序的库，也是一个用于生成应用程序和命令文件的程序。 我使用这个库来管理命令应用程序，执行运行程序，初始化配置，并启动 Rest API。 基于 cobra 的应用组织结构： ├──</description>
			<content type="html"><![CDATA[<p><p class="md__image">
  <img src="../imgs/10-top-framework.png"
    alt=""  />
</p>
</p>
<p>现在，很多开源库都支持构建应用程序。我应该向你推荐一些库，它们可以帮助启动具有简单设计、干净代码和良好性能的项目。</p>
<h2 id="01-cli-命令spf13cobra">01 CLI 命令(spf13/cobra)</h2>
<p><p class="md__image">
  <img src="../imgs/cobra.png"
    alt=""  />
</p>
</p>
<p>你想要构建一些 CLI 命令吗？</p>
<blockquote>
<p>Cobra 既是一个用于创建强大的现代 CLI 应用程序的库，也是一个用于生成应用程序和命令文件的程序。</p>
</blockquote>
<p>我使用这个库来管理命令应用程序，执行运行程序，初始化配置，并启动 Rest API。</p>
<p>基于 cobra 的应用组织结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">├── app
│ ├── main.go
│ ├── cmd
│ └── root.go
</code></pre></div><p>app/main.go 的代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;app/cmd&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">cmd</span><span class="p">.</span><span class="nf">Execute</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>app/cmd/root.go 代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">cmd</span>
<span class="kd">var</span> <span class="nx">rootCmd</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">cobra</span><span class="p">.</span><span class="nx">Command</span><span class="p">{</span>
   <span class="nx">Use</span><span class="p">:</span>   <span class="s">&#34;hugo&#34;</span><span class="p">,</span>
   <span class="nx">Short</span><span class="p">:</span> <span class="s">&#34;Hugo is a very fast static site generator&#34;</span><span class="p">,</span>
   <span class="nx">Long</span><span class="p">:</span> <span class="s">`A Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://hugo.spf13.com`</span><span class="p">,</span>
   <span class="nx">Run</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">cmd</span> <span class="o">*</span><span class="nx">cobra</span><span class="p">.</span><span class="nx">Command</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Do Stuff Here
</span><span class="c1"></span>   <span class="p">},</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Execute</span><span class="p">()</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rootCmd</span><span class="p">.</span><span class="nf">Execute</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
      <span class="nx">os</span><span class="p">.</span><span class="nf">Exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>项目地址：<a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">https://github.com/spf13/cobra</a>
。</p>
<h2 id="02-配置读取器spf13viper">02 配置读取器(spf13/viper)</h2>
<p><p class="md__image">
  <img src="../imgs/viper.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>Viper 是 Go 应用程序的完整配置解决方案。</p>
</blockquote>
<p>Viper 支持以下格式配置：</p>
<ul>
<li>JSON</li>
<li>TOML</li>
<li>YAML</li>
<li>HCL</li>
<li>INI</li>
<li>envfile</li>
<li>Java properties config files</li>
</ul>
<p>例如 config/config.toml：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-toml" data-lang="toml"><span class="nx">address</span><span class="p">=</span><span class="s2">&#34;localhost&#34;</span>
<span class="nx">port</span><span class="p">=</span><span class="s2">&#34;9090&#34;</span>
</code></pre></div><p>响应操作的文件 config.go：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ReadConfig</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">viper</span><span class="p">.</span><span class="nf">SetConfigName</span><span class="p">(</span><span class="s">&#34;config/config.toml&#34;</span><span class="p">)</span>
   <span class="nx">viper</span><span class="p">.</span><span class="nf">SetConfigType</span><span class="p">(</span><span class="s">&#34;toml&#34;</span><span class="p">)</span>
   <span class="nx">err</span> <span class="o">:=</span> <span class="nx">viper</span><span class="p">.</span><span class="nf">ReadInConfig</span><span class="p">()</span>
   <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;Fatal error config file: %s \n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">))</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后在 main.go 中使用 config 的值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">address</span> <span class="o">:=</span> <span class="nx">viper</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;address&#34;</span><span class="p">)</span>
   <span class="nx">port</span> <span class="o">:=</span> <span class="nx">viper</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;port&#34;</span><span class="p">)</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;address: %s&#34;</span><span class="p">,</span> <span class="nx">address</span><span class="p">)</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;port: %s&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>项目地址：<a href="https://github.com/spf13/viper" target="_blank" rel="noopener">https://github.com/spf13/viper</a>
。</p>
<h2 id="03-web-框架labstackecho">03 Web 框架(labstack/echo)</h2>
<p><p class="md__image">
  <img src="../imgs/echo.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>Echo 是一个高性能、极简主义的 Go Web 框架。</p>
</blockquote>
<p><strong>安装</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">// go get github.com/labstack/echo/<span class="o">{</span>version<span class="o">}</span>
go get github.com/labstack/echo/v4
</code></pre></div><p><strong>例子</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;net/http&#34;</span>
  <span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
  <span class="s">&#34;github.com/labstack/echo/v4/middleware&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Echo instance
</span><span class="c1"></span>  <span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

  <span class="c1">// Middleware
</span><span class="c1"></span>  <span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Logger</span><span class="p">())</span>
  <span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Recover</span><span class="p">())</span>

  <span class="c1">// Routes
</span><span class="c1"></span>  <span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">hello</span><span class="p">)</span>

  <span class="c1">// Start server
</span><span class="c1"></span>  <span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:1323&#34;</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Handler
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">hello</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>项目地址：<a href="https://github.com/labstack/echo" target="_blank" rel="noopener">https://github.com/labstack/echo</a>
。</p>
<h2 id="04-依赖注入uber-gofx">04 依赖注入(uber-go/fx)</h2>
<p><p class="md__image">
  <img src="../imgs/uber-fx.png"
    alt=""  />
</p>
</p>
<p>我发现这个库非常有用，你不需要生成任何东西。只有代码。非常模块化和清晰的层次。</p>
<blockquote>
<p>一个依赖注入的 Go 应用框架。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fx</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nf">injectModule</span><span class="p">()).</span><span class="nf">Run</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">injectModule</span><span class="p">()</span> <span class="nx">fx</span><span class="p">.</span><span class="nx">Option</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fx</span><span class="p">.</span><span class="nf">Options</span><span class="p">(</span>
		<span class="nx">fx</span><span class="p">.</span><span class="nf">Provide</span><span class="p">(</span> 
		     <span class="nx">NewTimeOutContext</span><span class="p">,</span> 
		     <span class="nx">NewDbConn</span><span class="p">,</span> 
		<span class="p">),</span>
		<span class="nx">repository</span><span class="p">.</span><span class="nx">Module</span><span class="p">,</span> 
		<span class="nx">service</span><span class="p">.</span><span class="nx">Module</span><span class="p">,</span> 
		<span class="nx">outbound</span><span class="p">.</span><span class="nx">Module</span><span class="p">,</span> 
		<span class="nx">server</span><span class="p">.</span><span class="nx">Module</span><span class="p">,</span> 
		<span class="nx">controller</span><span class="p">.</span><span class="nx">Module</span><span class="p">,</span>
	<span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>项目地址：<a href="https://github.com/uber-go/fx" target="_blank" rel="noopener">https://github.com/uber-go/fx</a>
。</p>
<h2 id="04-swagger-generator-ui-和-validation">04 Swagger Generator, UI 和 Validation</h2>
<p><p class="md__image">
  <img src="../imgs/swagger.png"
    alt=""  />
</p>
</p>
<p>在 swagger 部分，我必须使用不同的 3 个库，因为我没有找到 1 个库同时包含这个 3 个库功能的。如果你有推荐，请评论告知。</p>
<h3 id="aswagger-generator-swaggoswag">a、Swagger generator (swaggo/swag)</h3>
<blockquote>
<p>Swag 将 Go 注释转换为 Swagger Documentation 2.0。</p>
</blockquote>
<p>我们为流行的 <a href="https://github.com/swaggo/swag#supported-web-frameworks" target="_blank" rel="noopener">Go Webb 框架</a>
创建了各种各样的插件。这允许你快速集成一个现有的 Go 项目（使用 Swagger UI）。</p>
<p>支持的 Web 框架：</p>
<ul>
<li>gin</li>
<li>echo</li>
<li>buffalo</li>
<li>net/http</li>
</ul>
<p>Swag 已经处理了你那些 swagger 文件。所以你不再需要写 swagger.yml 或 swagger.json。你需要做的只是编写注释。看一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// @title Blueprint Swagger API
</span><span class="c1">// @version 1.0
</span><span class="c1">// @description Swagger API for Golang Project Blueprint.
</span><span class="c1">// @termsOfService http://swagger.io/terms/
</span><span class="c1">// @contact.name API Support
</span><span class="c1">// @contact.email martin7.heinz@gmail.com
</span><span class="c1">// @license.name MIT
</span><span class="c1">// @license.url https://github.com/MartinHeinz/go-project-blueprint/blob/master/LICENSE
</span><span class="c1">// @BasePath /api/v1
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
    <span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/swagger/*any&#34;</span><span class="p">,</span> <span class="nx">ginSwagger</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">swaggerFiles</span><span class="p">.</span><span class="nx">Handler</span><span class="p">))</span>
    <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>项目地址：<a href="https://github.com/swaggo/swag" target="_blank" rel="noopener">https://github.com/swaggo/swag</a>
。</p>
<h3 id="bswagger-ui-swaggoecho-swagger">b、Swagger UI (swaggo/echo-swagger)</h3>
<p>因为我正在使用 echo，所以我为 swagger 选择了这个 user interface。</p>
<p>使用示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
	<span class="s">&#34;github.com/swaggo/echo-swagger&#34;</span>
	<span class="nx">_</span> <span class="s">&#34;github.com/swaggo/echo-swagger/example/docs&#34;</span> <span class="c1">// docs is generated by Swag CLI, you have to import it.
</span><span class="c1"></span><span class="p">)</span>
<span class="c1">// @title Swagger Example API
</span><span class="c1">// @version 1.0
</span><span class="c1">// @description This is a sample server Petstore server.
</span><span class="c1">// @termsOfService http://swagger.io/terms/
</span><span class="c1">// @contact.name API Support
</span><span class="c1">// @contact.url http://www.swagger.io/support
</span><span class="c1">// @contact.email support@swagger.io
</span><span class="c1">// @license.name Apache 2.0
</span><span class="c1">// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
</span><span class="c1">// @host petstore.swagger.io
</span><span class="c1">// @BasePath /v2
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/swagger/*&#34;</span><span class="p">,</span> <span class="nx">echoSwagger</span><span class="p">.</span><span class="nx">WrapHandler</span><span class="p">)</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:1323&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>项目地址：<a href="https://github.com/swaggo/echo-swagger" target="_blank" rel="noopener">https://github.com/swaggo/echo-swagger</a>
。</p>
<h3 id="cswagger-validation-go-swaggergo-swagger">c、Swagger validation (go-swagger/go-swagger)</h3>
<blockquote>
<p>这个包包含了 Swagger 2.0（又名 <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md" target="_blank" rel="noopener">OpenAPI 2.0</a>
）的 golang 实现: 它知道如何序列化和反序列化 Swagger 规范。</p>
</blockquote>
<p>安装：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">go get github.com/go-swagger/go-swagger/cmd/swagger
</code></pre></div><p>运行以验证：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">swagger validate api/docs/swagger.yaml
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">2021/01/30 22:47:01 
The swagger spec at <span class="s2">&#34;api/docs/swagger.yaml&#34;</span> is valid against swagger specification 2.0
</code></pre></div><p>项目地址：<a href="https://github.com/go-swagger/go-swagger" target="_blank" rel="noopener">https://github.com/go-swagger/go-swagger</a>
。</p>
<h2 id="06自定义-logger-sirupsenlogrus">06、自定义 Logger (sirupsen/logrus)</h2>
<p><p class="md__image">
  <img src="../imgs/logrus.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>Logrus 是 Go (golang)的结构化 Logger，完全兼容标准库 Log。</p>
</blockquote>
<p>例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="nx">log</span> <span class="s">&#34;github.com/sirupsen/logrus&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">WithFields</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">Fields</span><span class="p">{</span>
    <span class="s">&#34;animal&#34;</span><span class="p">:</span> <span class="s">&#34;walrus&#34;</span><span class="p">,</span>
  <span class="p">}).</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;A walrus appears&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>项目地址：<a href="https://github.com/sirupsen/logrus" target="_blank" rel="noopener">https://github.com/sirupsen/logrus</a>
。</p>
<h2 id="07mock-生成器-vektramockery">07、Mock 生成器 (vektra/mockery)</h2>
<blockquote>
<p>一个 Mock 代码自动生成器</p>
</blockquote>
<p>安装：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">go get github.com/vektra/mockery/v2/.../
</code></pre></div><p>生成 mock：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">./bin/mockery --all
</code></pre></div><p>输出：</p>
<p><p class="md__image">
  <img src="../imgs/mock-01.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/mock-02.png"
    alt=""  />
</p>
</p>
<p>项目地址：<a href="https://github.com/vektra/mockery" target="_blank" rel="noopener">https://github.com/vektra/mockery</a>
。</p>
<h2 id="08migrate-golang-migratemigrate">08、Migrate (golang-migrate/migrate)</h2>
<blockquote>
<p>用 Go 编写的数据库迁移工具。作为 <a href="https://github.com/golang-migrate/migrate#cli-usage" target="_blank" rel="noopener">CLI</a>
 使用或作为<a href="https://github.com/golang-migrate/migrate#use-in-your-go-project" target="_blank" rel="noopener">库</a>
导入。</p>
</blockquote>
<p>支持如下数据库：</p>
<ul>
<li>PostgreSQL</li>
<li>Redshift</li>
<li>Ql</li>
<li>Cassandra</li>
<li>SQLite (todo #165)</li>
<li>SQLCipher</li>
<li>MySQL/ MariaDB</li>
<li>Neo4j</li>
<li>MongoDB</li>
<li>CrateDB (todo #170)</li>
<li>Shell (todo #171)</li>
<li>Google Cloud Spanner</li>
<li>CockroachDB</li>
<li>ClickHouse</li>
<li>Firebird</li>
<li>MS SQL Server</li>
</ul>
<p>安装：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get -u -d github.com/golang-migrate/migrate/cmd/migrate
</code></pre></div><p>创建迁移文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">migrate create -ext sql -dir database/migrations -seq create_user
</code></pre></div><p>运行升级版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">migrate -database <span class="s2">&#34;mysql://user:pass@tcp(localhost:3600)/user&#34;</span> -path<span class="o">=</span>database/migrations up
</code></pre></div><p>降版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">migrate -database <span class="s2">&#34;mysql://user:pass@tcp(localhost:3600)/user&#34;</span> -path<span class="o">=</span>database/migrations down
</code></pre></div><p>项目地址：<a href="https://github.com/golang-migrate/migrate" target="_blank" rel="noopener">https://github.com/golang-migrate/migrate</a>
。</p>
<h2 id="09messaging-nsq">09、Messaging (NSQ)</h2>
<p><p class="md__image">
  <img src="../imgs/nsq.png"
    alt=""  />
</p>
</p>
<p>NSQ 拓扑：</p>
<p><p class="md__image">
  <img src="../imgs/nsq01.png"
    alt=""  />
</p>
</p>
<p>NSQ 组件：</p>
<ol>
<li>nsqlookupd (daemon manage topologies / routes)</li>
<li>nsqd (daemon manage receives, queues, and delivers messages)</li>
<li>nsqadmin (default Web UI of nsq)</li>
</ol>
<p>基于 docker-compose 示例： (nsqlookupd，nsqd，nsqadmin)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;3&#39;</span><span class="w">
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="nt">nsqlookupd</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nsqio/nsq</span><span class="w">
</span><span class="w"></span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">/nsqlookupd</span><span class="w">
</span><span class="w"></span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="s2">&#34;4160:4160&#34;</span><span class="w">
</span><span class="w"></span>- <span class="s2">&#34;4161:4161&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">nsqd</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nsqio/nsq</span><span class="w">
</span><span class="w"></span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">/nsqd --lookupd-tcp-address=nsqlookupd:4160</span><span class="w">
</span><span class="w"></span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="l">nsqlookupd</span><span class="w">
</span><span class="w"></span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="s2">&#34;4150:4150&#34;</span><span class="w">
</span><span class="w"></span>- <span class="s2">&#34;4151:4151&#34;</span><span class="w">
</span><span class="w"></span><span class="nt">nsqadmin</span><span class="p">:</span><span class="w">
</span><span class="w"></span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nsqio/nsq</span><span class="w">
</span><span class="w"></span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">/nsqadmin --lookupd-http-address=nsqlookupd:4161</span><span class="w">
</span><span class="w"></span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="l">nsqlookupd</span><span class="w">
</span><span class="w"></span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w"></span>- <span class="s2">&#34;4171:4171&#34;</span><span class="w">
</span></code></pre></div><p>执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">To</span> <span class="nx">run</span> <span class="nx">docker</span><span class="p">:</span>
<span class="err">$</span> <span class="nx">docker</span><span class="o">-</span><span class="nx">compose</span> <span class="nx">up</span> <span class="o">-</span><span class="nx">d</span>
<span class="nx">or</span> <span class="k">if</span> <span class="nx">use</span> <span class="nf">name</span> <span class="p">(</span><span class="nx">docker</span><span class="o">-</span><span class="nx">compose</span><span class="o">-</span><span class="nx">nsq</span><span class="p">.</span><span class="nx">yml</span><span class="p">):</span>
<span class="err">$</span> <span class="nx">docker</span><span class="o">-</span><span class="nx">compose</span> <span class="o">-</span><span class="nx">f</span> <span class="nx">docker</span><span class="o">-</span><span class="nx">compose</span><span class="o">-</span><span class="nx">nsq</span><span class="p">.</span><span class="nx">yml</span> <span class="nx">up</span> <span class="o">-</span><span class="nx">d</span>
<span class="nx">To</span> <span class="nx">check</span> <span class="nx">container</span> <span class="nx">docker</span><span class="p">:</span>
<span class="err">$</span> <span class="nx">docker</span><span class="o">-</span><span class="nx">compose</span> <span class="nx">ps</span>
<span class="nx">To</span> <span class="nx">see</span> <span class="nx">logs</span><span class="p">:</span>
<span class="err">$</span> <span class="nx">docker</span><span class="o">-</span><span class="nx">compose</span> <span class="nx">logs</span>
<span class="nx">To</span> <span class="nx">check</span> <span class="nx">nsq</span> <span class="nx">web</span> <span class="nx">ui</span><span class="p">:</span> <span class="p">(</span><span class="nx">assuming</span> <span class="nx">port</span> <span class="nx">is</span> <span class="mi">32770</span><span class="p">)</span>
<span class="err">$</span> <span class="nx">curl</span> <span class="nx">http</span><span class="p">:</span><span class="c1">//127.0.0.1:32770/ping
</span></code></pre></div><p>Go 代码目录：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Create Folder:
├── consume
│   └── consume.go
└── publish
    └── publish.go
</code></pre></div><p>consume.go 代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;sync&#34;</span>
    <span class="s">&#34;github.com/nsqio/go-nsq&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nx">decodeConfig</span> <span class="o">:=</span> <span class="nx">nsq</span><span class="p">.</span><span class="nf">NewConfig</span><span class="p">()</span>
    <span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">nsq</span><span class="p">.</span><span class="nf">NewConsumer</span><span class="p">(</span><span class="s">&#34;My_NSQ_Topic&#34;</span><span class="p">,</span> <span class="s">&#34;My_NSQ_Channel&#34;</span><span class="p">,</span> <span class="nx">decodeConfig</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    		<span class="nx">log</span><span class="p">.</span><span class="nf">Panic</span><span class="p">(</span><span class="s">&#34;Could not create consumer&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">AddHandler</span><span class="p">(</span><span class="nx">nsq</span><span class="p">.</span><span class="nf">HandlerFunc</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">message</span> <span class="o">*</span><span class="nx">nsq</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;NSQ message received:&#34;</span><span class="p">)</span>
        <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nx">Body</span><span class="p">))</span>
    		<span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}))</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ConnectToNSQD</span><span class="p">(</span><span class="s">&#34;127.0.0.1:4150&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    		<span class="nx">log</span><span class="p">.</span><span class="nf">Panic</span><span class="p">(</span><span class="s">&#34;Could not connect&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Awaiting messages from NSQ topic \&#34;My NSQ Topic\&#34;...&#34;</span><span class="p">)</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>运行 consume.go：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run consume/consume.go
</code></pre></div><p>publish.go 代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;github.com/nsqio/go-nsq&#34;</span>
<span class="p">)</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">config</span> <span class="o">:=</span> <span class="nx">nsq</span><span class="p">.</span><span class="nf">NewConfig</span><span class="p">()</span>
    <span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">nsq</span><span class="p">.</span><span class="nf">NewProducer</span><span class="p">(</span><span class="s">&#34;127.0.0.1:4150&#34;</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   		 <span class="nx">log</span><span class="p">.</span><span class="nf">Panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">err</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Publish</span><span class="p">(</span><span class="s">&#34;My_NSQ_Topic&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;sample NSQ message&#34;</span><span class="p">))</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    		<span class="nx">log</span><span class="p">.</span><span class="nf">Panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>运行 publish：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run publish/publish.go
</code></pre></div><p>项目地址：<a href="https://github.com/nsqio/go-nsq" target="_blank" rel="noopener">https://github.com/nsqio/go-nsq</a>
。</p>
<h2 id="10sql-jmoironsqlx">10、SQL (jmoiron/sqlx)</h2>
<blockquote>
<p>sqlx 是一个库，它为 go 的标准 database/sql 库提供了一组扩展。</p>
</blockquote>
<p>我喜欢的 sqlx 是因为它们可以 scan 结构！使用简单。</p>
<p>StrucScan 的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">place</span> <span class="o">:=</span> <span class="nx">Place</span><span class="p">{}</span>
<span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Queryx</span><span class="p">(</span><span class="s">&#34;SELECT * FROM place&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">StructScan</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">place</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span> 
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">place</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>项目地址：<a href="https://github.com/jmoiron/sqlx" target="_blank" rel="noopener">https://github.com/jmoiron/sqlx</a>
。</p>
<h2 id="11附加的一些库">11、附加的一些库</h2>
<p>1）Go routine grouping (sync/errgroup)：<a href="https://pkg.go.dev/golang.org/x/sync/errgroup" target="_blank" rel="noopener">https://pkg.go.dev/golang.org/x/sync/errgroup</a>
</p>
<p>2）Fluent SQL generation for golang (Masterminds/squirrel)：<a href="https://github.com/Masterminds/squirrel" target="_blank" rel="noopener">https://github.com/Masterminds/squirrel</a>
</p>
<p>3）Golang Linter (golangci/golangci-lint)：<a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">https://github.com/golangci/golangci-lint</a>
</p>
<p>4）Circuit Breaker (gojek/heimdall)：<a href="https://github.com/gojek/heimdall" target="_blank" rel="noopener">https://github.com/gojek/heimdall</a>
</p>
<p>5）Go tool generate tags (fatih/gomodifytags)：<a href="https://github.com/fatih/gomodifytags" target="_blank" rel="noopener">https://github.com/fatih/gomodifytags</a>
</p>
<h2 id="12总结">12、总结</h2>
<p>要构建应用程序，我们应该知道有什么功能，特别是如果我们是团队协作，建议使用可读性强的代码，这样在成为遗留代码之前（也许 5-10 年之后） ，代码可以更容易维护。</p>
<p>构建应用程序的三个关键：</p>
<ol>
<li>简单设计（项目结构和依赖关系）</li>
<li>Clean Code (可读性和可维护性)</li>
<li>Modular（模块化） (Solid &amp; flexible skeleton)</li>
</ol>
<p>为了封装所有这些库，我有一个模板或框架项目，其设计简单，代码清晰。看看这个：<a href="https://github.com/kecci/goscription" target="_blank" rel="noopener">https://github.com/kecci/goscription</a>
。</p>
<p>以上就是我常用的 10 大 Go 框架/库和一些附加库。</p>
<p>我希望你喜欢我的推荐，如果你有其他的推荐，请留言！</p>
<blockquote>
<p>原文链接：<a href="https://keccikun.medium.com/top-10-framework-golang-library-to-build-microservice-391a2bb4c2cb" target="_blank" rel="noopener">https://keccikun.medium.com/top-10-framework-golang-library-to-build-microservice-391a2bb4c2cb</a>
</p>
<p>作者：Kecci Kun</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>那些 Go 语言实现的语言现在发展怎么样了？</title>
			<link>https://polarisxu.studygolang.com/posts/go/programming-language-implemented-by-go/</link>
			<pubDate>Mon, 01 Mar 2021 18:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/programming-language-implemented-by-go/</guid>
			<description>大家好，我是站长 polarisxu。 Go 是一门通用编程语言，Go1.5 实现了自举，也就是说，Go 语言是用它自身实现的。经过十来年的发展，开源界使用 Go 语言实现的编程语言不少，那它们发展的怎么样？本文进行一下梳理。 01 Go+ 这是国内七牛老大许式伟主导的，对 Go 语言的扩展，专为数据科学领域打造。目标是取代 Python 在数据科学领域的位置。 项目地址：https://github.com</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>Go 是一门通用编程语言，Go1.5 实现了自举，也就是说，Go 语言是用它自身实现的。经过十来年的发展，开源界使用 Go 语言实现的编程语言不少，那它们发展的怎么样？本文进行一下梳理。</p>
<h2 id="01-go">01 Go+</h2>
<p>这是国内七牛老大许式伟主导的，对 Go 语言的扩展，专为数据科学领域打造。目标是取代 Python 在数据科学领域的位置。</p>
<p>项目地址：<a href="https://github.com/goplus/gop" target="_blank" rel="noopener">https://github.com/goplus/gop</a>
，Star 数：4.2k+。</p>
<p>该语言的前身是 qlang，2020 年 6 月份左右将其重命名为 Go+，并定位为数据科学领域。截止目前最新版本是 2021 年 1 月 8 日发布的 0.7.17，还不是稳定版本。</p>
<p>这是一门静态编程语言，完全兼容 Go 语言，类似脚本语言的风格，比 Go 更具可读性的数据科学代码。</p>
<p>例如下面的 Go 代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">float64</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">}</span>
    <span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>对应的 Go+ 代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.4</span><span class="p">]</span>
<span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</code></pre></div><p>今天刚看到许大在寻找 Go+ 语言开发团队的负责人，有兴趣的可以联系许大（找我转达也没问题）。</p>
<p>目前看，距离目标还有很长的路要走，最少先推出稳定版本，然后有一个线上实际的应用。</p>
<h2 id="02-tengo">02 Tengo</h2>
<p>Tengo 是一种小型、动态、快速、安全的脚本语言，它使用 Go 语言实现，并且可以嵌入 Go 程序中。它的语法和 Go 语言类似。</p>
<p>项目地址：<a href="https://github.com/d5/tengo" target="_blank" rel="noopener">https://github.com/d5/tengo</a>
，Star 数：2.2k+，目前最新版本是 2.6.2（2020 年 9 月 18 日发布）。</p>
<p>代码示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/* The Tengo Language */</span>
<span class="nx">fmt</span> <span class="o">:=</span> <span class="kn">import</span><span class="p">(</span><span class="s">&#34;fmt&#34;</span><span class="p">)</span>

<span class="nx">each</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">seq</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">x</span> <span class="nx">in</span> <span class="nx">seq</span> <span class="p">{</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="nx">sum</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">init</span><span class="p">,</span> <span class="nx">seq</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">each</span><span class="p">(</span><span class="nx">seq</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="nx">init</span> <span class="o">+=</span> <span class="nx">x</span> <span class="p">})</span>
    <span class="k">return</span> <span class="nx">init</span>
<span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nb">println</span><span class="p">(</span><span class="nf">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>   <span class="c1">// &#34;6&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nb">println</span><span class="p">(</span><span class="nf">sum</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>  <span class="c1">// &#34;123&#34;
</span></code></pre></div><h2 id="03-cx">03 CX</h2>
<p>CX 是一种用于区块链的新编程语言，使用 Go 语言实现，语法类似 Go 语言。</p>
<p>项目地址：<a href="https://github.com/skycoin/cx" target="_blank" rel="noopener">https://github.com/skycoin/cx</a>
，Star 数 27，很凄惨。目前最新 tag 是 0.7.5，我查了下，该项目几年前就存在了。目前看属于半死不活的状态，是 skycoin 主导开发的。对区块链不太熟悉，不知道这个语言能为区块链开发带来什么革命性的功能。</p>
<p>我安装试用了下，写了一个 Hello World 程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">str</span><span class="p">.</span><span class="nb">print</span><span class="p">(</span><span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>哈哈哈，我又掌握了一门语言的 Hello World！</p>
<h2 id="04-goby">04 Goby</h2>
<p>受 Ruby 启发的面向对象的解释型语言，核心代码 100％ 使用 Go 实现。它具有标准库，可提供多种功能，例如插件系统。</p>
<p>项目地址：<a href="https://github.com/goby-lang/goby" target="_blank" rel="noopener">https://github.com/goby-lang/goby</a>
，Star 数 3.2k+，目前最新版本 0.1.13（2020 年 4 月 26 日发布）。</p>
<p>Goby 的预期是用于后端开发。它具备（但不限于）以下功能：</p>
<ul>
<li>基于 Go goroutine 的 thread/channel 机制；</li>
<li>内置 database 库；</li>
<li>json 支持；</li>
<li>插件系统，支持动态加载 Go 库（目前不支持 Windows 系统）；</li>
<li>可以直接访问 Go 对象；</li>
</ul>
<p>一个 Server 端 Hello World 的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s2">&#34;net/simple_server&#34;</span>

<span class="n">server</span> <span class="o">=</span> <span class="no">Net</span><span class="o">::</span><span class="no">SimpleServer</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&#34;3000&#34;</span><span class="p">)</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">server</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;/&#34;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">req</span><span class="p">,</span> <span class="n">res</span><span class="o">|</span>
  <span class="nb">puts</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
  <span class="n">res</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">req</span><span class="o">.</span><span class="n">method</span> <span class="o">+</span> <span class="s2">&#34; Hello World&#34;</span>
  <span class="n">res</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">200</span>
<span class="k">end</span>

<span class="n">server</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&#34;/not_found&#34;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">req</span><span class="p">,</span> <span class="n">res</span><span class="o">|</span>
  <span class="n">res</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="s2">&#34;Not Found&#34;</span>
  <span class="n">res</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">404</span>
<span class="k">end</span>

<span class="n">server</span><span class="o">.</span><span class="n">start</span>
</code></pre></div><p>不知道 Ruby 爱好者喜欢不？！</p>
<h2 id="05-总结">05 总结</h2>
<p>除了上面介绍的，还有其他一些 Go 语言实现的语言，比如 chai2010 的 <a href="https://github.com/wa-lang/wa" target="_blank" rel="noopener">wa 语言</a>
，以及其他一些脚本语言，如 Lua 虚拟机 Go 实现、JS 虚拟机实现、Python 解释器等。</p>
<p><p class="md__image">
  <img src="../imgs/tengo.png"
    alt=""  />
</p>
</p>
<p>有兴趣的可以通过 <a href="https://github.com/d5/tengo" target="_blank" rel="noopener">https://github.com/d5/tengo</a>
 项目的性能测试部分了解。</p>
<p>以上介绍的语言，你有看好的吗？会尝试哪个语言吗？如果你对编程语言实现感兴趣，可以参与其中。</p>
]]></content>
		</item>
		
		<item>
			<title>金三银四，聊聊换工作的那些事</title>
			<link>https://polarisxu.studygolang.com/posts/talk/2021-change-job/</link>
			<pubDate>Sat, 27 Feb 2021 20:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/2021-change-job/</guid>
			<description>大家好，我是站长 polarisxu。 下周就进入 3 月份了，正所谓金三银四，是换工作的黄金时间。 实际上从春节开工到现在十天左右时间，「Go语言中文网」上新发的招聘信息不少，从 「Go招聘」公众号上也看到了不少招聘信息。 那到底该不该换工作呢？什么情况下换工作？今天一起聊聊这个话题。 马云曾说，员工离职，原因很多种，但只有两点最真实： 钱，没给到位； 心，委屈了。 这些归根到</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>下周就进入 3 月份了，正所谓金三银四，是换工作的黄金时间。</p>
<p>实际上从春节开工到现在十天左右时间，「Go语言中文网」上新发的招聘信息不少，从 「Go招聘」公众号上也看到了不少招聘信息。</p>
<p>那到底该不该换工作呢？什么情况下换工作？今天一起聊聊这个话题。</p>
<hr>
<p>马云曾说，员工离职，原因很多种，但只有两点最真实：</p>
<ul>
<li>
<p><strong>钱，没给到位；</strong></p>
</li>
<li>
<p><strong>心，委屈了。</strong></p>
</li>
</ul>
<p>这些归根到底就一条：干得不爽。</p>
<p>其实更进一步，钱是物质，每个人都要生活，所以，工作获得报酬，这是基本的物质保障。而第二点可以归结为是精神层面的，工作是否让你精神舒畅，是否有成就感。</p>
<p>我个人认为，除了以上两点，还有一点，对现代人来说很重要，那就是是否有发展。这个发展包括两个方面，一个是个人能力的成长，一个是职位升迁的可能。有了好的发展，物质和精神层面的问题会得到更好地解决。</p>
<h2 id="01-成长">01 成长</h2>
<p>先说成长。</p>
<p>关于成长，你需要问问自己，过去一年，你在这个公司有成长吗？如果没有，原因在你自己还是公司做的事情不利于你成长。如果是你自己的原因，换个工作你大概率也不会有成长。</p>
<p>怎么判断自己能力有没有提升了？这个不好量化，但可以从一些维度进行考虑。我建议可以从以下方面进行考虑。</p>
<h3 id="1年终总结">1）年终总结</h3>
<p>回顾过去一年，自己做了哪些项目，从这些项目中自己学到了什么之前不懂的点；积累了什么经验，掌握了哪些技能。回顾并写下来，找出自己工作中的亮点，自己的贡献和解决的难题。实际上，这个过程是在复盘，是在为简历填充内容，也是在为可能的面试做准备。我个人比较建议，在项目过程中要有意识的做一些总结、复盘和反思，可以是周报、月报或项目总结，亦或是自己写博文等，养成好习惯，方便年终梳理。</p>
<p>除了工作上的，自己过去一年看了什么书，专项学习了哪些技能？学到老活到老。知识是需要积累的，学习能力也是需要锻炼的。通过额外给自己充电，可以在工作中更得心应手。</p>
<h3 id="2上级对你的评价">2）上级对你的评价</h3>
<p>大公司会进行评级，如果顺利晋级，自然可以说明你的能力提升了。</p>
<p>如果没有评级或不顺利，可以和上级沟通，听听上级的意见，自己过去一年哪些地方做的好，哪些做的不好，自己能力有无提升，哪些方面需要加强。这一方面是审视自己，听取别人的建议，另一方面也可以较好的表明自己的上进心。具体沟通的方式可以多种，比如面聊（可以轻松的环境，比如请上级吃个饭）、邮件等形式。也可以主动给上级发自己接下来一年的个人能力提升和工作计划，然后让领导对你进行一下评价。</p>
<h3 id="3日常工作的自我感觉">3）日常工作的自我感觉</h3>
<p>比如想想自己是否比之前有更多不知道的东西？是否有更多需要学习的？因为知道越多，不知道的也越多。在日常工作中，对类似的事情，或达到相同的结果是否更得心应手，或者工作结果是否达到了更难更高的目标。</p>
<h2 id="02-薪酬">02 薪酬</h2>
<p>聊完成长，聊聊薪酬。</p>
<p>关于薪酬，理想情况是“钱多事少离家近”，但这几乎是不可能的。所以对于薪酬，更多考虑的是“可接受的薪酬”。</p>
<p><strong>什么是可接受的薪酬？</strong></p>
<p>意思是说，根据你的能力，结合行业薪资情况，你可以接受的薪酬。特别是，你刚开始工作，更多追求的应该是好的工作机会，有发展的工作机会，薪酬别成为你的第一考虑，更别因为它而放弃好的机会。需要有往前看。</p>
<p>关于薪酬对标，推荐一个网站：<a href="https://duibiao.info/" target="_blank" rel="noopener">https://duibiao.info/</a>
，也许会对你有帮助。</p>
<p><p class="md__image">
  <img src="../imgs/duibiao.png"
    alt=""  />
</p>
</p>
<p>此外，如果你只是不满足现在的薪酬，建议你可以和你的上级谈谈。谈之前，你应该做一些必要的功课。比如自己过去一年的业绩、工作的表现，能力的成长，同时行业的工资水平，自己是什么水平。做到有理有据，而不是简单的：一年了，我应该涨薪资，因为别人都涨了。</p>
<p>接下来，谈谈发展机会的判断。</p>
<h2 id="03-判断机会">03 判断机会</h2>
<p>一个机会好不好，我认为可以从两方面考虑。一是合适的事；二是合适的人。因为换工作换的是事，同时也是换和不一样的人共事。</p>
<p>关于事，一方面是做什么，另一方面是怎么做。</p>
<p>俗话说，男怕入错行，女怕嫁错郎。对于一份工作，同样需要考虑做什么的问题。这件事跟目前行业大趋势有无关联？当前处于什么阶段？从 0 到 1 的起步探索阶段，还是从 1 到 n 的快速扩张阶段。不同的阶段，对自己锻炼是不一样的，风险也是不一样的，当然收益也不一样。所以，需要结合你的情况看自己看现阶段适合什么阶段的事。</p>
<p>做什么确定了，还需要考虑怎么做的问题。对于程序员来说，需要考虑做这件事，需要什么技能，自己掌握的技能和工作的匹配度，这样的技能要求，是否适合自己成长；这个公司做事的方法、使用的工具是怎么样的，你是否能接受。</p>
<p>所以，合适的事这个角度，不一定非得换公司，如果可能，公司内部换其他事情也是可以的。</p>
<p>关于人，我认为需要考虑两个方面：团队和领导。</p>
<p>是否要换工作，如果是因为人的因素，考虑你目前的团队是个什么样的团队，有什么问题。团队氛围是否融洽，沟通是否高效，是否彼此信任，分工是否明确，彼此能否互相帮助，能对彼此成长有帮助等。对于将要换的目标公司，你提前思考，怎么能够较好的了解团队的情况。</p>
<p>接着是领导。其实一个团队的情况，很大程度是领导决定的，所以领导很关键。你现在的领导是个什么样的人，是否能带领团队很好的拿结果，是团队的领路人还是阻挡者？能给团队成员起到引导的作用吗？</p>
<p>当然，如果你的职位比较高，其实可能需要进一步好好了解公司的老板，他是一个什么风格的人。</p>
<p>在群里经常有人发这样的表情：走对圈子跟对人。这说的就是团队和领导。</p>
<h2 id="04-总结">04 总结</h2>
<p>要不要换工作，需要综合考虑物质、精神和发展三个层面的满意度，分析现在的薪酬、做的事情和一起做事的人，你满意吗？如果你确定换工作，薪资、合适的事和合适的人也是你需要考虑的，因为事和人对你的发展很重要，对你的精神满足感也很重要。</p>
<p>当然，如果你没有想清楚，也可以去外面看看机会，了解行情，也可以验证自己的能力水平。但，请别裸辞，想清楚了，找到满意答案了，再考虑辞职。</p>
<blockquote>
<p>本文没有谈大公司还是小公司的问题。我认为那只是表现形式，本质上离不开薪酬（薪资、福利）、事和人。关键看你需要什么，看重什么。</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Go 官方应该搞一个类似 Rustup 的管理工具</title>
			<link>https://polarisxu.studygolang.com/posts/go/go-need-like-rustup-tool/</link>
			<pubDate>Thu, 25 Feb 2021 15:10:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/go-need-like-rustup-tool/</guid>
			<description>大家好，我是站长 polarisxu。 搭建开发环境复杂，会让很多新手抓狂。比如看到有人吐槽 Python 环境复杂，而搭建 PHP 环境，出现了很多一键安装包，像 lnmp 等。可见大家开始上手时，希望能够在环境上少一些折腾，别还没入门就劝退。 在早期，搭建 Go 语言开发环境，什么 GOROOT、GOPATH、GOBIN，很多新手一头雾水，经常稀里糊涂配置上了，写项目 go install 一下，找不到编译好的程序跑哪</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>搭建开发环境复杂，会让很多新手抓狂。比如看到有人吐槽 Python 环境复杂，而搭建 PHP 环境，出现了很多一键安装包，像 lnmp 等。可见大家开始上手时，希望能够在环境上少一些折腾，别还没入门就劝退。</p>
<p>在早期，搭建 Go 语言开发环境，什么 GOROOT、GOPATH、GOBIN，很多新手一头雾水，经常稀里糊涂配置上了，写项目 go install 一下，找不到编译好的程序跑哪去了。。。</p>
<h2 id="01-一个新的提案">01 一个新的提案</h2>
<p>Go 1.5 实现了自举，如果要源码安装 Go，需要先安装 Go1.4。今天看到 rsc 发布了一个提案：<a href="https://github.com/golang/go/issues/44505" target="_blank" rel="noopener">将 Go 1.16 用作 Go 1.18 的引导工具链</a>
，这意味着不再是 Go 1.4 了。</p>
<p>rsc 在提案中提到，最初计划实现自举时，计划采用滚动的方式，即下一个版本通过上一个版本构建，比如 Go1.4 用 Go1.3 构建，Go1.5 用 Go1.4 构建，但这样特别麻烦。比如我想源码安装最新的 Go1.16，我得先有 Go1.15。。。</p>
<p>所以，最后改成了固定使用 Go1.4 来构建，即要构建 Go1.x，对于 x ≥ 5，需要 <code>$GOROOT_BOOTSTRAP</code> 中已经安装 Go1.4 或更新版本，而该环境变量的默认值就是 <code>$HOME/go1.4</code>。</p>
<p>但现在距离 Go1.4 已经过去 6 年了，Go 发生了很多变化，特别是 M1 mac 的出现，使得 Go1.4 无法满足一些需求。因此 rsc 认为需要进行迭代，于是建议采用 Go1.16 作为引导工具链。</p>
<p>至于为什么是 1.16，而不是 1.15 或 1.17，rsc 也进行了解释：</p>
<ul>
<li>Go1.16 增加了 //go:build 指令，代替之前的 <code>+build</code>。（我认为还有一个就是上文说的，Go1.15 不支持 M1 mac）</li>
<li>Go1.17 目前看，没有增加编译器相关的特性，而且可以使用 Go1.16 作为测试 1.17 的引导工具，因为 1.17 还可以使用 1.4 引导，正好可以对比测试；</li>
<li>Go1.17 将会是第一个使用新的基于寄存器的 ABI 版本，因此可能会存在一些长期存在的 Bug。</li>
</ul>
<p>当然，不等到 Go1.18 的原因，因为 Go1.18 将包含泛型，改动会很大，不太适合。</p>
<p>rsc 还提到：</p>
<blockquote>
<p>The next obvious entry in the sequence after Go 1.4 and Go 1.16 is Go 1.256, followed by Go 1.65536.
(Or perhaps that is not quite the right pattern to establish.)</p>
</blockquote>
<p>目测 Go2 只是一个概念，Go1.x 可能长时间持续下去。</p>
<h2 id="02-梦想一个官方的-go-安装工具">02 梦想一个官方的 Go 安装工具</h2>
<p>上面说的提案，主要设计源码构建 Go 的问题。一般用户安装 Go，官方推荐怎么做的呢？</p>
<p>一般是推荐下载对应系统的预编译好版本，比如 Linux 系统，下载 go1.16.linux-amd64.tar.gz，然后执行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ tar -C /usr/local -xzf go1.16.linux-amd64.tar.gz
</code></pre></div><p>接着将 /usr/local/go/bin 加入 PATH 环境变量，一般建议修改 $HOME/.profile 或 /etc/profile：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$PATH</span>:/usr/local/go/bin
</code></pre></div><p>这个过程并不复杂。（其他系统也是类似操作）</p>
<p>但存在以下问题：</p>
<ul>
<li>有新版本，如何升级？</li>
<li>我想试验其他版本，如何做？</li>
<li>如何卸载 Go？</li>
</ul>
<p>正因为有这样的问题存在，但官方没有直接提供解决方案，于是 Go 社区出现了各种类似的解决方案，比如 goup、gvm 等，但毕竟不是官方的，很多人并不知晓它们的存在。</p>
<p>反观 Rust 的安装，只需要如下一行代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">curl --proto <span class="s1">&#39;=https&#39;</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class="p">|</span> sh
</code></pre></div><p>这是下载 rustup，同时通过 rustup 来安装 Rust，需要的环境变量也会帮设置好，而且类 Unix 系统都推荐采用这种方式安装。即使是 Windows 系统，也是下载 rustup 工具，然后通过它来安装 Rust。</p>
<p>安装了 Rust 后，上面提到的 Go 的三个问题，Rustup 都很好的解决了，而且它还能直接切换 Beta、Nightly 版本。</p>
<p>我们知道安装 Go 存在一个内地是否能正常下载的问题，这包括下载 Go 本身和下载依赖的第三方包。早期是很痛苦的，现在好很多。Go 官方专门为内地搭建了一个官网 <a href="https://golang.google.cn" target="_blank" rel="noopener">https://golang.google.cn</a>
，同时 GOPROXY 的存在，国内社区开发了相应的 proxy。</p>
<p>但这两道门槛，还是会让部分新手头疼：</p>
<ul>
<li>官网怎么访问不了？怎么下载 Go？</li>
<li>安装完 Go 后，写代码，依赖总是下载报错，因为默认的 GOPROXY 内地也访问不了。。。</li>
</ul>
<p>当然，国外并不存在这样的问题。但国内这个大市场，Go 应该考虑下。</p>
<p>所以，我觉得 Go 应该提供一个 Rustup 这样的官方工具，而且可以方便修改下载镜像，解决下载不了和慢的问题。当然这只是我的美好愿望~（不知道会不会有人向官方提 issue，或者大概率会被拒？）</p>
]]></content>
		</item>
		
		<item>
			<title>克制挺难的</title>
			<link>https://polarisxu.studygolang.com/posts/talk/restraint-is-hard/</link>
			<pubDate>Wed, 24 Feb 2021 00:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/restraint-is-hard/</guid>
			<description>大家好，我是站长 polarisxu。 昨天文章谈了 chi 这个 Go 框架，Kade 留言说，以为 chi 不会用 go mod，没想到去年就用了，但它支持的方式是从 v4.1.2 调到了 v1.5.0，也就是说之前都没有 go.mod，v1.5.0 开始加上了 go.mod。当 Go1.16 发布后，有了 ratract，他立马将其他所有版本都撤回了。面对社区的反对意见，他强硬的说：我在这个项目花了几年时间，尽管许多人不同</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>昨天文章谈了 chi 这个 Go 框架，Kade 留言说，以为 chi 不会用 go mod，没想到去年就用了，但它支持的方式是从 v4.1.2 调到了 v1.5.0，也就是说之前都没有 go.mod，v1.5.0 开始加上了 go.mod。当 Go1.16 发布后，有了 ratract，他立马将其他所有版本都撤回了。面对社区的反对意见，他强硬的说：我在这个项目花了几年时间，尽管许多人不同意，但大家并没有赞助或付费，你不喜欢，完全可以自己 fork 一份，维护自己的一个版本。</p>
<p>说他固执也好，强势也好，能这样坚持自己的人应该不是太多。</p>
<p>之所以今天谈“克制”，是因为看到了两条消息：</p>
<p>1）考虑要离开 Go 语言，因为泛型计划正式加入该语言了？<a href="https://www.youtube.com/watch?v=rzo8u03vC7Y" target="_blank" rel="noopener">油管有一个视频</a>
，标题是：You&rsquo;ll be Back (to Go) - Go generics is coming in Go 1.18</p>
<p><p class="md__image">
  <img src="../imgs/go-song.png"
    alt=""  />
</p>
</p>
<p>2）<a href="https://www.arp242.net/go-easy.html" target="_blank" rel="noopener">Go is not an easy language</a>
，文章作者强调，Simple != Easy。</p>
<p>加之昨天的文章和这段时间学习 Rust，我发现做任何事情，想要克制挺难的。</p>
<p>记得 Go 刚出来时，源文件不支持 UTF-8 带 BOM，国内有一哥们给官方提了一个 patch，结果被 Rob 拒了，这哥们一气之下，离开了 Go 阵营，还发了一篇长长的文章，说 Go Team 固执、独裁。UTF-8 是 Rob 和 Ken 发明的，他们有话语权。可是，行业，特别是 Windows 阵营的，UTF-8 默认带 BOM。于是乎，现在 Go 源码也支持带 BOM 了。。。Go Team 妥协了。（不知道 Rob 是否知晓此事~）</p>
<p>Go 一直强调“大道至简”，“少即是多”，正因为如此，使得它很适合入门学习。然而，别有误解，入门简单，不代表精通容易。说它不容易，大概率是说想掌握好它没那么容易。毕竟是一门编程语言，涉及到的内容不少，如果很容易就掌握、精通，程序员门槛是不是也太低了。</p>
<p>在保持简单、保持少这方面，Go Team 还是很克制的。比如一直没有增加三元操作符。就泛型而言，社区呼声实在太高，而且这个在某些情况下确实是极大提高表现力的，即使这样，官方也很谨慎，一次次“放鸽子”，确保是一个更好的方案。但依然没法做到让所有人满意，总是有人喜欢有人不喜欢。Go Team 一直在克制，避免 Go 连 Simple 都不是。</p>
<blockquote>
<p>乔布斯、马斯克就是特别能够坚持原则的人，制定高标准，并严格执行！</p>
</blockquote>
<p>互联网做产品，也经常讲要克制，别什么都要。但有多少人能真正做到？！做加法容易，做减法难。</p>
<p>有自己的原则，并坚持自己的原则，不会轻易受外界的影响，我说这是“克制”，是坚持自己认为是对的（如果真被打脸了，能及时调整）。这，真的挺难的吧！</p>
<p>你是一个克制的人吗？</p>
]]></content>
		</item>
		
		<item>
			<title>从 go-chi 框架撤回所有主版本聊 Go1.16 的新特性</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/go-chi-use-retract/</link>
			<pubDate>Tue, 23 Feb 2021 18:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/go-chi-use-retract/</guid>
			<description>大家好，我是站长 polarisxu。 在 Reddit 上看到一条消息： go-chi is retracting all major versions with go1.16 new retract directive. go.mod 的变更如下： 这利用了 Go 1.16 中 Module 的新特性。在这之前，先一起学习下该特性。 01 retract：撤回版本 也许不少人没有开发过自己的 Module（模块），但了解模块版本撤回还是有必要的，说不定哪天就能用到。因此建议你能够跟着本文操作一遍。 一般地，模块作者需要一种方法来指示不应该使用某个已发布</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>在 Reddit 上看到一条消息：</p>
<blockquote>
<p>go-chi is retracting all major versions with go1.16 new retract directive.</p>
</blockquote>
<p>go.mod 的变更如下：</p>
<p><p class="md__image">
  <img src="../imgs/chi-retract.png"
    alt=""  />
</p>
</p>
<p>这利用了 Go 1.16 中 Module 的新特性。在这之前，先一起学习下该特性。</p>
<h2 id="01-retract撤回版本">01 retract：撤回版本</h2>
<p>也许不少人没有开发过自己的 Module（模块），但了解模块版本撤回还是有必要的，说不定哪天就能用到。因此建议你能够跟着本文操作一遍。</p>
<p>一般地，模块作者需要一种方法来指示不应该使用某个已发布的模块版本。可能出于以下几点原因：</p>
<ul>
<li>发现了一个严重的安全漏洞；</li>
<li>发现了严重的不兼容性或 bug；</li>
<li>这个版本是偶然发布的，或是过早发布了；</li>
</ul>
<p>作者不能简单地删除版本标签（tag），因为它们很可能在模块代理上仍然可用。如果作者能够从所有代理中删除一个版本，那么依赖该版本的下游用户就会无法使用，出问题。</p>
<p>此外，作者在发布了 <code>go.sum</code> 文件之后也不能更改版本，校验和数据库会验证发布的版本从未更改。</p>
<p>那怎么办？作者应该能够撤回模块版本。撤回的模块版本是模块作者明确声明不应该使用的版本。(retract 这个词是从学术文献中借来的：一篇被撤回的研究论文仍然可用，但是它有问题，不应该成为未来工作的基础）。</p>
<p>撤回的版本应该在模块代理和原始代码库中保持可用。依赖已撤回版本的构建应可以继续工作。当用户依赖于一个已撤回的版本（直接或间接）时，应该通知用户。它也应该很难无意中升级到一个已撤回版本。</p>
<p>为了让大家更好的理解模块撤回功能，本文通过具体的例子来演示。我们会创建两个模块：</p>
<ul>
<li>foo，这是一个模块，本文将其 push 到 GitHub，完整路径：<a href="https://github.com/polaris1119/foo" target="_blank" rel="noopener">https://github.com/polaris1119/foo</a>
，你本地试验记得路径使用你的。本文将发布该模块的许多版本。</li>
<li>gopher，一个简单的 main 包，使用了上面的模块，该模块不会发布，只是作为本地模块；</li>
</ul>
<blockquote>
<p>注意，请确保 Go 版本是 1.16+。</p>
<p>本文演示用的操作系统是 MacOS。</p>
</blockquote>
<h3 id="创建-foo-模块">创建 foo 模块</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ mkdir -p ~/foo
$ <span class="nb">cd</span> ~/foo
$ git init -q
$ git remote add origin https://github.com/polaris1119/foo
$ go mod init github.com/polaris1119/foo
go: creating new go.mod: module github.com/polaris1119/foo
</code></pre></div><p>在模块目录中创建一个文件 foo.go，输入如下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">foo</span>

<span class="kd">func</span> <span class="nf">Bar</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;这是初始版本&#34;</span>
<span class="p">}</span>
</code></pre></div><blockquote>
<p>注意：在把该模块代码提交之前，先在 GitHub 上创建好项目 foo。</p>
</blockquote>
<p>将 foo 模块的改动提交 git 并 push。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git add -A
$ git commit -q -m <span class="s2">&#34;Initial commit&#34;</span>
$ git branch -M main
$ git push -u origin main
</code></pre></div><p>这是该模块的初始版本，我们用 v0 语言版本来标记它，表明它还不稳定。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git tag v0.1.0
$ git push -q origin v0.1.0
</code></pre></div><p>foo 的第一个版本已经发布，我们看看使用它的 gopher 模块。</p>
<h3 id="创建-gopher-模块">创建 gopher 模块</h3>
<p>该模块就放在本地，因此不用设置 git：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ mkdir ~/gopher
$ <span class="nb">cd</span> ~/gopher
$ go mod init gopher
</code></pre></div><p>创建一个 main.go 文件，内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>

    <span class="s">&#34;github.com/polaris1119/foo&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nf">Bar</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><p>接下来，我们通过 go get 显示指定依赖 foo 的版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get github.com/polaris1119/foo@v0.1.go
go: downloading github.com/polaris1119/foo v0.1.0
go get: added github.com/polaris1119/foo v0.1.0
</code></pre></div><blockquote>
<p>注意：我本地配置了 GOPROXY=https://goproxy.cn,direct</p>
</blockquote>
<p>然后运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run .
这是初始版本
</code></pre></div><p>目前一切正常。</p>
<h3 id="一个更好的版本">一个更好的版本</h3>
<p>经过一段时间，foo 的功能有一些变化，这里假设 Bar 方法语句变了（一个兼容的变化）。</p>
<p>回到 foo 模块，修改代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">foo</span>

<span class="kd">func</span> <span class="nf">Bar</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;这是一个更好的版本&#34;</span>
<span class="p">}</span>
</code></pre></div><p>提交并推送到 GitHub。</p>
<p>但现在 foo 模块还不是稳定版，因此不想标记为 v1。安全起见，我们发布 v0.2.0：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git tag v0.2.0
$ git push -q origin v0.2.0
</code></pre></div><p>现在 foo 发布了 v0.2.0 版本，我们在 gopher 项目尝试下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/gopher
$ go get github.com/polaris1119/foo@v0.2.0
go: downloading github.com/polaris1119/foo v0.2.0
go get: upgraded github.com/polaris1119/foo v0.1.0 <span class="o">=</span>&gt; v0.2.0
</code></pre></div><p>然后 go run 运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run .
这是一个更好的版本
</code></pre></div><p>这时，你发现 “这是一个更好的版本” 不好，怎么办？你可以修改掉，然后再发布一个新版本。然而，gopher 项目已经依赖了 v0.2.0，怎么办？</p>
<h3 id="撤回模块版本">撤回模块版本</h3>
<p>我们可以在 go.mod 中增加 retract 指令来撤回某个模块版本。</p>
<p>可以通过命令实现：（也可以直接修改 go.mod 文件）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go mod edit -retract<span class="o">=</span>v0.2.0
</code></pre></div><p>这时 go.mod 内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">module github.com/polaris1119/foo

go 1.16

retract v0.2.0
</code></pre></div><p>一般建议在 retract 上加上撤回的原因。go get、go list 等会显示这个原因。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">module github.com/polaris1119/foo

go 1.16

// Bar 方法返回值不友好
retract v0.2.0
</code></pre></div><p>修改下 Bar 的返回内容，提交 GitHub 并发布 v0.3.0：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Bar</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;这是v0.3.0版本&#34;</span>
<span class="p">}</span>
</code></pre></div><p>v0.3.0 发布后，回到 gopher 模块，使用这个新版本。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/gopher
$ go get github.com/polaris1119/foo@v0.3.0
go: downloading github.com/polaris1119/foo v0.3.0
go get: upgraded github.com/polaris1119/foo v0.2.0 <span class="o">=</span>&gt; v0.3.0
</code></pre></div><p>这一步确保 <a href="https://goproxy.cn" target="_blank" rel="noopener">https://goproxy.cn</a>
 这个代理知晓了 v0.3.0 版本，这是一种手动让代理拉取你模块的方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run .
这是v0.3.0版本
</code></pre></div><p>已经正常了。</p>
<p>经过这个步骤到底发生了什么？我们通过以下命令看一下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go list -m -versions github.com/polaris1119/foo
github.com/polaris1119/foo v0.1.0 v0.3.0
</code></pre></div><p>v0.2.0 不见了。通过增加 -retracted 选项可以查看撤回的版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go list -m -versions -retracted github.com/polaris1119/foo
github.com/polaris1119/foo v0.1.0 v0.2.0 v0.3.0
</code></pre></div><p>如果我们依赖回收的 v0.2.0 版本会怎么样了？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get github.com/polaris1119/foo@v0.2.0
go: warning: github.com/polaris1119/foo@v0.2.0: retracted by module author: Bar 方法返回值不友好
go: to switch to the latest unretracted version, run:
	go get github.com/polaris1119/foo@latest go get: downgraded github.com/polaris1119/foo v0.3.0 <span class="o">=</span>&gt; v0.2.0
</code></pre></div><p>提示信息还是挺友好的，告知你 v0.2.0 是一个撤回的版本。</p>
<p>虽然警告，但 v0.2.0 可以正常使用吗？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run .
这是一个更好的版本
</code></pre></div><p>发现一切正常。</p>
<p>有了这个功能，有一些模块可能会使用它。那怎么知晓我们的项目有没有依赖撤回的版本呢？使用 go list 命令即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go list -m -u all
gopher
github.com/polaris1119/foo v0.2.0 <span class="o">(</span>retracted<span class="o">)</span> <span class="o">[</span>v0.3.0<span class="o">]</span>
</code></pre></div><p>我们现在回到最新版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get github.com/polaris1119/foo@latest
go get: upgraded github.com/polaris1119/foo v0.2.0 <span class="o">=</span>&gt; v0.3.0
</code></pre></div><h3 id="为-foo-模块增加功能">为 foo 模块增加功能</h3>
<p>又过了一段时间，我们为 foo 模块增加了新的功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Quz</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&#34;This is Quz function&#34;</span>
<span class="p">}</span>
</code></pre></div><p>提交到 GitHub，并发布 v0.4.0，依然是不稳定版本。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git tag v1.0.0
$ git push -q origin v1.0.0

</code></pre></div><p>但很糟糕的是，我不小心发布了 v1.0.0，这样会让用户以为你的模块已经是稳定版本，但实际上并不是这样。所以，我们想撤回 v1.0.0。</p>
<p>在撤回这个版本之前，我们应该先发布 v0.4.0 版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git tag v0.4.0
$ git push -q origin v0.4.0
</code></pre></div><p>要撤回 v1.0.0，我们需要发布 v1.0.1（为什么？因为我们要写入撤回的信息）。不过这样一来，我们还得撤回 v1.0.1，死循环了。。。go module 允许我们指定一个撤回的版本范围，这次手动编辑 go.mod 文件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">module github.com/polaris1119/foo

go 1.16

retract <span class="o">(</span>
    // Bar 方法返回值不友好
    v0.2.0

    // v1 提前发布了
    <span class="o">[</span>v1.0.0, v1.0.1<span class="o">]</span>
<span class="o">)</span>
</code></pre></div><p>提交这次改动到 GitHub，然后再创建 v1.0.1 版本。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git tag v1.0.1
$ git push -q origin v1.0.1
</code></pre></div><p>接着切到 gopher 模块。</p>
<p>为了让 <a href="https://goproxy.cn" target="_blank" rel="noopener">https://goproxy.cn</a>
 知晓 v1.0.0 等版本，我们先获取它。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get github.com/polaris1119/foo@v1.0.0
$ go get github.com/polaris1119/foo@v1.0.1
$ go get github.com/polaris1119/foo@v0.4.0
</code></pre></div><blockquote>
<p>注意，切换到 v1.0.x 版本时，很可能看不到版本撤回的信息，因为 proxy 可能还没自动定期更新。一般需要等待一段时间，比如 1 分钟。如果没有看到警告信息，等待 1 分钟后再试，应该能看到。</p>
</blockquote>
<p>现在列出所有的版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go list -m -versions -retracted github.com/polaris1119/foo
github.com/polaris1119/foo v0.1.0 v0.2.0 v0.3.0 v0.4.0 v1.0.0 v1.0.1
</code></pre></div><p>或只列出未撤回版本：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go list -m -versions github.com/polaris1119/foo
github.com/polaris1119/foo v0.1.0 v0.3.0 v0.4.0
</code></pre></div><p>赞！v0.4.0 是该模块的新版本。</p>
<p>这时可以更新下 gopher，来使用 foo 的新功能：（加上对 foo.Quz 函数的调用）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run .
这是v0.3.0版本
This is Quz <span class="k">function</span>
</code></pre></div><blockquote>
<p>提示：如果你将来要发布 v1 稳定版，应该从 v1.0.2 开始，因为 v1.0.0 和 v1.0.1 被占用了。</p>
</blockquote>
<h2 id="02-关于-incompatible">02 关于 incompatible</h2>
<p>讲解完 retract 指令后，先看本文开头截图中的另外一个东西：incompatible。</p>
<p>在 go-chi 框架中，v2.x.x、v3.x.x 和 v4.x.x 都加上了 incompatible，这是什么意思？</p>
<p>Go 模块的版本号需要遵循 <code>v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> 的格式，当 major 大于 1 时，版本号需要体现在模块名中，比如 Echo 框架：github.com/labstack/echo/v4。</p>
<p>然而，由于 Go 模块功能出现较晚（Go1.11 才出现），在它出现之前，很多项目的版本号已经大于 1 了，比如 Echo 框架，这些版本连 go.mod 文件都没有，更别提模块名加上版本号。于是，这些版本就会有 incompatible 标记。</p>
<p>因为模块名没有版本信息，导致无法判断版本的兼容性问题，比如 v2.x.x 和 v3.x.x 都是 incompatible 的，使用 v2.x.x 的项目，更新依赖时，会直接升级到 v3.x.x，这显然是不行的，因此才标记它们为 incompatible（不兼容）。</p>
<p>你可以在上面做这个试验：新增版本 v2.0.0，但不修改 go.mod 文件中的 module 名，看看最新版本是否会带 incompatible。</p>
<p>一般不建议项目使用 incompatible，毕竟稳定性没法保证，它是不符合 Go Module 规范的。</p>
<h2 id="03-go-chi-撤回所有主版本">03 go-chi 撤回所有主版本</h2>
<p>先介绍下 chi 这个框架：</p>
<blockquote>
<p>lightweight, idiomatic and composable router for building Go HTTP services</p>
</blockquote>
<p>它主要强调自己是一个路由，方便构建 HTTP 服务。它兼容 net/http，没有任何第三方依赖。</p>
<p>简单使用示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/go-chi/chi&#34;</span>
	<span class="s">&#34;github.com/go-chi/chi/middleware&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">chi</span><span class="p">.</span><span class="nf">NewRouter</span><span class="p">()</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nx">Logger</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">w</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;welcome&#34;</span><span class="p">))</span>
	<span class="p">})</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:3000&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>有兴趣的自己去了解。这里主要说下它撤回主版本的事情。</p>
<p>chi 保证自己有很好的兼容性，而作者特别厌烦模块名带版本号，即 <code>github.com/go-chi/chi/v4</code> 这样的（有强迫症），但 chi 项目 tag 已经到 4.x.x 了，怎么办？</p>
<p>从上面截图看，它一直使用的 incompatible。没想过到 Go1.16 除了 retract 的功能，于是 chi 作者做了一个决定：在已经发布的版本中，只保留 v1.5.x 系列，其他的全部撤回。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go list -m -versions github.com/go-chi/chi
github.com/go-chi/chi v1.5.0 v1.5.1 v1.5.2 v1.5.3
</code></pre></div><p>没有了一大堆带 incompatible 的版本，世界瞬间清静了。</p>
<p>不过它的这个决定，有不少人反对，reddit 上也是激烈讨论。</p>
<p>作者表示：<a href="https://github.com/go-chi/chi/issues/561" target="_blank" rel="noopener">https://github.com/go-chi/chi/issues/561</a>
</p>
<blockquote>
<p>对于给您带来的不便，我再次表示歉意，但是我为此项目投入了数年甚至数千小时的时间，对此我非常感兴趣，SIV 是我坚决反对的事情，因此我不会采纳它。尽管许多人不同意，但请记住，这是 OSS，不是以任何方式赞助或付费的，您始终可以选择 fork 它并维护自己的版本。</p>
</blockquote>
<p>作者很强硬。（谁知道 SIV 是什么意思？）</p>
<p>实际上使用 retract，之前的版本依然可以正常使用。我个人比较支持 chi 作者的做法。你呢？欢迎交流你的看法。</p>
]]></content>
		</item>
		
		<item>
			<title>为什么学 Rust 及相关学习资料推荐</title>
			<link>https://polarisxu.studygolang.com/posts/rust/why-rust-and-study-book/</link>
			<pubDate>Sat, 20 Feb 2021 17:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/why-rust-and-study-book/</guid>
			<description>大家好，我是站长 polarisxu。 春节结束，我的 Rust 之旅才刚刚开始。经过春节期间的学习，发现 Rust 真的是有点复杂，好吧，我觉得很复杂。如果你跟我一样，决定学习 Rust，那一定要有心理准备，要啃一块硬骨头，毕竟跟 Go 语言比起来，复杂太多了。 01 为什么要学 Rust 呢？ 看看 Google 上的结果： 爱总是能找到一堆理由，不爱亦如此。比如也有反对你学习 Rust 的，比如这篇：《我为什么反对使用 Rust</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>春节结束，我的 Rust 之旅才刚刚开始。经过春节期间的学习，发现 Rust 真的是有点复杂，好吧，我觉得很复杂。如果你跟我一样，决定学习 Rust，那一定要有心理准备，要啃一块硬骨头，毕竟跟 Go 语言比起来，复杂太多了。</p>
<h2 id="01-为什么要学-rust-呢">01 为什么要学 Rust 呢？</h2>
<p>看看 Google 上的结果：</p>
<p><p class="md__image">
  <img src="../imgs/why-should-learn-rust.png"
    alt=""  />
</p>
</p>
<p>爱总是能找到一堆理由，不爱亦如此。比如也有反对你学习 Rust 的，比如这篇：<a href="https://www.infoq.cn/article/65tlwzqz2capvldohgix" target="_blank" rel="noopener">《我为什么反对使用 Rust？》</a>
。</p>
<p>所以为什么学，为什么不学，由你自己定。但有两个事实供参考。</p>
<p><strong>1、StackOverflow 调查中，连续 5 次夺得最受程序员喜爱的语言评比第一名。</strong></p>
<p>比如 2020 年的调查结果，65,000 名参与调查程序员中，最爱 Rust 的竟然占比高达 86.1%，远超第二名。咋一看很奇怪，其实这里有一个误区，问的问题这样的：多少开发人员正在使用该语言或技术进行开发，并且表示有兴趣继续开发该语言或技术。也就是说，使用 Rust 的开发这种，有 86.1% 的人有兴趣继续使用。实际上，这个调查中，一共只有 5% 的人使用 Rust。</p>
<p><p class="md__image">
  <img src="../imgs/stackoverflow-loved-rank.png"
    alt=""  />
</p>
</p>
<p>我的理解是，那些入门 Rust 的人或喜欢 Rust 的人大概率继续喜欢（入门了就大概率成为了忠实粉，是不是不想白学。哈哈哈哈，毕竟辛苦不容易。玩笑下~），但让更多人入门 Rust 是个问题。。。</p>
<p>StackOverflow 专门做了一个调查，为什么 Rust 用户喜欢 Rust，这里直接放上译文：<a href="https://rustcc.cn/article?id=3ce10a05-9506-475d-8c8a-3ad74130ad83" target="_blank" rel="noopener">https://rustcc.cn/article?id=3ce10a05-9506-475d-8c8a-3ad74130ad83</a>
。</p>
<p><strong>2、Microsoft、Google 和 AWS 等似乎都在挺 Rust。</strong></p>
<p>比如 <a href="https://www.oschina.net/news/128818/microsoft-rust-team" target="_blank" rel="noopener">微软组建 Rust 开发人员团队</a>
、<a href="https://www.oschina.net/news/121772/amazon-software-engineer-rust" target="_blank" rel="noopener">加大支持力度，AWS 计划招聘更多 Rust 开发人员</a>
、<a href="https://www.infoq.cn/article/mqz2zrqt9pyu0ojoavra" target="_blank" rel="noopener">微软正用 Rust 重写 Windows 组件</a>
、<a href="https://www.infoq.cn/article/uup3gzeGpAtd7KIS8pzf" target="_blank" rel="noopener">用 Rust 重构核心开源软件吧，谷歌愿意给你钱</a>
 等。</p>
<p>在 <a href="https://mp.weixin.qq.com/s/_VIUKpr20_h6jBNarnmk2g" target="_blank" rel="noopener">Rust 的第一印象</a>
就提到，Rust 基金会成立，这几个都是基金会成员，国内的华为也是。</p>
<p>从这些信息看出，这些公司都希望使用 Rust 替代 C++。所以，如果你掌握了 C++，Rust 对你来说是不错的选择，而且入门也会更容易。</p>
<p>至于我个人来说，为什么学习 Rust，主要有如下考虑：</p>
<ul>
<li>应该尝试学习不同的语言，而且 Rust 是现代的编程语言，有很多常规语言中没有的东西；</li>
<li>程序员修炼之道中有个建议，就是想要抵抗技术过时的风险，就得每年学一门语言；</li>
<li>想通过对 Rust 的学习，和 Go 对比着来梳理、输出，加深对两门语言的理解；</li>
</ul>
<p>所以，我学习 Rust 并没有想过将它用在工作中（但实际会不会用，谁知道呢），完全是出于好奇，让自己多掌握一门技能，提升自己。</p>
<h2 id="02-相关学习资料推荐">02 相关学习资料推荐</h2>
<p>我自己学习才几天，但连续看了一些资料，这里列举一些：</p>
<p><strong>1、官方文档</strong></p>
<p>官方有一本 The Rust Programming Language，国内也有人翻译了，免费阅读版本：<a href="https://kaisery.github.io/trpl-zh-cn/" target="_blank" rel="noopener">https://kaisery.github.io/trpl-zh-cn/</a>
，因为官方这本书就是可以免费阅读的，虽然也出版了。官方出版了，国内出版社也引进了，这就是《Rust 权威指南》。</p>
<p>我最开始就是看的这本书，但看了一大半有点看不下去了。我个人感觉这本书不太适合入门。据说第一版本更是不适合，现在是改版之后的，稍微好些。</p>
<p><strong>2、Rust 编程之道</strong></p>
<p>这是国内张汉东老师出的，我初略看完了。为什么是初略？有些章节仔细认真阅读了，有些略过，因为内容太多了。但这本书看下来，会比官方的 “Rust 圣经” 更易看懂。借用书中前言的一段话：</p>
<blockquote>
<p>Rust 官方虽然提供了 Rust Book（即上面说的圣经），但是内容的组织非常不友好，基本就是对知识点的罗列，系统性比较差。后来官方也意识到了这个问题，推出了第 2 版的Rust Book，内容组织方面改善了很多，对学习者也非常友好，但系统性还是差了点。后来又看了国内 Rust 社区组织群友们合著的 Rust Primer，以及国外的Programming Rust，我才对 Rust 建立了基本的认知体系。</p>
</blockquote>
<p><strong>3、Rust Primer</strong></p>
<p>给初学者的 Rust 中文教程。这是国内 Rust 社区组织编写的，在线阅读地址：<a href="https://rustcc.gitbooks.io/rustprimer/content/" target="_blank" rel="noopener">https://rustcc.gitbooks.io/rustprimer/content/</a>
。这本书我还没有看。</p>
<p><strong>4、Programming Rust</strong></p>
<p>这是 O’REILLY 出版的一本书，图灵社区引进翻译了，但从评论看，似乎翻译的不好：<a href="https://www.ituring.com.cn/book/2101" target="_blank" rel="noopener">https://www.ituring.com.cn/book/2101</a>
。挺奇怪的，译者感觉主要涉及的领域是 Web 前端，不知道为什么会翻译这本书。从评论看，如果要看这本书，似乎英文版更合适。当然我自己没看过，完全从大家的评论分析的。</p>
<p><strong>5、Mastering Rust</strong></p>
<p>这本书目前已经更新第二版了，而且中文版也出版了，即：《精通 Rust 第二版》。目前我还在看这本，看了一半，整体感觉写的挺好的。但翻译中有一些错误（在所难免，整体还是可以）。所以我建议大家看该书时，遇到一些名词或感觉不对的，和英文原版对照着确认下。</p>
<p><strong>6、Rust Programming Cookbook</strong></p>
<p>Cookbook 系列，中文版《Rust 语言编程实战》2021 年刚上线售卖。</p>
<p><strong>7、深入浅出 Rust</strong></p>
<p>这也是国人写的一本书，没有看过，不做评论。</p>
<p>此外，国外还有其他一些 Rust 相关的图书，比如 Rust 函数式编程、Rust 构建微服务系统、Rust 进行 WebAssembly 编程、用 Rust 实现数据结构和算法、Rust 并发编程、Rust 机器学习实践、Rust 系统编程等等，可以在 <a href="https://www.amazon.com/s?k=rust&amp;i=stripbooks&amp;rh=n%3A283155%2Cn%3A5&amp;dc&amp;qid=1613572146&amp;rnid=283155&amp;ref=sr_nr_n_4" target="_blank" rel="noopener">Amazon</a>
 上查到。另外 《Rust In Action》也快出版了。</p>
<p>可见，Rust 相关的资料这两年还是出了不少。</p>
<p>因为 Rust 内容很多，入门不易，容易劝退，比较建议大家从中文资料入手。所以，我个人推荐看以下图书：</p>
<ul>
<li>精通 Rust 第二版，对照着英文看。英文版可以关注公众号 <strong>polarisxu</strong> ，回复 <strong>rust01</strong> 获取；</li>
<li>Rust 编程之道</li>
<li>Rust Primer</li>
</ul>
<p>可以选择一本，然后遇到不明白的，可以查其他的，结合者学习。同时，官方的文档应该查阅，比如标准库文档。</p>
<p>此外，有一个群友推荐了一个 B 站上的 Rust 视频教程：<a href="https://www.bilibili.com/video/BV1hp4y1k7SV" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1hp4y1k7SV</a>
，喜欢视频的朋友可以看看。如果你有好的资料推荐，欢迎留言，也欢迎对以上资料做评价。</p>
<p>是的，我创建了一个 Rust 的微信群，用来学习&amp;吐槽 Rust，想进群的加我微信：<strong>gopherstudio</strong>，备注 rust。</p>
]]></content>
		</item>
		
		<item>
			<title>Go1.17 快报：将移除 GOPATH</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go1.17-will-remove-gopath/</link>
			<pubDate>Fri, 19 Feb 2021 09:20:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go1.17-will-remove-gopath/</guid>
			<description>大家好，我是站长 polarisxu。 是的，没看错，Go 1.16 刚正式发布，但这里说的是 Go1.17 将会包含的改变（不出意外的话），我会出一系列文章介绍 Go1.17 的变化。 关于 Go 1.16 的变化。Reddit 上有一张图总结的挺好的： 相关的知识点，我之前也写过很好几篇文章，有兴趣的可以看看： Go 1.16 的这个新变化需要适应下：go get 和 go install 的变化 提前试用将在 Go1.16 中发布的内嵌静态资源功能 基于 Go1.16 实现静态文件的 HTTP</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>是的，没看错，Go 1.16 刚正式发布，但这里说的是 Go1.17 将会包含的改变（不出意外的话），我会出一系列文章介绍 Go1.17 的变化。</p>
<p>关于 Go 1.16 的变化。Reddit 上有一张图总结的挺好的：</p>
<p><p class="md__image">
  <img src="../imgs/go1.16-full-feature.png"
    alt=""  />
</p>
</p>
<p>相关的知识点，我之前也写过很好几篇文章，有兴趣的可以看看：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/18AZEEX1UeShLx6-9Ir9Zw" target="_blank" rel="noopener">Go 1.16 的这个新变化需要适应下：go get 和 go install 的变化</a>
</li>
<li><a href="https://mp.weixin.qq.com/s/SiCTV7R2wA_I2nCQkC3GGQ" target="_blank" rel="noopener">提前试用将在 Go1.16 中发布的内嵌静态资源功能</a>
</li>
<li><a href="https://mp.weixin.qq.com/s/dxDQkMGLB9sTsklWzx_pnQ" target="_blank" rel="noopener">基于 Go1.16 实现静态文件的 HTTP Cache</a>
</li>
<li><a href="https://mp.weixin.qq.com/s/8ukhxjSPqK5e9wSJyKGTZA" target="_blank" rel="noopener">图书《Go 语言标准库》更新了：io/fs 包讲解</a>
</li>
</ul>
<p>刚刚 Go 官方发表<a href="https://docs.studygolang.com/blog/go116-module-changes" target="_blank" rel="noopener">博文</a>
，针对 Go1.16 中 “Modules on by default” 进行了详细讲解。默认启用 Module 是什么意思？也就是说 GO111MODULE=on，进一步，即使没有 go.mod ，go 命令现在仍以模块感知模式（module-aware mode）构建包。</p>
<p>尽管如此，你至少还可以手动禁用 Module，即设置  GO111MODULE=off。</p>
<p>但官方计划在 Go1.17 中移除  GO111MODULE 这个环境变量，届时将只能使用 Module 模式。Go 语言总是针对某个问题的尽量只有一种解决方案，保持其简单的“本性”，我个人还是挺喜欢的。当然我相信也会有人不喜欢。</p>
<p>这里给大家一些建议：</p>
<ul>
<li>网上的文章，讲解 Go 环境搭建的，如果不是基于 module，而是 GOPATH 的，直接忽略。GOPATH 的历史，有兴趣可以了解，但作为新手，入门时多半下载的最新版本 Go，这时如果看到文章还是 GOPATH 年代的，基本环境都搞不定，会很有受挫感。</li>
<li>目前市面上的图书，大部分都还是基于 GOPATH 的（注：我出版的 《Go 语言编程之旅》是基于 Module 的），这部分内容，基本也可以略过，毕竟 GOPATH 要进博物馆了。</li>
<li>如果还没有迁移到支持 Module 的版本，这半年时间尽快迁移吧，毕竟现在的库基本会基于 Module 构建，Go 1.17 预计 2021 年 8 月发布，距离 Go 1.11 过去好几个版本了，给了充足的过度时间。</li>
</ul>
<p>此外，在 Go1.17 中关于 module 的特性还会有其他改进，比如支持 <a href="https://github.com/golang/go/issues/36460" target="_blank" rel="noopener">lazy module loading</a>
，这应该会使模块加载过程更快，更稳定。对 Go1.17 中其他设计模块变化的部分，可以通过 <a href="https://github.com/golang/go/labels/modules" target="_blank" rel="noopener">https://github.com/golang/go/labels/modules</a>
 查看。</p>
<p>对于 Go 做出废弃 GOPATH 的决定，你怎么看？</p>
]]></content>
		</item>
		
		<item>
			<title>Rust 的第一印象</title>
			<link>https://polarisxu.studygolang.com/posts/rust/rust-first-impression/</link>
			<pubDate>Sun, 14 Feb 2021 23:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/rust/rust-first-impression/</guid>
			<description>大家好，我是站长 polarisxu。 有些朋友应该知道，我最近在看 Rust，在朋友圈我发了一些关于 Rust 相关的东西。2021 年，会陆续写一些 Rust 相关的文章。今天先来一篇。 这篇文章不谈具体的语法，主要从总体上介绍下 Rust，更确切说是 Rust 给我的第一印象，文章（包括后续 Rust 的文章）会和 Go 对比着来，方便 Go 朋友们一起学习、交流。 01 官网 对于中国开发者来说，我认为 Rust 的官网相比 Go 官网</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>有些朋友应该知道，我最近在看 Rust，在朋友圈我发了一些关于 Rust 相关的东西。2021 年，会陆续写一些 Rust 相关的文章。今天先来一篇。</p>
<p>这篇文章不谈具体的语法，主要从总体上介绍下 Rust，更确切说是 Rust 给我的第一印象，文章（包括后续 Rust 的文章）会和 Go 对比着来，方便 Go 朋友们一起学习、交流。</p>
<h2 id="01-官网">01 官网</h2>
<p>对于中国开发者来说，我认为 Rust 的官网相比 Go 官网至少有两大优势：</p>
<ul>
<li>可以正常访问；</li>
<li>多国语言支持很好；</li>
</ul>
<p><p class="md__image">
  <img src="../imgs/rust-lang.png"
    alt=""  />
</p>
</p>
<p>官网中文版：<a href="https://www.rust-lang.org/zh-CN/" target="_blank" rel="noopener">https://www.rust-lang.org/zh-CN/</a>
，而 Go 语言官网的中文版呢？残缺不全，不权威，不是核心团队组织领导弄的。</p>
<p>这些当然不是大问题，但一定程度上能反映出 Rust 社区的强大，由社区驱动 Rust 的发展，特别是 Mozilla 裁员，不少人担心 Rust。前些天 <a href="https://foundation.rust-lang.org/" target="_blank" rel="noopener">Rust Foundation</a>
 成立，成员包括 Mozilla、Google、Microsoft、华为、AWS 等，这表明，Rust 不会由某一个公司掌控，是完全社区驱动的，从官网的相关团队也可以看出一二：</p>
<p><p class="md__image">
  <img src="../imgs/rust-member.png"
    alt=""  />
</p>
</p>
<p>此外还有相应的工作组，分工明确。</p>
<p>浏览官方，你会发现，和 Rust 相关的大部分内容都是官方团队在维护，比如 Rust By Example，竟然有专门的工作组。而 Go By Example 是一个 Go 爱好者写的。</p>
<p>只看官网，Rust 明显胜过 Go。</p>
<p>注：Go 除了 golang.org，还有 go.dev，这个站点在不断变强大。</p>
<h2 id="02-学习文档">02 学习文档</h2>
<p>这里说的文档指官方的。</p>
<p>Rust 有一本“圣经”，The Rust Programming Language，即《Rust 程序设计语言》，这不是出版的图书，而是官方提供的供免费阅读。Go 也有“圣经”，不过不是官方免费阅读的。Go 官方提供的是 Effective Go，比“圣经”还是简单很多。</p>
<p>在工具方面的文档，Rust 和 Go 一样，文档挺详细的，但 Rust 在展现形式上，采用书籍的形式，更有利于阅读。</p>
<p>Go 有语言规范，而 Rust 目前还没有规范，只是有一个参考手册（reference）。</p>
<h2 id="03-安装和工具链">03 安装和工具链</h2>
<p>如果是类 Unix 系统（MacOS、Linux 等），一条命令即可搞定 Rust 的安装。当然也可以和 Go 的安装方式一样，下载预编译好的安装包，进行安装。</p>
<p>Rust 提供的 rustup 可以方便的管理 Rust 自身，包括安装稳定版本、测试版本或 Nightly 版本，也可以方便的卸载 Rust。</p>
<p>Go 爱好者们都感慨其工具链的强大。Rust 也有强大的工具链，特别是 cargo（竟然有 go，哈哈哈哈），很强大，它既是包管理工具也是系统构建工具。</p>
<h2 id="04-特性很多">04 特性很多</h2>
<p><p class="md__image">
  <img src="../imgs/rust-feature.png"
    alt=""  />
</p>
</p>
<p>上图是从 Rust 官网截取的，各种黑魔法、未稳定特性手册，这让人多少就感觉特性不少，还不断在加入。</p>
<h2 id="05-欢迎一起学习">05 欢迎一起学习</h2>
<p>你准备好一起学习 Rust 了吗？都说 Rust 难，有没有自己实际学习看看，是不是真的那么难？也许可以验证一下学习能力？！哈哈哈~</p>
<p>手动内存管理，如 C、C++；带 GC，如 Java、Go。你想过还有第三种选择吗？一起开启 Rust 之旅吧！</p>
]]></content>
		</item>
		
		<item>
			<title>Go 终于可以开发原生 Mac APP 了</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/use-mac-apis-and-build-mac-apps-with-go/</link>
			<pubDate>Wed, 10 Feb 2021 23:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/use-mac-apis-and-build-mac-apps-with-go/</guid>
			<description>本文是 macdriver 作者写的，这是一个 Go 语言的 Objective-C 桥接器，使得 Go 可以使用 Mac API。如果做过 Apple 相关应用开发，可以试试这个。 如果你使用 Apple 设备并且是 Go 程 序员，或者正在考虑学习 Go，那么我们会获得一些非常酷的新功能。今天，我发布了 macdriver 的 Alpha 版，这是一个 Go 语言的 Objective-C 桥，具有与常见 Mac API 的绑定。 那些关注我的上一篇有关 Large Type in 80 lines of Go 的文章的人可能已经找到了 macdriver。 largetype 程序是 macdriver 的示例项</description>
			<content type="html"><![CDATA[<blockquote>
<p>本文是 macdriver 作者写的，这是一个 Go 语言的 Objective-C 桥接器，使得 Go 可以使用 Mac API。如果做过 Apple 相关应用开发，可以试试这个。</p>
</blockquote>
<p>如果你使用 Apple 设备并且是 Go 程 序员，或者正在考虑学习 Go，那么我们会获得一些非常酷的新功能。今天，我发布了 <a href="https://github.com/progrium/macdriver" target="_blank" rel="noopener">macdriver</a>
 的 Alpha 版，这是一个 Go 语言的 Objective-C 桥，具有与常见 Mac API 的绑定。</p>
<p><p class="md__image">
  <img src="../imgs/macdriver.gif"
    alt=""  />
</p>
</p>
<p>那些关注我的上一篇有关 <a href="https://dev.to/progrium/large-type-legacy-celebrated-in-80-line-go-program-1mob" target="_blank" rel="noopener">Large Type in 80 lines of Go</a>
 的文章的人可能已经找到了 macdriver。 largetype 程序是 macdriver 的示例项目之一。</p>
<p><p class="md__image">
  <img src="../imgs/macdriver1.jpeg"
    alt=""  />
</p>
</p>
<p>macdriver repo 中的另一个示例是这个额外的小菜单栏（又名 systray 或状态图标），它为您提供了 Pomodoro 计时器。这个小程序也使用 macdriver 的<a href="https://github.com/progrium/macdriver/blob/main/examples/pomodoro/main.go" target="_blank" rel="noopener">不到 80 行代码</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/macdriver2.gif"
    alt=""  />
</p>
</p>
<p>最后，如果您正在使用 Go 1.16 beta，或者可以等待它的正式发布，也有一个示例可以为您提供具有透明背景的全屏 Web 视图，让您可以使用 Web 技术在屏幕上绘制 overlays 之类的东西。Twitch streamers 可能也加入其中，是不是很棒！</p>
<h2 id="多年的打磨">多年的打磨</h2>
<p>MacDriver 的动机是方便通过 Go 来使用 Mac 系统 API（例如 Cocoa）制作 GUI 应用程序，就是说，我的大部分工作现在都将网络技术用于用户界面，即 la Electron。</p>
<p>去年，我使用 <a href="https://github.com/webview/webview" target="_blank" rel="noopener">webview</a>
 项目在 Go 中启动了一个替代的 Electron 堆栈，该项目使用您平台的本机浏览器引擎并创建一个带有 webview 的窗口。尽管绝对简单且跨平台，但该项目并未优先考虑任何平台特定的功能。</p>
<p>最重要的是，如果您还想在同一程序中制作一个类似于 Pomodoro 计时器的小菜单小程序（并非罕见），您可以找到另一个独立的跨平台 Go 库来存放系统托盘内容，但是这些一次性库通常会有 API 不完整的困扰。更重要的是，它们是不可组合的！您不能将 systray 库与 webview 库一起使用，因为它们都假定拥有主 Cocoa 线程。</p>
<p>因此，像往常一样，我感到沮丧的是，没有一个更广泛思考，更通用的解决方案。如果我想使用其他 Mac API，该怎么办？等待另一个不完整，不可组合的项目？不，我们在这里建立自己的未来。</p>
<p>早在 2013 年，我就发现了一个丹麦人 Mikkel 创建的项目：<a href="https://github.com/mkrautz/objc" target="_blank" rel="noopener">Objective-C bridge for Go</a>
，虽然它不能正常工作。</p>
<p>这整个过程应该很简单。 <a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime" target="_blank" rel="noopener">Objective-C 运行时</a>
实际上是一个名为 libobjc 的 C 库。因此，从理论上讲，您应该能够像其他 C 库一样使用 cgo 调用 libobjc 并在 Go 中使用 Objective-C 对象。</p>
<p>不幸的是，libobjc 中调用函数（对于任何方法/函数调用都是通用的）的参数是可变的（接受任意数量的参数）。 Cgo 不支持可变参数函数调用！因此，Mikkel 使用了<a href="https://github.com/mkrautz/variadic" target="_blank" rel="noopener">汇编操作</a>
，以使几乎任何可变的 C 函数都可调用。惊人！但是自 2013 年以来，对 Go 运行时的更改打破了这一点，他很早就转向其他项目。</p>
<p>有了一定的决心，我又进行了黑客般的工作。我甚至忘了我在 2018 年在 dev.to 上发布了有关此问题的信息。还有更多的事情需要解决，但是直到去年初我需要解决此 Webview 和系统托盘可组合性问题时，我都是将其搁置的。我引入了废弃的 objc bridge 程序包（我已修复的可变参数程序包），并开始为某些更常见的 Mac API 制作本机 Go 包装器。结果是 macdriver！</p>
<h2 id="好处">好处</h2>
<p>现在，您可以在 Go 中制作可以处理 Mac 的快速，本机二进制文件。不仅仅意味着制作 MacOS 应用程序。有许多 API 只是开辟了新的可能性。例如，我很兴奋能使用 Core ML API 在新的 M1 设备上使用神经引擎。</p>
<p>另一个好处是能够使用 Go 构建工具链快速制作 Mac 应用。没有 Xcode！只需要 go build。</p>
<h2 id="后续计划">后续计划</h2>
<p>我很高兴看到人们使用 macdriver。在 <a href="https://github.com/progrium/macdriver" target="_blank" rel="noopener">README</a>
 中有很多有关使用它的信息，但我仍在研究文档。在这一点上，它应该主要是自我解释，但随时可以在<a href="https://github.com/progrium/macdriver/discussions" target="_blank" rel="noopener">论坛</a>
中提问。</p>
<p>如果您有兴趣与我一起探索新的可能性，我一直想尝试将 macdriver 用于 Apple Watch 应用程序。 Mikkel 的原始桥包中有一个 iOS 概念验证，但我还没有尝试过。假设它可以工作（可能涉及 Xcode 或其他开发人员工具），似乎也可以用于 Apple Watch 甚至 Apple TV。</p>
<blockquote>
<p>原文链接：<a href="https://dev.to/progrium/use-mac-apis-and-build-mac-apps-with-go-ap6" target="_blank" rel="noopener">https://dev.to/progrium/use-mac-apis-and-build-mac-apps-with-go-ap6</a>
</p>
<p>本文作者：Jeff Lindsay</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>明天除夕，闲聊几件事</title>
			<link>https://polarisxu.studygolang.com/posts/talk/2021-02-10-talking/</link>
			<pubDate>Wed, 10 Feb 2021 21:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/2021-02-10-talking/</guid>
			<description>大家好，我是站长 polarisxu。 明天就除夕了，农历 2020 年马上也过完了，提前祝大家新年快乐！ 今天上午折腾了一上午 Gopher 晚会文章发布的问题，写好的文章莫名违规，怎么修改都不行。最后网站发布了原文 ，公众号发布临时写的文章 ，做一件事真的太难了！（没看到这个 gopher 晚会消息可以看看） 下午带小孩去雪地嘉年华玩了一下午，发现北京人似乎没少，往年过年，北京几乎是空城，可见在北京过年</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>明天就除夕了，农历 2020 年马上也过完了，提前祝大家新年快乐！</p>
<p>今天上午折腾了一上午 Gopher 晚会文章发布的问题，写好的文章莫名违规，怎么修改都不行。最后网站发布了<a href="https://studygolang.com/topics/13112" target="_blank" rel="noopener">原文</a>
，公众号发布<a href="https://mp.weixin.qq.com/s/AWztZA6KoC2cfVBPxuslPg" target="_blank" rel="noopener">临时写的文章</a>
，做一件事真的太难了！（没看到这个 gopher 晚会消息可以看看）</p>
<p>下午带小孩去雪地嘉年华玩了一下午，发现北京人似乎没少，往年过年，北京几乎是空城，可见在北京过年的很多。这导致了一个问题：过年期间去哪里玩，大家一定要提前计划、提前预约。虽然现在都有点晚了。因为前些天我们计划好的，今天准备预约，好多都约满了。。。特殊时期，考虑的还是不周全！</p>
<p>不知道大家有无这种感觉，至少我是：放假回家，比如春节、国庆长假，做的计划，比如充电、成长，节过完了，发现计划一点也没完成。但在原地过节，计划执行的会好很多。今年留在北京过年，提前请了两天假，总体来说，和平常周末差不多，所以这个春节，我的计划应该能够较好的落实。你在回家过年还是在原地呢？是这样的情况吗？</p>
<p>在明天晚上的 Gopher 晚会上，有一个节目是和 Rust 社区联谊。想当初 Rust 刚出来时，有简单了解过，然后就没有然后后了。前段时间，有人拉我进了一个 Rust 群。近期也关注了 Rust 社区的一些动态，比如 Rust Foundation 成立，Google、华为、Microsoft、AWS、和 Mozilla 等是该基金会的创始成员，并于美国东部时间 2月 9 日下午 4 点举行第一次董事会会议。这对 Rust 来说是极大的好消息！</p>
<p><p class="md__image">
  <img src="../imgs/rust-foundation.png"
    alt=""  />
</p>
</p>
<p>下午在陪小朋友的间隙间重新看了一些 Rust 的信息，我计划 2021 年学学 Rust，会和 Go 对比着来学。这个 flag 希望能够坚持。欢迎 gopher 们一起，技多不压身，毕竟 Go 和 Rust 不冲突，而两者有些相同处，但更多是不同，值得了解另外一门优秀语言的设计！有兴趣一起组团学。</p>
<hr>
<p>明天除夕，媳妇家过年主要过明天（这天大吃大喝）；而我家主要过初一（这天大吃大喝）。。。问媳妇，初一吃什么。答曰：吃明天（除夕）剩下的。。。哎，谁让是她做饭呢。。。你那里过年主要哪天？更重除夕还是初一？</p>
]]></content>
		</item>
		
		<item>
			<title>聊聊近期出版或将出版的几本 Go 图书</title>
			<link>https://polarisxu.studygolang.com/posts/go/book/2021-go-book/</link>
			<pubDate>Sun, 07 Feb 2021 11:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/book/2021-go-book/</guid>
			<description>大家好，我是站长 polarisxu。 大家觉得 Go 的图书多吗？其实是很少的。今天聊下近期将要出版的基本 Go 图书。 01 《Go语言设计与实现》 这是一本 Go 语言进阶图书。作者历时两年，在他的网站可以免费阅读：https://draveness.me/golang/ 。他朋友圈透露，该书已经交稿，应该很快会出版。这本书绝对是 2021 年度最值得期待的 Go 图书。 作为支持，书出版时，我会送出</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>大家觉得 Go 的图书多吗？其实是很少的。今天聊下近期将要出版的基本 Go 图书。</p>
<h2 id="01-go语言设计与实现">01 《Go语言设计与实现》</h2>
<p>这是一本 Go 语言进阶图书。作者历时两年，在他的网站可以免费阅读：<a href="https://draveness.me/golang/" target="_blank" rel="noopener">https://draveness.me/golang/</a>
。他朋友圈透露，该书已经交稿，应该很快会出版。这本书绝对是 2021 年度最值得期待的 Go 图书。</p>
<p>作为支持，书出版时，我会送出几本，敬请期待！</p>
<p>从网站上看该书，主要包含如下内容（直接引用书中的思维导图）：</p>
<p><p class="md__image">
  <img src="../imgs/draveness-01.png"
    alt=""  />
</p>
</p>
<p>该书作者功底很深，如果你的计算机基础不扎实，不少内容会看的一头雾水，这表示你需要夯实你的基础了。我相信，如果你能把它吃透，一定会很有收获。</p>
<p><strong>五星推荐</strong></p>
<h2 id="02-ultimate-go-notebook">02 《ultimate go notebook》</h2>
<p>作者 William Kennedy，他是 《Go In Action》作者之一，是 <a href="https://www.ardanlabs.com/" target="_blank" rel="noopener">https://www.ardanlabs.com/</a>
 的创始人。目前在做咨询和培训。</p>
<p>前段时间，他在 Twitter 说，几个月没露脸了，因为在潜心写一本书：</p>
<p><p class="md__image">
  <img src="../imgs/goinggodotnet.jpeg"
    alt=""  />
</p>
</p>
<p>关于该书的内容，作者没有透露更多，但期待一下。预计 2021 年 3 月份出版。不过是英文版，中文是否会引进，我觉得看质量吧。</p>
<h2 id="03-nonsequential-and-distributed-programming-with-go">03 《Nonsequential and Distributed Programming with Go》</h2>
<p>这本书是已经出版了的。本书介绍了 Go 的非顺序和分布式编程。它系统地介绍了并发进程的同步和通信的基本概念。其中包括锁，信号量，公平性和死锁，监视器，本地和整个网络的消息传递，图形网络，网络探索，分布式深度和广度优先搜索以及网络领导者的选择。为了使读者熟悉这些概念，作者始终采用相同的经典示例。这使学习变得更容易，因为所介绍的概念可以更轻松地与语言资源比较。</p>
<p><p class="md__image">
  <img src="../imgs/distributed-go.jpg"
    alt=""  />
</p>
</p>
<p>该书是有电子版的。但价格真的。。。相比来说，国内的图书真的好便宜。</p>
<h2 id="04-learning-go">04 《Learning Go》</h2>
<p>从书名看，感觉是一本比较普通的入门书籍。但它有一个副标题：An Idiomatic Approach to Real-World Go Programming。</p>
<p><p class="md__image">
  <img src="../imgs/learning-go.jpg"
    alt=""  />
</p>
</p>
<p>Go 语言爱好者，很多是其他语言转过来的，在写 Go 代码时，总是能看到其他语言的影子。该书的目标是教大家 Go 的习惯用法，它提供了编写清晰且惯用的 Go 所需的基本背景。</p>
<p>无论你的经验水平如何，通过该书都将学习如何像 Go 开发人员那样思考。作者 Jon Bodner 介绍了 Go 开发人员所采用的设计模式，并探讨了使用它们的原理。你还将预览 Go 即将推出的泛型支持以及它如何适应该语言。</p>
<p>目前该书还未出版，预计 2021 年 3 月底与大家见面。</p>
<p>这本书还是挺期待的，O’Reilly 出品应该不错~</p>
<p>以上 4 本书，你期待哪本？</p>
]]></content>
		</item>
		
		<item>
			<title>10 年 Java 经验者：你应该尝试 Go 的 7 个理由</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/7-reasons-you-should-try-use-go/</link>
			<pubDate>Fri, 05 Feb 2021 22:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/7-reasons-you-should-try-use-go/</guid>
			<description>本文作者是一位工作了 20+ 年的工程师，其中 10+ 年使用 Java，7+ 年使用 C#，最近 3+ 年使用 Go。文章的观点是作者的个人总结，提倡你尝试并使用 Go 语言。目前作者已经不使用 Java 和 C# 了。 原因一：开发速度 如今，当我要编写一款软件时（我肯定可以用上面提到的三种语言编写它），我将始终选择 Go。 因为我可以花较短时间用 Go 开发完，而且代码更具可读性，不那么抽象，更“切合实际”。 在编写 Go</description>
			<content type="html"><![CDATA[<p>本文作者是一位工作了 20+ 年的工程师，其中 10+ 年使用 Java，7+ 年使用 C#，最近 3+ 年使用 Go。文章的观点是作者的个人总结，提倡你尝试并使用 Go 语言。目前作者已经不使用 Java 和 C# 了。</p>
<h2 id="原因一开发速度">原因一：开发速度</h2>
<p>如今，当我要编写一款软件时（我肯定可以用上面提到的三种语言编写它），我将始终选择 Go。</p>
<p>因为我可以花较短时间用 Go 开发完，而且代码更具可读性，不那么抽象，更“切合实际”。</p>
<p>在编写 Go 代码时，您所做的正是您应该做的。编写的代码基本就是“生产级别”代码。你不是在编写类，子类，getter，setter 和一堆代码，实际上这些都没做。当你编写 Go 代码时，你在编写代码，这可以完成某些工作。您不是在为“代码本身”编写代码。（polarisxu 注：意思是说，写的代码都是完成任务核心的代码，而不是一堆无关的代码，比如 getter/setter 之类的就是和完成任务不相关的代码）。</p>
<p>最终，你将减少编写代码的时间，并减少对代码工作的思考，因此开发的速度将蒸蒸日上。</p>
<p>旁注：从我的个人经验来看，用 Go 编写的代码从这三种语言中读起来最简单。我已经对此进行了测试。我曾经用他们最好的技术用 C＃，Java 和 Go 编写过一个软件。然后，我问了三个同事一个简单的问题：“这段代码在做什么？”。它们在 Java 和 C＃（现在是 PHP 开发人员）中迷失了，但是他们从 Go 代码中看懂了。</p>
<h2 id="原因二部署速度">原因二：部署速度</h2>
<p>这是我个人最喜欢 Go 的第二点。我倾向于实时修改。我希望修改后能立即看到修改的结果。</p>
<p>Go 代码的构建速度如此之快，我可以根据需要进行多次更改，这没有问题。而且我不在乎项目有多大。</p>
<p>想为三个主流操作系统（Win、Linux、Mac）部署二进制文件吗？小菜一碟。</p>
<h2 id="原因三只有一种方式">原因三：只有一种方式</h2>
<p>在数月或数年后看之前的代码，你将不胜感激。根据创建者的决定，Go 代码采用相同的格式设置。这意味着你将几乎理解任何 Go 代码。</p>
<p>例如，作为 C＃开发人员，你大约有 7 种不同的方式将整数转换为字符串。你可以通过更多选择来做很多其他事情。</p>
<p>你是否可以想象，如果将所有这些“不同的处理方式”结合起来，例如将整数转换为字符串，那么你将拥有多少种不同的代码？我在理解其他开发人员的 Java 和 C＃ 代码时仍然遇到问题，但是即使当时我还不知道的Go代码在做什么，却可以立很容易看懂。</p>
<p>Go 的简单性是它的优势之一，随着时间的流逝，您一定会喜欢这点。</p>
<h2 id="原因四二进制大小">原因四：二进制大小</h2>
<p>作为开发人员，你应该始终尝试拥有尽可能小的二进制文件。较小的尺寸意味着更快的部署。较小的尺寸意味着较少的网络传输。越小越好。</p>
<p>在我们公司中，我们将 Docker 用作运行时环境，因此我们将软件“打包”到 Docker 映像中。 Docker Hub 存储库中有大量映像，因此我们可以轻松比较它们的大小。当然，无论使用哪种语言，我们都会使用最佳技术来使镜像尽可能小。</p>
<p>我们不在 Docker 中使用 Java，因此抱歉，在这里无法进行比较。</p>
<p>但是我们使用 C＃ 和 Go，所以比较相同的功能。</p>
<p><a href="https://hub.docker.com/r/petrjahoda/zapsiservercore/tags?page=1&amp;ordering=last_updated" target="_blank" rel="noopener">C# 镜像 40+ MB</a>

<a href="https://hub.docker.com/r/petrjahoda/zapsi_service/tags" target="_blank" rel="noopener">Go 镜像 3+ MB</a>
</p>
<p>你可以在<a href="https://itnext.io/create-go-service-the-easy-way-viii-157427e7cd35" target="_blank" rel="noopener">本文</a>
中了解更多信息。</p>
<h2 id="原因五标准库">原因五：标准库</h2>
<p>当我们开始使用 Go 时，我们开始搜索库。因为你需要库来执行其他操作，对吗？</p>
<p>在 Go 中，它具有令人难以置信的标准库：stdlib。你仅使用标准库就可以编写几乎所有内容。更少的库（这里是模块）意味着您需要寻找的第三方代码也更少。我在<a href="https://petrjahoda.medium.com/lessons-learned-while-developing-enterprise-system-287c3afce1ca" target="_blank" rel="noopener">这篇文章</a>
中写了这个。</p>
<h2 id="原因六goroutine">原因六：Goroutine</h2>
<p>这是我们所有人的最爱。我们正在开发基于网络的软件。与该设备的通信，与该设备的通信，与…的通信，你明白了吧。我们希望在所有这些设备之间进行区分。</p>
<p>这意味着，线程是我们在软件中经常使用的东西。如果你曾经使用过线程，也许你会记得，你是如何学习的以及必须要做的工作。（polarisxu 注：比如 Java 怎么开线程，你知道吗？）</p>
<p>在 Go 中，如果要在“线程”中运行 function()，只需在其前面添加 go，即像 <code>go function()</code> 这样。</p>
<p>就这样。当我第一次看到它的时候，我就像：“就这样吗？”。是的，仅此而已。</p>
<p>另外，您是否知道，默认情况下，一个 Java 线程分配大约 1MB 的内存，C＃ 线程也分配大约 1MB 的内存，但是 Go 的 goroutine 仅分配大约 2kb 的内存？那有多棒？!</p>
<h2 id="原因七web-server">原因七：Web Server</h2>
<p>这是一瞬间的爱，特别是对我来说。你可以使用下面的代码运行一个简单的 Web 服务器，侦听 80 端口。</p>
<p>然后将你的 html，css 和 javascript 文件放入 data 文件夹中，就可以了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/julienschmidt/httprouter&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">router</span> <span class="o">:=</span> <span class="nx">httprouter</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">router</span><span class="p">.</span><span class="nf">ServeFiles</span><span class="p">(</span><span class="s">&#34;/data&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="s">&#34;data&#34;</span><span class="p">))</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:80&#34;</span><span class="p">,</span> <span class="nx">router</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>如果你想看完整的教程，<a href="https://medium.com/swlh/create-go-service-the-easy-way-iii-c84489cc1ee0" target="_blank" rel="noopener">这篇文章</a>
适合你。</p>
<p>注：我主张使用标准库，在这里，在此 Web 服务器示例中，我实际上是在使用第三方库。</p>
<p>原因很简单：我一直都在使用它，但我错误地将其视为标准。下面是没有第三方库，实现相同功能。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">Dir</span><span class="p">(</span><span class="s">&#34;./data&#34;</span><span class="p">)))</span>
	<span class="nx">_</span> <span class="p">=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:80&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="总结">总结</h2>
<p>当我第一次了解 Go 时，我并不感兴趣。我以为，我使用的已经是世界上最好的语言了（即 Java 和 C＃），并得到了大公司的支持。（polarisxu 注：世界上最好的语言不是 PHP 吗？哈哈哈哈）</p>
<p>但是后来我读了一些有关 goroutine 的东西。它吸引了我的注意。当我看到运行 Web 服务器有多么容易时，我就迷上了。我开始使用 Go，从此无法回头。 Go 成为我最爱、最常用的语言。</p>
<p>所以，我建议您尝试一下。</p>
<p>你会惊讶于你的生产力。</p>
<blockquote>
<p>本文作者：Petr Jahoda</p>
<p>原文链接：<a href="https://itnext.io/7-reasons-you-should-try-use-go-5fb4714015d1" target="_blank" rel="noopener">https://itnext.io/7-reasons-you-should-try-use-go-5fb4714015d1</a>
</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>微信支持个人免费制作红包封面了：不过跟 clubhouse 一样，只能 iOS</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/myself-wechat-red-cover/</link>
			<pubDate>Fri, 05 Feb 2021 15:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/myself-wechat-red-cover/</guid>
			<description>大家好，我是站长 polarisxu。 01 这段时间，我隐约感觉 iOS 用户各种“晒”，而 Android 用户一脸懵逼，总感觉不是一个圈子的。以下两件事特别明显： 微信 8.0 发布时，iOS 用户炸弹玩得飞起，Android 用户只能弱弱的问：这是怎么弄的？几天之后，Android 用户才有。 嘿，你有 clubhouse 邀请码吗？这些天 clubhouse 真是火的不要不要的，各种互助群。邀请码太难搞，但即使有办法搞到邀请码，如果你不</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<h2 id="01">01</h2>
<p>这段时间，我隐约感觉 iOS 用户各种“晒”，而 Android 用户一脸懵逼，总感觉不是一个圈子的。以下两件事特别明显：</p>
<ul>
<li>微信 8.0 发布时，iOS 用户炸弹玩得飞起，Android 用户只能弱弱的问：这是怎么弄的？几天之后，Android 用户才有。</li>
<li>嘿，你有 clubhouse 邀请码吗？这些天 clubhouse 真是火的不要不要的，各种互助群。邀请码太难搞，但即使有办法搞到邀请码，如果你不是 iOS 用户，抱歉，暂时没法用，因为 clubhouse 还没有 Android APP。</li>
</ul>
<p>好家伙，你们这不是“鄙视” Android 用户吗？！气~</p>
<p>今天我特意了解了下，为什么类似微信或一些新的 APP 喜欢优先在 iOS 平台发布。我认为有如下一些原因。</p>
<p><strong>1、Android 开发、适配难度大</strong></p>
<p>iOS 是苹果垄断的，机型比较少，开发、测试、适配相对都更容易。而 Android 市场，各大手机厂商都喜欢“深度”定制系统，机型千差万别，开发、测试、适配都相对比较费劲。而且，一般设计师们在设计时，也是按照 iOS 标准来进行，对 Android，有必要时才进行适当调整。</p>
<p>所以，iOS 相当于公测，在 iOS 上的功能体验，能够更好的保持一致。iOS 没问题了，Android 才会跟上，甚至有时候一些功能 iOS 试用后不合适，可能会去掉，Android 用户可能就用不到被下掉的功能了。</p>
<p><strong>2、审核机制</strong></p>
<p>AppStore 的审核机制是出了名的严格，小到一个图标的尺寸，大到开发者的资质，都是它审查的方向。而且，一般 iOS 的审核时间比较长，短则一三五天，长则可能需要半个月左右，所以一般会提前送审 iOS 版本。</p>
<p>而 Android 市场几乎没有太多审核，而且有些更新，是通过应用内进行，根本不需要经过应用市场，所以时间更可控。</p>
<p>比如王者荣耀，应该是优先提交 iOS 审核，审核通过了，才会进行两大平台的发布，这样可以更好的控制发布时间。</p>
<p><strong>3、用户群和生态</strong></p>
<p>大家一般认为，iOS 和 Android 的用户群体还是不太一样的，iOS 可以更好的打出知名度。同时，iOS 上，似乎付费更多，生态、用户群和习惯，导致不少应用喜欢在 iOS 上首发。</p>
<p>另外，iOS 都是通过 AppStore 来控制，而且 iOS 应用升级机制做的也更好，优先 iOS，控制升级，还是废弃特定新功能的版本都更容易些，而 Android 可控性较差。</p>
<p>你认为还有什么原因？</p>
<h2 id="02">02</h2>
<p>“瓜”又来了，有些人应该听说过微信红包封面，我之前想过弄一套 Go 语言中文网的，但门槛不低，而且一个要 1 块钱，如果我想让 1000 个人领红包封面，得 1000 块钱，成本不低。</p>
<p>今天看到有人分享了一个小程序，腾讯发布的，叫：微信红包封面，如下图。</p>
<p><p class="md__image">
  <img src="../imgs/wechat-red-cover01.png"
    alt=""  />
</p>
</p>
<p>从要求看，这是继续推广视频号。只要你有视频号，同时发表过一个视频并获得 10 个赞，就可以制作 1 款红包封面，要求还是很低的，制作也很方便，制作完成后可以预览效果，还允许修改一次。如果你还没有注册视频号，可以注册一个。</p>
<p>和这个公众号对应的视频号欢迎关注：polarisxu。</p>
<p><p class="md__image">
  <img src="../imgs/wechat-red-cover02.png"
    alt=""  />
</p>
</p>
<p>然而，这个小程序要求微信版本是 8.0.2，iOS 已经发布了该版本，但 Android 并未发布，因此 Android 用户无法使用，进入该小程序会提示让升级到最新版本。</p>
<p>在制作红包封面时，需要上传一张封面图，然后可以放一个你视频号中的视频。因为我这个视频号是我个人的，内容会更随意些，做了一个红包封面，是免费的，一共 10 个（可以送给 10 个人）。不过不适合分享给大家，截图让大家看下。</p>
<p><p class="md__image">
  <img src="../imgs/wechat-red-cover03.png"
    alt=""  />
</p>
</p>
<h2 id="03">03</h2>
<p>当我准备使用 Go 语言中文网制作一个 Gopher 专用红包封面时，发现没法使用了，应该是官方在做一些调整。我会时刻关注着，恢复了会做一个 Gopher 的，到时候分享出来。</p>
<p><p class="md__image">
  <img src="../imgs/wechat-red-cover04.png"
    alt=""  />
</p>
</p>
<p>注意：这个小程序目前好像搜索不到，只能分享。如果需要，可以加我微信（微信号：<strong>gopherstudio</strong>），我分享给大家，当可以使用时，方便制作一个自己的红包封面。</p>
<p>最后，注册了 clubhouse 的，欢迎 follow 我：polarisxu，别问我要邀请码，用完了。感兴趣的加我微信进互助群倒是可以的。</p>
]]></content>
		</item>
		
		<item>
			<title>怎么知道某个 API 是在哪个 Go 版本添加的？这个功能如何实现的</title>
			<link>https://polarisxu.studygolang.com/posts/go/how-realize-go-std-version-show/</link>
			<pubDate>Thu, 04 Feb 2021 15:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/how-realize-go-std-version-show/</guid>
			<description>大家好，我是站长 polarisxu。 因为 Go 的兼容性做的很好，很多人不太关心 Go 的具体版本。然而有时候可能会涉及到版本的问题，比如你想使用 strings.Builder，Go 版本就必须 &amp;gt;= 1.10，但以下代码在 Go1.10 却编译不通过。 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;strings&amp;#34; ) func main() { var b strings.Builder b.WriteString(&amp;#34;polarisxu&amp;#34;) fmt.Println(b.Cap()) } 编译会报错： $ go version go version go1.10.8 darwin/amd64 $ go run main.go # command-line-arguments ./main.go:11:15: b.Cap undefined (type strings.Builder has no field or method Cap) 提示 strings.Builder 类型没有 Cap 字段或方法。 所以，你知道标准库中</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>因为 Go 的兼容性做的很好，很多人不太关心 Go 的具体版本。然而有时候可能会涉及到版本的问题，比如你想使用 strings.Builder，Go 版本就必须 &gt;= 1.10，但以下代码在 Go1.10 却编译不通过。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">b</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Builder</span>
  <span class="nx">b</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="s">&#34;polarisxu&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nf">Cap</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><p>编译会报错：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go version
go version go1.10.8 darwin/amd64
$ go run main.go
<span class="c1"># command-line-arguments</span>
./main.go:11:15: b.Cap undefined <span class="o">(</span><span class="nb">type</span> strings.Builder has no field or method Cap<span class="o">)</span>
</code></pre></div><p>提示 strings.Builder 类型没有 Cap 字段或方法。</p>
<p>所以，你知道标准库中哪个 API 是什么版本引入的吗？或者更实际的是，我当前的版本是否能使用某个 API。</p>
<h2 id="01-常见的两种方式">01 常见的两种方式</h2>
<p>在 Go 官网有最新稳定版本的标准库文档。从 Go1.11 版本开始，在标准库中，每个类型、函数或方法有加入的版本信息，如果没有，表示 Go1.0 就有了，具体 issue 见：<a href="https://github.com/golang/go/issues/5778" target="_blank" rel="noopener">https://github.com/golang/go/issues/5778</a>
。但目前常量和变量没有版本信息，具体 issue 见：<a href="https://github.com/golang/go/issues/29204" target="_blank" rel="noopener">https://github.com/golang/go/issues/29204</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/std-show-version01.png"
    alt=""  />
</p>
</p>
<p>第二种方法，不是看具体某个 API 对应的版本，而是至少知晓，你当前使用的 Go 版本有没有某个 API，这就是 pkg.go.dev，具体通过这个网站 <a href="https://pkg.go.dev/std?tab=versions" target="_blank" rel="noopener">https://pkg.go.dev/std?tab=versions</a>
 选择你对应的版本，然后查找是否有对应的 API。</p>
<p>当然了，你使用 GoLand 之类的编辑器，某个 API 是否有，它会自动提示。</p>
<h2 id="02-标准库显示版本是如何实现的">02 标准库显示版本是如何实现的</h2>
<p>保持好奇心很重要，这是求知的动力之一。看到官网标准库显示了版本信息，我就想看看它是怎么实现的。</p>
<p>怎么查找实现的代码？</p>
<p>我的第一反应是看标准库注释里有没有写。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// A Builder is used to efficiently build a string using Write methods.
</span><span class="c1">// It minimizes memory copying. The zero value is ready to use.
</span><span class="c1">// Do not copy a non-zero Builder.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Builder</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">addr</span> <span class="o">*</span><span class="nx">Builder</span> <span class="c1">// of receiver, to detect copies by value
</span><span class="c1"></span>	<span class="nx">buf</span>  <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></div><p>没有看到任何版本相关信息。这时你会如何查找？</p>
<p>我的方式是这样的。</p>
<p>1）在页面审查元素，看到 <code>&lt;span title=&quot;Added in Go 1.10&quot;&gt;1.10&lt;/span&gt;</code> 节点。</p>
<p><p class="md__image">
  <img src="../imgs/std-show-version02.png"
    alt=""  />
</p>
</p>
<p>2）Go 官网源码在这里：<a href="https://github.com/golang/website" target="_blank" rel="noopener">https://github.com/golang/website</a>
，在该源码中搜索 <code>Added in</code>，找到了 package.html 模板文件。</p>
<p><p class="md__image">
  <img src="../imgs/std-show-version03.png"
    alt=""  />
</p>
</p>
<p>3）上图中， $since 变量代表了 Go 版本，而它是通过 since 函数得到的： <code>{{$since := since &quot;func&quot; &quot;&quot; .Name $.PDoc.ImportPath}}</code>，很显然这是一个自定义模板函数，因此查找它。website 项目没有找到，因此到 <a href="https://github.com/golang/tools" target="_blank" rel="noopener">tools</a>
 项目去找：因为 godoc 在这个项目中。</p>
<p><p class="md__image">
  <img src="../imgs/std-show-version04.png"
    alt=""  />
</p>
</p>
<p>通过这个可以找到 sinceVersionFunc 所在文件：versions.go，然后就能找到如下的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// InitVersionInfo parses the $GOROOT/api/go*.txt API definition files to discover
</span><span class="c1">// which API features were added in which Go releases.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Corpus</span><span class="p">)</span> <span class="nf">InitVersionInfo</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">pkgAPIInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">parsePackageAPIInfo</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// TODO: consider making this fatal, after the Go 1.11 cycle.
</span><span class="c1"></span>		<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;godoc: error parsing API version files: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">parsePackageAPIInfo</span><span class="p">()</span> <span class="p">(</span><span class="nx">apiVersions</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">apiGlob</span> <span class="kt">string</span>
	<span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;GOROOT&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">apiGlob</span> <span class="p">=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">build</span><span class="p">.</span><span class="nx">Default</span><span class="p">.</span><span class="nx">GOROOT</span><span class="p">,</span> <span class="s">&#34;api&#34;</span><span class="p">,</span> <span class="s">&#34;go*.txt&#34;</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">apiGlob</span> <span class="p">=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;GOROOT&#34;</span><span class="p">),</span> <span class="s">&#34;api&#34;</span><span class="p">,</span> <span class="s">&#34;go*.txt&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">files</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Glob</span><span class="p">(</span><span class="nx">apiGlob</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">vp</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">versionParser</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">files</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">vp</span><span class="p">.</span><span class="nf">parseFile</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">vp</span><span class="p">.</span><span class="nx">res</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>通过以上代码可以看出来版本信息是通过读取 GOROOT 下 api/go*.txt 文件获取的。</p>
<p><p class="md__image">
  <img src="../imgs/std-show-version05.png"
    alt=""  />
</p>
</p>
<p>api 目录下的这些文件维护了每个版本新增的内容。</p>
<p>最终从这些文件中读取的内容会用以下的类型表示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// pkgAPIVersions contains information about which version of Go added
</span><span class="c1">// certain package symbols.
</span><span class="c1">//
</span><span class="c1">// Only things added after Go1 are tracked. Version strings are of the
</span><span class="c1">// form &#34;1.1&#34;, &#34;1.2&#34;, etc.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">pkgAPIVersions</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">typeSince</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>            <span class="c1">// &#34;Server&#34; -&gt; &#34;1.7&#34;
</span><span class="c1"></span>	<span class="nx">methodSince</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="c1">// &#34;*Server&#34; -&gt;&#34;Shutdown&#34;-&gt;1.8
</span><span class="c1"></span>	<span class="nx">funcSince</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span>            <span class="c1">// &#34;NewServer&#34; -&gt; &#34;1.7&#34;
</span><span class="c1"></span>	<span class="nx">fieldSince</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span> <span class="c1">// &#34;ClientTrace&#34; -&gt; &#34;Got1xxResponse&#34; -&gt; &#34;1.11&#34;
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这里有类型、方法、函数和（类型）字段，但没有变量和常量，这也就是说变量和常量的版本号显示还未实现。</p>
<p>最后，在 website 项目的 main 函数中有这么一句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Initialize the version info before readTemplates, which saves
</span><span class="c1">// the map value in a method value.
</span><span class="c1"></span><span class="nx">corpus</span><span class="p">.</span><span class="nf">InitVersionInfo</span><span class="p">()</span>
</code></pre></div><p>用于初始化版本信息。</p>
<h2 id="03-总结">03 总结</h2>
<p>希望你平时生活、学习和工作过程中，能多一些好奇。本文是一个引子，内容不太重要，过程希望能够对你有所启发。当然，如果你计划学习学习 Go 语言官网的实现，也许本文的帮助会更大。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 开发者 Top 6 IDE：你知道几个，又用哪个？</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/go-top-ide/</link>
			<pubDate>Wed, 03 Feb 2021 20:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/go-top-ide/</guid>
			<description>声明：这里的 IDE 包括普通的文本编辑器和真正的 IDE。或者应该叫做开发工具。 这个 Top 排行，没有直接数据支持，凭直觉的，哈哈哈哈哈。（其实也结合了部分网上资料，比如 2019 年官方的调查结果）。 1、VSCode 这是微软出品的，超级棒的文本编辑器。我出过 VSCode 系列相关教程 ，目前我主要使用 VSCode 进行开发。VSCode 本身不是专门针对 Go 的编辑器，所以需要通过插件来支持 Go，这就是 Go for Visual Studio</description>
			<content type="html"><![CDATA[<blockquote>
<p>声明：这里的 IDE 包括普通的文本编辑器和真正的 IDE。或者应该叫做开发工具。</p>
</blockquote>
<p>这个 Top 排行，没有直接数据支持，凭直觉的，哈哈哈哈哈。（其实也结合了部分网上资料，比如 2019 年官方的调查结果）。</p>
<h2 id="1vscode">1、VSCode</h2>
<p>这是微软出品的，超级棒的文本编辑器。我出过 <a href="https://mp.weixin.qq.com/s/twGr49fAqRG8UguZ_9TiiA" target="_blank" rel="noopener">VSCode 系列相关教程</a>
，目前我主要使用 VSCode 进行开发。VSCode 本身不是专门针对 Go 的编辑器，所以需要通过插件来支持 Go，这就是 Go for Visual Studio Code 插件，前些天更新到了 v0.22.0，默认启用了 gopls。关于什么是 gopls，可以参考我写的<a href="https://mp.weixin.qq.com/s/vMWvSs2h3LwpghS27VQ9rg" target="_blank" rel="noopener">这篇文章</a>
。</p>
<p>注意，目前该插件是 Go Team 维护的。官方支持，值得拥有！</p>
<p><p class="md__image">
  <img src="../imgs/top-go-ide-vscode.png"
    alt=""  />
</p>
</p>
<p>有了 gopls，VSCode 写 Go 代码的感觉特别棒，我认为一定程度上可以媲美 GoLand，而且它是开源免费的呢。</p>
<h2 id="2goland">2、GoLand</h2>
<p>JetBrains 以 Intellij IDEA 和针对特定语言的 IDE 而闻名。而 GoLand 是为 Go 开发者提供的 JetBrains 解决方案。</p>
<p>GoLand 是一个专门为 Go 开发者构建的跨平台 IDE。它是一个商业 IDE，也就是要钱的，不过正因为要钱，它的功能特别强大。</p>
<p><p class="md__image">
  <img src="../imgs/top-go-ide-goland.png"
    alt=""  />
</p>
</p>
<p>比如有动态错误检测和修复建议、一步撤销重构、智能代码完成、未使用代码检测和文档提示等。</p>
<p>此外，它还具有强大的调试功能，用户友好的代码导航，以及对 Git、GitHub 和 Mercurial 开箱即用的支持。</p>
<p>目前个人用户第一年 89 美金，后续续费会便宜些。</p>
<p>可能很多人抱怨贵，但 JetBrains 还是很不错的，如果你有开源项目，可以申请免费 Licence；如果你是学生，也可以申请。</p>
<h2 id="3liteide">3、LiteIDE</h2>
<p>有些人可能不知道这款 IDE，这是国人开发的，专门为 Go 语言打造的 IDE。在 2012 年我刚接触 Go 语言时，这款 IDE 就跟着出现了。</p>
<p>官方的介绍：这是一款简单，开源，跨平台的 Go IDE，主页地址：<a href="http://liteide.org" target="_blank" rel="noopener">http://liteide.org</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/top-go-ide-liteide.png"
    alt=""  />
</p>
</p>
<p>因为 LiteIDE 是为 Go 设计的，所以它为开发者提供了许多开箱即用的有用特性。其中包括可配置的构建命令、高级代码编辑器、代码管理、gdb 和 Delve 调试器支持、自动完成和 WordApi 主题化、基于 MIME 类型的系统等等。</p>
<p>作者是七叶，更新很积极，应该拥有一批忠实的用户。</p>
<h2 id="4vim">4、Vim</h2>
<p>作为编辑器之神，自然会支持 Go，这是通过 <a href="https://github.com/fatih/vim-go" target="_blank" rel="noopener">vim-go</a>
 这个插件实现的。</p>
<p><p class="md__image">
  <img src="../imgs/top-go-ide-vim.png"
    alt=""  />
</p>
</p>
<p>vim-go 插件是免费的，易于安装，维护良好，经常在 Github 上更新。安装后，vim-go 将为你的 Vim 文本编辑器配备 Go 包编译、折叠和语法高亮显示、集成的 delve 支持，以及在用 Golang 编写应用程序时可能需要的其他功能，Vim 可扩展性特别强。</p>
<p>此外，作者维护了较好的<a href="https://github.com/fatih/vim-go/wiki" target="_blank" rel="noopener">文档</a>
，有问题可以得到较好的支持。</p>
<h2 id="5sublime-text">5、Sublime Text</h2>
<p>曾经 Sublime Text 风光无限，自从 VSCode 出来后，受到了极大的冲击。如果你是 Sublime Text 爱好者，通过 GoSublime 插件可以进行 Go 开发。</p>
<p><p class="md__image">
  <img src="../imgs/top-go-ide-sublime.png"
    alt=""  />
</p>
</p>
<p>值得注意的是，你可能需要一些额外的插件来充分发挥 Sublime Text 作为 Go IDE 的作用。比如 <a href="https://github.com/golang/sublime-build" target="_blank" rel="noopener">Golang Build package</a>
，它是用于 Go Build 系统集成的官方 Sublime Text package。</p>
<h2 id="6atom">6、Atom</h2>
<p>这是 GitHub 出品的。它是一个轻量级框架，通过大量插件，来丰富其功能。</p>
<p>如果你是 Atom 的爱好者，可以通过 <a href="https://atom.io/packages/go-plus" target="_blank" rel="noopener">Go-plus</a>
 插件来支持 Go 开发。</p>
<p><p class="md__image">
  <img src="../imgs/top-go-ide-atom.png"
    alt=""  />
</p>
</p>
<p>该插件提供了构建流程、lints、vet 和覆盖测试等工具。此外还有自动完成、格式化、测试和文档功能。</p>
<h2 id="总结">总结</h2>
<p>除了上面介绍的 6 款（它们都是跨平台的），在<a href="https://blog.codota.com/top-7-golang-ides-for-go-developers/" target="_blank" rel="noopener">这篇文章</a>
看到了另外一款：<a href="https://www.zeusedit.com/languages/go.html" target="_blank" rel="noopener">Zeus IDE</a>
。这个国内应该很多人都没听过，这是 Windows 上的一款 IDE，Windows 的用户可以试试。</p>
<p><p class="md__image">
  <img src="../imgs/top-go-ide-zeus.png"
    alt=""  />
</p>
</p>
<p>注意，Eclipse 上的 Go 插件已经不维护了，所以大家别用 Eclipse 开发 Go 了。</p>
<p>最后问一句，有人使用 Emacs 开发 Go 吗？</p>
]]></content>
		</item>
		
		<item>
			<title>除了心灵美，颜值也很重要</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/article-pretty/</link>
			<pubDate>Tue, 02 Feb 2021 11:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/article-pretty/</guid>
			<description>大家好，我是站长 polarisxu。 好吧，这篇文章不是聊美女的，而是聊排版的。让你失望了！ 记得高中语文作文，老师总是一再强调，字要工整。如果字迹不清楚，看起来很费劲，即使内容很好，阅卷老师可能也没耐心读，给人的印象就很不好。 现在我们在网络上写文章，同样存在“字要工整”的问题，这就是排版。现在受欢迎的软件，一个个颜值都很高。我们的文章，也必须是高颜值。本文就介</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>好吧，这篇文章不是聊美女的，而是聊排版的。让你失望了！</p>
<p>记得高中语文作文，老师总是一再强调，字要工整。如果字迹不清楚，看起来很费劲，即使内容很好，阅卷老师可能也没耐心读，给人的印象就很不好。</p>
<p>现在我们在网络上写文章，同样存在“字要工整”的问题，这就是排版。现在受欢迎的软件，一个个颜值都很高。我们的文章，也必须是高颜值。本文就介绍一些“高颜值”文章的基本工具和排版小建议。</p>
<h2 id="01-mardown-和-typora">01 Mardown 和 Typora</h2>
<p>Markdown 几乎成了标准，出版社都支持使用 Markdown 进行图书撰写。所以，如果你还不会 Markdown，一定简单学习下，这里有一个极简的教程：<a href="https://studygolang.com/markdown" target="_blank" rel="noopener">https://studygolang.com/markdown</a>
。</p>
<p>目前，日常写作，我全部使用的 Markdown。关于 Markdown 的编辑器有很多，我个人一直使用 Typora，很不错，因此推荐给你。</p>
<p>这款软件有几个功能我认为特别棒：</p>
<ul>
<li>网页复制的内容，粘贴到 Typora，默认会转为 Markdown 格式，包括代码，一般都能正确转换；这个功能真的超级喜欢；</li>
<li>默认所见即所得方式编辑。一般的编辑器都是 Markdown 编写，然后预览；或者一个窗口编写，一个窗口预览，而 Typora 是输入 Markdown 格式即可在当前位置看到预览效果；这个也是我超级喜欢的；</li>
<li>直接粘贴图片，可以对图片进行复制操作（即使是网络图片也可以复制到本地）；这个是很常用的功能，它还支持配置图床，不过我没有用到；</li>
<li>支持复制为多种格式：纯文本、Markdown、HTML 代码或简化格式的内容，方便粘贴到其他地方；</li>
</ul>
<p>当然还有很多其他的功能，这里不一一介绍，你需要某个功能时可以自己摸索一下。</p>
<h2 id="02-公众号排版">02 公众号排版</h2>
<p>虽然微信公众号不支持 markdown，但它是一个富文本编辑器，支持各种带格式的文本。（相比很多其他平台，微信公众号好用很多）</p>
<p>于是有很多第三方的工具，专门帮助微信公众号进行文章排版。我一直使用的是 mdnice.com，相信不少人也在使用它。</p>
<p>个人喜欢 mdnice 的如下功能：</p>
<ul>
<li>专门为程序员准备，支持 markdown 格式，可以方便将渲染会后的内容复制到微信公众号、知乎等；</li>
<li>对文章进行格式化，让格式更适合阅读，比如中英文之间自动加空格等；</li>
<li>由于微信公众号不支持外链，支持一键将外链生成为文末「参考资料」；</li>
<li>有众多风格主题和代码主题供选择；</li>
<li>可以对主题进行自定义：修改 CSS；比如我就将 <code>#nice</code> 增加了 padding: 1px；</li>
</ul>
<p>下图是本文的效果：</p>
<p><p class="md__image">
  <img src="../imgs/article-pretty.png"
    alt=""  />
</p>
</p>
<p>关于图片：我一般都是微信公众号里面通过本地上传，而没有使用 mdnice 集成的图床功能，因为即使用了，复制到微信，也是经常粘贴失败。</p>
<p>此外，文章开头，大家都喜欢给一些引导语句，比如关注 xxx，设为星标之类的，看你的喜好了。而文章末尾，可以加上往期推荐，放上公众号二维码做关注引导！关于头尾，微信公众号有模板，可以提前配置好模板，每次发文章时，插入模板，保证内容形式的统一。</p>
<h2 id="03-总结">03 总结</h2>
<p>markdown 是新时代必备的技能，大家应该掌握。通过网络写文章，应该考虑读者的阅读体验，把它当做一个产品来经营，给大家输出高质量文章的同时，保证文章的美观，保证阅读体验！</p>
<p>小提示：不知道大家发现没，不像读书时候学到的，段落第一行缩进 2 个字，现在网络上的阅读，都没有缩进的习惯，遇到了缩进的反倒不习惯了。比如 markdown 排版的文章，段落和段落之间会有明显的空行，个人认为比缩进阅读体验更好。所以，建议你别用缩进。</p>
<p>此外，为了阅读体验，可以进行大段落划分，即使没有合适的标题，也可以通过 01、02、03 这样的方式进行划分。</p>
<p>本文的阅读体验如何？欢迎吐槽！</p>
]]></content>
		</item>
		
		<item>
			<title>从网友对 MySQL 手册的一个疑问聊起</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/mysql-bit-go/</link>
			<pubDate>Thu, 28 Jan 2021 15:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/mysql-bit-go/</guid>
			<description>在 Go 语言中文网微信群有人提出了这样的疑问，如下图（文档地址：https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html ） 不理解为什么 DATE 是通过 YYYY×16×32 + MM×32 + DD 表示，主要不理解为什么 16、32。我做了讲解，但似乎他还是不太理解。干脆我写篇</description>
			<content type="html"><![CDATA[<p>在 Go 语言中文网微信群有人提出了这样的疑问，如下图（文档地址：<a href="https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html</a>
）</p>
<p><p class="md__image">
  <img src="../imgs/mysql-bit01.png"
    alt=""  />
</p>
</p>
<p>不理解为什么 DATE 是通过 YYYY×16×32 + MM×32 + DD 表示，主要不理解为什么 16、32。我做了讲解，但似乎他还是不太理解。干脆我写篇文章详细讲解下，希望对不清楚的人能有所帮助，答案不是重点，关键在于分析的过程。</p>
<h2 id="01">01</h2>
<p>讲一个真实的事情。几年前，某大厂的一个 iOS 开发，说之前接触过 PHP，了解一些后端，于是简单聊了聊（半面试形式）。聊到的一些点，让我感觉他的基础很薄弱，于是我试探性的问：int 类型一般占多大空间？（这样的问题我一般不会问，以免让人感觉“鄙视”他）</p>
<p>他回答：32。我就知道他对这块稀里糊涂的。于是追问一句：单位是什么？他不确定的答道：是字节吧？！</p>
<p>回到 MySQL 中的问题，DATE 用 3 字节的整数类型存储，怎么存？如果不考虑空间，DATE 类型最简单的存储方式可能是，直接将 YYYYMMDD 当做整数存储，比如：20210128。这个数是否可以用 3 个字节存储呢？</p>
<p>1 个字节（byte）是 8 位（bit），3 个字节有 24 位，如果表示无符号整数，最大能表示 (1 &laquo; 24) - 1（移位操作优先级低于减法），即 16777215。很显然它比 20210128 小，因此我们不能直接使用 YYYYMMDD  当做整数存储。</p>
<p>如果直接把 YYYYMMDD 形式当做整数，中间会有很多“空洞”，也就是很多数字没有用到，是不连续的，空间利用率太低。比如下图，20210101 比它头一天 20201231 大 8870。</p>
<p><p class="md__image">
  <img src="../imgs/mysql-bit02.png"
    alt=""  />
</p>
</p>
<p>因此，我们可以采用“压缩”的方式，让日期集合更“紧凑”。MySQL 这里采用的方法就是。具体为什么是 YYYY×16×32 + MM×32 + DD 呢？</p>
<h2 id="02">02</h2>
<p>日期 DD 的范围是：1~31，用 5 个位就可以表示。月份的范围是：1~12，用 4 个位就可以表示，但前面 5 个位被 DD 占用了，因此 MM 得从第 6 位开始，所以需要左移（&laquo;） 5 位，即乘以 32，所以 MM×32 是这么来的。这样一来，MM 和 DD 一共占据了 5 + 4 = 9 位，3 个字节（24 位）还剩 15 位，也就是说有 15 位可以存放年（YYYY），15 位能表示到 32767 年，远超 2021 年。因此，对于 YYYY 来说，需要左移 5 + 4 位，也就是 YYYY×32×16。</p>
<p><p class="md__image">
  <img src="../imgs/mysql-bit03.png"
    alt=""  />
</p>
</p>
<p>至于 TIME，因为用秒表示的值可以存入 3 个字节，因此直接将 TIME 转为秒。即  DD×24×3600 + HH×3600 + MM×60 + SS</p>
<p>而 DATETIME 使用了 8 个字节存储，4 个字节存日期，4 个字节存时间。因为空间比较充足，这里的“压缩”没有采用而二进制位，而是直接用十进制的方式。YYYY×10000 + MM×100 + DD，年月日不会重叠，而且没有超过 4 字节能表示的范围，时间一样的道理。</p>
<h2 id="03">03</h2>
<p>如果你问我：为什么 24 位无符号整数最大值是（1&laquo;24) - 1 = 16777215，我建议你可以好好看看《深入理解计算机系统》。</p>
<p>MySQL 这里使用的技巧值得学习。</p>
<p>最后留一个问题：开头文档中第一点，YEAR 这个类型，使用一个字节存储，你觉得该怎么做？！</p>
]]></content>
		</item>
		
		<item>
			<title>百度终于重视码农了：专门为开发者准备的搜索</title>
			<link>https://polarisxu.studygolang.com/posts/talk/baidu-kaifa-search/</link>
			<pubDate>Wed, 27 Jan 2021 10:20:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/baidu-kaifa-search/</guid>
			<description>大家好，我是站长 polarisxu。 百度，这个国内最大的搜索引擎，大家对其是又爱又恨，特别是程序员。所以，有一些程序员会直接不用百度，甚至觉得程序员就不应该用百度，用百度是 low 的行为。 的确，百度在搜索技术相关的东西，会让人很抓狂。比如搜索世界上最好的语言 php： 我的天，全是广告。。。 反观谷歌： 第一个就是 PHP 官网。 据相关调研预测，到 2026 年国内编程教育覆盖人数也将超过</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>百度，这个国内最大的搜索引擎，大家对其是又爱又恨，特别是程序员。所以，有一些程序员会直接不用百度，甚至觉得程序员就不应该用百度，用百度是 low 的行为。</p>
<p>的确，百度在搜索技术相关的东西，会让人很抓狂。比如搜索世界上最好的语言 php：</p>
<p><p class="md__image">
  <img src="../imgs/baidu-php.png"
    alt=""  />
</p>
</p>
<p>我的天，全是广告。。。</p>
<p>反观谷歌：</p>
<p><p class="md__image">
  <img src="../imgs/google-php.png"
    alt=""  />
</p>
</p>
<p>第一个就是 PHP 官网。</p>
<p>据相关调研预测，到 2026 年国内编程教育覆盖人数也将超过 1 亿。如此庞大的用户群体，不能无视他们的搜索体验。终于，今天看到百度出了一个专门针对开发者的搜索引擎：<a href="https://kaifa.baidu.com" target="_blank" rel="noopener">https://kaifa.baidu.com</a>
。作为开发者，同时也是站长，我想谈谈自己的一些看法，欢迎交流。</p>
<p>首先，这是一个好消息，你看搜索 php 的结果：</p>
<p><p class="md__image">
  <img src="../imgs/kaifa-php.png"
    alt=""  />
</p>
</p>
<p>官网终于排在第一了，而且没有任何广告，至少现在没有。</p>
<p>在搜索结果的顶部，有「站点」、「语言」、「系统」三个筛选项，右侧有百科对应的词条，右下角是来自 gitee 平台的相关项目。隐约感觉，gitee 要大火？！</p>
<p>但是，细心的读者会发现，目前的版本存在一些局限，比如搜索结果固定来自几个站点：「博客园」、「CSDN」、「知乎」。。。而实际上很多个人独立技术博客的质量很高，这里却搜索不到，可见目前这个所谓的开发者搜索，只是简单的搜索这几个站点的内容。</p>
<p>此外，对于像 「Go语言中文网」 这样的站点来说，相当不友好，在 baidu.com 上搜索 golang，排除广告的话，它排第一，但在这个开发者搜索中却搜索不到它的任何内容。</p>
<p>当然，我相信这只是起步。以上的一些问题，特别是内容丰富性方面，只要百度用心，肯定可以做的更好：比如基于 AI 技术，分析出全网站点，哪些是技术类的，提升权重等。</p>
<p>如果这个搜索引擎真的做起来了，码农们都使用它，文中开头的哪些培训机构是不是不在百度投广告了？真有那一天，不知道百度能否顶住诱惑，像谷歌一样，有节制的展示广告。</p>
<p>不过，要做起来其实挺难的，虽然 PC 时代的搜索，搜狗也还好，360 也好，都没有对百度形成冲击，但现在头条搜索、微信搜索，它们在另一个维度上和百度竞争，对百度的冲击还是不小。</p>
<p>优质内容 + 好的体验，如果百度能做到，对于开发者这个人群来说，PC 搜索是更适合的，就看百度是否真要这部分市场了。</p>
]]></content>
		</item>
		
		<item>
			<title>微信 8.0 的这个功能和 Go 的 error 一样？</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/wechat-8.0/</link>
			<pubDate>Mon, 25 Jan 2021 11:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/wechat-8.0/</guid>
			<description>大家好，我是站长 polarisxu。 今天早上发了一个朋友圈，吐槽了一下微信 8.0 的一个功能，不少人有同感，其中一位朋友提到了 Go 的 error。 微信 8.0 通过好友请求时，仅聊天还是朋友圈，你必须选择一个。挺烦的。有一个朋友留言说：这就跟 err 一样，某些地方强迫你有意识的做选择，在这里就是强迫你对自己的隐私做选择。 Go 中的 error，社区的反应特别的激烈，喜欢的人夸，不喜欢的人</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天早上发了一个朋友圈，吐槽了一下微信 8.0 的一个功能，不少人有同感，其中一位朋友提到了 Go 的 error。</p>
<p><p class="md__image">
  <img src="../imgs/wechat8.0-01.png"
    alt=""  />
</p>
</p>
<ul>
<li>微信 8.0 通过好友请求时，仅聊天还是朋友圈，你必须选择一个。挺烦的。有一个朋友留言说：这就跟 err 一样，某些地方强迫你有意识的做选择，在这里就是强迫你对自己的隐私做选择。</li>
</ul>
<p>Go 中的 error，社区的反应特别的激烈，喜欢的人夸，不喜欢的人喷，出现了两级分化。就像这位朋友说的，Go 希望开发者明确知晓有可能有错误发生。Go 的初衷也许是好的，但这也导致了代码中经常出现这样的情况：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">x</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="nx">y</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">bar</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="nx">z</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">baz</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="o">...</span>
</code></pre></div><p>这样的代码必然会遭到很多人吐槽！据说 Go2.0 对错误处理会重新考虑，但 2.0 到现在也只是一个“概念”，虽知道哪天会来~</p>
<p>回到微信 8.0，虽然不是专业产品经理，对产品知识略晓皮毛，但作为用户还是想吐槽下。</p>
<p>微信 8.0 的发布，加上微信 10 周年公开课，网上各种解读、好评。这样的话也许大家也见过：</p>
<blockquote>
<p>我相信又有很多人要教龙哥做产品了。。。</p>
</blockquote>
<p>作为一个用户，我觉得不是教龙哥做产品，而是反馈下使用体验，不一定对，但却是真实使用感受！</p>
<p>读高中时经常调侃一句话：</p>
<blockquote>
<p>名人说的话是名言，凡人说的话是废话</p>
</blockquote>
<p>的确如此，人家之所以是名人，那是人家的本事，能成为名人必然有其不寻常之处。</p>
<p>达利欧在《原则》一书提到「可信度加权」：对那些能力更强的决策者的观点赋予更大的权重，给予更多的重视。大白话说就是成功的人士、成功的产品自带光环，做什么都很香，毕竟他们之前做的都很好，这次大概率做的也是很好的。听起来确实没毛病！</p>
<p>但马克思告诉我们要辩证的看待问题。我用的不爽，就不能认为它做的不好？</p>
<p>有人要说，这个很小众，毕竟大部人处理好友的请求数量很少，偶尔要处理让他们明确选择，对隐私进行保护。但我想说的是，这些好友很少的人，大概率加的好友都是真的好友，又有多少会不让看朋友圈呢？而对于有较多好友请求要处理的人来说，情况很糟糕！有些人可能不知道，微信 8.0 之前，微信好友中，最多有 5000 人可以看到朋友圈，超过 5000，再有人加你好友，微信会提示，然后自动选择仅聊天，因为之前好友是默认可以看朋友圈的。</p>
<p>现在放开了 5000 人的限制。你看，5000 人好友，这个需求难道就不小众，微信却考虑到了，满足了！而且，这么牛逼的产品，追求极致应该是必然的，小众需求也会有所考虑：<strong>毕竟微信的理念是简单，你需要它才出现</strong>。</p>
<p>因此，对于这个功能，我的一些不一定成熟的看法：</p>
<ul>
<li>处理好友请求很少的人，可以统计他们有多少会选择仅好友？我猜测大部分人都会选择朋友圈；</li>
<li>微信的渗透很强，很多农村老人都用，他们能理解「仅聊天」、「朋友圈」？求求你让我方便的加上一个好友吧；</li>
<li>好友超过 5000 的人，大概率新加好友也会很多，每个好友请求都要操作这么多步，真的好累！</li>
</ul>
<p>我这里预测，该功能会改进。要么回到之前，默认「朋友圈」；要么做到个性化，根据不同人群的习惯，给一个不同的默认选项。比如每次加好友的选择；是否从来不看朋友圈，设置关闭了朋友圈；是否从来不发朋友圈等等。</p>
<p>另外 8.0 还有一个功能：状态。功能本身我不说，但这个入口按钮的位置，给我一种感觉：要加一个状态的功能，入口放哪好呢？随便找一个显眼的位置放一下吧！总感觉特别突兀~</p>
<p><p class="md__image">
  <img src="../imgs/wechat8.0-02.png"
    alt=""  />
</p>
</p>
<p>看到我一个朋友也发了一条朋友圈吐槽，UI 像狗皮膏药。。。</p>
<p><p class="md__image">
  <img src="../imgs/wechat8.0-03.png"
    alt=""  />
</p>
</p>
<p>之前的悬浮窗口，8.0 改掉了，龙哥就评价说悬浮窗口像狗皮膏药，你看，微信的设计也不可能全部是完美的。</p>
<p>我没有能力教龙哥做产品，但就像 Go 社区对 error 不满意一样发声，作为微信用户，不爽的地方也是可以发声的。发表自己的意见，不一定对，但也是提升自己思考能力的机会！</p>
]]></content>
		</item>
		
		<item>
			<title>Unicode 和 UTF-8 是什么关系？本文为你解惑</title>
			<link>https://polarisxu.studygolang.com/posts/basic/char-set-encoding/</link>
			<pubDate>Thu, 21 Jan 2021 22:40:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/basic/char-set-encoding/</guid>
			<description>十几年前，国内 UTF-8 还不太流行，新手开发过程中，乱码问题是很常见的。记得我刚毕业那会，公司的系统是这样的：数据库 MySQL 使用的是 Latin-1 编码（ISO8859-1），程序源码使用的是 GBK，这样的情况，乱码真是满天飞~好在对数据库操作做了封装，编码问题在中间层处理了。那时候听到关于乱码问题的一个终极解决方案是：保证各个地方编码一致。 现如今，Unicode 相当普及，中文使用 UTF-8 编</description>
			<content type="html"><![CDATA[<p>十几年前，国内 UTF-8 还不太流行，新手开发过程中，乱码问题是很常见的。记得我刚毕业那会，公司的系统是这样的：数据库 MySQL 使用的是 Latin-1 编码（ISO8859-1），程序源码使用的是 GBK，这样的情况，乱码真是满天飞~好在对数据库操作做了封装，编码问题在中间层处理了。那时候听到关于乱码问题的一个终极解决方案是：保证各个地方编码一致。</p>
<p>现如今，Unicode 相当普及，中文使用 UTF-8 编码虽然比 GBK 编码占用更多的空间，但一般都不会在乎。特别是使用了 Go 语言后，乱码问题更是没有了。在 Go 语言标准库中有 unicode 包，它下面还有 utf8 和 utf16 两个子包。也许有此疑问：又是 Unicode、又是 UTF-8、UTF-16，它们是什么关系？</p>
<p>本文试着为大家解决关于字符集和字符编码的困惑。</p>
<p>本文目录：</p>
<p><p class="md__image">
  <img src="../imgs/char-set-encoding-content.png"
    alt=""  />
</p>
</p>
<h2 id="1什么是字符集">1、什么是字符集</h2>
<p>字符集，从字面看，是多个字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。因此不同的字符组合在一起就可以认为是不同的字符集。当然不是瞎组合。国人常见字符集如下：</p>
<p><p class="md__image">
  <img src="..//Users/xuxinhua/project/polarisxu/basic/imgs/charset01.png"
    alt=""  />
</p>
</p>
<h2 id="2什么是字符编码">2、什么是字符编码</h2>
<p>大家都知晓，计算机只认 0 和 1 组成的二进制数。所以整数通过进制转换转为二进制就可以被计算机处理。然而像文本、音频、视频等这样的信息，如何转为二进制被计算机处理呢？这就需要进行编码。</p>
<p><strong>编码</strong>（encode）是把数据从一种形式转换为另外一种形式的过程，它是一套算法。解码（decode）就是编码的逆过程。</p>
<p>比如对于 ASCII 字符集中的字符 1，转换为二进制是 00110001，这就是一次编码；将 00110001 显示为 1，涉及到一次解码。</p>
<p><strong>字符编码</strong>，顾名思义，是对字符进行编码，是字符和二进制数据之间转换的算法，它们之间必须一一对应，这是本文需要讨论的主题。一个二进制叫做位，8 位称为“字节”，根据计算一个字节一共可组合出 256（2 的 8 次方）种不同的状态。</p>
<p>关于字符集和字符编码，使用 ASCII 进行总结说明：</p>
<blockquote>
<p>ASCII <strong>字符集</strong>是字母、数字、标点符号以及控制符（回车、换行、退格）等组成的 128 个字符。</p>
<p>ASCII <strong>字符编码</strong>是将这 128 个字符转换为计算机可识别的二进制数据的一套规则（算法）。</p>
</blockquote>
<p>因此当我们说 ASCII 时，一般同时指 ASCII 字符集和 ASCII 字符编码。通常，字符集会同时定义一套同名的字符编码规则。然而万事都有特例，比如 Unicode 就只是代表字符集，对应的字符编码有多种，比如 UTF-8、UTF-16 等。</p>
<h2 id="3unicode-和-utf-系列">3、Unicode 和 UTF 系列</h2>
<p>现在知道了 Unicode 只是代表字符集，它的编码规则是通过 UTF 系列定义的。</p>
<p>那 Unicode 是什么？<a href="https://home.unicode.org/basic-info/overview/" target="_blank" rel="noopener">官方</a>
有这么一句话：</p>
<blockquote>
<p>Unicode provides a unique number for every character, no matter what the platform, program, or language is.</p>
</blockquote>
<p>即 Unicode 为每一个字符提供了一个唯一的数字编码（代号），叫做 Code Point（码点）。这里可以查找你要查询某个字符的码点（Code Point）：<a href="https://www.unicode.org/cgi-bin/GetUnihanData.pl" target="_blank" rel="noopener">https://www.unicode.org/cgi-bin/GetUnihanData.pl</a>
。注意这里的码点不是字符编码，只是字符集而已。</p>
<p>所以，Unicode 字符集一个最主要的工作就是维护这样一个表，可以把它想象成是一个数据库表，里面存储着每一个字符对应的唯一 ID（即 Code Point），统一用 U+XXXX 来表示（X 为 16 进制的字符，因为字符很多，并不一定所有的字符都是 4 个 16 进制数，比如笑哭的 Emoji 表情，Code Point 是 U+1F602），如 「徐」U+5F90、「新」U+65B0。现在这个数据表已经拥有 100 多万的字符，还在不停的更新。</p>
<p>为什么会出现 Unicode 呢？因为之前的编码方式，大多只考虑自己国家，不同国家的编码方式不同，导致使用中国 GBK 编码的文档，在日本用本地编码打开就乱码了。标准总是在混乱中诞生的，于是一些国际组织制定出了全球统一的编码格式。这就是 Unicode。</p>
<blockquote>
<p>大家可能见到过 USC，这是 ISO 制定的一种计算机行业标准，和 Unicode 目的是一样的。他们双方意识到不应该出现两种不同的国际标准。因此你可以认为它们是一样的。</p>
</blockquote>
<p>了解了 Unicode，那为什么会有 UTF-8、UTF-16？</p>
<h3 id="utf-系列">UTF 系列</h3>
<p>前面说了 Unicode 本身主要工作是维护一个表，它并没有规定一个字符到底用几个字节来表示，只规定了每个字符对应到唯一的码点（code point），码点可以从 0000 ~ 10FFFF <a href="https://unicode-table.com/cn/blocks/" target="_blank" rel="noopener">共 1114112 个值</a>
。</p>
<p>那为什么 Unicode 不规定字符编码呢？如果将 Unicode 码点直接当编码规则会如何？其实是有的，这就是 UTF-32。因为计算机没法确认两字节到底是表示 1 个字符还是 2 个字符，因此 UTF-32 粗暴的取最大值，所有字符都按 4 字节编码。很显然，这在空间上是极浪费的（英文文档直接大 3 倍），因此 UTF-32 很少使用。</p>
<p>UTF 是 Unicode Transformation Format （Unicode 转换格式）的首字母缩写，专门解决 Unicode 的编码问题。根据编码规则的不同有 UTF-8、UTF-16 和 UTF-32 等几种具体的方案。</p>
<p>由于 UTF-32 浪费空间，使用不多，本文着重介绍 UTF-8 和 UTF-16。</p>
<h2 id="4utf-8">4、UTF-8</h2>
<p>UTF-8，也可写为 UTF8，是 Unicode 的一种变长编码方案。它完全兼容 ASCII，同时避免了 UTF-16 和 UTF-32 中的字节序等复杂性。UTF-8 能够被广泛接受，跟其完全兼容 ASCII 有很大关系。</p>
<p>为什么叫 <code>-8</code>？因为它将每个 Unicode 字符编码为 1~4 个八位元（octets）（八位元即一个字节），因此叫 <code>-8</code>。其中字节的个数取决于分配给 Unicode 字符的整数值。</p>
<p>当面对 4 个字节，UTF-8 如何知晓应该把它当做 1 个字符解析、还是 2 个？亦或是 4 个？这就是 UTF-8 设计巧妙之处。</p>
<ul>
<li>单字节可编码的 Unicode 范围：\u0000~\u007F（0~127）</li>
<li>双字节可编码的 Unicode 范围：\u0080~\u07FF（128~2047）</li>
<li>三字节可编码的 Unicode 范围：\u0800~\uFFFF（2048~65535）</li>
<li>四字节可编码的 Unicode 范围：\u10000~\u1FFFFF（65536~2097151）</li>
</ul>
<p>UTF-8 从首字节就可以判断一个字符的 UTF-8 编码有几个字节， 具体判断逻辑就是，根据首字节二进制的起始内容：</p>
<ul>
<li>如果以 0 开始，肯定是单字节编码；</li>
<li>如果以 110 开头，肯定是双字节编码；</li>
<li>如果以 1110 开头，肯定是三字节编码；</li>
<li>如果以 11110 开头，肯定是四字节编码；</li>
</ul>
<p>除首字节之外，其他字节也有规定，如下：</p>
<table>
<thead>
<tr>
<th>字节数</th>
<th>用来表示码点的位数</th>
<th>Unicode 十六进制码点范围</th>
<th>字节1</th>
<th>字节2</th>
<th>字节3</th>
<th>字节4</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>7</td>
<td>0000 0000 - 0000 007F</td>
<td>0xxxxxxx</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>11</td>
<td>0000 0080 - 0000 07FF</td>
<td>110xxxxx</td>
<td>10xxxxxx</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>16</td>
<td>0000 0800 - 0000 FFFF</td>
<td>1110xxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>21</td>
<td>0001 0000 - 0010 FFFF</td>
<td>11110xxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
</tr>
</tbody>
</table>
<p>具体如何编码和解码呢？以中文“徐”为例，说明这个过程。</p>
<p>「徐」的 Unicode 码点是 0x5F90（二进制：101 1111 1001 0000），对照上面的表发现 0x5F90 位于第三行的范围，所以格式是 1110xxxx 10xxxxxx 10xxxxxx。接着从「徐」Unicode 码点的二进制数最后一位开始，按从右向左依次填充这个格式中的 x，多出的 x 用 0 补上。这样就得到了「徐」这个汉字的 UTF-8 编码：11100101 10111110 10010000，转成十六进制是 0xE5 0xBE 0x90。</p>
<p>解码的过程也十分简单：如果一个字节（编码的二进制表示）的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位是 1，那么连续有多少个 1，就表示该字符占用多少个字节。还是以「徐」字为例，它的 UTF-8 编码的二进制表示是：11100101 10111110 10010000，根据规则，第一个字节的第一位是 1，且有三个 1，因此占用 3 个字节。根据上面表中第三行，将第一个字节开头的 1110 去掉，第二、第三个字节开头的 10 去掉，剩下的组合在一起，即：1011 11110 010000，这就是 0x5F90。</p>
<p>关于 UTF-8 的规范参考 <a href="https://tools.ietf.org/html/rfc3629" target="_blank" rel="noopener">rfc3629</a>
，这是 Ken Thompson 和 Rob Pike 等制定的，这两位也是 Go 语言的作者。</p>
<h2 id="5utf-16">5、UTF-16</h2>
<p>UTF-16  是 16-bit Unicode Transformation Format。有一点需要特别强调，它跟 UTF-8 一样，是可变长度的。代码点（Code Point）是用一个或两个 16 位代码单元编码的。至于网上有些资料说的 UTF-16 是固定 2 个字节长度编码，那其实不是 UTF-16，而是 UCS-2 （用于 2 字节通用字符集）。UTF-16 可以看做是它的父集。</p>
<blockquote>
<p>这里涉及一个概念，简单介绍下。</p>
<p>基本多语言平面（BMP）：UCS-2 只对这些字符进行了编码，一共能编码 65,536 个字符。后来不够用了，怎么办？IEEE 引入了 UCS-4，所有字符都用 4 字节编码，这太浪费空间了，因此出现了一个折中方案：UTF-16，即超出 U+FFFF 的部分使用 4 字节，这部分叫做辅助平面（SMP），码点范围 U+010000 到 U+10FFFF。</p>
<p>注意 UCS-2 已经过时了。</p>
</blockquote>
<p>因为是变长的方案，就需要有办法标识到底是 2 个字节还是 4 个字节。上文讲解 UTF-8 时，判断首字节字节开头位即可。类似的，看如下一张表：</p>
<table>
<thead>
<tr>
<th>字节数</th>
<th>16 进制码点范围</th>
<th>16-bit code 1</th>
<th>16-bit code 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>U+0000 - U+D7FF</td>
<td>xxxxxxxxxxxxxxxx</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>U+E000 - U+FFFF</td>
<td>xxxxxxxxxxxxxxxx</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>U+00010000 - U+0010FFFF</td>
<td>110110xxxxxxxxxx</td>
<td>110111xxxxxxxxxx</td>
</tr>
</tbody>
</table>
<p>使用 UTF-16 最知名的是 Java，JVM 内部使用的就是 UTF-16 编码。因为 UTF-16 不兼容 ASCII，因此网络传输一般不会使用它。</p>
<p>但 Java 的编码方式其实没那么简单。一般地 Java 中是这样的：（来源于 《Java 核心技术手册》 一书）</p>
<ul>
<li>Java 源文件，可能使用本地编码（比如中国是 GB）；</li>
<li>类文件（class 文件），使用 modified UTF-8（即做了部分修改的 UTF-8）；</li>
<li>虚拟机，使用过 UTF-16</li>
</ul>
<p>接下来，以汉字&quot;?&ldquo;为例，说明 UTF-16 编码方式是如何工作的。</p>
<p>汉字&rdquo;?&ldquo;的 Unicode 码点为 <code>0x20BB7</code>，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 <code>0x20BB7 - 0x10000</code> 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为<code>0001000010 1110110111</code>。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。<code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>，直接填充后面的 10 个二进制位即可，得到 <code>1101100001000010</code>，转成 16 进制数则为 <code>0xD842</code>。同理可得，低位为 <code>0xDFB7</code>。因此得出汉字&rdquo;?&ldquo;的 UTF-16 编码为 <code>0xD842 0xDFB7</code>。</p>
<h2 id="6go-中-unicode-相关包">6、Go 中 Unicode 相关包</h2>
<p>Go 语言让复杂的编码问题变得简单很多，极大的减轻了程序员的心智负担。为了方便对 unicode 字符串进行处理，Go 语言标准库提供三个包：unicode、unicode/utf8 和 unicode/utf16。</p>
<p>这里简单介绍下三个包的功能：</p>
<ul>
<li>unicode：unicode 提供数据和函数来测试 Unicode 代码点（Code Point，用 rune 存储）的某些属性。</li>
<li>unicode/utf8：用于处理 UTF-8 编码的文本，提供一些常量和函数，包括在 rune（码点） 和 UTF-8 字节序列之间的转换。</li>
<li>unicode/utf16：函数比较少，主要是 UTF-16 序列的编码和解码。</li>
</ul>
<p>具体函数不讲解了，大家可以看标准库文档或通过我的开源书阅读相关章节：<a href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example" target="_blank" rel="noopener">https://github.com/polaris1119/The-Golang-Standard-Library-by-Example</a>
。</p>
<p>着重介绍下 Go 中字符串的写法。</p>
<p>在 Go 语言中，字符串字面值有 4 种写法，比如「徐新华」可以这么写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s1</span> <span class="o">:=</span> <span class="s">&#34;徐新华&#34;</span>
<span class="nx">s2</span> <span class="o">:=</span> <span class="s">&#34;\u5F90\u65B0\u534E&#34;</span>
<span class="nx">s3</span> <span class="o">:=</span> <span class="s">&#34;\U00005F90\U000065B0\U0000534E&#34;</span>
<span class="nx">s4</span> <span class="o">:=</span> <span class="s">&#34;\xe5\xbe\x90\xe6\x96\xb0\xe5\x8d\x8e&#34;</span>
</code></pre></div><p>简单来生活就是 \u 紧跟四个十六进制数，\U 紧跟八个十六进制数。其中 \u 或 \U 代表后面是 Unicode 码点。而 \x 紧跟两个十六进制数，这些十六进制不是 Unicode 码点，而是 UTF-8 编码。</p>
<p>下面的代码有利于你的理解：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;unicode/utf8&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="s">`徐新华`</span>
	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
		<span class="nx">n</span>   <span class="kt">int</span>
	<span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;字符\tUnicode码点\tUTF-8编码十六进制\tUTF-8编码二进制&#34;</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nf">EncodeRune</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\t%U\t\t%X\t\t%b\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">],</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
	<span class="p">}</span>
	
	<span class="nx">s2</span> <span class="o">:=</span> <span class="s">&#34;\u5F90\u65B0\u534E&#34;</span>
	<span class="nx">s3</span> <span class="o">:=</span> <span class="s">&#34;\U00005F90\U000065B0\U0000534E&#34;</span>
	<span class="nx">s4</span> <span class="o">:=</span> <span class="s">&#34;\xe5\xbe\x90\xe6\x96\xb0\xe5\x8d\x8e&#34;</span>
	
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s4</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>运行结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">字符	Unicode码点	UTF-8编码十六进制	UTF-8编码二进制
<span class="s1">&#39;徐&#39;</span>	U+5F90		E5BE90		<span class="o">[</span><span class="m">11100101</span> <span class="m">10111110</span> 10010000<span class="o">]</span>
<span class="s1">&#39;新&#39;</span>	U+65B0		E696B0		<span class="o">[</span><span class="m">11100110</span> <span class="m">10010110</span> 10110000<span class="o">]</span>
<span class="s1">&#39;华&#39;</span>	U+534E		E58D8E		<span class="o">[</span><span class="m">11100101</span> <span class="m">10001101</span> 10001110<span class="o">]</span>
徐新华
徐新华
徐新华
</code></pre></div><p>此外，关于字符串其他方面的处理，比如编码转换等，可以到 <a href="https://pkg.go.dev/golang.org/x/text" target="_blank" rel="noopener">https://pkg.go.dev/golang.org/x/text</a>
 里找。</p>
<h2 id="7大小端问题little-endian-和-big-endian">7、大小端问题（Little endian 和 Big endian）</h2>
<p>最后聊一下大小端的问题。</p>
<p>一个字符使用多字节存储时，涉及到哪个在前哪个在后。以汉字「徐」为例，Unicode 码点是 5F90，需要用两个字节存储，一个字节是<code>5F</code>，另一个字节是<code>90</code>。存储的时候，<code>5F</code>在前，<code>90</code> 在后，这就是 Big endian 方式；<code>90</code>在前，<code>5F</code>在后，这是 Little endian 方式。</p>
<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头（Big-endian）敲开还是从小头（Little-endian）敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>
<p>第一个字节在前，就是”大端方式&rdquo;（Big endian），第二个字节在前就是”小端方式&quot;（Little endian）。</p>
<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>
<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做&quot;零宽度非换行空格&quot;（zero width no-break space），用 FEFF 表示。这正好是两个字节，而且 FF 比 FE 大1。</p>
<p>如果一个文本文件的头两个字节是 FE FF，就表示该文件采用大端方式；如果头两个字节是 FF FE，就表示该文件采用小端方式。</p>
<p>但从上面关于 UTF-8 编码的说明可以看出，虽然 UTF-8 存在多字节表示一个字符的情况，但顺序是固定的，没有字节序的问题。Unix 系统下，UTF-8 没有任何前置字符，但 Windows 下记事本保存的 UTF-8 文件会带上 BOM（Byte Order Mark），即 EF BB BF 这三个字节。关于这一点，Unicode 之父 Rob Pike 明确说 UTF-8 不需要 BOM，所以一开始 Go 源文件是不允许有 BOM 的，否则编译不通过，不过现在已经可以有了。但建议还是别带 BOM。</p>
<blockquote>
<p>UTF-8 带 BOM 说不是为了区分字节序，而是为了更方便的知晓这是一个 UTF-8 文件。</p>
</blockquote>
<p>你可以通过 hexdump 工具查看文件开始的字符。</p>
<h2 id="8参考文献">8、参考文献</h2>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a>
</li>
<li><a href="https://books.studygolang.com/gopl-zh/ch3/ch3-05.html" target="_blank" rel="noopener">https://books.studygolang.com/gopl-zh/ch3/ch3-05.html</a>
</li>
<li><a href="https://blog.csdn.net/hezh1994/article/details/78899683" target="_blank" rel="noopener">https://blog.csdn.net/hezh1994/article/details/78899683</a>
</li>
<li><a href="https://blog.csdn.net/weixin_39640298/article/details/84074498" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39640298/article/details/84074498</a>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>公众号如何涨粉</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/wechat-add-follow/</link>
			<pubDate>Wed, 20 Jan 2021 22:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/wechat-add-follow/</guid>
			<description>大家好，我是站长 polarisxu。 这是公众号系列原创文章的第 3 篇。上篇文章有人留言问公众号如何涨粉，这篇文章就聊聊这个话题。 微信是一个相对封闭的生态，不像其他平台，比如今日头条靠推荐（虽然微信公众号现在也加入了一些推荐机制）。因为是封闭的，加上触达机制，微信公众号的粉丝价值特别高。比如我的知乎账号有 9 万粉丝，但目前一分钱收入都没有，而公众号不到 1 万粉丝，就</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这是公众号系列原创文章的第 3 篇。上篇文章有人留言问公众号如何涨粉，这篇文章就聊聊这个话题。</p>
<p>微信是一个相对封闭的生态，不像其他平台，比如今日头条靠推荐（虽然微信公众号现在也加入了一些推荐机制）。因为是封闭的，加上触达机制，微信公众号的粉丝价值特别高。比如我的知乎账号有 9 万粉丝，但目前一分钱收入都没有，而公众号不到 1 万粉丝，就可以轻松月入几千。</p>
<p>但因为粉丝价值高，涨粉也不那么容易。公众号早期，有流量红利，现在流量越来越贵。</p>
<p>我的粉丝不多，粉丝也是缓慢增长，但我为什么还要写这篇文章呢？因为 Go 圈公众号还是比较少（或者说有一点粉丝的少），因此，我相信我的一些经验或认知对我的读者，对公众号感兴趣的读者会有一定帮助。</p>
<h2 id="01-常规方法">01 常规方法</h2>
<p>这里说的是从头开始做公众号，没有其他流量来源的情况，属于冷启动。</p>
<h3 id="原创投稿">原创投稿</h3>
<p>一般是选择一个领域，写原创文章，然后找该领域的大号投稿。我观察过，转载一篇文章，阅读量 2000 左右的话，应该可以带过去 80 左右的粉丝。当然这不是绝对的，看文章质量以及转载过多少次。很多原创作者最开始的粉丝都是通过这种方式获得的。</p>
<p>很多公众号菜单都有投稿的联系方式，我建议你联系某个号之前，先给他开通白名单（不知道怎么开通？这个你自己找一下吧）。我最近发现，有不少人根本没有联系我就给「Go语言中文网」开白了，而且很多是不对口的，我肯定不会转载的！</p>
<p>一般来说，接受投稿的公众号是那种非个人定位的。比如我这个 「polarisxu」公众号目前是不接受公众号投稿的。所以投稿前，应该明确对方是否接受投稿。</p>
<h3 id="进入领域圈子">进入领域圈子</h3>
<p>文章在公众号发了，及时是好文，不暴露给用户，是吸引不来粉丝的。所以，为了让目标用户看到你的好文，你应该让文章进入他们的视线。分享到微信朋友圈和群是很好的方式。</p>
<p>先说群。因为你是冷启动，我想目标用户是你微信好友的可能性比较小。这时候，你可以加一些你选择的领域的群。但提醒下，这个群是别人的，分享文章要注意下。我个人建议，可以现在群里和群友交流，混个脸熟，而且文章写的不错的话，很有可能有合适的机会分享给群友。此外，如果你在群里有了一定的知名度，可以偶尔将你认为不错的文章分享到群里，注意一定要和群的内容相关。比如在一个 Go 群，你发 Java 的文章，肯定不合适，很可能群主会踢了你。而且别只发文章就完事了，最好说下文章的亮点。你的文章不错，自然会有人关注。</p>
<p>接着说朋友圈。虽然微信公众号文章群发时会触达用户，但打开看的人数还是不那么多，而且用户还可能取消关注。因此，大家可以在文章末尾引导粉丝加你好友，交流技术。朋友圈是一个重要的私域流量，除了可以分享自己的文章，让没有读的人阅读，还会有商业价值。所以，尽可能多加目标粉丝为好友！</p>
<h3 id="其他平台引流">其他平台引流</h3>
<p>在早期，很多其他平台可以往公众号引流。比如把你的文章发布在其他平台，文末放上你的微信公众号二维码。但现在大流量的平台基本都会屏蔽二维码，流量真的是越来越难了。</p>
<p>但这些平台也并非完全无法引流。比如知乎，虽然文章不让放二维码了，但用户自己信息处还是可以写公众号名称的。如果你是有心人，可以看看目前各大平台，看看大家都是怎么引流的，总会有一些空子可以钻。</p>
<p>这里重点推荐一个还可以引流的平台，有不少人主要靠这个引流，那就是 GitHub。GitHub 上可以随便放二维码，但前提条件是你的项目火起来。怎么火？好项目应该是可以火的。另外一个方式，可以尝试整理一些大家都需要的内容。这个需要花时间和心思了。也许你刚好有一个不错的开源项目，那赶紧把你的二维码放上吧！</p>
<h2 id="02-互助">02 互助</h2>
<p>俗话说，一个人走得更快，一群人走的更远。众人拾柴火焰高。所以，做公众号的朋友应该互相帮助。其实上面说的原创投稿也是互助的一种方式。</p>
<p>经过这两年的公众号运营，我发现公众号的很多号主很会玩，我也参与了一些。</p>
<h3 id="互推">互推</h3>
<p>2019 年我开始运营公众号时，技术圈的公众号主们在组队互推，具体规则就是：一个车 10 来个号主，每个号主一段介绍加二维码，根据新榜指数排名，决定公众号的排序。每个号主安排某一天发文，可以是头条或次条，但对阅读量有要求，而且对标题也有一定要求。比如这个车要求是阅读达到 2000，如果你 24 小时没达标，需要找时间补发。</p>
<p>这种方式开始的时候效果还挺不错的，而且新增的粉丝大概率是真粉。那段时间 Go语言中文网公众号粉丝还是增加了不少。</p>
<p>不过次数多了，一方面反复那些号，增粉效果差；另一方面，读者也疲劳了，阅读量上不去。毕竟推这样的文章多了，会有点心累，而且会感觉有点对不住读者。</p>
<p>现在圈内基本不用这种方式了。也许过一些时间，可以再尝试下。不过这种方式，号主们的平均阅读量最好达到 1k 左右，否则效果太差。</p>
<h3 id="抽奖车">抽奖车</h3>
<p>2020 年春节前后，圈内流行抽奖车，即在原来的互推车基础上增加抽奖。有一个小程序，支持联合抽奖。10 来个号主联合，一起送一件礼物，比如 iPad，每个号主发文，每关注一个号增加一次抽奖机会，中奖概率将提升。</p>
<p>这种方式粉丝增加挺多的，不过真粉丝的概率很难说。如果互推车都是相关技术的，那真粉多，否则可能只是冲着奖品来的，抽奖结束，取消关注的也会不少，当然总体上粉丝还是增加的。</p>
<p>说明一句，有人怀疑抽奖有内幕，其实只要认真一想，不可能有内幕的，关键没必要。再说抽奖的小程序是第三方的，想内幕也不可能。</p>
<h3 id="单推">单推</h3>
<p>这种方式分两种：朋友圈互推和公众号送资料单推。</p>
<p>朋友圈互推是约一个号主，彼此在朋友圈介绍对方，让好友关注。找到合适的号主，这种互推方式还是不错的。</p>
<p>至于公众号送资料，就是找到合适的号主，各自准备一篇推文，关注公众号后，回复关键字获取资料。我自己这种方式用的很少，Go 圈还是有点小众，非 Go 真实粉丝我又不太想要。整体上这种方式送的资料还是挺重要的，感觉关键还是找到好的资料和合适的互推号主。</p>
<h2 id="03-小结">03 小结</h2>
<p>增粉很重要，但也是一个漫长的过程。有些人很厉害，通过爆款文章就可以增加很多粉丝，但这没有普适性。普通人，坚持原创产出，坚持，我相信会有收获！</p>
<p>另外一点，就是大家要心怀一颗利他之心，帮助别人，别人也会帮助你。加油！</p>
<p>最后欢迎给「Go语言中文网」公众号投稿，一起加油！你有其他涨粉方式，欢迎留言交流，大家一起涨粉！</p>
]]></content>
		</item>
		
		<item>
			<title>第 78 期周刊题目解析：答题正确率有点低</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/weekly-question-78/</link>
			<pubDate>Mon, 18 Jan 2021 11:25:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/weekly-question-78/</guid>
			<description>大家好，我是站长 polarisxu。 昨天在 Go语言爱好者周刊第 78 期 出了一道题，以下代码输出什么？ package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { ch1 := make(chan int) go fmt.Println(&amp;lt;-ch1) ch1 &amp;lt;- 5 time.Sleep(1 * time.Second) } A：5；B：编译不通过；C：运行时死锁 如果你没有做这道题，往下看之前，先思考下。 今天看了下答题结果，正确率有点低，才 35%： 可见不少人的基础还是不扎实。 此题如果改为这样： package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { ch1 := make(chan int) go func(){ fmt.Println(&amp;lt;-ch1) }() ch1 &amp;lt;- 5 time.Sleep(1 * time.Second)</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>昨天在 <a href="https://mp.weixin.qq.com/s/kma8hvdLVPIkZnKw_MaSKg" target="_blank" rel="noopener">Go语言爱好者周刊第 78 期</a>
出了一道题，以下代码输出什么？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">go</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">)</span>
	<span class="nx">ch1</span> <span class="o">&lt;-</span> <span class="mi">5</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>A：5；B：编译不通过；C：运行时死锁</p>
<p>如果你没有做这道题，往下看之前，先思考下。</p>
<p>今天看了下答题结果，正确率有点低，才 35%：</p>
<p><p class="md__image">
  <img src="../imgs/weekly-question-78.png"
    alt=""  />
</p>
</p>
<p>可见不少人的基础还是不扎实。</p>
<p>此题如果改为这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">)</span>
  <span class="p">}()</span>
	<span class="nx">ch1</span> <span class="o">&lt;-</span> <span class="mi">5</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果就是 A 了。对比下你能知道原因了吧！</p>
<p>在 Go 语言规范中，关于 <a href="https://docs.studygolang.com/ref/spec#Go_statements" target="_blank" rel="noopener">go 语句</a>
有这么一句描述：</p>
<blockquote>
<pre tabindex="0"><code>GoStmt = &quot;go&quot; Expression .
</code></pre><p>The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for <a href="https://docs.studygolang.com/ref/spec#Expression_statements" target="_blank" rel="noopener">expression statements</a>
.</p>
<p>The function value and parameters are <a href="https://docs.studygolang.com/ref/spec#Calls" target="_blank" rel="noopener">evaluated as usual</a>
 in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete.</p>
</blockquote>
<p>这里说明，go 语句后面的函数调用，其参数会先求值，这和普通的函数调用求值一样。在规范中<a href="https://docs.studygolang.com/ref/spec#Calls" target="_blank" rel="noopener">调用部分</a>
是这样描述的：</p>
<blockquote>
<p>Given an expression <code>f</code> of function type <code>F</code>,</p>
<pre tabindex="0"><code>f(a1, a2, … an)
</code></pre><p>calls <code>f</code> with arguments <code>a1, a2, … an</code>. Except for one special case, arguments must be single-valued expressions <a href="https://docs.studygolang.com/ref/spec#Assignability" target="_blank" rel="noopener">assignable</a>
 to the parameter types of <code>F</code> and are evaluated before the function is called.</p>
</blockquote>
<p>大意思是说，函数调用之前，实参就被求值好了。</p>
<p>因此这道题目 <code>go fmt.Println(&lt;-ch1)</code> 语句中的 <code>&lt;-ch1</code> 是在 main goroutine 中求值的。这相当于一个无缓冲的 chan，发送和接收操作都在一个 goroutine 中（main goroutine）进行，因此造成死锁。</p>
<p>更进一步，大家可以通过汇编看看上面两种方式的不同。</p>
<p>此外，defer 语句也要注意。比如下面的做法是不对的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">defer</span> <span class="nb">recover</span><span class="p">()</span>
</code></pre></div><p>而应该使用这样的方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">recover</span><span class="p">()</span>
<span class="p">}()</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>钉钉 6.0 发布会上提到的 Low-Code 是个什么鬼？</title>
			<link>https://polarisxu.studygolang.com/posts/talk/low-code/</link>
			<pubDate>Sat, 16 Jan 2021 20:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/low-code/</guid>
			<description>2021 年 1 月 14 日钉钉 6.0 发布会上提到了“云钉一体”战略，其中讲解了 「Low-Code」 这个词。不知道大家看到这个词是啥感觉？这是说我写的代码 low 吗？ 阿里似乎比较喜欢带节奏，比如中台，不管大小公司都模仿；前段时间看网上有说他们去中台。。。心好累！ Low-Code 这玩意竟然很早就有了，很多人不知晓，多半是因为一直不温不火！不知道大家是否知晓，反正我之前是不知道，是这两天才看的很多资料</description>
			<content type="html"><![CDATA[<p>2021 年 1 月 14 日钉钉 6.0 发布会上提到了“云钉一体”战略，其中讲解了 「Low-Code」 这个词。不知道大家看到这个词是啥感觉？这是说我写的代码 low 吗？</p>
<p>阿里似乎比较喜欢带节奏，比如中台，不管大小公司都模仿；前段时间看网上有说他们去中台。。。心好累！</p>
<p>Low-Code 这玩意竟然很早就有了，很多人不知晓，多半是因为一直不温不火！不知道大家是否知晓，反正我之前是不知道，是这两天才看的很多资料。所以，这是一篇概念普及性的文章。</p>
<h2 id="01-low-code-是什么">01 low-code 是什么？</h2>
<p>low-code 一般翻译为低代码，表示的是用很少甚至不用代码就能开发软件。看一张图：</p>
<p><p class="md__image">
  <img src="../imgs/low-code.png"
    alt=""  />
</p>
</p>
<p>35 岁，不懂代码，2小时能开发出「疫情防控应用」，最喜欢的语言不是 PHP，而是「拖拉拽」。。。</p>
<p>Low-Code 是什么，大家应该有一个初步的概念了。维基百科是这么描述的（关于 low-code development platform）：</p>
<blockquote>
<p>A <strong>low-code development platform</strong> (<strong>LCDP</strong>) provides a development environment used to create application software through graphical user interfaces and configuration instead of traditional hand-coded computer programming。</p>
</blockquote>
<p>也就是说，低代码开发平台（LCDP）本身也是一种软件，它为开发者提供了一个创建应用软件的开发环境。对于程序员而言，低代码开发平台的性质与 IDEA、VS 等代码 IDE 类似，都是服务于开发者的生产力工具。但与传统代码 IDE 不同的是，低代码开发平台提供的是更高维和易用的可视化 IDE。大多数情况下，开发者并不需要使用传统的手写代码方式进行编程，而是可以通过图形化拖拽、参数配置等更高效的方式完成开发工作。</p>
<p>所以，钉钉就是要打造一个这样的平台。</p>
<blockquote>
<p>Low-Code 这个词最早是 Forrester 在 2014 年提出来的。</p>
</blockquote>
<h2 id="02-能做什么">02 能做什么？</h2>
<p>在参考文献「1」中，阿里内部目前很看好它，认为这是一场革命。它把普通的编程比作文章，把低代码比作视频，视频越来越受欢迎，虽然文章依然有其存在市场，但视频已成为大部分人获取信息的主要渠道。</p>
<p>说起拖拽编程，很多人可能会不屑：想想 Dreamware、Visual Basic 等，提供了强大的拖拽，但实际上大家很少用拖拽。不过低代码跟之前的还是不太一样，它可以给非程序员使用。</p>
<p>计算机领域有一句至理名言：任何问题都可以通过增加一个间接的中间层来解决。低代码的思路亦是如此：与当年的操作系统和现在的云平台一样，都是想通过建立一个黑盒化的中间层抽象来降低开发者的工作量与心智负担。</p>
<p>具体来说，低代码适用于哪些场景？</p>
<ul>
<li>自动化表单系统。低代码平台提供基础组件，企业可以基于此，通过拖拽的方式创建自己的表单系统，比如常见的 OA 的各种表单、审批。基本上表单收集信息、展示这类型的应用都可以通过低代码（甚至无代码）实现。</li>
<li>低代码开发 Saas 系统。</li>
<li>低代码开发 Pass 系统。</li>
</ul>
<h2 id="03-展望">03 展望</h2>
<p>除了这次钉钉的高调发布会，腾讯云也有低代码系统，他们总体的思路都是“云端一体”，解决了云，还希望解决本地“端”的问题。</p>
<p>虽然技术都有成熟度曲线，但不同的技术，成熟度曲线的跨度等是不一样的。Saas、Pass、Faas、Serverless 等一堆技术，它们都有一定程度的应用，但没有银弹，没有那种技术是一统江湖的。像微服务、中台不是银弹一样，鼓吹低代码是新一代技术革命，我觉得有点过了。</p>
<p>总的来看，我觉得低代码比较适合的场景还是偏向服务企业，开发企业内部的应用。实话说，这部分的系统，也是很多程序员不愿意开发的。但这部分又是企业数字化很重要的部分，因此低代码还是能发挥很大的作用，特别是对于传统企业数字化转型更是如此。</p>
<p>而且，我认为低代码开发平台属于大企业会做的事情（有一些创业公司可能会做这个方向），他们服务中小企业，说白了是一个 2B 的生意，大量 2C 的公司以及大厂们，要么用不上低代码，要么自己搭建一套这样的系统。同时，这些低代码平台会吸引更多的开发者参与进来，开发基础组件，打造生态。所以，低代码咋一看，似乎要革程序员的命，实际上程序员们呵呵一笑~</p>
<p>你怎么看？欢迎留言交流！</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>「1」：https://www.cnblogs.com/aliyun-emas/p/14004815.html</li>
<li>「2」：https://www.zhihu.com/question/439292804</li>
<li>「3」：https://en.wikipedia.org/wiki/Low-code_development_platform</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>用 Go 如何实现精准统计文章字数</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/stat-words/</link>
			<pubDate>Thu, 14 Jan 2021 17:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/stat-words/</guid>
			<description>大家好，我是站长 polarisxu。 今天要聊的内容应该可以当做一道面试题，你可以先想想该怎么实现。 统计字数是一个很常见的需求，很多人印象最深的应该是微博早些时候限制 140 字，而且边输入会边统计剩余字数。现在很多社区文章也会有字数统计的功能，而且可以依据字数来预估阅读时间。比如 Go语言中文网就有这样的功能。 01 需求分析 下手之前先分析下这个需求。从我个人经验看，在实际</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天要聊的内容应该可以当做一道面试题，你可以先想想该怎么实现。</p>
<p>统计字数是一个很常见的需求，很多人印象最深的应该是微博早些时候限制 140 字，而且边输入会边统计剩余字数。现在很多社区文章也会有字数统计的功能，而且可以依据字数来预估阅读时间。比如 Go语言中文网就有这样的功能。</p>
<h2 id="01-需求分析">01 需求分析</h2>
<p>下手之前先分析下这个需求。从我个人经验看，在实际面试中，针对一个面试题，你的分析过程，循序渐进的解决方案，可以很好的展示你的思考过程。正所谓分析问题、解决问题。这会给你加分的。</p>
<p>我们采用类似词法分析的思路分析这个需求。</p>
<p>一篇文章通常包含如下元素，我们也称之为 token：</p>
<ul>
<li>普通文字</li>
<li>标点符号</li>
<li>图片</li>
<li>链接（包含各种协议的链接）</li>
<li>代码</li>
</ul>
<p>其中普通文字通常会分为欧美和中日韩（CJK），因为 CJK 属于表意文字，和欧美字母的文字差异很大。同时这里还涉及到编码的问题。本文假设使用 UTF-8 编码。</p>
<p>对于标点符号，中文标点和英文标点也会很不一样。</p>
<p>此外还有全角和半角的问题。</p>
<p>根据以上分析，对于该需求作如下假定：</p>
<ul>
<li>空格（包括换行）不算字数；</li>
<li>HTML 标签需要剔除；</li>
<li>编码方式：假定为 UTF-8 编码；</li>
<li>标点符号算不算做字数。如果算，像括号这样的按 2 个字算；</li>
<li>链接怎么算？一个链接约定为 1 个字可能更合适，大概阅读时只是把它当链接，而不太会关心链接由什么字母组成；</li>
<li>图片不算做字数，但如果计算阅读时间，可能需要适当考虑图片的影响；</li>
<li>对于技术文章，代码是最麻烦的。统计代码字数感觉是没多大意义的。统计代码行数可能更有意义；</li>
</ul>
<p>本文的解决方案针对以上的假定进行。</p>
<h2 id="02-go-语言实现">02 Go 语言实现</h2>
<p>先看最简单的。</p>
<h3 id="纯英文">纯英文</h3>
<p>根据以上分析，如果文章只包含普通文本且是英文，也就是说，每个字（单词）根据空格分隔，统计是最简单的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TotalWords</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">inWord</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">wasInWord</span> <span class="o">:=</span> <span class="nx">inWord</span>
		<span class="nx">inWord</span> <span class="p">=</span> <span class="p">!</span><span class="nx">unicode</span><span class="p">.</span><span class="nf">IsSpace</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">inWord</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">wasInWord</span> <span class="p">{</span>
			<span class="nx">n</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></div><p>还有一种更简单的方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nb">len</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</code></pre></div><p>不过看 strings.Fields 的实现，性能会不如第一种方式。</p>
<p>回顾上面的需求分析，会发现这个实现是有 Bug 的。比如下面的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s1</span> <span class="o">:=</span> <span class="s">&#34;Hello,playground&#34;</span>
<span class="nx">s2</span> <span class="o">:=</span> <span class="s">&#34;Hello, playground&#34;</span>
</code></pre></div><p>用上面的实现，s1 的字数是 1，s2 的字数是 2。它们都忽略了标点符号。而且因为写法的多样性（不规范统一），导致计算字数会有误差。所以我们需要对写法进行规范。</p>
<h3 id="规范排版">规范排版</h3>
<p>其实和写代码要有规范一样，文章也是有规范的。比如出版社对于一本书的排版会有明确的规定。为了让我们的文章看起来更舒服，也应该遵循一定的规范。</p>
<p>这里推荐一个 GitHub 上的排版指南：<a href="https://github.com/studygolang/GCTT/blob/master/chinese-copywriting-guidlines.md" target="_blank" rel="noopener">《中文文案排版指北》</a>
，它的宗旨，统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。这个规范开头关于空格的一段话很有意思：</p>
<blockquote>
<p>有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。</p>
</blockquote>
<p>建议大家可以看看这个指北，一些知名的网站就是按照这个做的。</p>
<p>因为 GCTT 的排版在这个规范做，但人为约束不是最好的方法，所以我开发了一个 Go 工具：<a href="https://github.com/studygolang/autocorrect" target="_blank" rel="noopener">https://github.com/studygolang/autocorrect</a>
，用于自动给中英文之间加入合理的空格并纠正专用名词大小写。</p>
<p>所以为了让字数统计更准确，我们假定文章是按一定的规范书写的。比如上面的例子，规范的写法是 <code>s2 := &quot;Hello, playground&quot;</code>。不过这里标点不算作字数。</p>
<p>刚去微博上试了一下，发现微博的字数计算方式有点诡异，竟然是 9 个字。</p>
<p><p class="md__image">
  <img src="../imgs/stat-words-weibo.png"
    alt=""  />
</p>
</p>
<p>测试一下发现，它直接把两个英文字母算作一个字（两个字节算一个字）。而汉字是正常的。大家可以想想微博是怎么实现的。</p>
<h3 id="中英文混合">中英文混合</h3>
<p>中文不像英文，单词之间没有空格分隔，因此开始的那两种方式不适合。</p>
<p>如果是纯中文，我们怎么计算字数呢？</p>
<p>在 Go 语言中，字符串使用 UTF-8 编码，一个字符用 rune 表示。因此在标准库中查找相关计算方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RuneCountInString</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></div><p>这个方法能计算字符串包含的 rune（字符）数，对于纯中文，就是汉字数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">str</span> <span class="o">:=</span> <span class="s">&#34;你好世界&#34;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">utf8</span><span class="p">.</span><span class="nf">RuneCountInString</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span>
</code></pre></div><p>以上代码输出 4。</p>
<p>然而，因为很多时候文章会中英文混合，因此我们先采用上面的纯英文的处理方式，即：<code>strings.Fields()</code>，将文章用空格分隔，然后处理每一部分。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TotalWords</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">wordCount</span> <span class="o">:=</span> <span class="mi">0</span>
  
	<span class="nx">plainWords</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">plainWords</span> <span class="p">{</span>
		<span class="nx">runeCount</span> <span class="o">:=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nf">RuneCountInString</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span> <span class="o">==</span> <span class="nx">runeCount</span> <span class="p">{</span>
			<span class="nx">wordCount</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">wordCount</span> <span class="o">+=</span> <span class="nx">runeCount</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">wordCount</span>
<span class="p">}</span>
</code></pre></div><p>增加如下的测试用例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestTotalWords</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">name</span>  <span class="kt">string</span>
		<span class="nx">input</span> <span class="kt">string</span>
		<span class="nx">want</span>  <span class="kt">int</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">&#34;en1&#34;</span><span class="p">,</span> <span class="s">&#34;hello,playground&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;en2&#34;</span><span class="p">,</span> <span class="s">&#34;hello, playground&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;cn1&#34;</span><span class="p">,</span> <span class="s">&#34;你好世界&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;encn1&#34;</span><span class="p">,</span> <span class="s">&#34;Hello你好世界&#34;</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;encn2&#34;</span><span class="p">,</span> <span class="s">&#34;Hello 你好世界&#34;</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">tt</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">got</span> <span class="o">:=</span> <span class="nx">wordscount</span><span class="p">.</span><span class="nf">TotalWords</span><span class="p">(</span><span class="nx">tt</span><span class="p">.</span><span class="nx">input</span><span class="p">);</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;TotalWords() = %v, want %v&#34;</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">})</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>发现 en1 和 encn1 测试不通过，因为没有按照上面说的规范书写。因此我们通过程序增加必要的空格。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AutoSpace 自动给中英文之间加上空格
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AutoSpace</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">out</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">str</span> <span class="p">{</span>
		<span class="nx">out</span> <span class="p">=</span> <span class="nf">addSpaceAtBoundary</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">addSpaceAtBoundary</span><span class="p">(</span><span class="nx">prefix</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">nextChar</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">nextChar</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">r</span><span class="p">,</span> <span class="nx">size</span> <span class="o">:=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nf">DecodeLastRuneInString</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)</span>
	<span class="k">if</span> <span class="nf">isLatin</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="o">!=</span> <span class="nf">isLatin</span><span class="p">(</span><span class="nx">utf8</span><span class="p">.</span><span class="nf">RuneLen</span><span class="p">(</span><span class="nx">nextChar</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="nf">isAllowSpace</span><span class="p">(</span><span class="nx">nextChar</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">isAllowSpace</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">prefix</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">nextChar</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">prefix</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">nextChar</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">isLatin</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">isAllowSpace</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">!</span><span class="nx">unicode</span><span class="p">.</span><span class="nf">IsSpace</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">unicode</span><span class="p">.</span><span class="nf">IsPunct</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这样可以在 TotalWords 函数开头增加 AutoSpace 进行规范化。这时结果就正常了。</p>
<h3 id="处理标点和其他类型">处理标点和其他类型</h3>
<p>以上例子标点没计算在内，而且如果英文和中文标点混合在一起，情况又复杂了。</p>
<p>为了更好地实现开始的需求分析，重构以上代码，设计如下的结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Total</span>     <span class="kt">int</span> <span class="c1">// 总字数 = Words + Puncts
</span><span class="c1"></span>	<span class="nx">Words</span>     <span class="kt">int</span> <span class="c1">// 只包含字符数
</span><span class="c1"></span>	<span class="nx">Puncts</span>    <span class="kt">int</span> <span class="c1">// 标点数
</span><span class="c1"></span>	<span class="nx">Links</span>     <span class="kt">int</span> <span class="c1">// 链接数
</span><span class="c1"></span>	<span class="nx">Pics</span>      <span class="kt">int</span> <span class="c1">// 图片数
</span><span class="c1"></span>	<span class="nx">CodeLines</span> <span class="kt">int</span> <span class="c1">// 代码行数
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>同时将 TotalWords 重构为 Counter 的 Stat 方法，同时记录标点数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">wc</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nf">Stat</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">wc</span><span class="p">.</span><span class="nx">Links</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rxStrict</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
	<span class="nx">wc</span><span class="p">.</span><span class="nx">Pics</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">imgReg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

	<span class="c1">// 剔除 HTML
</span><span class="c1"></span>	<span class="nx">str</span> <span class="p">=</span> <span class="nf">StripHTML</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>

	<span class="nx">str</span> <span class="p">=</span> <span class="nf">AutoSpace</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>

	<span class="c1">// 普通的链接去除（非 HTML 标签链接）
</span><span class="c1"></span>	<span class="nx">str</span> <span class="p">=</span> <span class="nx">rxStrict</span><span class="p">.</span><span class="nf">ReplaceAllString</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span>
	<span class="nx">plainWords</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">plainWord</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">plainWords</span> <span class="p">{</span>
		<span class="nx">words</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">FieldsFunc</span><span class="p">(</span><span class="nx">plainWord</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">unicode</span><span class="p">.</span><span class="nf">IsPunct</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">wc</span><span class="p">.</span><span class="nx">Puncts</span><span class="o">++</span>
				<span class="k">return</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">})</span>

		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">words</span> <span class="p">{</span>
			<span class="nx">runeCount</span> <span class="o">:=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nf">RuneCountInString</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span> <span class="o">==</span> <span class="nx">runeCount</span> <span class="p">{</span>
				<span class="nx">wc</span><span class="p">.</span><span class="nx">Words</span><span class="o">++</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">wc</span><span class="p">.</span><span class="nx">Words</span> <span class="o">+=</span> <span class="nx">runeCount</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">wc</span><span class="p">.</span><span class="nx">Total</span> <span class="p">=</span> <span class="nx">wc</span><span class="p">.</span><span class="nx">Words</span> <span class="o">+</span> <span class="nx">wc</span><span class="p">.</span><span class="nx">Puncts</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">rxStrict</span> <span class="p">=</span> <span class="nx">xurls</span><span class="p">.</span><span class="nf">Strict</span><span class="p">()</span>
	<span class="nx">imgReg</span>   <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`&lt;img [^&gt;]*&gt;`</span><span class="p">)</span>
	<span class="nx">stripHTMLReplacer</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReplacer</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">,</span> <span class="s">&#34;&lt;/p&gt;&#34;</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">,</span> <span class="s">&#34;&lt;br&gt;&#34;</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">,</span> <span class="s">&#34;&lt;br /&gt;&#34;</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">// StripHTML accepts a string, strips out all HTML tags and returns it.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">StripHTML</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="c1">// Shortcut strings with no tags in them
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">ContainsAny</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;&lt;&gt;&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">s</span>
	<span class="p">}</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nx">stripHTMLReplacer</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

	<span class="c1">// Walk through the string removing all tags
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="nf">GetBuffer</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nf">PutBuffer</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">inTag</span><span class="p">,</span> <span class="nx">isSpace</span><span class="p">,</span> <span class="nx">wasSpace</span> <span class="kt">bool</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">inTag</span> <span class="p">{</span>
			<span class="nx">isSpace</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">r</span> <span class="o">==</span> <span class="sc">&#39;&lt;&#39;</span><span class="p">:</span>
			<span class="nx">inTag</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="k">case</span> <span class="nx">r</span> <span class="o">==</span> <span class="sc">&#39;&gt;&#39;</span><span class="p">:</span>
			<span class="nx">inTag</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">case</span> <span class="nx">unicode</span><span class="p">.</span><span class="nf">IsSpace</span><span class="p">(</span><span class="nx">r</span><span class="p">):</span>
			<span class="nx">isSpace</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="k">fallthrough</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">inTag</span> <span class="o">&amp;&amp;</span> <span class="p">(!</span><span class="nx">isSpace</span> <span class="o">||</span> <span class="p">(</span><span class="nx">isSpace</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">wasSpace</span><span class="p">))</span> <span class="p">{</span>
				<span class="nx">b</span><span class="p">.</span><span class="nf">WriteRune</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">wasSpace</span> <span class="p">=</span> <span class="nx">isSpace</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>代码过多的细节不讨论。此外，关于文章内的代码行数统计未实现（目前没有想到特别好的方法，如果你有，欢迎交流）。</p>
<h2 id="03-总结">03 总结</h2>
<p>通过本文的分析发现，精准统计字数没那么容易，这里涉及到很多的细节。</p>
<p>当然，实际应用中，字数不需要那么特别精准，而且对于非正常文字（比如链接、代码）怎么处理，会有不同的约定。</p>
<p>本文涉及到的完整代码放在 GitHub：<a href="https://github.com/polaris1119/wordscount" target="_blank" rel="noopener">https://github.com/polaris1119/wordscount</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>我为什么运营微信公众号</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/why-wechat/</link>
			<pubDate>Mon, 11 Jan 2021 20:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/why-wechat/</guid>
			<description>大家好，我是站长 polarisxu。 这个话题有些人可能不喜欢，但我近期发现，越来越多的 Gopher 开始注册自己的微信公众号了，有些甚至花钱购买留言号。虽然我不是公众号运营的牛人，但这一两年还是有一些心得，因此写一些关于微信公众号的文章，希望对刚入门的 Gopher 有所帮助。 今天先谈谈我为什么运营微信公众号。 虽然 Go 语言中文网公众号很早就注册了（2014 年），但一直没有怎么运营。直到</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这个话题有些人可能不喜欢，但我近期发现，越来越多的 Gopher 开始注册自己的微信公众号了，有些甚至花钱购买留言号。虽然我不是公众号运营的牛人，但这一两年还是有一些心得，因此写一些关于微信公众号的文章，希望对刚入门的 Gopher 有所帮助。</p>
<p>今天先谈谈我为什么运营微信公众号。</p>
<p>虽然 Go 语言中文网公众号很早就注册了（2014 年），但一直没有怎么运营。直到 2018 年，因为 GCTT 的原因，组织了一些自愿者将翻译的文章发布到公众号，那时候粉丝 8k 左右，工作日几乎每天都发布，一直到 2019 年中旬，粉丝增长比较缓慢，平均阅读基本在 1000 以下。那时基本属于佛系运营。</p>
<p>因为阅读量和粉丝增长缓慢，我决定自己运营。</p>
<p>我自己运营后，开始日更。</p>
<p>很多人应该知道，微信公众号文章的标题很重要。自愿者运营，基本只是简单的搬运，我自己运营后，开始琢磨标题，琢磨公众号运营涨粉的事情。</p>
<p>随着公众号粉丝和阅读量的增加，运营的动力更足：有自己的粉丝，写的内容有不少人看，这在很多平台是得不到的。所以运营公众号能得到自我满足。</p>
<p>但毫不隐晦的说，日更的主要动力在于公众号有收入。Go 语言中文网公众号到一定粉丝后，有广告主主动找我投广告。虽然不是因为赚钱而运营的公众号，但赚钱成了自然而然的事情。至于能赚到多少钱，以后再谈！</p>
<p>运营公众号的第三点，因为要输出会督促自己不断输入。一方面，为了将文章写的更好，会尝试不断提升自己的写作水平；另一方面，为了输出高质量文章，需要不断输入技术知识，而且这个输入会让你比一般时候更细心。将输入输出，会有自己的加工过程，加工处理的过程会让你对某个知识掌握的更牢靠。如果只是输入没有输出，这个输入大概率很快就归还了。</p>
<p>最后一点，公众号可以更好的统计自己的输出情况。以下是 「polarisxu」这个号 2020 年的数据情况（从 2020 年 6 月份开始）：</p>
<ul>
<li>累计 18 万阅读；991 在看；</li>
<li>有 107 天发布了文章，一共发布了 114 篇，其中 90 篇声明了原创；</li>
<li><a href="https://mp.weixin.qq.com/s/w0_cur6qrwlcmplDoD1a4w" target="_blank" rel="noopener">《从来没有这么强烈想推荐一个工具》</a>
 这篇文章阅读量最高：4965 阅读，29 在看；</li>
<li>2020 年发布的文章一共有 46.2 万字，总阅读时长大概 962 分钟；</li>
</ul>
<p>还可以看到很多其他数据，这些都是对自己一个很好的总结。</p>
<p>总结一下，我认为运营公众号至少有以下收获：</p>
<ol>
<li>获得自我满足，实现自我价值；</li>
<li>获得额外收入，运营的好，这个收入不菲；</li>
<li>促进自己输入，鞭策提升自己，以便更好地输出；</li>
<li>一目了然的知晓自己的产出统计数据，很有成就感；</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>基于 Go1.16 实现静态文件的 HTTP Cache</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/hashfs-http-cache/</link>
			<pubDate>Sun, 10 Jan 2021 22:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/hashfs-http-cache/</guid>
			<description>大家好，我是站长 polarisxu。 之前写过一篇文章：《提前试用将在 Go1.16 中发布的内嵌静态资源功能》 ，如果之前没阅读，建议继续看本文前先阅读下该文。 现在 Go 1.16 Beta 已经发布，离正式版发布不远了，在 GitHub 发现了一个库，它实现了 io/fs.FS 接口，它能够计算文件的 SHA256 哈希值并附加到文件名中以允许进行 HTTP Cache：即控制静态文件的版本。本文对其进行介绍并顺带讲解一些涉及到的其他内容。 温馨提示</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>之前写过一篇文章：<a href="https://mp.weixin.qq.com/s/SiCTV7R2wA_I2nCQkC3GGQ" target="_blank" rel="noopener">《提前试用将在 Go1.16 中发布的内嵌静态资源功能》</a>
，如果之前没阅读，建议继续看本文前先阅读下该文。</p>
<p>现在 Go 1.16 Beta 已经发布，离正式版发布不远了，在 GitHub 发现了一个库，它实现了 io/fs.FS 接口，它能够计算文件的 SHA256 哈希值并附加到文件名中以允许进行 HTTP Cache：即控制静态文件的版本。本文对其进行介绍并顺带讲解一些涉及到的其他内容。</p>
<blockquote>
<p>温馨提示：本文内容基于 Go 1.16 Beta，之前版本不支持！</p>
</blockquote>
<h2 id="01-hashfs-包">01 hashfs 包</h2>
<p>包地址：<a href="https://github.com/benbjohnson/hashfs" target="_blank" rel="noopener">https://github.com/benbjohnson/hashfs</a>
，有效代码函数不到 200。</p>
<p>对于给定的一个文件，比如 scripts/main.js，hashfs.FS 文件系统处理后会生成一个带 hash 的文件，类似 scripts/main-b633a..d628.js（中间有省略），客户端请求该文件时，可以选择让客户端缓存。hash 算法使用的是 SHA256。当文件内容发生变化时，hash 值也会变。</p>
<p>该包默认提供对 net/http 的兼容。通过例子看看具体怎么使用。</p>
<h2 id="02-基于-nethttp-的使用">02 基于 net/http 的使用</h2>
<p>创建一个目录，使用 module：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ mkdir ~/embed
$ <span class="nb">cd</span> ~/embed
$ go mod init gtihub.com/polaris1119/embed
</code></pre></div><p>为了基于同一个项目演示不同使用方式，创建如下目录结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">├── cmd
│   ├── std
│   │   └── main.go
├── embed.go
├── go.mod
├── go.sum
├── static
│   └── main.js	// 主要处理该文件的嵌入、hash
├── template
│   └── index.html
</code></pre></div><p>其中 embed.go 的作用在本文开头文章提到过，内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">embed</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;embed&#34;</span>

	<span class="s">&#34;github.com/benbjohnson/hashfs&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">embedFS</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="c1">// 带 hash 功能的 fs.FS
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">Fsys</span> <span class="p">=</span> <span class="nx">hashfs</span><span class="p">.</span><span class="nf">NewFS</span><span class="p">(</span><span class="nx">embedFS</span><span class="p">)</span>
</code></pre></div><blockquote>
<p>再说一句，因为 //go:embed 只能相对当前源文件所在目录，所以单独创建这个文件以便和 static 在同一级目录。</p>
</blockquote>
<p>index.html 和 main.js 的内容很简单。</p>
<p>index.html：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>测试 Embed Hash<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;/assets/{{.mainjs}}&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>测试 Embed Hash<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">hr</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      以下内容来自 JS：
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;content&#34;</span> <span class="na">style</span><span class="o">=</span><span class="s">&#34;color: red;&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><p>该模板中有一个变量：mainjs。</p>
<p>main.js：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#content&#39;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s2">&#34;我是 JS 内容&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>如果一切正常，看到的页面如下：</p>
<p><p class="md__image">
  <img src="../imgs/hashfs.png"
    alt=""  />
</p>
</p>
<p>在 cmd/std/main.go 中写上如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;html/template&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/benbjohnson/hashfs&#34;</span>
	<span class="s">&#34;github.com/polaris1119/embed&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/assets/&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">StripPrefix</span><span class="p">(</span><span class="s">&#34;/assets/&#34;</span><span class="p">,</span> <span class="nx">hashfs</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">)))</span>

	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">tpl</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;index.html&#34;</span><span class="p">).</span><span class="nf">ParseFiles</span><span class="p">(</span><span class="s">&#34;template/index.html&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">err</span> <span class="p">=</span> <span class="nx">tpl</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
			<span class="s">&#34;mainjs&#34;</span><span class="p">:</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">HashName</span><span class="p">(</span><span class="s">&#34;static/main.js&#34;</span><span class="p">),</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">})</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>特意为静态资源加上 <code>/assets/</code> 前缀，后文解释；</li>
<li><code>hashfs.FileServer(embed.Fsys))</code> 是 hashfs 包对 net/http 的支持，即 hashfs.FileServer 是一个 http.Handler；</li>
<li><code>embed.Fsys.HashName(&quot;static/main.js&quot;)</code> 将文件生成为带 hash 的；</li>
</ul>
<p>执行 <code>go run ./cmd/std/main.go</code>，打开浏览器访问：http://localhost:8080 即可看到上面截图的页面，审查元素可以看到如下信息，缓存一年。（见代码：<a href="https://github.com/benbjohnson/hashfs/blob/main/hashfs.go#L200" target="_blank" rel="noopener">https://github.com/benbjohnson/hashfs/blob/main/hashfs.go#L200</a>
）</p>
<p><p class="md__image">
  <img src="../imgs/hashfs01.png"
    alt=""  />
</p>
</p>
<p>当你再次刷新浏览器，看到 js 文件直接从缓存获取的。</p>
<p><p class="md__image">
  <img src="../imgs/hashfs02.png"
    alt=""  />
</p>
</p>
<p>当 main.js 的内容发生变化，main-xxx.js 中的 hash 部分也会变化，你可以自行试验。（注意，因为资源内嵌了，修改了 js 的内容，需要重新 go run）。</p>
<h2 id="03-关于服务静态文件">03 关于服务静态文件</h2>
<p>这块有必要单独拿出来说下，因为比较容易搞错。比如上面的一行代码改为这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/assets&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">StripPrefix</span><span class="p">(</span><span class="s">&#34;/assets&#34;</span><span class="p">,</span> <span class="nx">hashfs</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">)))</span>
</code></pre></div><p>再次运行结果就不对（没有 “我是 JS 内容”）。（注意禁用浏览器缓存，否则看不到效果）</p>
<p>如果是 Echo 框架，则可以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">Static</span><span class="p">(</span><span class="s">&#34;/assets&#34;</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">)</span>
</code></pre></div><p>Gin 框架，也可以：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">router</span><span class="p">.</span><span class="nf">Static</span><span class="p">(</span><span class="s">&#34;/assets&#34;</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">)</span>
</code></pre></div><p>关于其中的细节，大家有兴趣可以查阅相关源码。这里只要记住，服务目录，末尾加上 <code>/</code>，（目录嘛，应该有 <code>/</code>），即：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/assets/&#34;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</code></pre></div><h2 id="04-基于-echo-的使用">04 基于 Echo 的使用</h2>
<p>在 cmd 目录下创建 echo/main.go 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;mime&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;net/url&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;path&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;text/template&#34;</span>

	<span class="s">&#34;github.com/benbjohnson/hashfs&#34;</span>
	<span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
	<span class="s">&#34;github.com/polaris1119/embed&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/assets/*&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">filename</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">PathUnescape</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;*&#34;</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">isHashed</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">hashfs</span><span class="p">.</span><span class="nf">ParseName</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">hash</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">HashName</span><span class="p">(</span><span class="nx">base</span><span class="p">)</span> <span class="o">==</span> <span class="nx">filename</span> <span class="p">{</span>
				<span class="nx">filename</span> <span class="p">=</span> <span class="nx">base</span>
				<span class="nx">isHashed</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrNotFound</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrInternalServerError</span>
		<span class="p">}</span>
		<span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

		<span class="c1">// Fetch file info. Disallow directories from being displayed.
</span><span class="c1"></span>		<span class="nx">fi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Stat</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrInternalServerError</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">fi</span><span class="p">.</span><span class="nf">IsDir</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrForbidden</span>
		<span class="p">}</span>

		<span class="nx">contentType</span> <span class="o">:=</span> <span class="s">&#34;text/plain&#34;</span>
		<span class="c1">// Determine content type based on file extension.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ext</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Ext</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">ext</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">contentType</span> <span class="p">=</span> <span class="nx">mime</span><span class="p">.</span><span class="nf">TypeByExtension</span><span class="p">(</span><span class="nx">ext</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Cache the file aggressively if the file contains a hash.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">isHashed</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">Response</span><span class="p">().</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Cache-Control&#34;</span><span class="p">,</span> <span class="s">`public, max-age=31536000`</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Set content length.
</span><span class="c1"></span>		<span class="nx">ctx</span><span class="p">.</span><span class="nf">Response</span><span class="p">().</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Length&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">fi</span><span class="p">.</span><span class="nf">Size</span><span class="p">(),</span> <span class="mi">10</span><span class="p">))</span>

		<span class="c1">// Flush header and write content.
</span><span class="c1"></span>		<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">().</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;HEAD&#34;</span> <span class="p">{</span>
			<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Blob</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">contentType</span><span class="p">,</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">tpl</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;index.html&#34;</span><span class="p">).</span><span class="nf">ParseFiles</span><span class="p">(</span><span class="s">&#34;template/index.html&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="kd">var</span> <span class="nx">buf</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">tpl</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
			<span class="s">&#34;mainjs&#34;</span><span class="p">:</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">HashName</span><span class="p">(</span><span class="s">&#34;static/main.js&#34;</span><span class="p">),</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">HTML</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>服务静态文件的代码： <code>e.GET(&quot;/assets/*&quot;, func(ctx echo.Context) error {</code>，主要参照了 <a href="https://github.com/benbjohnson/hashfs/blob/main/hashfs.go#L162" target="_blank" rel="noopener">https://github.com/benbjohnson/hashfs/blob/main/hashfs.go#L162</a>
 的实现；</li>
<li>首页的路由和 net/http 基本一样，关注 mainjs 模板变量；</li>
</ul>
<p>简单解释下服务静态文件的实现原理：</p>
<ul>
<li>获取请求的路径（<code>*</code> 部分）;</li>
<li>通过 hashfs.ParseName 解析出文件的 base 和 hash 两部分；</li>
<li>使用 fs.FS 打开文件，判断文件类型、大小，并将内容返回给客户端，如果有缓存，设置 HTTP Cache；</li>
</ul>
<p>运行 go run ./cmd/echo/main.go，不出意外和 net/http 版本一样的效果。</p>
<h2 id="05-基于-gin-的使用">05 基于 Gin 的使用</h2>
<p>其实知道了如何基于 Echo 框架使用，其他框架参照着实现即可。因为 Gin 框架用户多，因此也实现下。</p>
<p>在 cmd 目录下创建文件：gin/main.go</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;mime&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;net/url&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;path&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;strings&#34;</span>

	<span class="s">&#34;github.com/benbjohnson/hashfs&#34;</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/polaris1119/embed&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>

	<span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/assets/*filepath&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">filename</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">PathUnescape</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;filepath&#34;</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">filename</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimPrefix</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>

		<span class="nx">isHashed</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">hashfs</span><span class="p">.</span><span class="nf">ParseName</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">hash</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">HashName</span><span class="p">(</span><span class="nx">base</span><span class="p">)</span> <span class="o">==</span> <span class="nx">filename</span> <span class="p">{</span>
				<span class="nx">filename</span> <span class="p">=</span> <span class="nx">base</span>
				<span class="nx">isHashed</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

		<span class="c1">// Fetch file info. Disallow directories from being displayed.
</span><span class="c1"></span>		<span class="nx">fi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Stat</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">fi</span><span class="p">.</span><span class="nf">IsDir</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusForbidden</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">contentType</span> <span class="o">:=</span> <span class="s">&#34;text/plain&#34;</span>
		<span class="c1">// Determine content type based on file extension.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ext</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Ext</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">ext</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">contentType</span> <span class="p">=</span> <span class="nx">mime</span><span class="p">.</span><span class="nf">TypeByExtension</span><span class="p">(</span><span class="nx">ext</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Cache the file aggressively if the file contains a hash.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">isHashed</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Cache-Control&#34;</span><span class="p">,</span> <span class="s">`public, max-age=31536000`</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Set content length.
</span><span class="c1"></span>		<span class="nx">ctx</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Length&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">fi</span><span class="p">.</span><span class="nf">Size</span><span class="p">(),</span> <span class="mi">10</span><span class="p">))</span>

		<span class="c1">// Flush header and write content.
</span><span class="c1"></span>		<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;HEAD&#34;</span> <span class="p">{</span>
			<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">ctx</span><span class="p">.</span><span class="nf">Data</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">contentType</span><span class="p">,</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
	<span class="p">})</span>

	<span class="nx">r</span><span class="p">.</span><span class="nf">LoadHTMLGlob</span><span class="p">(</span><span class="s">&#34;template/*&#34;</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">ctx</span><span class="p">.</span><span class="nf">HTML</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;index.html&#34;</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
			<span class="s">&#34;mainjs&#34;</span><span class="p">:</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">HashName</span><span class="p">(</span><span class="s">&#34;static/main.js&#34;</span><span class="p">),</span>
		<span class="p">})</span>
	<span class="p">})</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>服务静态文件的内容和 Echo 框架基本一样，除了各自框架特有的。</p>
<blockquote>
<p>因为 Gin 框架提供了 LoadHTMLGlob，首页路由的处理函数代码很简单。</p>
</blockquote>
<p>运行 go run ./cmd/gin/main.go，不出意外和 net/http 版本一样的效果。</p>
<h2 id="06-总结">06 总结</h2>
<p>举一反三，在学习过程中可以让你更好的掌握某个知识点。</p>
<p>之前有读者问到 module 如何使用 vendor（没网情况下使用）。今天试验这个就是用了 vendor。其实它的使用很简单，在项目下执行：go mod vendor 即可。不过需要注意的是，加入了新的依赖，就应该执行一次 go mod vendor。</p>
<p>今天介绍的这个库在这个时代用到的可能性不高，不过也有可能会用得到。更重要的是希望这篇文章可以作为一个小项目实践下。希望你能从头自己编码实现。</p>
<p>另外还留了一个问题给你：index.html 文件没有内嵌，请你自己完成。（提示：html/template 增加了对 io/fs.Fs 的支持）</p>
<p>本项目完整代码：<a href="https://github.com/polaris1119/embed" target="_blank" rel="noopener">https://github.com/polaris1119/embed</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>从一份 2020 年大厂加班榜说起</title>
			<link>https://polarisxu.studygolang.com/posts/talk/2020-996-rank/</link>
			<pubDate>Tue, 05 Jan 2021 18:25:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/2020-996-rank/</guid>
			<description>大家好，我是站长 polarisxu。 这几天圈内讨论最多的事非 pdd 事件莫属，于是再一次引出 996 问题的讨论，这似乎是国内码农永远的痛？！ 新华网都发声了：（https://finance.sina.cn/tech/2021-01-05/detail-iiznezxt0681211.d.html） 互联网内卷真是不要太严重。 今天不再讨论 pdd 的事情。谈一下互联网加班的问题，因</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这几天圈内讨论最多的事非 pdd 事件莫属，于是再一次引出 996 问题的讨论，这似乎是国内码农永远的痛？！</p>
<p>新华网都发声了：（https://finance.sina.cn/tech/2021-01-05/detail-iiznezxt0681211.d.html）</p>
<p><p class="md__image">
  <img src="../imgs/996-xinhuanet.png"
    alt=""  />
</p>
</p>
<p>互联网内卷真是不要太严重。</p>
<p>今天不再讨论 pdd 的事情。谈一下互联网加班的问题，因为在群里里看到这样一张图片：</p>
<p><p class="md__image">
  <img src="../imgs/2020-996-rank.png"
    alt=""  />
</p>
</p>
<p>这是一份 2020 年大厂加班榜，据说数据是广大网友提交的。</p>
<p>我读者中应该有不少在以上大厂的，这个数据还算真实吗？！</p>
<p>我想借这份榜单谈谈我职场这么多年的一些体会。先说我几个经历的事情。</p>
<h2 id="01">01</h2>
<p>我研究生毕业后去的开心网，经历过开心“最恐怖”的加班时刻。当时因为人人网上市，开心压力很大，员工都理解。但公司做了一个决定：做上市前的冲刺，开全员会议，宣布一周 7 天工作制。。。宣布完，就有一些人提离职！</p>
<p>我那时候应该刚毕业，心里想着就是好好工作，提升自己。我印象中加班最狠的一次：凌晨 2 点上线。因为是一个全新的、大项目上线，上线必然会有问题需要处理。我记得处理到 4、5 点。然后回去睡了一会（因为住公司附近，走路上下班）。8 点多起床接着上班，因为白天用户更多，需要对可能的问题及时处理。也许真的是因为年轻，那两天，整个人飘飘的感觉，很兴奋，一点睡意都没有，但吃饭也很少，感觉不到饿。现在想想，其实挺可怕的。。。</p>
<p>当然，最后开心网上市计划泡汤了。当初宣布 7 天工作制就是一个错误的决定，基本上没执行下去不说，弄得大家很不舒服。</p>
<h2 id="02">02</h2>
<p>创业这么多年，期间自己角色也在变。从 360 离开，加入一个创业公司，是想体验下创业的感觉。那时候，公司每个人都是创业的心态，每天 9 点到公司，晚上基本没有 10 点之前下班过，一周 6 天，远远超过 996 了。而且周日在家，我基本也是随时处理问题。那时，我并没有觉得累。（说明下：北京上下班单程平均时间近 1 个小时，我差不多在这个水平。也就是说，每天基本 7 点 50 左右出门，晚上到家一般 23 点之后）</p>
<p>我经常想，是什么让我可以那么多精力投入在工作上而不会觉得累？！我现在觉得是对创业的新鲜感，对做成后可能的回报的憧憬，而且那时人员少，大家很简单，工作时间虽然长，但心情比较愉快，不会有领导 PUA。</p>
<h2 id="03">03</h2>
<p>后来，我成为了负责人，心态有一些不一样了。</p>
<p>因为我属于很守时类型的人，讨厌迟到，无论是读书时代还是工作，很少迟到。</p>
<p>当我是普通员工时，我做好自己，不太会关心别人是什么情况，迟不迟到跟我没关系。但当我是负责人时，看到下属迟到，一两次还好，经常迟到的，心里会很不舒服。我知道有些人虽然迟到了，但晚上下班也会比较晚。因此我总是安慰自己，要看到大家的好。</p>
<p>但我不是公司老板，公司老板如果看到我的团队总是迟到等，他会怎么想？要知道，很多老板更多看到的是问题。他会发现总有人迟到，而不是发现总有人加班。我一直希望给技术团队一个相对自由的时间、环境。所以，很多事情老板并不管。但有一个前提是大家做的不错。</p>
<p>实话说，关于工作时长，我是要求过团队的。为了避免老板干预我的团队，我自然需要作出一些要求。不过现在看，时间的要求跟榜单上比还是少了很多。难道这就是我们创业不成功的原因？哈哈哈~</p>
<hr>
<p>每个人都会焦虑！现在这个时代更是如此，更何况各种内卷严重。。。</p>
<ul>
<li>开心网当时那个状态、压力，老板肯定特别焦虑，压力很大。但通过全员 7 天工作制就能解决压力吗？老板的焦虑就没了吗？如果最后上市成功了，老板你什么回报，普通员工什么回报？而且不少员工应该是没有期权，还有不少有期权跟没有也没太多区别。这样的情况下，凭什么老板的焦虑要用员工的时间来分担。</li>
<li>自发的行为和强制是有本质区别的。如何让员工更自发的去奋斗？这也许是 HR 要长期思考的问题吧。</li>
<li>作为管理者或老板，看到员工的问题也许是无法避免的。但应该有同理心。为什么大家都说外企很轻松？难道轻松的外企就不优秀吗？前段时间看了微软第三任 CEO 萨提亚-纳德拉的《刷新：重新发现商业与未来》，对萨提亚反复强调的“同理心是微软企业文化的重要内容”印象深刻，微软在他的带领下取得了辉煌的成绩。</li>
</ul>
<p>借用新华网的话，奋斗不能只靠激情。年轻人要奋斗，要快乐的奋斗，健康的奋斗！</p>
]]></content>
		</item>
		
		<item>
			<title>2021 年了，你可能没注意到的微信公众号的一些变化</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/2021-01-wechat-changes/</link>
			<pubDate>Mon, 04 Jan 2021 18:25:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/2021-01-wechat-changes/</guid>
			<description>大家好，我是站长 polarisxu。 2021 年计划聊一些微信公众号的事情。今天先聊聊微信公众号（订阅号）的一些变化，作为这个系列的开篇。 01 基础知识 先简单普及一些基础知识：订阅号和服务号，主要介绍下它们关键的一些不同点，着重介绍下订阅号的一些知识。 订阅号 如果你开通自己的公众号，一定是选择订阅号。个人主体只能注册订阅号，目前一个身份证只能注册一个订阅号（以前是 5 个）。</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>2021 年计划聊一些微信公众号的事情。今天先聊聊微信公众号（订阅号）的一些变化，作为这个系列的开篇。</p>
<h2 id="01-基础知识">01 基础知识</h2>
<p>先简单普及一些基础知识：订阅号和服务号，主要介绍下它们关键的一些不同点，着重介绍下订阅号的一些知识。</p>
<h3 id="订阅号">订阅号</h3>
<p>如果你开通自己的公众号，一定是选择订阅号。个人主体只能注册订阅号，目前一个身份证只能注册一个订阅号（以前是 5 个）。</p>
<p><strong>关于认证</strong></p>
<p>个人订阅号无法进行微信认证。前段时间微信灰度了个人认证，也就是下面这样：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes01.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes02.png"
    alt=""  />
</p>
</p>
<p>不过目前这个认证没有任何额外的功能，只是一个标识。</p>
<p>而企业（包括个体户）订阅号是支持微信认证的（一次 300 元，一年要认证一次）。认证了的企业订阅号，支持更多的接口功能，进行一些额外开发对接。同时，服务号只能企业注册，认证费用 300/次，一年一次。服务号可以开通微信支付。当然，服务号还有更多其他的能力。</p>
<blockquote>
<p>因为新注册公众号没有留言功能，如果你想购买，个人订阅号是不行的，必须是注册的企业订阅号，因为被迁移主体必须是认证的企业订阅号。具体这方面有疑问可以和我沟通，我这个号就是迁移得来的。</p>
</blockquote>
<p><strong>关于群发消息</strong></p>
<p>订阅号每天可以发送一次，每次条数不限制。服务号一个月可以发送 4 次，每次条数也不限制，为什么服务号一个月才能发送 4 次？下面你就会知道。</p>
<hr>
<p>在微信聊天列表，有一个订阅号消息，所有的订阅号（个人和非个人）都会在这里面；而服务号是在外面的，和普通好友聊天同级。比如「西贝莜面村」就是服务号。</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes03.png"
    alt=""  />
</p>
</p>
<p>正因为直接在消息列表中，因此微信限制了服务号一个月只能群发 4 次消息，避免恶意打扰用户。毕竟服务号的定位是提供功能服务，不是群发消息，比如提供下单服务。</p>
<h2 id="02-列表页的变化">02 列表页的变化</h2>
<p>细心的读者会发现，订阅号消息列表页最近有一些变化。</p>
<blockquote>
<p>有些人可能没留意，一个公众号的一次群发消息（不管多少篇文章）在订阅号消息列表中最多只会显示头条和次条，之后的都是折叠的。</p>
</blockquote>
<h3 id="头条样式">头条样式</h3>
<p>普通用户可能不会注意。以前订阅号消息列表页，各个公众号的消息头条显示样式有两种：</p>
<ul>
<li>样式一：常读公众号的样式</li>
</ul>
<p><p class="md__image">
  <img src="../imgs/2101-changes04.png"
    alt="样式一"  />
</p>
</p>
<ul>
<li>样式二：非常读公众号的样式。即不管头条还是非头条，标题和封面都是一样的显示方式。</li>
</ul>
<p><p class="md__image">
  <img src="../imgs/2101-changes05.png"
    alt=""  />
</p>
</p>
<p>但现在所有的消息都是样式一。不过单篇文章分享出去，封面永远是那个正方形样式。</p>
<p>这样对所有的号公平展示。</p>
<h3 id="单条消息样式">单条消息样式</h3>
<p>有些公众号一次只发送一条消息。之前的样式是这样的：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes06.png"
    alt=""  />
</p>
</p>
<p>封面、标题和摘要，在标题上方显示多少朋友读过。</p>
<p>现在是这样的：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes07.png"
    alt=""  />
</p>
</p>
<p>没有了摘要，多少朋友读过放在了摘要那。不过文章分享出去以及进入某个公众号里面看到的，摘要还是有的。</p>
<p>另外，据说有些人被灰度到了这样的样式：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes08.png"
    alt=""  />
</p>
</p>
<p>会直接显示阅读数、赞数，也许不显示摘要就是为这个做准备的吧。</p>
<blockquote>
<p>直接显示阅读数和赞数，靠标题党吸引阅读的，可能效果会比较差了。比如阅读数高，赞少，多半是标题党，用户可能就不点了？！</p>
</blockquote>
<h2 id="03-公众号主页的变化">03 公众号主页的变化</h2>
<p>没有截以前的图，直接看现在的样子：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes09.png"
    alt=""  />
</p>
</p>
<ul>
<li>
<p>增加了视频 Tab。内容是公众号的视频消息（单独群发的视频）。有点鼓励发视频了。比如视频号的视频也发到公众号。（因为我的号没发过视频，所以没有这个 Tab）</p>
</li>
<li>
<p>新增了服务 Tab。将原来的自定义菜单整合到此处，不过 callback 的菜单项不会显示。</p>
</li>
<li>
<p>取消关注位置变了。</p>
</li>
</ul>
<p>另外还有一个，即可将话题标签配置在公众号主页显示，如下图：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes10.png"
    alt=""  />
</p>
</p>
<p>最多可以配置 10 个。具体配置方法：登录 mp.weixin.qq.com，点击左侧 话题标签 菜单进行配置：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes11.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>微信在话题这个事情上越来越“微博化了”：公众号话题功能、朋友圈和微信群对 <code>#</code> 的支持，以及通过话题进行相关查询、推荐等。</p>
</blockquote>
<h2 id="04-文章详情的变化">04 文章详情的变化</h2>
<p>平时点赞的朋友应该发现，在公众号文章详情末尾，默认是这样的：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes12.png"
    alt=""  />
</p>
</p>
<p>只要你点了“赞”或“在看”，就变成了这样：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes13.png"
    alt=""  />
</p>
</p>
<p>但我真的想说：这个喜欢的推荐我基本都不喜欢，好吗？！推荐给你的，你喜欢吗？</p>
<h2 id="05-总结">05 总结</h2>
<p>以上就是近期我发现的一些微信公众号的变化。有些已经存在不短时间了，有些刚上线，很多人还没用上，而有些可能还在灰度测试中。希望本文对你有帮助，特别是还没设置主页标签的，可以设置一波了。</p>
]]></content>
		</item>
		
		<item>
			<title>2020 年终总结：希望对你有所帮助</title>
			<link>https://polarisxu.studygolang.com/posts/talk/2020-summary/</link>
			<pubDate>Thu, 31 Dec 2020 16:40:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/2020-summary/</guid>
			<description>大家好，我是站长 polarisxu。 第一次正式写年终总结，也许是一个好的开始，希望以后年年写。 可能每个年终总结都会感慨，2020 年是不平凡的一年，疫情持续了一年，原以为好些了，最近似乎有变严重了。大家多保重。口罩戴了一年，不知道什么时候才能去掉，希望这天早点到来。 年终总结，是对我自己的一个回顾，但发出来，我希望能够对大家有点帮助或启发。 这份总结主要会聊五个方</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>第一次正式写年终总结，也许是一个好的开始，希望以后年年写。</p>
<p>可能每个年终总结都会感慨，2020 年是不平凡的一年，疫情持续了一年，原以为好些了，最近似乎有变严重了。大家多保重。口罩戴了一年，不知道什么时候才能去掉，希望这天早点到来。</p>
<p>年终总结，是对我自己的一个回顾，但发出来，我希望能够对大家有点帮助或启发。</p>
<p>这份总结主要会聊五个方面的内容：</p>
<ul>
<li>写作</li>
<li>读书</li>
<li>创业</li>
<li>家庭</li>
<li>收获</li>
</ul>
<h2 id="01-写作">01 写作</h2>
<p>先聊聊写书。</p>
<h3 id="写书">写书</h3>
<p>2020 年最大的成绩就是出版了一本书。因为疫情，这个春节比往年都长，而且在家办公了一段时间，省去了路上的时间。当然最关键的还是，那段时间只有我和爱人在北京，使得我可以安心地写书。</p>
<p>目前这本书在豆瓣上的评分是 8.4 分，感谢大家的支持：<a href="https://book.douban.com/subject/35130972/" target="_blank" rel="noopener">https://book.douban.com/subject/35130972/</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/2020-mywritebook.png"
    alt=""  />
</p>
</p>
<p>关于写书，有些人可能想问点什么。比如：</p>
<ul>
<li>赚了不少钱吧？</li>
<li>写书一种什么体验？</li>
<li>写书性价比高吗？</li>
<li>。。。</li>
</ul>
<p>首先，对大部分人来说（畅销书作者除外），写书赚的钱是很少的。其实大家可以算一笔账：</p>
<blockquote>
<p>假如一本书定价 100 元，一般版税 7%~8%，卖一本你得到 7 块钱，1 万本也才 7 万块钱，而实际上卖 1 万本真的挺难的。</p>
</blockquote>
<p>既然赚不了多少钱，为什么还有那么多人出书呢？</p>
<p>我的理解，因为出书相当于给自己做了背书。之前还听说，某大厂职级晋升，如果出了书会有加分。一般来说，一件事情的回报不会是单一的，我们不能只盯着眼前的，不能只盯着金钱的回报。张一鸣总是强调延迟满足感，字节跳动的小伙伴因此也总提这个，我觉得大家要学会把眼光看远。</p>
<p>所以，如果你有机会出书，别犹豫，干就对了。如果你觉得自己有这个能力出书，想出书，但不清楚相关的事情，欢迎和我交流。</p>
<h3 id="写文章">写文章</h3>
<p>大家应该见到过不少类似这样的文章：技术人应不应该写博客？</p>
<p>写博客文章和写书还是不一样的，写文章会更灵活，写书限制、要求都会更多。我个人觉得，如果你想将来出一本书，但觉得水平不够，可以先试试写一些博文，提升提升写作水平。当你写的多了，很可能出版社会主动找你哦。</p>
<p>回顾 2020 年，我陆陆续续写了 60+ 篇文章。2020 年之前写的文章还是比较少，在 2020 年中旬，我决定开一个自己的公众号，并花钱买了留言功能，也就是现在的 「polarisxu」。之前写的文章如果要在「Go语言中文网」公众号发布，只能限于 Go 相关，但有了个人的公众号，主题可以很随意。在职场打拼这么多年，加上这几个月看了一些非技术类的文章、图书，我觉得写下来的，不应该只有技术。所以接下来，除了分享技术，我还会分享非技术的内容。</p>
<p>另外，如果你计划写作，我个人建议可以开通自己的公众号，搞一个自己的博客。为什么搞两个？</p>
<ul>
<li>公众号读者粘性好，关注你了，你可以更好地触达他。目前我觉得公众号的粉丝是所有平台里价值最高的。</li>
<li>但公众号有一个问题，就是时效性，历史的文章很少有人看了。而博客可以借助搜索引擎，不断有流量，同时历史文章也更利于读者阅读。</li>
</ul>
<p>对公众号运营感兴趣的可以一起交流。</p>
<h2 id="02-读书">02 读书</h2>
<blockquote>
<p>没有什么问题是一本书解决不了的，如果有那就再来一本。。。</p>
</blockquote>
<p>大家都是读书人。学生时代，教科书读了不少，工作后，你读了多少书呢？书买了相当于看了：很多人热衷于买书，其实是好事，但只是热衷于买，多少就有点浪费了。</p>
<p>我自己买书比较少，一方面喜欢随时阅读，纸质图书不方便；另一方面，买了经常不读，内心有罪恶感。</p>
<p>2020 年中下旬，我开始使用微信读书。这里我个人强烈推荐「微信读书」：</p>
<ul>
<li>数字化时代，应该充分利用数字化。下个十年，预计能被数字化的都会被数字化。</li>
<li>通过微信读书，可以把你的阅读进行数字化，让你很容易进行数据统计：读完了哪几本书？每本书阅读了多长时间？每周阅读多长时间？做了多少笔记等等。微信读书还为你生成了年度读书报告。</li>
<li>根据你的兴趣，为你推荐你喜欢的书，相当于帮你找书。</li>
<li>可以方便的看到大家对这本书的评价，书中还会有别人的笔记。</li>
<li>书中引用的其他图书，可以直接点击，看看是否自己喜欢，加入书架等。</li>
<li>还可以听书，非技术类的，听书的效果还不错。</li>
<li>。。。</li>
</ul>
<p>半年来，我在微信读书读了 12 本图书，有些书是略读，有些书是精读：做了读书笔记。有一些还没有读完，正在阅读中。</p>
<p><p class="md__image">
  <img src="../imgs/2020-myreadbooks.png"
    alt=""  />
</p>
</p>
<p>这里推荐大家读一下樊登的《读懂一本书》，里面提到的一些方法有一定借鉴作用。</p>
<blockquote>
<p>注意：技术类的图书，特别是代码比较多的，微信读书的阅读体验可能会差些。</p>
</blockquote>
<p>2021 年也许会考虑写写读书心得。</p>
<p>对了，用微信读书，不代表说让你别买书了，有些书该买还得买。而且我一直认为，有些书买了不一定是用来读的：家里书架上满满的图书，是不是有种书香门第的感觉？我相信这对培养孩子读书的兴趣也是有帮助的。</p>
<h2 id="03-创业">03 创业</h2>
<p>关于创业，前段时间写过一篇短文。虽然创业了很多年，但因为一直没有做出什么成绩，所以这块不想说太多。</p>
<p>在上面读过的书中，有一本创业记，作者将自己创业的过程完完整整记录了下来，没有过创业经历的人可能对其中的内容不会有太多体会。创业的苦、创业的难，个中滋味只有自己最清楚。</p>
<p>2020 年，因为疫情，虽然产生很多新机会，比如在线教育大火。但受影响的企业真的很多。很多人可能没有什么体会，因为你没有丢工作。前段时间，公司准备换办公室，去望京 SOHO 那块看了一些办公室，空的办公室不少。据中介介绍，疫情影响真的挺大，空出了很多办公室，房租价格也是比之前低不少。可见，很多小公司在疫情期间活不下去，关门了。</p>
<p>回顾 2020 年，创业对我来说，相比之前还是有更多的收获，虽然业务没起来，但比之前经历了更多，从技术、产品、运营等纯线上的管理到仓配、采购等线下的业务流程和管理，接触了很多之前不熟悉的领域，无形中学到了不少新知识。</p>
<p>不知道关注我的人中有多少是在校生。我个人特别不建议毕业后就去一个创业公司。当然自己创业或跟着认识的人觉得特别靠谱的除外，毕竟选择大于努力。如果你对一个创业公司不了解（除非是你的熟人，否则很难了解），风险挺大的。虽然似乎拿到的钱不少（实际上不多，因为加上福利，基本和大公司是有差距的），但随时都有可能丢工作，特别是今年，大环境不好，被动换工作，结果真的挺惨。如果你没得选，只能进一个小公司，建议你找一个注重员工个人成长的公司，因为环境挺重要的。当然个人积极主动学习更重要。</p>
<h2 id="04-家庭">04 家庭</h2>
<p>因为创业，欠家庭还是挺多的。</p>
<p>关于家庭方面，2020 年有两件大事。</p>
<ul>
<li>
<p>住进了自己的小家，再也不用每年为房租涨价心烦，更不用为搬家发愁。</p>
</li>
<li>
<p>大女儿上小学了。</p>
</li>
</ul>
<p>但家家有一本难念的经。有一天晚上，媳妇对我说：大女儿说想自己一个人睡，希望有一个自己的房间，因为她同学有。</p>
<p>随着孩子一天天长大，这个愿望会越来越强烈，而且也应该给她一个独立的空间。作为父亲需要承担这个责任，为孩子早日实现愿望。。。然而在北京真的好难！</p>
<p>如果愿望一时半会实现不了，希望自己在周末能够多花些时间陪陪她们。</p>
<p>如果你跟我一样，全靠自己奋斗，类似的问题、苦恼大概迟早也会到来吧。所以，趁年轻、趁单身，提升自己，多赚点钱，让将来过的更好些。</p>
<h2 id="05-收获">05 收获</h2>
<p>关于收获，主要聊两方面。</p>
<h3 id="公众号">公众号</h3>
<p>上文提到，2020 年中（6 月 17 日）启用个人微信公众号，开始记录、分享我个人的学习、生活、工作和感想。因为这个号是基于之前「火丁笔记」的，自带了近 3.5k 粉丝。经过这半年的努力，涨了近 1.5 万粉丝。感谢大家的支持。</p>
<p>除了粉丝，运营公众号另外的收获就是能获得一定的收入回报。关于公众号运营的一些事情，2021 年计划写一些相关文章聊聊。</p>
<p>另外，上次发文说过，知乎有人给打理，收获了近 9 万粉丝。感谢有你！</p>
<h3 id="社区">社区</h3>
<p>这一年，Go 语言中文网网站的开发工作很少，但 GCTT 一直在产出，无闻大佬一直在帮校对，感谢大家。</p>
<p>回顾这一年，社区主要做了如下事情：</p>
<ul>
<li>Go官网的镜像 <a href="https://docs.studygolang.com" target="_blank" rel="noopener">https://docs.studygolang.com</a>
 启用新版，同时提供 playground、blog 等访问；</li>
<li>组织了一次重庆 gopher 聚餐；一次北京 gopher dinner；</li>
<li>为大家定制了 gopher 卫衣；</li>
<li>组织 Go 语言官网的翻译；</li>
<li>Go 语言中文网公众号每天为大家推送 Go 相关文章；</li>
<li>每周一期的《Go 语言爱好者周刊》；</li>
<li>开发上线了一版 Go 语言中文网小程序；</li>
<li>。。。</li>
</ul>
<p>当然最重要的是认识了更多的朋友：一些新认识的，一些之前没见过面见上了，一些有了更多的交流。。。</p>
<p>2021 年，希望 Go 语言中文网网站能给大家带来一些惊喜。</p>
<hr>
<p>一年了，你可能觉得自己没做什么，但只要你静下心来回顾，会发现做了不少事情，而且肯定有值得记录的。也许等你老了，回过头来看看自己的过往记录，回忆起过去的你，也算是一种幸福吧！</p>
<p>冯大说，每个人都应该阶段性对自己做一次梳理、总结，工作也好、生活也罢。其实，我的这份总结是不够的，因为缺少复盘和反思。但毕竟是公开的，自己反思的内容就先不放上了。建议你元旦可以为自己的生活、学习或工作写一份总结，至少工作上应该写一份，然后看情况发给你的 Leader，也许年终奖或来年加薪有惊喜也未可知！</p>
]]></content>
		</item>
		
		<item>
			<title>Go 1.16 的这个新变化需要适应下：go get 和 go install 的变化</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go-get-install/</link>
			<pubDate>Sun, 27 Dec 2020 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go-get-install/</guid>
			<description>大家好，我是站长 polarisxu。 一直以来，我们通常都是通过 go get 来下载并安装包的。但从 Go 1.16 起，不推荐通过 go get 来安装包（主要是说安装可执行文件），也就是说，go get 应该只是用来下载包，而且将来版本可能会给该命令始终加上 -d 标志。 你可能会问，这对我使用有什么影响呢？ 让我们看一个实际的例子。 01 安装 Delve 的例子 我们在本地通过源码安装 Go 的调试器 Delve，可以这么做： $ go get</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>一直以来，我们通常都是通过 <code>go get</code> 来下载并安装包的。但从 Go 1.16 起，不推荐通过 go get 来安装包（主要是说安装可执行文件），也就是说，go get 应该只是用来下载包，而且将来版本可能会给该命令始终加上 <code>-d</code> 标志。 你可能会问，这对我使用有什么影响呢？</p>
<p>让我们看一个实际的例子。</p>
<h2 id="01-安装-delve-的例子">01 安装 Delve 的例子</h2>
<p>我们在本地通过源码安装 Go 的调试器 Delve，可以这么做：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get github.com/go-delve/delve/cmd/dlv
</code></pre></div><p>因为 go get 会下载、编译并安装包（如果有 main 包）。</p>
<p>Go 1.16 建议这么使用 go get：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get -d github.com/go-delve/delve/cmd/dlv
</code></pre></div><p>这只会下载 delve，并不会构建和安装，而且将来 go get 只会用来下载。因此，你还需要手动执行安装。</p>
<h2 id="02-go-install-的变化">02 go install 的变化</h2>
<h3 id="gopath-年代">GOPATH 年代</h3>
<p>早在 GOPATH 年代，go install 的作用如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Install compiles and installs the packages named by the import paths.

The -i flag installs the dependencies of the named packages as well.
</code></pre></div><p>也就是说，go install 会将包编译成 <code>.a</code> 文件并安装到 <code>$GOPATH/pkg/$GOOS_$GOARCH</code> 下；如果是 main 包，会编译并生成可执行文件安装到 <code>$GOPATH/bin</code> 目录下（如果设置了 <code>$GOBIN</code>，则会安装到 <code>$GOBIN</code> 下 ）。这也是和 go build 不同之处。</p>
<h3 id="go-module-年代">Go Module 年代</h3>
<p>到了 Go Module 年代，情况发生了变化。大家似乎完全忘记了 go install 的存在（也有可能在 GOPATH 年代，大家就从来不用 go install），因为 go get、go build 就解决问题了。</p>
<p>特别是，从 Go Module 开始，工作目录没有了 src/pkg/bin 这三个目录，使得 go build 比 go install 更受欢迎。（GOPATH 年代，我更喜欢 go install，因为它会在项目生成和 GOROOT 一样的 src/pkg/bin，保持一致）。</p>
<p>看看 Module 年代，go install 命令的作用：（基于 Go1.15.x）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Install compiles and installs the packages named by the import paths.

Executables are installed in the directory named by the GOBIN environment
variable, which defaults to <span class="nv">$GOPATH</span>/bin or <span class="nv">$HOME</span>/go/bin <span class="k">if</span> the GOPATH
environment variable is not set. Executables in <span class="nv">$GOROOT</span>
are installed in <span class="nv">$GOROOT</span>/bin or <span class="nv">$GOTOOLDIR</span> instead of <span class="nv">$GOBIN</span>.

When module-aware mode is disabled, other packages are installed in the
directory <span class="nv">$GOPATH</span>/pkg/<span class="nv">$GOOS_$GOARCH</span>. When module-aware mode is enabled,
other packages are built and cached but not installed.

The -i flag installs the dependencies of the named packages as well.
</code></pre></div><p>Module 没启用时，和 GOPATH 年代的作用是一样的。当启用 Module 模式时，go install 对普通包（非 main 包）不再安装（即没有了 <code>pkg/$GOOS_$GOARCH</code>），这和 go build 一样了。而对于 main 包，会将生成的可执行文件安装到 <code>$GOBIN</code> 目录下（<code>$GOBIN</code> 的默认值是 <code>$GOPATH/bin</code>，如果 <code>$GOPATH</code> 没有设置，则是 <code>$HOME/go/bin</code>）。</p>
<p>那么，Module 模式下，什么情况下你可能会使用 go install 呢？</p>
<p>如果你有这样的习惯会使用 go install。</p>
<blockquote>
<p>$GOBIN 在 PATH 环境变量下，这样，GOBIN 下面的可执行文件可以方便的运行。比如你的工作 module 是：github.com/polaris1119/test ，可以通过 <code>go install github.com/polaris1119/test</code> 将 test 安装到 GOBIN 下，然后直接执行 test 运行。</p>
</blockquote>
<h3 id="go-116-及以后">Go 1.16 及以后</h3>
<p>从 Go 1.16 起，go install 可以接受带有版本后缀的参数（例如 go install <a href="mailto:example.com/cmd@v1.0.0">example.com/cmd@v1.0.0</a>
）。这将导致 go install 以模块感知模式构建和安装包，而忽略当前目录或任何父目录（如果有）中的 go.mod 文件。这对于在不影响主模块依赖性的情况下安装可执行文件很有用。</p>
<p>如本文开头提到的，go get 不建议用来构建和安装包了。</p>
<p>所以，Go 1.16 及以后，go get 和 go install 应该什么时候使用呢？</p>
<ul>
<li>如果要安装第三方库的可执行文件，比如上面的 Delve，使用 go install，但需要带上版本后缀，比如 @latest；（不清楚为什么设计成必须带上版本号）</li>
<li>普通的库，继续使用 go get，建议加上 -d 标志；</li>
</ul>
<p>注意，虽然 go install 一个普通的第三方包（不过必须带上版本后缀）也会下载对应的包，但不会修改 go.mod，这和 go get 是不同的。</p>
<h2 id="03-总结">03 总结</h2>
<p>总结一下这个变化：（Go 1.16 还不会有影响，将来就会有影响，所以可以提前习惯下）</p>
<ul>
<li>日常的开发，还和之前一样使用 go get 即可；</li>
<li>但如果是要源码安装一些第三方可执行文件，比如 vscode-go 插件依赖的可执行文件，则应该使用 go install；</li>
<li>如果你本地编译习惯了我文中提到的方式，继续使用 go install 即可，虽然绝大部分人喜欢使用 go build。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>详解 Go 中的环境变量</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/environment-variables-in-golang/</link>
			<pubDate>Sat, 26 Dec 2020 10:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/environment-variables-in-golang/</guid>
			<description>了解环境变量以及在 Golang 应用程序中使用它们的不同方法。 开始之前 本教程假定你具有： 对 Go 语言的基本了解 系统上安装了最新 Golang 版本 几分钟的时间 在本文中，我们将了解环境变量以及为什么要使用它们。并且将使用内置和第三方包在 Go 应用程序中访问它们。 什么是环境变量？ 环境变量是系统级的键-值对，正在运行的进程可以访问它。这些通常用于使同一程序在不同的部署环境（例如 PROD， DEV 或 TES</description>
			<content type="html"><![CDATA[<p>了解环境变量以及在 Golang 应用程序中使用它们的不同方法。</p>
<h2 id="开始之前">开始之前</h2>
<p>本教程假定你具有：</p>
<ul>
<li>对 Go 语言的基本了解</li>
<li>系统上安装了最新 Golang 版本</li>
<li>几分钟的时间</li>
</ul>
<p>在本文中，我们将了解环境变量以及为什么要使用它们。并且将使用内置和第三方包在 Go 应用程序中访问它们。</p>
<h2 id="什么是环境变量">什么是环境变量？</h2>
<p>环境变量是系统级的键-值对，正在运行的进程可以访问它。这些通常用于使同一程序在不同的部署环境（例如 PROD， DEV 或 TEST）中表现不同。在环境中存储配置是 twelve-factor 应用程序的原理之一。它使应用程序具有可移植性。</p>
<h2 id="为什么要使用环境变量">为什么要使用环境变量</h2>
<ul>
<li>如果您在代码中使用敏感信息，那么所有有权访问该代码的未授权用户都将拥有敏感数据，您可能不希望如此。</li>
<li>如果您使用的代码版本控制工具如：<code>git</code>，那么可能将 DB 凭据与代码一起推送，它将公开。</li>
<li>如果要在一处管理变量，则可以进行任何更改，而不必在应用程序代码中的所有位置都进行更改。</li>
<li>您可以管理多个部署环境，例如 PROD，DEV 或 TEST。在部署之间可以轻松更改环境变量，而无需更改任何应用程序代码。</li>
</ul>
<blockquote>
<p>永远不要忘记在 .gitignore 中包含环境变量文件</p>
</blockquote>
<h2 id="内置操作系统包">内置操作系统包</h2>
<p>您不需要任何外部程序包即可访问 Golang 中的环境变量，并且可以使用标准库 <code>os</code> 包来实现。以下是与环境变量有关的函数及其用途的列表。</p>
<ul>
<li><code>os.Setenv()</code> 设置环境值的值。</li>
<li><code>os.Getenv()</code> 获取指定键对应的环境变量值。</li>
<li><code>os.Unsetenv()</code> 删除指定键命名对应的单个环境值，如果我们再尝试使用 <code>os.Getenv()</code> 来获取该环境值，将返回一个空值。</li>
<li><code>os.ExpandEnv</code> 根据环境变量的值替换字符串中的 <code>${var}</code> 或 <code>$var</code>。如果不存在任何环境变量，则将使用空字符串替换它。</li>
<li><code>os.LookupEnv()</code> 获取指定键对应的环境变量值。如果系统中不存在该变量，则返回值将为空，并且布尔值将为 false。否则，它将返回值（可以为空），并且布尔值为 true。</li>
</ul>
<blockquote>
<p>如果不存在环境变量，则 os.Getenv() 将返回一个空字符串，使用 LookupEnv 来区分空值和未设置值。</p>
</blockquote>
<p>现在，让我们在代码中使用上述所有函数。在一个空文件夹中创建一个 main.go 文件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Set Environment Variables
</span><span class="c1"></span>  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;SITE_TITLE&#34;</span><span class="p">,</span> <span class="s">&#34;Test Site&#34;</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;DB_HOST&#34;</span><span class="p">,</span> <span class="s">&#34;localhost&#34;</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;DB_PORT&#34;</span><span class="p">,</span> <span class="s">&#34;27017&#34;</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;DB_USERNAME&#34;</span><span class="p">,</span> <span class="s">&#34;admin&#34;</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;DB_PASSWORD&#34;</span><span class="p">,</span> <span class="s">&#34;password&#34;</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;DB_NAME&#34;</span><span class="p">,</span> <span class="s">&#34;testdb&#34;</span><span class="p">)</span>

  <span class="c1">// Get the value of an Environment Variable
</span><span class="c1"></span>  <span class="nx">host</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;SITE_TITLE&#34;</span><span class="p">)</span>
  <span class="nx">port</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;DB_HOST&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Site Title: %s, Host: %s\n&#34;</span><span class="p">,</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>

  <span class="c1">// Unset an Environment Variable
</span><span class="c1"></span>  <span class="nx">os</span><span class="p">.</span><span class="nf">Unsetenv</span><span class="p">(</span><span class="s">&#34;SITE_TITLE&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After unset, Site Title: %s\n&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;SITE_TITLE&#34;</span><span class="p">))</span>

  <span class="c1">//Checking that an environment variable is present or not.
</span><span class="c1"></span>  <span class="nx">redisHost</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">LookupEnv</span><span class="p">(</span><span class="s">&#34;REDIS_HOST&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;REDIS_HOST is not present&#34;</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Redis Host: %s\n&#34;</span><span class="p">,</span> <span class="nx">redisHost</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Expand a string containing environment variables in the form of $var or ${var}
</span><span class="c1"></span>  <span class="nx">dbURL</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">ExpandEnv</span><span class="p">(</span><span class="s">&#34;mongodb://${DB_USERNAME}:${DB_PASSWORD}@$DB_HOST:$DB_PORT/$DB_NAME&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;DB URL: &#34;</span><span class="p">,</span> <span class="nx">dbURL</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>下面是我们在终端中执行  <code>go run main.go</code>  的输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">go run main.go

// output
Site Title: Test Site, Host: localhost
After unset, Site Title: <span class="m">27017</span>
REDIS_HOST is not present
DB URL:  mongodb://admin:password@localhost:27017/testdb
</code></pre></div><p>还有两个函数 <code>os.Clearenv</code> 和 <code>os.Environ()</code>，让我们在单独的程序中使用它们。</p>
<ul>
<li><code>os.Clearenv</code>  删除所有环境变量，清理测试环境可能很有用</li>
<li><code>os.Environ()</code> 以 key = value 的形式返回包含所有环境变量的字符串的一部分。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Environ returns a slice of string containing all the environment variables in the form of key=value.
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">env</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Environ</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// env is
</span><span class="c1"></span>    <span class="nx">envPair</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">SplitN</span><span class="p">(</span><span class="nx">env</span><span class="p">,</span> <span class="s">&#34;=&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nx">key</span> <span class="o">:=</span> <span class="nx">envPair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nx">value</span> <span class="o">:=</span> <span class="nx">envPair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s : %s\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Delete all environment variables
</span><span class="c1"></span>  <span class="nx">os</span><span class="p">.</span><span class="nf">Clearenv</span><span class="p">()</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Number of environment variables: &#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nf">Environ</span><span class="p">()))</span>
<span class="p">}</span>
</code></pre></div><p>上面的函数将列出系统中所有可用的环境变量，包括 <code>NAME</code> 和 <code>DB_HOST</code>。一旦运行<code>os.Clearenv()</code>，它将清除正在运行的进程的所有环境变量。</p>
<h2 id="godotenv-包">GoDotEnv 包</h2>
<p>Ruby dotenv 项目启发了 <a href="https://github.com/joho/godotenv" target="_blank" rel="noopener">GoDotEnv</a>
 包，它从 <code>.env</code> 文件加载环境变量。</p>
<p>让我们创建一个 <code>.env</code> 文件，其中包含所有配置。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ini" data-lang="ini"><span class="c1"># .env file</span>
<span class="c1"># This is a sample config file</span>

<span class="na">SITE_TITLE</span><span class="o">=</span><span class="s">Test Site </span>

<span class="na">DB_HOST</span><span class="o">=</span><span class="s">localhost</span>
<span class="na">DB_PORT</span><span class="o">=</span><span class="s">27017</span>
<span class="na">DB_USERNAME</span><span class="o">=</span><span class="s">admin</span>
<span class="na">DB_PASSWORD</span><span class="o">=</span><span class="s">password</span>
<span class="na">DB_NAME</span><span class="o">=</span><span class="s">testdb</span>
</code></pre></div><p>然后在 main.go 文件中，我们将使用 godotenv 加载环境变量。</p>
<blockquote>
<p>我们也可以一次加载多个 env 文件。godotenv 还支持 YAML。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// main.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;os&#34;</span>

  <span class="s">&#34;github.com/joho/godotenv&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// load .env file from given path
</span><span class="c1"></span>  <span class="c1">// we keep it empty it will load .env from current directory
</span><span class="c1"></span>  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">godotenv</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="s">&#34;.env&#34;</span><span class="p">)</span>

  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Error loading .env file&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// getting env variables SITE_TITLE and DB_HOST
</span><span class="c1"></span>  <span class="nx">siteTitle</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;SITE_TITLE&#34;</span><span class="p">)</span>
  <span class="nx">dbHost</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;DB_HOST&#34;</span><span class="p">)</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;godotenv : %s = %s \n&#34;</span><span class="p">,</span> <span class="s">&#34;Site Title&#34;</span><span class="p">,</span> <span class="nx">siteTitle</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;godotenv : %s = %s \n&#34;</span><span class="p">,</span> <span class="s">&#34;DB Host&#34;</span><span class="p">,</span> <span class="nx">dbHost</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>打开终端并运行  <code>main.go</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">go run main.go

// output
godotenv : Site <span class="nv">Title</span> <span class="o">=</span> Test Site
godotenv : DB <span class="nv">Host</span> <span class="o">=</span> localhost
</code></pre></div><h2 id="viper-包">Viper 包</h2>
<blockquote>
<p>Viper 是 Go 应用程序的配置的完整解决方案。它旨在在应用程序中工作，并且可以处理所有类型的配置需求和格式。</p>
</blockquote>
<p><a href="https://github.com/spf13/viper" target="_blank" rel="noopener">Viper</a>
 支持多种文件格式来加载环境变量，例如，从 JSON，TOML，YAML，HCL，envfile 和 Java 属性配置文件（properties）中读取。因此，在此示例中，我们将研究如何从 YAML 文件中加载环境变量。</p>
<blockquote>
<p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件和用于存储或传输数据的应用程序。</p>
</blockquote>
<p>让我们在一个空文件夹中创建 config.yaml 和 main.go。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="c"># config.yaml</span><span class="w">
</span><span class="w"></span><span class="nt">SITE</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">TITLE</span><span class="p">:</span><span class="w"> </span><span class="l">Test Site</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">DB</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">HOST</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;localhost&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">PORT</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;27017&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">USERNAME</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;admin&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">PASWORD</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;password&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">NAME</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;testdb&#34;</span><span class="w">
</span></code></pre></div><p>在下面的代码中，我们使用 Viper 从 config.yaml 中加载环境变量。我们可以从所需的任何路径加载配置文件。如果配置文件中没有任何环境变量，我们还可以为任何环境变量设置默认值。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// main.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;os&#34;</span>

  <span class="s">&#34;github.com/spf13/viper&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Set the file name of the configurations file
</span><span class="c1"></span>  <span class="nx">viper</span><span class="p">.</span><span class="nf">SetConfigName</span><span class="p">(</span><span class="s">&#34;config&#34;</span><span class="p">)</span>

  <span class="c1">// Set the path to look for the configurations file
</span><span class="c1"></span>  <span class="nx">viper</span><span class="p">.</span><span class="nf">AddConfigPath</span><span class="p">(</span><span class="s">&#34;.&#34;</span><span class="p">)</span>

  <span class="c1">// Enable VIPER to read Environment Variables
</span><span class="c1"></span>  <span class="nx">viper</span><span class="p">.</span><span class="nf">AutomaticEnv</span><span class="p">()</span>

  <span class="nx">viper</span><span class="p">.</span><span class="nf">SetConfigType</span><span class="p">(</span><span class="s">&#34;yml&#34;</span><span class="p">)</span>

  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">viper</span><span class="p">.</span><span class="nf">ReadInConfig</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Error reading config file, %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Set undefined variables
</span><span class="c1"></span>  <span class="nx">viper</span><span class="p">.</span><span class="nf">SetDefault</span><span class="p">(</span><span class="s">&#34;DB.HOST&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1&#34;</span><span class="p">)</span>

  <span class="c1">// getting env variables DB.PORT
</span><span class="c1"></span>  <span class="c1">// viper.Get() returns an empty interface{}
</span><span class="c1"></span>  <span class="c1">// so we have to do the type assertion, to get the value
</span><span class="c1"></span>  <span class="nx">DBPort</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">viper</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;DB.PORT&#34;</span><span class="p">).(</span><span class="kt">string</span><span class="p">)</span>

  <span class="c1">// if type assert is not valid it will throw an error
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Invalid type assertion&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;viper : %s = %s \n&#34;</span><span class="p">,</span> <span class="s">&#34;Database Port&#34;</span><span class="p">,</span> <span class="nx">DBPort</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>打开终端并运行 <code>main.go</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">go run main.go

// output
viper : Database <span class="nv">Port</span> <span class="o">=</span> <span class="m">27017</span>
</code></pre></div><h2 id="结论">结论</h2>
<p>使用环境变量是在我们的应用程序中处理配置的绝佳方法。总体而言，它为您提供了轻松的配置，更好的安全性，多个部署环境以及更少的生产错误。</p>
<p>现在您可以在 go 应用程序中管理环境变量，并且可以在我们的 <a href="https://github.com/LoginRadius/engineering-blog-samples/tree/master/GoLang/EnvironmentVariables" target="_blank" rel="noopener">Github Repo</a>
 上找到本教程中使用的完整代码。</p>
<blockquote>
<p>原文链接：<a href="https://www.loginradius.com/engineering/blog/environment-variables-in-golang/" target="_blank" rel="noopener">https://www.loginradius.com/engineering/blog/environment-variables-in-golang/</a>
</p>
<p>作者：Puneet Singh</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>这道题竟然只有 12% 的人答对。。。</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/weekly-question-embed-time/</link>
			<pubDate>Mon, 21 Dec 2020 16:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/weekly-question-embed-time/</guid>
			<description>这题是有点坑，但很多人对结果还是不知所以。</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>在 <a href="https://mp.weixin.qq.com/s/oDMSFjjzGbu7kkERM8ilGw" target="_blank" rel="noopener">《Go 语言爱好者周刊第 74 期》</a>
有一道题，以下代码输出什么？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
		<span class="nx">N</span> <span class="kt">int</span>
	<span class="p">}{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Date</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">UTC</span><span class="p">),</span>
		<span class="mi">5</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">m</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>A：<code>{&quot;Time&quot;: &quot;2020-12-20T00:00:00Z&quot;, &quot;N&quot;: 5}</code>；B：<code>&quot;2020-12-20T00:00:00Z&quot;</code>；C：<code>{&quot;N&quot;: 5}</code>；D：<code>&lt;nil&gt;</code></p>
<p>答题结果如下：</p>
<p><p class="md__image">
  <img src="../imgs/weekly-question-time.png"
    alt=""  />
</p>
</p>
<p>虽然参与投票的人不是很多，但从结果还是能反馈出来一些问题的，不少人知晓了答案是 B，但还是想不明白为什么。所以写篇文章对该题进行解析。大家不用在乎是不是刁钻的题目，通过题目能学到知识才是最重要的。</p>
<h2 id="01">01</h2>
<p>对一个结构体实例进行 json 系列化，直觉很容易选 A。但很显然，不可能这么简单，因此需要仔细看代码。至于选 C 和 D 的人，多半是瞎猜的吧，当然选 B 也不排除有瞎猜的。</p>
<p>为什么选 B 呢？我想借助一个例子讲解。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">name</span>  <span class="kt">string</span>
  <span class="nx">hobby</span> <span class="kt">string</span>
<span class="p">}</span>	

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">person</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;polarisxu&#34;</span><span class="p">,</span> <span class="nx">hobby</span><span class="p">:</span> <span class="s">&#34;Golang&#34;</span><span class="p">}</span>
  <span class="nx">m</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>如果你认为输出 <code>{&quot;name&quot;:&quot;polarisxu&quot;,&quot;hobby&quot;:&quot;Golang&quot;}</code>，那你得去补补 encoding/json 包的知识了。要想输出  <code>{&quot;name&quot;:&quot;polarisxu&quot;,&quot;hobby&quot;:&quot;Golang”}</code>，一般我们会这么做：将 Person 的字段导出，同时设置上 tag。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
  <span class="nx">Hobby</span> <span class="kt">string</span> <span class="s">`json:&#34;hobby&#34;`</span>
<span class="p">}</span>
</code></pre></div><p>但如果我们不想导出 Person 的字段呢？可以通过实现 Marshaler 来做到。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="nf">MarshalJSON</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`{&#34;name&#34;:&#34;`</span><span class="o">+</span><span class="nx">p</span><span class="p">.</span><span class="nx">name</span><span class="o">+</span><span class="s">`&#34;,&#34;hobby&#34;:&#34;`</span><span class="o">+</span><span class="nx">p</span><span class="p">.</span><span class="nx">hobby</span><span class="o">+</span><span class="s">`&#34;}`</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h2 id="02">02</h2>
<p>回到题目上，<a href="https://docs.studygolang.com/pkg/time/#Time" target="_blank" rel="noopener">time.Time</a>
 是什么类型？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Time</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这是一个没有导出任何字段的结构体类型，因此它肯定<a href="https://docs.studygolang.com/src/time/time.go?s=38148:38191#L1230" target="_blank" rel="noopener">实现了 Marshaler 接口</a>
。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// MarshalJSON implements the json.Marshaler interface.
</span><span class="c1">// The time is a quoted string in RFC 3339 format, with sub-second precision added if present.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Time</span><span class="p">)</span> <span class="nf">MarshalJSON</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Year</span><span class="p">();</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&gt;=</span> <span class="mi">10000</span> <span class="p">{</span>
		<span class="c1">// RFC 3339 is clear that years are 4 digits exactly.
</span><span class="c1"></span>		<span class="c1">// See golang.org/issue/4556#c15 for more discussion.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Time.MarshalJSON: year outside of range [0,9999]&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">RFC3339Nano</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="sc">&#39;&#34;&#39;</span><span class="p">)</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">AppendFormat</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">RFC3339Nano</span><span class="p">)</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="sc">&#39;&#34;&#39;</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>这么说，答案不应该就是 A 吗？别急。</p>
<h2 id="03">03</h2>
<p>如果 t 是这么定义的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span> <span class="o">:=</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Time</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
  <span class="nx">N</span> <span class="kt">int</span>
<span class="p">}{</span>
  <span class="nx">time</span><span class="p">.</span><span class="nf">Date</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">UTC</span><span class="p">),</span>
  <span class="mi">5</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>那结果就是 A。而题目中，time.Time 是内嵌的。你学习 Go 时，应该看过通过内嵌来模拟继承的功能吧！</p>
<p>正是因为内嵌，t 的方法集包括了 time.Time 的方法集，所以，t 自动实现了 Marshaler 接口。因此答案是 B。</p>
<p>其实这道题的情况，在日常工作中还真有可能遇到。所以，当你内嵌某个类型时，特别这个类型不是你自己定义的，需要留意这种情况。</p>
<p>一般解决这个问题的方法有两种：1）不内嵌；2）重新实现 MarshalJSON 方法。</p>
<p>然而这道题无法重新实现 MarshalJSON 方法，因为结构体类型是匿名的。只能通过不内嵌来得到正确的结果。</p>
<h2 id="04">04</h2>
<p>最后一起看下 json.Marshal 函数的文档，主要看下面这段：</p>
<blockquote>
<p>Marshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.</p>
</blockquote>
<p>大意是说，如果值实现了 json.Marshaler 接口并且不是 nil 指针，则 Marshal 函数会调用其 MarshalJSON 方法以生成 JSON。如果不存在 MarshalJSON 方法，但该值实现 encoding.TextMarshaler 接口，则 Marshal 函数调用其 MarshalText 方法并将结果编码为 JSON 字符串。</p>
<p>可见，json.Marshal 函数优先调用 MarshalJSON，然后是 MarshalText，如果都没有，才会走正常的类型编码逻辑。</p>
]]></content>
		</item>
		
		<item>
			<title>感慨 Apple 的 强大</title>
			<link>https://polarisxu.studygolang.com/posts/apple/is-apple-m1-ready/</link>
			<pubDate>Sat, 19 Dec 2020 15:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/apple/is-apple-m1-ready/</guid>
			<description>大家好，我是站长 polarisxu。 这段时间关注 Apple M1 芯片挺多的，对 Apple 的强大由衷的感慨。市值 2.1 万亿美金，做的动作都成为行业引领者。 当年扁平化设计出来，被各种吐槽；结果大家都扁平化了； 出暗黑模式（很程序员？），有些人不喜欢，但现在各种都支持暗黑模式； iPhone 12 不带耳机和充电器，骂声一片，目测各个手机厂商都跟进，比如三星就宣布不带了； Mac 换成自己的 M1 芯片，很多软件厂商及时</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这段时间关注 Apple M1 芯片挺多的，对 Apple 的强大由衷的感慨。市值 2.1 万亿美金，做的动作都成为行业引领者。</p>
<ul>
<li>当年扁平化设计出来，被各种吐槽；结果大家都扁平化了；</li>
<li>出暗黑模式（很程序员？），有些人不喜欢，但现在各种都支持暗黑模式；</li>
<li>iPhone 12 不带耳机和充电器，骂声一片，目测各个手机厂商都跟进，比如三星就宣布不带了；</li>
<li>Mac 换成自己的 M1 芯片，很多软件厂商及时跟进支持；</li>
<li>。。。</li>
</ul>
<p>昨天 Go 1.16 Beta1 发布，原生支持 M1 芯片，今天无意中发现了一个 Twitter 账号：Is Apple Silicon Ready ?
@ism1ready，以及对应的网站：<a href="https://isapplesiliconready.com" target="_blank" rel="noopener">https://isapplesiliconready.com</a>
。刚换芯片，软件厂商们立马跟进，还有人做了这么个站点，不得不感叹：Apple 就是牛逼！</p>
<p><p class="md__image">
  <img src="../imgs/m1-01.png"
    alt=""  />
</p>
</p>
<p>如果你买了 M1 的 Mac，可以看看这个网站，它支持多国语言。对应用做了分类，同时就支持程度分为：原生支持 M1、只支持 Rosetta 2、不可用和还没测试。同时支持搜索某个软件。</p>
<p>有了这个网站，你可以很清晰的知晓软件对 M1 的支持程度。</p>
<h2 id="rosetta-2">Rosetta 2</h2>
<p>有些人可能不清楚 Rosetta 2 是啥，这里简单普及一下。</p>
<p>要说 Rosetta 2，先说说 Rosetta。</p>
<p>2006 年，苹果发布了 Rosetta，原因是它由原来的 PowerPC 芯片换成了 Intel 芯片，为了过渡，使许多 PowerPC 应用程序无需修改即可在基于 Intel 的 Mac 计算机上运行。因此可以简单的理解为，Rosetta 做了转换。</p>
<p>现在苹果又放弃了 Intel 芯片，采用 ARM 架构的 M1 芯片，同样会存在过渡问题，因此推出了 Rosetta 2，搭载苹果芯片的 Mac，可以运行专为 Intel 处理器 Mac 构建的 App。</p>
<p>苹果官方介绍在大多数情况下，需要 Rosetta 的 App 的性能不会出现任何差异。但实际上，性能和运行速度就无法保证和在 Intel 芯片的 Mac 上一样了。毕竟原生肯定优化的更好。</p>
<h2 id="软件原生支持情况">软件原生支持情况</h2>
<p>浏览器方面，Safari、Chrome、Edge、Firefox 都原生支持 M1 了。</p>
<p>编程语言方面，Go 1.16 支持，已经发布了 Beta1 版本；PHP 已经支持；Java 已经支持；Python 已经支持；Ruby 已经支持；Node 已经支持。其他一些语言，可以通过 Rosetta 2 来运行。</p>
<p>更多其他软件的支持情况可以通过该站的搜索查看。</p>
<p>所以，整体来说，因为有 Rosetta 2 的存在，新版 Mac 的使用完全不是问题，问题是有没有钱买~哈哈哈哈</p>
]]></content>
		</item>
		
		<item>
			<title>听说你还不知道如何查看 Go 历史文档？</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/view-go-history-std-version/</link>
			<pubDate>Thu, 17 Dec 2020 17:15:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/view-go-history-std-version/</guid>
			<description>大家好，我是站长 polarisxu。 这是一篇短文，写这篇文章主要是看到了两个信息： tonybai 写的《如何查看历史版本的 Go 文档？》 Go 官方发博文，2021 年初开始，godoc.org 默认将重定向到 pkg.go.dev ； tonybai 在文章中说了两种方法： 利用 go doc，可行，但非最优。比如 go doc http.Request。通过切换本地的 Go 版本实现查看不同版本的 Go 标准库文档； 使用 godoc 建立历史版本的 Web 化文档中心。</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这是一篇短文，写这篇文章主要是看到了两个信息：</p>
<ul>
<li>tonybai 写的<a href="https://tonybai.com/2020/12/15/how-to-see-the-manual-of-go-history-version/" target="_blank" rel="noopener">《如何查看历史版本的 Go 文档？》</a>
</li>
<li>Go 官方发博文，2021 年初开始，<a href="https://docs.studygolang.com/blog/godoc.org-redirect" target="_blank" rel="noopener">godoc.org 默认将重定向到 pkg.go.dev</a>
；</li>
</ul>
<p>tonybai 在文章中说了两种方法：</p>
<ul>
<li>利用 go doc，可行，但非最优。比如 go doc http.Request。通过切换本地的 Go 版本实现查看不同版本的 Go 标准库文档；</li>
<li>使用 godoc 建立历史版本的 Web 化文档中心。这种方式需要额外安装 godoc：<code>go get golang.org/x/tools/cmd/godoc</code>。这种方法相当于本地启动一个旧版 Go 官网。godoc 支持一个参数 -goroot 来指定不同的 Go 版本目录树；</li>
</ul>
<p>但这两种方法都挺费劲的，因为需要你本地有各个版本的 Go 源码。以前没有更好的方法，但自从有了 pkg.go.dev，查看历史文档方便多了。因为 pkg.go.dev 更懂 Go module，通过它不仅可以查看标准库的历史版本文档，而且可以查看第三方库的历史版本。具体可以查看这里：<a href="https://pkg.go.dev/std?tab=versions" target="_blank" rel="noopener">https://pkg.go.dev/std?tab=versions</a>
。</p>
<p>虽然 godoc.org 也可以同时查看标准库文档和第三方库文档，但没有历史版本。pkg.go.dev 经过一年多的发展，经历了开源、重构等，官方终于决定正式弃用 godoc.org，将其重定向到 pkg.go.dev。</p>
<p>所以，是时候使用 pkg.go.dev 了，而且它可以直接访问，而不像 golang.org 不能访问。</p>
]]></content>
		</item>
		
		<item>
			<title>新买了 Apple M1 Mac，却不知道如何安装 Go？</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/apple-m1-install-go/</link>
			<pubDate>Wed, 16 Dec 2020 20:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/apple-m1-install-go/</guid>
			<description>大家好，我是站长 polarisxu。 前些天有一位朋友问我： 有些朋友可能会有点奇怪，M1 有什么特别的吗？为了照顾部分童鞋，这里简单介绍下。 01 为什么会出现这个问题 大家知道不同的操作系统是很不一样的，同时不同的 CPU 架构也是很不一样的。Go 号称是跨平台的，自然要支持这些操作系统和 CPU 架构。 在 Go 中，GOOS 表示操作系统，GOARCH 表示 CPU 架构。比如你的 Linux 服务器，一般是 GO</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>前些天有一位朋友问我：</p>
<p><p class="md__image">
  <img src="../imgs/apple-m1-install-go.png"
    alt=""  />
</p>
</p>
<p>有些朋友可能会有点奇怪，M1 有什么特别的吗？为了照顾部分童鞋，这里简单介绍下。</p>
<h2 id="01-为什么会出现这个问题">01 为什么会出现这个问题</h2>
<p>大家知道不同的操作系统是很不一样的，同时不同的 CPU 架构也是很不一样的。Go 号称是跨平台的，自然要支持这些操作系统和 CPU 架构。</p>
<p>在 Go 中，GOOS 表示操作系统，GOARCH 表示 CPU 架构。比如你的 Linux 服务器，一般是 GOOS=linux，GOARCH=amd64（即 x86-64）；你现在的 Mac 很可能是 GOOS=darwin，GOARCH=amd64 等。这里定义了 Go 支持的操作系统和 CPU 架构：<a href="https://docs.studygolang.com/pkg/runtime/internal/sys/#pkg-constants" target="_blank" rel="noopener">https://docs.studygolang.com/pkg/runtime/internal/sys/#pkg-constants</a>
。当然，这里的 GOOS 和 GOARCH 并非任意组合都支持。</p>
<p>一般地，很多人安装 Go，通过网上下载编译好的、对应系统的包，比如到 <a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a>
 可以下载你需要的文件，常见的系统是：Linux、Mac 和 Windows。</p>
<p><p class="md__image">
  <img src="../imgs/apple-m1-install-go-01.png"
    alt=""  />
</p>
</p>
<p>比如 Apple macOS，下载后双击打开，按提示操作即可。</p>
<p>然而，最新版 Mac 没有使用 Intel 芯片，而是使用了自研的 M1 芯片。之前 Intel 芯片是 amd64 架构，而 M1 芯片是 arm64 结构。前面说了，虽然 Go 是支持 arm64 架构的，但并非操作系统和 CPU 架构的任意组合都支持，也就是说 GOOS=darwin，GOARCH=arm64 的组合不支持（或者说没有针对这个用于 Mac 的组合做处理）。因此，现有预编译的版本都没法安装到 M1 Mac 上。</p>
<h2 id="02-探讨解决方案">02 探讨解决方案</h2>
<p>要解决这个问题，当然前提是 Go 团队支持 M1。虽然 Go 以往的版本都不支持，但对 M1 的支持，Go 已经开发完毕，而且网上已经有了 Intel 和 M1 的性能测试。</p>
<ul>
<li><a href="https://roland.zone/m1-go-benchmarks/" target="_blank" rel="noopener">Go 标准库性能测试，对比 Intel 和 苹果 M1 处理器</a>
</li>
<li><a href="https://gohugo.io/news/hugo-macos-intel-vs-arm/" target="_blank" rel="noopener">Hugo 在 Apple M1 的性能测试</a>
</li>
</ul>
<p>对 M1 的支持，需要等到 Go1.16 发布，也就是明年 2 月份。但我们可以通过 Go 代码仓库的 master 分支来编译安装 Go，因为它是支持 M1 的（注意，因为是开发版本，请勿用于生产环境）。</p>
<p>现在引出另一个问题：因为 Go 自 1.5 开始实现了自举，如果从源码安装 Go，需要本地有 Go 的编译器。。。陷入了死循环。</p>
<p>如果是非 M1 芯片，通常的做法是：下载一份 Go1.4 版本代码，编译一个 Go1.4（因为它是 C 语言实现的，不依赖 Go）。然后用这个 Go1.4 编译最新的 Go 源码。</p>
<p>实际上，官方告诉你有四种方法处理这种情况。</p>
<h3 id="源码安装的四种方法">源码安装的四种方法</h3>
<ul>
<li>下载 Go 的最新二进制版本（其实可以不是最新的）；</li>
<li>在一台安装有 Go 的电脑上执行交叉编译；</li>
<li>使用 gccgo；</li>
<li>即上面提到的方法，编译一个 Go1.4，然后用它编译其他 Go 版本；</li>
</ul>
<p>更多详细信息参考官方文档：<a href="https://docs.studygolang.com/doc/install/source#go14" target="_blank" rel="noopener">https://docs.studygolang.com/doc/install/source#go14</a>
。</p>
<p>所以，对于 M1 芯片安装 Go，方法 1 和方法 4 行不通（Go 1.4 很显然不支持 M1 芯片），而使用交叉编译是一个不错的选择，毕竟 gccgo，很多人并不熟悉。</p>
<h2 id="03-通过交叉编译在-m1-上安装-go">03 通过交叉编译在 M1 上安装 Go</h2>
<p>我认为支持交叉编译是 Go 的一大特色，不仅支持交叉编译 Go 程序，本身也支持交叉编译。</p>
<p>现在就讲解通过交叉编译解决 M1 安装 Go 的问题。</p>
<p>1）下载 Go 最新源码。</p>
<p>在一台非 M1 电脑上，下载 Go 最新源码，假设下载到用户目录：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~
$ git clone https://github.com/golang/go
</code></pre></div><p>2）进行交叉编译</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> go/src
$ <span class="nv">GOOS</span><span class="o">=</span>darwin <span class="nv">GOARCH</span><span class="o">=</span>arm64 ./bootstrap.bash
<span class="c1">#### Copying to ../../go-darwin-arm64-bootstrap</span>

<span class="c1">#### Cleaning ../../go-darwin-arm64-bootstrap</span>
Removing VERSION.cache
Removing bin/
Removing pkg/
Removing src/cmd/cgo/zdefaultcc.go
Removing src/cmd/go/internal/cfg/zdefaultcc.go
Removing src/cmd/go/internal/cfg/zosarch.go
Removing src/cmd/internal/objabi/zbootstrap.go
Removing src/go/build/zcgo.go
Removing src/runtime/internal/sys/zversion.go

<span class="c1">#### Building ../../go-darwin-arm64-bootstrap</span>

Building Go cmd/dist using /Users/xuxinhua/go1.4. <span class="o">(</span>go1.4-bootstrap-20170531 darwin/amd64<span class="o">)</span>
Building Go toolchain1 using /Users/xuxinhua/go1.4.
Building Go bootstrap cmd/go <span class="o">(</span>go_bootstrap<span class="o">)</span> using Go toolchain1.
Building Go toolchain2 using go_bootstrap and Go toolchain1.
Building Go toolchain3 using go_bootstrap and Go toolchain2.
Building packages and commands <span class="k">for</span> host, darwin/amd64.
Building packages and commands <span class="k">for</span> target, darwin/arm64.
----
Bootstrap toolchain <span class="k">for</span> darwin/arm64 installed in /Users/xuxinhua/go-darwin-arm64-bootstrap.
Building tbz.
-rw-r--r--  <span class="m">1</span> xuxinhua  staff  <span class="m">128102136</span> <span class="m">12</span> <span class="m">16</span> 17:15 /Users/xuxinhua/go-darwin-arm64-bootstrap.tbz
</code></pre></div><p>从上面的输出可以看到，在用户目录下会生成 go-darwin-arm64-bootstrap 文件夹和 go-darwin-arm64-bootstrap.tbz 压缩包，将其中之一发送给 M1 Mac，在 M1 电脑上可以以此作为 bootstrap，重新编译 Go，也可以直接将它作为 Go 编译器使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/go-darwin-arm64-bootstrap
$ bin/go env    
<span class="nv">GO111MODULE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOARCH</span><span class="o">=</span><span class="s2">&#34;arm64&#34;</span>
<span class="nv">GOBIN</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOCACHE</span><span class="o">=</span><span class="s2">&#34;~/Library/Caches/go-build&#34;</span>
<span class="nv">GOENV</span><span class="o">=</span><span class="s2">&#34;~/Library/Application Support/go/env&#34;</span>
<span class="nv">GOEXE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOFLAGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOHOSTARCH</span><span class="o">=</span><span class="s2">&#34;arm64&#34;</span>
<span class="nv">GOHOSTOS</span><span class="o">=</span><span class="s2">&#34;darwin&#34;</span>
<span class="nv">GOINSECURE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOMODCACHE</span><span class="o">=</span><span class="s2">&#34;~/go/pkg/mod&#34;</span>
<span class="nv">GONOPROXY</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GONOSUMDB</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOOS</span><span class="o">=</span><span class="s2">&#34;darwin&#34;</span>
<span class="nv">GOPATH</span><span class="o">=</span><span class="s2">&#34;~/go&#34;</span>
<span class="nv">GOPRIVATE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOPROXY</span><span class="o">=</span><span class="s2">&#34;https://proxy.golang.org,direct&#34;</span>
<span class="nv">GOROOT</span><span class="o">=</span><span class="s2">&#34;~/go-darwin-arm64-bootstrap&#34;</span>
<span class="nv">GOSUMDB</span><span class="o">=</span><span class="s2">&#34;sum.golang.org&#34;</span>
<span class="nv">GOTMPDIR</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOTOOLDIR</span><span class="o">=</span><span class="s2">&#34;~/Downloads/go-darwin-arm64-bootstrap/pkg/tool/darwin_arm64&#34;</span>
<span class="nv">GOVCS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOVERSION</span><span class="o">=</span><span class="s2">&#34;devel +5a25a3fd1d Tue Dec 15 02:35:59 2020 +0000&#34;</span>
<span class="nv">GCCGO</span><span class="o">=</span><span class="s2">&#34;gccgo&#34;</span>
<span class="nv">AR</span><span class="o">=</span><span class="s2">&#34;ar&#34;</span>
<span class="nv">CC</span><span class="o">=</span><span class="s2">&#34;clang&#34;</span>
<span class="nv">CXX</span><span class="o">=</span><span class="s2">&#34;clang++&#34;</span>
<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="s2">&#34;1&#34;</span>
<span class="nv">GOMOD</span><span class="o">=</span><span class="s2">&#34;/dev/null&#34;</span>
<span class="nv">CGO_CFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_CPPFLAGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">CGO_CXXFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_FFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_LDFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">PKG_CONFIG</span><span class="o">=</span><span class="s2">&#34;pkg-config&#34;</span>
<span class="nv">GOGCCFLAGS</span><span class="o">=</span><span class="s2">&#34;-fPIC -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/6r/nghqxtb92kv5136s7k67_cc00000gn/T/go-build4293620280=/tmp/go-build -gno-record-gcc-switches -fno-common&#34;</span>
</code></pre></div><h2 id="04-总结">04 总结</h2>
<p>吃螃蟹嘛，应该有一定的心里准备。但 Go 还是很给力。Bradfitz 发推文说，苹果在 6 月 22 日说，会给 Go 支持 Apple Silicon (arm64) 提交 patch，但到目前为止没看到，至少没有在邮件组中出现，他们没有在 <a href="https://tip.golang.org/CONTRIBUTORS" target="_blank" rel="noopener">https://tip.golang.org/CONTRIBUTORS</a>
 列表中。所有支持 Apple Silicon 的工作都是 Go 社区做的。</p>
<p>买了 M1 还没装 Go 的，可以试试了！</p>
]]></content>
		</item>
		
		<item>
			<title>你是不是没想过，结构体竟然可以内嵌一个接口？</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/weekly-question-analysis-embed-interface/</link>
			<pubDate>Mon, 14 Dec 2020 17:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/weekly-question-analysis-embed-interface/</guid>
			<description>大家好，我是站长 polarisxu。 时不时有人催问周刊题目的解析，那就先先解析下第 71 期 的题目。 01 题目是，以下代码能否通过编译： package main import ( &amp;#34;fmt&amp;#34; ) type worker interface { work() } type person struct { name string worker } func main() { var w worker = person{} fmt.Println(w) } 这是大家的投票结果： 只有 35% 的人答对了。 这里答错的原因在于 worker 是一个接口，如果是一个普通的类型，相信大家会答对。一个结构体竟然可以嵌入一个接口？！ 02 我们都知晓 Go 没有继承，但可以通</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>时不时有人催问周刊题目的解析，那就先先解析下<a href="https://mp.weixin.qq.com/s/QpG5oBlz9mcmBUV8gl7P7w" target="_blank" rel="noopener">第 71 期</a>
的题目。</p>
<h2 id="01">01</h2>
<p>题目是，以下代码能否通过编译：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">worker</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">work</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
	<span class="nx">worker</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">w</span> <span class="nx">worker</span> <span class="p">=</span> <span class="nx">person</span><span class="p">{}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这是大家的投票结果：</p>
<p><p class="md__image">
  <img src="../imgs/weekly71-73-01.png"
    alt=""  />
</p>
</p>
<p>只有 35% 的人答对了。</p>
<p>这里答错的原因在于 worker 是一个接口，如果是一个普通的类型，相信大家会答对。一个结构体竟然可以嵌入一个接口？！</p>
<h2 id="02">02</h2>
<p>我们都知晓 Go 没有继承，但可以通过内嵌类型模拟部分继承的功能。大家要记住，接口也是类型，自然也将它作为嵌入类型。如果题目的 person 接口体改为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
	<span class="nx">worker</span> <span class="nx">worker</span>
<span class="p">}</span>
</code></pre></div><p>相信会有更多人答对，这和嵌入类型唯一的区别在于是否显示指定了字段名，其他并无区别。</p>
<p>将接口作为嵌入类型可能让人感觉有些奇怪：那这个类型不是默认就实现了这个接口？！确实是这样的，所以才有了题目中这一句能编译通过：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">w</span> <span class="nx">worker</span> <span class="p">=</span> <span class="nx">person</span><span class="p">{}</span>
</code></pre></div><p>只不过，因为实例化 person 时，没有给 worker 指定值，因此 person 中的 worker 是 nil，调用它的话会报错，但编译是没问题的。</p>
<h2 id="03">03</h2>
<p>有人可能要问，嵌入接口有实际用途吗？我找一个标准库中的例子。</p>
<p>在 sort 包中，有一个接口：Interface</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Interface</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Len is the number of elements in the collection.
</span><span class="c1"></span>	<span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span>
	<span class="c1">// Less reports whether the element with
</span><span class="c1"></span>	<span class="c1">// index i should sort before the element with index j.
</span><span class="c1"></span>	<span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="c1">// Swap swaps the elements with indexes i and j.
</span><span class="c1"></span>	<span class="nf">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这是用于排序的。还有另外一个结构体：<a href="https://docs.studygolang.com/src/sort/sort.go?s=7078:7105#L239" target="_blank" rel="noopener">reverse</a>
</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">reverse</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// This embedded Interface permits Reverse to use the methods of
</span><span class="c1"></span>	<span class="c1">// another Interface implementation.
</span><span class="c1"></span>	<span class="nx">Interface</span>
<span class="p">}</span>
</code></pre></div><p>它就内嵌了一个 Interface，用于排序的反转。</p>
<p>而内嵌接口的关键在于如何给这个内嵌的接口赋值。sort 包有一个函数：Reverse</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Reverse</span><span class="p">(</span><span class="nx">data</span> <span class="nx">Interface</span><span class="p">)</span> <span class="nx">Interface</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">reverse</span><span class="p">{</span><span class="nx">data</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>其中实例化 reverse 时，直接通过传递的 Interface 实例赋值给 reverse 的内嵌接口，然后 reverse 类型可以有选择的重新实现内嵌的 Interface 的方法。比如 Less 方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="nx">reverse</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Interface</span><span class="p">.</span><span class="nf">Less</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="04">04</h2>
<p>回到上面的题目，如果我们通过实例化的 w 调用 work 方法会报错：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">w</span> <span class="nx">worker</span> <span class="p">=</span> <span class="nx">person</span><span class="p">{}</span>
<span class="nx">w</span><span class="p">.</span><span class="nf">work</span><span class="p">()</span>	<span class="c1">// panic
</span></code></pre></div><p>和上面 reverse 类似，你需要给 person 中的 worker 实例化，也就是需要一个实现了 worker 接口的类型实例。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">student</span> <span class="kd">struct</span><span class="p">{</span>
    <span class="nx">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">student</span><span class="p">)</span> <span class="nf">work</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;I am &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;, I am learning&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>然后这样实例化 person：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">w</span> <span class="nx">worker</span> <span class="p">=</span> <span class="nx">person</span><span class="p">{</span><span class="nx">worker</span><span class="p">:</span> <span class="nx">student</span><span class="p">{</span><span class="s">&#34;polarisxu&#34;</span><span class="p">}}</span>
</code></pre></div><p>你掌握了吗？</p>
]]></content>
		</item>
		
		<item>
			<title>体验下“世界上最好的语言”新版本的特性</title>
			<link>https://polarisxu.studygolang.com/posts/php/php8-intro/</link>
			<pubDate>Tue, 08 Dec 2020 11:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/php/php8-intro/</guid>
			<description>大家好，我是站长 polarisxu。 看到标题，大家应该知晓今天聊的主角是谁。是的，它就是 PHP。 PHP 曾经很辉煌，现在怎么样？不做过多评价，前几天好未来不刚组织了一届 PHP 大会吗？！正因为曾经很辉煌，很多现在的 Go 爱好者曾经都是 PHPer，应该还有不少还在用着 PHP。我觉得完全没必要非得贬低一门语言去抬高另外一门语言，自己喜欢就好。而且掌握多门语言是自己的优势。 为什么</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>看到标题，大家应该知晓今天聊的主角是谁。是的，它就是 PHP。</p>
<p>PHP 曾经很辉煌，现在怎么样？不做过多评价，前几天好未来不刚组织了一届 PHP 大会吗？！正因为曾经很辉煌，很多现在的 Go 爱好者曾经都是 PHPer，应该还有不少还在用着 PHP。我觉得完全没必要非得贬低一门语言去抬高另外一门语言，自己喜欢就好。而且掌握多门语言是自己的优势。</p>
<p>为什么聊 PHP，因为我也写了好几年 PHP，而且现在也会关注 PHP 的一些动态。PHP 8 发布差不多半个月了，有些人可能根本不知晓，还停留在 PHP 5.x。没想到吧，一眨眼，PHP 8 都发布了。</p>
<p>关于版本的那些事，这里不探讨，主要看看 PHP 8 有哪些新特性。另外，本文只会讲述新特性的一些关键点，因为官方文档对它们已经有更详细的介绍，你应该认真阅读官方文档。</p>
<h2 id="01-union-types联合类型">01 Union Types（联合类型）</h2>
<p>说明一点，从 PHP 7 开始，支持下面这样的语法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="k">function</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">int</span> <span class="nv">$a</span><span class="p">,</span> <span class="nx">int</span> <span class="nv">$b</span><span class="p">)</span><span class="o">:</span> <span class="nx">int</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>是不是越来越强类型的感觉？虽然如此，但在非严格类型模式下（strict_types=0，这是默认值），你依然可以这么调用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="nx">sum</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div><p>但因为函数参数接收 int 类型（返回值也是 int 类型），因此上面结果是 4，而不是 4.2。如果是严格模式下，只允许传递 int 类型了。（<code>sum('1.2', 3.0)</code> 结果也是 4）</p>
<p>如果希望结果输出 4.2，同时又保持类型约束，怎么办？PHP 不支持方法重载。这就有了 PHP 8 的联合类型。</p>
<blockquote>
<p>联合类型接受多个不同的类型做为参数。声明联合类型的语法为 T1|T2|&hellip;。</p>
</blockquote>
<p>所以，上面代码可以改为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="k">function</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">int</span><span class="o">|</span><span class="nx">float</span> <span class="nv">$a</span><span class="p">,</span> <span class="nx">int</span><span class="o">|</span><span class="nx">float</span> <span class="nv">$b</span><span class="p">)</span><span class="o">:</span> <span class="nx">int</span><span class="o">|</span><span class="nx">float</span>
<span class="p">{</span>
		<span class="k">return</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这样 <code>sum(1.2, 3)</code> 的结果就是 4.2 了。</p>
<p>一些注意事项：</p>
<ul>
<li>
<p>联合类型也可用于类成员变量；</p>
</li>
<li>
<p>null 可以用于联合类型中，但不能单独作为类型。比如 <code>int|null</code> 允许，但 null 作为类型不允许；</p>
</li>
<li>
<p>下面的函数是合法的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="k">function</span> <span class="nf">index</span><span class="p">()</span><span class="o">:</span> <span class="nx">int</span><span class="o">|</span><span class="k">false</span>
<span class="p">{</span>
      <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>但返回值改为：<code>int|true</code> 却是非法的。这是出于历史原因，很多内部函数在失败时返回了 false 而不是 null。 这类函数的典型例子是 strpos()。因此允许联合类型中使用 false，但不允许使用 true。注意 false 并非是类型，这里看出是伪类型，不能单独使用。</p>
</li>
</ul>
<p>还有其他一些细节点，详情请访问官方文档查看：<a href="https://www.php.net/manual/zh/language.types.declarations.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/language.types.declarations.php</a>
。</p>
<blockquote>
<p>不得不说，也许越来越意识到弱类型的问题，PHP 这是在做强类型的事情。然而，不少人要说了，搞这么费劲、这么复杂，还不如直接换强类型语言呢？！你觉得呢？</p>
</blockquote>
<p>当然，你完全可以忽略联合类型，继续使用 5.x 的方式写 PHP。</p>
<h2 id="03-named-arguments命名参数">03 Named Arguments（命名参数）</h2>
<p>这个特性还是很棒的。了解 Python 的朋友应该对这个特性很熟悉。这样一来，PHP 的函数支持不定参数、参数默认值、命名参数等。相对来说，Go 的函数还是弱很多。</p>
<p>比如 htmlspecialchars 函数签名如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="nx">htmlspecialchars</span> <span class="p">(</span> <span class="nx">string</span> <span class="nv">$string</span> <span class="p">[,</span> <span class="nx">int</span> <span class="nv">$flags</span> <span class="o">=</span> <span class="nx">ENT_COMPAT</span> <span class="o">|</span> <span class="nx">ENT_HTML401</span> <span class="p">[,</span> <span class="nx">string</span> <span class="nv">$encoding</span> <span class="o">=</span> <span class="nx">ini_get</span><span class="p">(</span><span class="s2">&#34;default_charset&#34;</span><span class="p">)</span> <span class="p">[,</span> <span class="nx">bool</span> <span class="nv">$double_encode</span> <span class="o">=</span> <span class="k">TRUE</span> <span class="p">]]]</span> <span class="p">)</span> <span class="o">:</span> <span class="nx">string</span>
</code></pre></div><p>PHP 8 之前，如果想要最后一个参数传递 false，需要这么调用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="nx">htmlspecialchars</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nx">ENT_COMPAT</span> <span class="o">|</span> <span class="nx">ENT_HTML401</span><span class="p">,</span> <span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
</code></pre></div><p>而有了命名参数后（PHP 8），可以这么调用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="nx">htmlspecialchars</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nx">double_encode</span><span class="o">:</span> <span class="k">false</span><span class="p">);</span>
</code></pre></div><p>简单清晰。</p>
<p>总结一下就是：</p>
<ul>
<li>仅需指定必需的参数，可跳过可选的参数。</li>
<li>参数是与顺序无关的且具有自记录功能。</li>
</ul>
<p>命名参数确实带来了不少便利。不过我觉得也有一些要注意的点:</p>
<ul>
<li>函数参数可能会很多，Python 中很多函数一大堆参数，可维护性可能是一个问题；</li>
<li>原本函数参数名称是不重要的，但命名参数使得参数名称不能随便改，因为调用者可能依赖它了；</li>
</ul>
<h2 id="04-match-表达式">04 Match 表达式</h2>
<p>实际中我们经常通过 state 来表示各种状态，比如：0-待审核；1-上线；2-下线；3-删除。因为数据库中存的数字，但显示希望是文字说明。这时一般有两种做法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="k">switch</span> <span class="p">(</span><span class="nv">$state</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
    <span class="nv">$stateDesc</span> <span class="o">=</span> <span class="s1">&#39;待审核&#39;</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
    <span class="nv">$stateDesc</span> <span class="o">=</span> <span class="s1">&#39;上线&#39;</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
    <span class="nv">$stateDesc</span> <span class="o">=</span> <span class="s1">&#39;下线&#39;</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
    <span class="nv">$stateDesc</span> <span class="o">=</span> <span class="s1">&#39;删除&#39;</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">echo</span> <span class="nv">$stateDesc</span><span class="p">;</span>
</code></pre></div><p>我个人喜欢通过 map 来实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="nv">$stateMap</span> <span class="o">=</span> <span class="p">[</span>
  <span class="mi">0</span> <span class="o">=&gt;</span> <span class="s1">&#39;待审核&#39;</span><span class="p">,</span>
  <span class="mi">1</span> <span class="o">=&gt;</span> <span class="s1">&#39;上线&#39;</span><span class="p">,</span>
  <span class="mi">2</span> <span class="o">=&gt;</span> <span class="s1">&#39;下线&#39;</span><span class="p">,</span>
  <span class="mi">3</span> <span class="o">=&gt;</span> <span class="s1">&#39;删除&#39;</span><span class="p">,</span>
<span class="p">];</span>

<span class="k">echo</span> <span class="nv">$stateMap</span><span class="p">[</span><span class="nv">$state</span><span class="p">];</span>
</code></pre></div><p>PHP 8 针对这样的场景提供了 match 表达式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="k">echo</span> <span class="nx">match</span><span class="p">(</span><span class="nv">$state</span><span class="p">)</span> <span class="p">{</span>
  <span class="mi">0</span> <span class="o">=&gt;</span> <span class="s1">&#39;待审核&#39;</span><span class="p">,</span>
  <span class="mi">1</span> <span class="o">=&gt;</span> <span class="s1">&#39;上线&#39;</span><span class="p">,</span>
  <span class="mi">2</span> <span class="o">=&gt;</span> <span class="s1">&#39;下线&#39;</span><span class="p">,</span>
  <span class="mi">3</span> <span class="o">=&gt;</span> <span class="s1">&#39;删除&#39;</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div><p>可见 match 类似于 switch 语句，有如下特点：</p>
<ul>
<li>Match 是一个表达式，因此其结果可以存储在变量中或返回；</li>
<li>Match 分支仅支持单行表达式，不需要 break 语句；</li>
<li>switch 相当于使用 <code>==</code> 比较，而 Match 使用 <code>===</code> 比较；</li>
<li>如果没匹配到任何项，会抛 UnhandledMatchError 错误；</li>
<li>也支持 default；</li>
</ul>
<p>更多信息查看官方文档：<a href="https://www.php.net/manual/zh/control-structures.match.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/control-structures.match.php</a>
。</p>
<h2 id="05-nullsafe-运算符nullsafe-operator">05 Nullsafe 运算符（Nullsafe operator）</h2>
<p>了解 Swift 之类的语言，应该知晓其中的可选型。PHP 8 新增的这个特性，我觉得多少有点可选型的意思。</p>
<p>在 PHP 7 中的如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="nv">$country</span> <span class="o">=</span>  <span class="k">null</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nv">$session</span> <span class="o">!==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">$user</span> <span class="o">=</span> <span class="nv">$session</span><span class="o">-&gt;</span><span class="na">user</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nv">$user</span> <span class="o">!==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$address</span> <span class="o">=</span> <span class="nv">$user</span><span class="o">-&gt;</span><span class="na">getAddress</span><span class="p">();</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="nv">$address</span> <span class="o">!==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nv">$country</span> <span class="o">=</span> <span class="nv">$address</span><span class="o">-&gt;</span><span class="na">country</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在 PHP 8 中简化为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="nv">$country</span> <span class="o">=</span> <span class="nv">$session</span><span class="o">?-&gt;</span><span class="na">user</span><span class="o">?-&gt;</span><span class="na">getAddress</span><span class="p">()</span><span class="o">?-&gt;</span><span class="na">country</span><span class="p">;</span>
</code></pre></div><h2 id="06-构造器属性提升">06 构造器属性提升</h2>
<p>PHP 8 起构造器的参数可以提升为类的属性。构造器的参数赋值给类属性的行为很普遍，否则无法操作。 而构造器提升的功能则为这种场景提供了便利。 例如下面的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="k">public</span> <span class="nx">float</span> <span class="nv">$x</span><span class="p">;</span>
  <span class="k">public</span> <span class="nx">float</span> <span class="nv">$y</span><span class="p">;</span>
  <span class="k">public</span> <span class="nx">float</span> <span class="nv">$z</span><span class="p">;</span>

  <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span>
    <span class="nx">float</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="nx">float</span> <span class="nv">$y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="nx">float</span> <span class="nv">$z</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">y</span> <span class="o">=</span> <span class="nv">$y</span><span class="p">;</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">z</span> <span class="o">=</span> <span class="nv">$z</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>改为 PHP 8 的方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span>
    <span class="k">public</span> <span class="nx">float</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="k">public</span> <span class="nx">float</span> <span class="nv">$y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="k">public</span> <span class="nx">float</span> <span class="nv">$z</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
  <span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><h2 id="07-字符串与数字的比较更符合逻辑">07 字符串与数字的比较更符合逻辑</h2>
<p>PHP 8 比较数字字符串（numeric string）时，会按数字进行比较。 不是数字字符串时，将数字转化为字符串，按字符串比较。</p>
<p>这一点要注意，之前这样的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="mi">0</span> <span class="o">==</span> <span class="s1">&#39;foobar&#39;</span> <span class="c1">// true
</span></code></pre></div><p>现在是 false：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="mi">0</span> <span class="o">==</span> <span class="s1">&#39;foobar&#39;</span> <span class="c1">// false
</span></code></pre></div><p>更多说明参见这里：<a href="https://wiki.php.net/rfc/string_to_number_comparison" target="_blank" rel="noopener">https://wiki.php.net/rfc/string_to_number_comparison</a>
。</p>
<h2 id="08-注解attributes">08 注解（attributes）</h2>
<p>现在可以用 PHP 原生语法来使用结构化的元数据，而非 PHPDoc 声明。</p>
<p>之前这么写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="k">class</span> <span class="nc">PostsController</span>
<span class="p">{</span>
    <span class="sd">/**
</span><span class="sd">     * @Route(&#34;/api/posts/{id}&#34;, methods={&#34;GET&#34;})
</span><span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">get</span><span class="p">(</span><span class="nv">$id</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>现在这么写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="k">class</span> <span class="nc">PostsController</span>
<span class="p">{</span>
    <span class="c1">#[Route(&#34;/api/posts/{id}&#34;, methods: [&#34;GET&#34;])]
</span><span class="c1"></span>    <span class="k">public</span> <span class="k">function</span> <span class="nf">get</span><span class="p">(</span><span class="nv">$id</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="09-即时编译">09 即时编译</h2>
<p>PHP 8 引入了两个即时编译引擎。 Tracing JIT 在两个中更有潜力，它在综合基准测试中显示了三倍的性能， 并在某些长时间运行的程序中显示了 1.5-2 倍的性能改进。 典型的应用性能则和 PHP 7.4 不相上下。</p>
<p>官方给了一个性能测试：</p>
<p><p class="md__image">
  <img src="../imgs/php8-jit.png"
    alt=""  />
</p>
</p>
<h2 id="10-总结">10 总结</h2>
<p>PHP 8 还有很多其他改动，在这里有详细的说明：<a href="https://www.php.net/releases/8.0/zh.php" target="_blank" rel="noopener">https://www.php.net/releases/8.0/zh.php</a>
。其中新增了 3 个函数实用的函数：str_contains()、str_starts_with() 和 str_ends_with()。（Go 表示第一天就有了）</p>
<p>这里面的新特性，命名参数我个人还是比较喜欢。你呢？</p>
]]></content>
		</item>
		
		<item>
			<title>推荐一个网站：其实是三个网站</title>
			<link>https://polarisxu.studygolang.com/posts/share/programming-idioms/</link>
			<pubDate>Mon, 07 Dec 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/share/programming-idioms/</guid>
			<description>大家好，我是站长 polarisxu。 现在这样的环境要求我们程序员掌握多门语言。然而，很多人在掌握了一门语言后，学习其他语言时，总会有前一门语言的影子；亦或有些人希望在学习新语言时能和之前的语言进行对比学习。 无意中发现一个网站，对有上述情况的人可能有些帮助，因此推荐给大家。网站地址：https://programming-idioms.org/ 。 从网站名称也能</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>现在这样的环境要求我们程序员掌握多门语言。然而，很多人在掌握了一门语言后，学习其他语言时，总会有前一门语言的影子；亦或有些人希望在学习新语言时能和之前的语言进行对比学习。</p>
<p>无意中发现一个网站，对有上述情况的人可能有些帮助，因此推荐给大家。网站地址：<a href="https://programming-idioms.org/" target="_blank" rel="noopener">https://programming-idioms.org/</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/programming-idioms-home.png"
    alt=""  />
</p>
</p>
<p>从网站名称也能猜出作者的意图，希望让大家掌握每门语言自己的习语。</p>
<p>下面简单介绍下该网站。</p>
<h2 id="01">01</h2>
<p>首先这个网站的核心存储部分代码是开源的，使用 Go 语言实现。源码地址：<a href="https://github.com/Deleplace/programming-idioms" target="_blank" rel="noopener">https://github.com/Deleplace/programming-idioms</a>
。</p>
<p>这个网站看起来功能不少，看菜单：</p>
<p><p class="md__image">
  <img src="../imgs/programming-idioms-nav.png"
    alt=""  />
</p>
</p>
<p>实际上主要是 idioms （目前 241 个），以及 31 门语言。通过这两者的组合，形成了相关的内容。比如，你可以看看 Hello World 在各个语言都是如何实现的。</p>
<h2 id="02">02</h2>
<p>我认为该网站最有价值的一点在于它提供的 Cheatsheets 功能。</p>
<p><p class="md__image">
  <img src="../imgs/programming-idioms-cheatsheets.png"
    alt=""  />
</p>
</p>
<p>通过选择两门语言来对比学习，比如 Go 和 Rust，你可以在这里查看：<a href="https://programming-idioms.org/cheatsheet/Go/Rust" target="_blank" rel="noopener">https://programming-idioms.org/cheatsheet/Go/Rust</a>
。这样你可以快速的通过一门自己熟悉的语言了解另外一门陌生的语言。</p>
<p><p class="md__image">
  <img src="../imgs/programming-idioms-go-vs-rust.png"
    alt=""  />
</p>
</p>
<h2 id="03">03</h2>
<p>目前该站点的 Idioms 还不多，但每个人都可以贡献，通过该链接可以创建一个 idioms：<a href="https://programming-idioms.org/idiom-create" target="_blank" rel="noopener">https://programming-idioms.org/idiom-create</a>
。</p>
<p>此外，通过这个站点还发现了另外两个站点。</p>
<ul>
<li><a href="https://hyperpolyglot.org/" target="_blank" rel="noopener">https://hyperpolyglot.org/</a>
。这个站点通过并排的方式显示不同语言的对比，类似上面的 Cheatsheets。比如 C 语言与 Go 语言的对比就值得一看：<a href="https://hyperpolyglot.org/c" target="_blank" rel="noopener">https://hyperpolyglot.org/c</a>
；</li>
<li><a href="https://rosettacode.org/wiki/Rosetta_Code" target="_blank" rel="noopener">https://rosettacode.org/wiki/Rosetta_Code</a>
。这是一个编程主题网站。这个想法是要以尽可能多的不同语言提供针对同一任务的解决方案，以展示语言的相似性和差异性，并以一种解决方案为基础来帮助一个人学习另一门语言。 Rosetta Code 目前有 1,081 个任务，220 个草稿任务，有超过 810 种语言。当然没法为每种语言的每项任务提供解决方案，这需要大家一起努力，它已经形成了一个社区。实际上，这里有很多 LeetCode 上的题解。这个网站是刷算法的一个辅助网站。</li>
</ul>
<h2 id="04">04</h2>
<p>你发现了其他好的站点吗？欢迎留言分享给大家，好东西别私藏哦。</p>
]]></content>
		</item>
		
		<item>
			<title>GoLand 2020.3 正式发布了，有不少新功能，包括支持泛型</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/goland-2020-3-release/</link>
			<pubDate>Fri, 04 Dec 2020 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/goland-2020-3-release/</guid>
			<description>这是 2020 年第 3 个版本，也是最后一个版本。在 GoLand 2020.3 中，您可以探索 goroutines dumps，运行并导航到单个表测试（table tests），并从对 Testify 测试框架的扩展支持中获得更多信息。你还将发现许多新的代码编辑功能，包括对 time 包的支持，更智能的处理包方法，UI 改进，用于 Web 开发和使用数据库的各种新功能以及用于协作开发和结对编程的新服务。具体看看有哪些新特性。 01 调试器改进 Dump Goroutines 调试器中新</description>
			<content type="html"><![CDATA[<p>这是 2020 年第 3 个版本，也是最后一个版本。在 GoLand 2020.3 中，您可以探索 goroutines dumps，运行并导航到单个表测试（table tests），并从对 Testify 测试框架的扩展支持中获得更多信息。你还将发现许多新的代码编辑功能，包括对 time 包的支持，更智能的处理包方法，UI 改进，用于 Web 开发和使用数据库的各种新功能以及用于协作开发和结对编程的新服务。具体看看有哪些新特性。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020-3-release.png"
    alt=""  />
</p>
</p>
<h2 id="01-调试器改进">01 调试器改进</h2>
<h3 id="dump-goroutines">Dump Goroutines</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-dump-goroutines.gif"
    alt=""  />
</p>
</p>
<p>调试器中新的转储 Goroutines（Dump Goroutines） 图标使您可以在调试会话期间轻松地在堆栈中查找包含指定字符串的 goroutine。只需单击该图标即可在单独的窗口中打开转储。</p>
<p>为了帮助您始终关注重要信息，可以选择隐藏单个goroutine或具有相同堆栈的goroutine。右键单击goroutine，然后选择所需的操作，或按Delete键将其移至转储窗口中的特殊“隐藏”部分，这样不会分散您的注意力。</p>
<h3 id="go-remote-configuration">Go Remote configuration</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-remote-debug.gif"
    alt=""  />
</p>
</p>
<p>如果不需要重新连接，GoLand 2020.3可以通过 Go Remote 配置停止进程。</p>
<p>在配置设置中，您可以指定断开连接时调试器的默认行为，可以选择 “Stop remote Delve processes”，“使其保持运行状态”或让 GoLand 每次询问您如何继续。</p>
<h2 id="02-测试增强">02 测试增强</h2>
<h3 id="支持-table-tests">支持 table tests</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-table-tests-support.gif"
    alt=""  />
</p>
</p>
<p>您可以从 “Run” 工具窗口运行并导航到表测试。</p>
<p>有一些限制：</p>
<ul>
<li>测试数据变量必须是切片，数组或 map。它必须在与调用相同的函数中定义，并且在初始化后不得修改（for 循环中的 range 子句除外）。</li>
<li>各个测试数据条目必须是结构体字面值。调用前不得使用子测试名称表达式中使用的循环变量。</li>
<li>子测试名称表达式可以是测试数据中的字符串字段，测试数据字符串字段的连接以及带有 ％s 和 ％d 动词的fmt.Sprintf() 调用。</li>
</ul>
<h3 id="扩展了对-testify-的支持">扩展了对 Testify 的支持</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-testify-framework.gif"
    alt=""  />
</p>
</p>
<p>现在，IDE 可以识别启动测试套件的测试功能，并提供一种启动单个 suite.Run 和 suite.T().Run，只要子测试名称是字符串常量即可。另外，可以从“Run”工具窗口重新运行子测试，以避免重新运行整个顶级测试。</p>
<p>此外，GoLand 现在可以在一个测试用例中使用相同的方法名称分别运行 Testify 套件。</p>
<p>最后但并非最不重要的一点是，当您准备写测试函数时（testing.T 作为第一个参数），GoLand 会在可能的情况下自动传递该参数。这适用于 testify/assert，testify/require，testify/mock 和 testify/suite 包。</p>
<h2 id="03-代码检查">03 代码检查</h2>
<p><p class="md__image">
  <img src="../imgs/2020-3-incorrect-usage-println-printf.png"
    alt=""  />
</p>
</p>
<p>不正确使用类似 Println/Printf 的函数，GoLand 会有警告，之前只对标准库起作用，现在支持 github.com/pkg/errors, github.com/sirupsen/logrus 和 go.uber.org/zap 包。</p>
<p>最重要的是，我们添加了占位符突出显示和折叠，以及添加格式字符串参数的意图。</p>
<p><p class="md__image">
  <img src="../imgs/2020-3-code-inspection-cancel-function.png"
    alt=""  />
</p>
</p>
<p>context.CancelFunc（不称为代码检查）报告了 context 取消的潜在不安全使用。当 context 返回的 “cancel” 函数未在所有执行路径上调用时，此功能特别有用。</p>
<p>更多细节可以查看标准库文档：<a href="https://docs.studygolang.com/pkg/context" target="_blank" rel="noopener">https://docs.studygolang.com/pkg/context</a>
。</p>
<h2 id="04-代码编辑">04 代码编辑</h2>
<h3 id="time-包的支持">time 包的支持</h3>
<blockquote>
<p>Go 语言中文网注：Go 中的时间格式化和其他语言不一样，其他语言都是使用 YYYY、MM、dd 等，而 Go 使用魔法数字：2006-01-02 15:04:05 这样的固定时间。有些人可能记不住或习惯其他语言的格式。GoLand 2020.3 做了这样的转换，见下图。</p>
</blockquote>
<p><p class="md__image">
  <img src="../imgs/2020-3-go-time-support.gif"
    alt=""  />
</p>
</p>
<p>我们增加了对 time 包的支持，因此您可以更轻松地使用 time 和 duration。 GoLand 将通过代码补全（⌃Space）建议使用 ISO-8601 中 YYYY，MM，DD 占位符的预定义 Layout。</p>
<p>在某个 token 上按 ⌘P，IDE 将显示其含义。Layout 标记也有语法突出显示。代码完成还建议在字符串文字之外的标准时间 Layout。</p>
<h3 id="更智能的包处理">更智能的包处理</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-go-smarter-package-handling.gif"
    alt=""  />
</p>
</p>
<p>现在，IDE 可以更聪明地为您经常使用的包的提示项配置优先级，这些包是在项目的 go.mod 文件中明确声明的。</p>
<p>我们还添加了一个选项，可将包从项目导入路径和完成建议中完全排除。您可以通过 Alt + Enter 或在排除窗口中执行此操作。</p>
<h3 id="支持变量-shadowing">支持变量 shadowing</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-shadow-variables.png"
    alt=""  />
</p>
</p>
<p>GoLang 可以更轻松地发现变量 shadowing。</p>
<ul>
<li>IDE 显示的变量现在可以用不同的颜色区分 shadowing 变量。</li>
<li>导航到 shadowing 声明意图操作，使您可以立即切换到 shadowing 声明。</li>
</ul>
<h3 id="类型参数中的方括号">类型参数中的方括号</h3>
<p>我们跟踪了 Go 小组对 <a href="https://groups.google.com/g/golang-nuts/c/iAD0NBz3DYw?pli=1" target="_blank" rel="noopener">泛型</a>
 的更新，并增加了对泛型语法方括号的支持。</p>
<p>请注意，Settings | Go 中的 “<em>Enable generics (experimental support for type parameters)</em> ” 默认情况下处于关闭状态。您需要明确选择该复选框才能开始使用该功能。</p>
<p>更多关于该功能的信息可以<a href="https://blog.jetbrains.com/go/2020/11/24/experimenting-with-go-type-parameters-generics-in-goland/" target="_blank" rel="noopener">查看该文章</a>
。</p>
<h2 id="05-其他改进">05 其他改进</h2>
<p><p class="md__image">
  <img src="../imgs/2020-3-bench-test-live-templates.png"
    alt=""  />
</p>
</p>
<p>在测试文件中键入 func 时，默认情况下，GoLand 会提示出 bench 和 test 函数模板。</p>
<p><p class="md__image">
  <img src="../imgs/2020-3-for-loop-for-bench.png"
    alt=""  />
</p>
</p>
<p>当您在基准测试中输入 for 时，IDE 建议使用 b.N 的 for 循环来完成它。</p>
<h3 id="改进了拼写和语法检查器">改进了拼写和语法检查器</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-grammar-checkers.gif"
    alt=""  />
</p>
</p>
<p>现在，当您按 Alt + Enter 时，建议会立即显示在对话框中。此外，新版本的 LanguageTool 语法检查引擎还改进了英语检查功能，并增加了对 10 种其他语言的支持。</p>
<h2 id="06-和我编码结对编程">06 和我编码（结对编程）</h2>
<p><p class="md__image">
  <img src="../imgs/2020-3-code-with-me-marketplace.png"
    alt=""  />
</p>
</p>
<p>GoLand 2020.3 支持 Code With Me（EAP），这是 JetBrains 的一项新服务，用于协作开发和结对编程。与我一起编写代码使您可以与他人共享您当前在 IDE中 打开的项目，并实时进行协作。</p>
<p>关于该功能的更多信息请查看<a href="https://blog.jetbrains.com/tag/codewithme/" target="_blank" rel="noopener">这篇文章</a>
。</p>
<h2 id="07-其他">07 其他</h2>
<p>其他的改进有：</p>
<ul>
<li>UI 改进；</li>
<li>VSC 更新；</li>
<li>Web 开发增强；</li>
<li>对数据库支持增强；</li>
</ul>
<p>关于这块的详细信息可以到<a href="https://www.jetbrains.com/go/promo/whatsnew/" target="_blank" rel="noopener">这里查看</a>
。</p>
<h2 id="08-总结">08 总结</h2>
<p>GoLand 是一个收费软件，可以试用 30 天。如果觉得不错，欢迎支持！当然免费的 VSCode 也香，对吧！</p>
]]></content>
		</item>
		
		<item>
			<title>列举一些 Go1.16 中可能对大家有影响的变化</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go1.16-changes-2020/</link>
			<pubDate>Wed, 02 Dec 2020 19:20:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go1.16-changes-2020/</guid>
			<description>大家好，我是站长 polarisxu。 先说一下我一般怎么了解 Go 最新的一些动态。 01 从哪获取信息 主要通过以下方式： 逛推特，通过搜索功能，浏览 Go 信息，比如搜索：#golang since:2020-12-01 until:2020-12-02 看 Go 仓库的提交记录； 查看 https://tip.golang.org 。这个一般在一个版本开发了一段时间看，比如现在可以看 Go1.16 的一些内容，主要可以看还未完成的 Release Notes：https://tip.golang.org/doc/go1.1</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>先说一下我一般怎么了解 Go 最新的一些动态。</p>
<h2 id="01-从哪获取信息">01 从哪获取信息</h2>
<p>主要通过以下方式：</p>
<ul>
<li>
<p>逛推特，通过搜索功能，浏览 Go 信息，比如搜索：<code>#golang since:2020-12-01 until:2020-12-02</code></p>
</li>
<li>
<p>看 Go 仓库的提交记录；</p>
<p><p class="md__image">
  <img src="../imgs/go-commit-log.png"
    alt=""  />
</p>
</p>
</li>
<li>
<p>查看 <a href="https://tip.golang.org" target="_blank" rel="noopener">https://tip.golang.org</a>
。这个一般在一个版本开发了一段时间看，比如现在可以看 Go1.16 的一些内容，主要可以看还未完成的 Release Notes：<a href="https://tip.golang.org/doc/go1.16" target="_blank" rel="noopener">https://tip.golang.org/doc/go1.16</a>
。其实这个文件是 Go 代码仓库中的 doc/go1.16.html；</p>
</li>
</ul>
<p>此外，Reddit 的 r/golang 频道也会有很多信息。</p>
<h2 id="02-go-116-的一些改动">02 Go 1.16 的一些改动</h2>
<p>按计划，Go1.16 会在 2021 年 2 月份发布。目前 Release Notes 中已经有部分内容了。</p>
<h3 id="module-模式会默认开启">Module 模式会默认开启</h3>
<p>经过了这么多版本，终于默认开启了。默认开启是什么意思？即 GO111MODULE 环境变量的默认值将从 auto 改变为 on。这将解决一些目前使用 go 命令时的尴尬 。比如有些人可能说，明明我设置了 GOPROXY，但是 go get 依然没有经过它，下载依然失败。这是因为在非 modules 感知目录下运行 go get 时，自动选择了 GOPATH 模式而忽略了 GOPROXY 环境变量。如果你现在遇到这种情况，请手动将 GO111MODULE 环境变量更改为 on。</p>
<h3 id="内嵌静态资源">内嵌静态资源</h3>
<p>支持内嵌静态资源（文件或者文件夹）至生成的二进制文件中。这部分之前写文章介绍过，<a href="https://mp.weixin.qq.com/s/SiCTV7R2wA_I2nCQkC3GGQ" target="_blank" rel="noopener">见这里</a>
。</p>
<h3 id="支持最新版本-mac">支持最新版本 Mac</h3>
<p>最新版 Mac 使用了 ARM 架构，因此 Go 1.16 增加 <code>GOOS=darwin, GOARCH=arm64</code> 支持，而这之前是用于 iOS 的，以后 iOS port 改为 <code>GOOS=ios, GOARCH=arm64</code>。</p>
<h3 id="linux-系统下-rss-会更准确">Linux 系统下 RSS 会更准确</h3>
<p>在 Linux 上，runtime 现在默认会迅速地（使用 MADV_DONTNEED）向操作系统释放内存，而不是在操作系统面临内存压力时（使用 MADV_FREE）惰性地释放内存。</p>
<p>这意味着像 RSS 这样的进程级内存统计信息将更准确地反映 Go 进程所使用的物理内存数量。因此 Go1.16 中，不再需要配置 GODEBUG=madvdontneed=1 来改善内存监控行为。</p>
<h3 id="切片扩容策略改变">切片扩容策略改变</h3>
<p>如果一个 <code>append(x, values…)</code> 调用需要扩容，则基础切片 x 的容量将决定结果切片的容量（而不是原来的基础切片 x 的长度决定结果切片的容量）。</p>
<p>借用<a href="https://mp.weixin.qq.com/s/JAWKZeDSNYJlVc6GPNKqlg" target="_blank" rel="noopener">公众号 Go101</a>
 中的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">N</span> <span class="p">=</span> <span class="mi">1024</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="nx">N</span><span class="p">]</span><span class="kt">int</span>
  <span class="nx">x</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">[:</span><span class="nx">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="nx">N</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
  <span class="nx">y</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">[:</span><span class="nx">N</span><span class="p">:</span><span class="nx">N</span><span class="p">],</span> <span class="mi">9</span><span class="p">)</span>
  <span class="nb">println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">y</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>Go 1.15 将输出 2048 1280，但是使用 Go 1.16 将输出 1280 1280。</p>
<p>具体提交见：<a href="https://github.com/golang/go/commit/2333c6299f340a5f76a73a4fec6db23ffa388e97?branch=2333c6299f340a5f76a73a4fec6db23ffa388e97&amp;diff=unified" target="_blank" rel="noopener">https://github.com/golang/go/commit/2333c6299f340a5f76a73a4fec6db23ffa388e97?branch=2333c6299f340a5f76a73a4fec6db23ffa388e97&diff=unified</a>
。</p>
<h3 id="标准库">标准库</h3>
<p>1）增加了 io/fs、embed 等库。</p>
<p>2）template 允许跨行。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="p">{{</span><span class="s">&#34;hello&#34;</span> <span class="p">|</span>
   <span class="nx">printf</span><span class="p">}}</span>
</code></pre></div><p>3）strconv.ParseFloat 性能提升 2 倍。原因是它改为使用 <a href="https://nigeltao.github.io/blog/2020/eisel-lemire.html" target="_blank" rel="noopener">Eisel-Lemire 算法</a>
。这也会加速解码诸如 encoding/json 这样的文本格式。</p>
<h3 id="简化的结构体字段标签写法">简化的结构体字段标签写法</h3>
<p>在进行 Web 开发时，Model 类可能会有好几种标签，写起来很繁琐，因此还出现了不少这样辅助写标签的工具。Go 1.16 开始，结构体字段的标签中的值相同的键值对可以合并写成一个，方便很多，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">UserName</span> <span class="kt">string</span> <span class="s">`json bson gorm:&#34;user_name,omitempty&#34;`</span>
<span class="p">}</span>
</code></pre></div><h3 id="知晓-init-函数的执行时间和内存消耗">知晓 init 函数的执行时间和内存消耗</h3>
<p>关于该函数，大家都建议尽量别用，至少不能依赖它。同时不应该在其中处理耗时的事情。但之前没有很好地方法检测。Go 1.16 为 GODEBUG 环境变量增加了 inittrace=1 选项，可以输出 init 函数的执行时间和内存消耗。</p>
<p>再次借用 <a href="https://mp.weixin.qq.com/s/Lz1PwW0mzWMNxiuJBvdcXA" target="_blank" rel="noopener">Go101 的例子</a>
。</p>
<p>对于下面的程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;bye&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>使用下面的命令运行（Linux 系统，Go tip rev:7f688d18c0）:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nv">GODEBUG</span><span class="o">=</span><span class="nv">inittrace</span><span class="o">=</span><span class="m">1</span> go run main.go 
</code></pre></div><p>的输出为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">init internal/bytealg @0.018 ms, <span class="m">0</span> ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
init runtime @0.15 ms, 0.56 ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
init errors @1.7 ms, 0.010 ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
init sync @1.8 ms, 0.001 ms clock, <span class="m">16</span> bytes, <span class="m">1</span> allocs
init internal/oserror @1.8 ms, 0.001 ms clock, <span class="m">80</span> bytes, <span class="m">5</span> allocs
init syscall @1.9 ms, 0.010 ms clock, <span class="m">944</span> bytes, <span class="m">2</span> allocs
init <span class="nb">time</span> @1.9 ms, 0.014 ms clock, <span class="m">400</span> bytes, <span class="m">8</span> allocs
init context @2.0 ms, 0.002 ms clock, <span class="m">128</span> bytes, <span class="m">4</span> allocs
init math @2.0 ms, <span class="m">0</span> ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
init strconv @2.1 ms, 0.006 ms clock, <span class="m">32</span> bytes, <span class="m">2</span> allocs
init unicode @2.1 ms, 0.086 ms clock, <span class="m">23944</span> bytes, <span class="m">27</span> allocs
...
init internal/bytealg @0 ms, <span class="m">0</span> ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
init runtime @0.048 ms, 0.042 ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
hello
init main @0.21 ms, 0.004 ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
bye
</code></pre></div><p>可见此 GODEBUG 环境变量选项对于查找 init 函数中的瓶颈很有帮助。</p>
<p>相关 issue: <a href="https://github.com/golang/go/issues/41378" target="_blank" rel="noopener">https://github.com/golang/go/issues/41378</a>
。</p>
<h2 id="03-总结">03 总结</h2>
<p>Go 1.16 相比 Go 1.15 改动多不少，更多内容等待明年 2 月份发布。</p>
<p>另外推荐 Go101 这本开源书，作者对 Go 的细节掌握的很深，而且他写了双语版，这里是中文版：<a href="https://github.com/golang101/golang101" target="_blank" rel="noopener">https://github.com/golang101/golang101</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>Hugo &#43; GitHub Pages 搭建自己的网站</title>
			<link>https://polarisxu.studygolang.com/posts/talk/myblog-with-hugo-github-pages/</link>
			<pubDate>Tue, 01 Dec 2020 11:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/myblog-with-hugo-github-pages/</guid>
			<description>大家好，我是站长 polarisxu。 很早之前，我使用 WordPress 搭建了个人博客：http://blog.studygolang.com ，毕竟那时候 WordPress 是首选。现如今，大家似乎更喜欢静态博客，各种语言的静态博客生成器轮子不断，比如 Go 语言的 Hugo 就是一个静态博客生成器。我个人认为，静态博客生成器流行的一个很大原因，是 Markdown 的流行，开发人员习惯了使用 Markdown 进行写作。 对于我，有另外一个痛点</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>很早之前，我使用 WordPress 搭建了个人博客：<a href="http://blog.studygolang.com" target="_blank" rel="noopener">http://blog.studygolang.com</a>
，毕竟那时候 WordPress 是首选。现如今，大家似乎更喜欢静态博客，各种语言的静态博客生成器轮子不断，比如 Go 语言的 Hugo 就是一个静态博客生成器。我个人认为，静态博客生成器流行的一个很大原因，是 Markdown 的流行，开发人员习惯了使用 Markdown 进行写作。</p>
<p>对于我，有另外一个痛点。最近在公众号写了一些文章，希望同步到博客，只是文字还好处理些，如果涉及到图片，微信公众号上传了一次，博客还得再来一次，挺费劲的。同时，为了保留最原始的文字，原始博文放在 GitHub 是一个不错的选择（用 Git 保留你的修改，不要太棒好嘛！）。</p>
<p>既然博文都保存在了 GitHub 上，怎么方便快速的基于 GitHub 来搭建自己的博客呢？（有些人直接就让在 GitHub 阅读，虽然可以，但体验还是不太好，而且看起来没有那么高大上，是不是？）</p>
<p>我想过使用 GitBook 来搭建，安装时，发现官方已经不维护 gitbook-cli 了，而且每次新增加文章，都得维护目录等，也是挺费劲的。于是放弃了这种方式。</p>
<p>这时我想到了通过静态博客生成器来搞。最喜欢 Go，自然 Hugo 成为第一选择。</p>
<p>废话不多少，记录下我搭建的过程。</p>
<h2 id="01-安装-hugo">01 安装 Hugo</h2>
<p>你可以通过 <a href="https://github.com/gohugoio/hugo/releases" target="_blank" rel="noopener">https://github.com/gohugoio/hugo/releases</a>
 下载相应的安装包，我喜欢源码安装。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get -v github.com/gohugoio/hugo
</code></pre></div><p>如果你也想通过源码安装，请自行准备好 Go 环境。</p>
<p>查看版本同时验证是否安装成功：（查看该文时，最新版本可能变了）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ hugo version
Hugo Static Site Generator v0.76.5 darwin/amd64 BuildDate: unknown
</code></pre></div><h2 id="02-使用-hugo">02 使用 Hugo</h2>
<p>在你本机某个目录执行如下命令，创建一个网站，我使用 polarisxu 这个名字。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ hugo new site polarisxu
Congratulations! Your new Hugo site is created in /Users/xuxinhua/project/testhugo/polarisxu.

Just a few more steps and you<span class="err">&#39;</span>re ready to go:

1. Download a theme into the same-named folder.
   Choose a theme from https://themes.gohugo.io/ or
   create your own with the <span class="s2">&#34;hugo new theme &lt;THEMENAME&gt;&#34;</span> command.
2. Perhaps you want to add some content. You can add single files
   with <span class="s2">&#34;hugo new &lt;SECTIONNAME&gt;/&lt;FILENAME&gt;.&lt;FORMAT&gt;&#34;</span>.
3. Start the built-in live server via <span class="s2">&#34;hugo server&#34;</span>.

Visit https://gohugo.io/ <span class="k">for</span> quickstart guide and full documentation.
</code></pre></div><p>进入 polarisxu 目录，查看目录结构如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ tree
.
├── archetypes
│   └── default.md
├── config.toml
├── content
├── data
├── layouts
├── static
└── themes

<span class="m">6</span> directories, <span class="m">2</span> files
</code></pre></div><p>接下来需要为我们的网站指定一个主题，这里我们选择 <a href="https://themes.gohugo.io/hermit/" target="_blank" rel="noopener">https://themes.gohugo.io/hermit/</a>
 这个主题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git clone https://github.com/Track3/hermit.git themes/hermit
</code></pre></div><p>将该主题增加到网站的配置文件中，这样才能生效：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s1">&#39;theme = &#34;hermit&#34;&#39;</span> &gt;&gt; config.toml
</code></pre></div><p>测试下是否成功，运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ hugo serve
</code></pre></div><p>打开浏览器访问：<a href="http://localhost:1313/" target="_blank" rel="noopener">http://localhost:1313/</a>
，看到如下内容：</p>
<p><p class="md__image">
  <img src="../imgs/hugo01.png"
    alt=""  />
</p>
</p>
<p>对该主题进行一些配置。一般的，主题会有例子，我们直接拷贝例子中的 config.toml 覆盖网站的 config.toml：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ cp -rf themes/hermit/exampleSite/config.toml .
</code></pre></div><p>再次运行 <code>hugo serve</code>，页面如下：</p>
<p><p class="md__image">
  <img src="../imgs/hugo02.png"
    alt=""  />
</p>
</p>
<p>可见，这个页面内容可以通过 config.toml 配置，根据需要做一些修改，页面变成这样：（不同主题可能不一样）</p>
<p><p class="md__image">
  <img src="../imgs/hugo04.png"
    alt=""  />
</p>
</p>
<p>不过点击 「文章」 和 「关于」 都报 404。</p>
<h3 id="增加列表页">增加列表页</h3>
<p>在 content/posts 目录下新增一个文件：<code>_index.md</code>，内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown">---
title: &#34;文章列表&#34;
---
</code></pre></div><p>这时（hugo serve 会自动编译）点击 Posts，页面如下：</p>
<p><p class="md__image">
  <img src="../imgs/hugo03.png"
    alt=""  />
</p>
</p>
<h3 id="增加-about-页面">增加 About 页面</h3>
<p>同样的，在 content/posts 目录下新增文件 <code>about.md</code>，正文内容随意，类似这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown">---
title: &#34;关于&#34;
date: &#34;2020-12-01&#34;
---

这是关于页面，polarisxu。
</code></pre></div><h3 id="测试文章">测试文章</h3>
<p>接着，增加一篇测试文章：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ hugo new posts/my-first-post.md
</code></pre></div><p>这会在 content/posts 目录下生成一个 my-first-post.md 文件，里面内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown">---
title: &#34;My First Post&#34;
date: 2020-11-30T23:33:03+08:00
draft: true
toc: false
images:
tags:
  <span class="k">-</span> untagged
---
</code></pre></div><p>其中 <code>---</code> 之间的数据是文章的元数据，在 Hugo 中叫做 <a href="https://gohugo.io/content-management/front-matter/" target="_blank" rel="noopener">Front Matter</a>
。</p>
<p>随意增加一些内容，并做一些修改：（其中 isCJKLanguage: true 用于准确计算中文字数）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown">---
title: &#34;第一篇文章&#34;
date: 2020-11-30T23:33:03+08:00
draft: false
toc: false
isCJKLanguage: true
images:
tags: 
  <span class="k">-</span> 文章
---

这是第一篇文章。。。
</code></pre></div><p>查看文章详情：<a href="http://localhost:1313/posts/my-first-post/" target="_blank" rel="noopener">http://localhost:1313/posts/my-first-post/</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/hugo05.png"
    alt=""  />
</p>
</p>
<p>如果文章完成，可以执行 <code>hugo</code> 命令，生成静态页面。默认会将生成的静态页面放入 public 目录中。</p>
<p>关于 Hugo 更多的定制，比如 theme 的定制，这里不过多讲解，有兴趣的自己琢磨。比如虽然 <a href="https://polarisxu.studygolang.com/" target="_blank" rel="noopener">https://polarisxu.studygolang.com/</a>
 和这里的例子使用了同一个模板，但样子却有不少不同，你可以查看 <a href="https://github.com/polaris1119/polarisxu" target="_blank" rel="noopener">https://github.com/polaris1119/polarisxu</a>
，对比到底做了什么，折腾一番，基本会了。</p>
<h2 id="03-使用-github-pages-部署站点">03 使用 GitHub Pages 部署站点</h2>
<p>这是 GitHub 为你和你的项目准备网站的，GitHub Pages 官方站点：<a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com/</a>
，大概就是通过将网站内容放到 GitHub，通过 GitHub Pages 可以弄出一个自己的站点。它最常使用的是通过 Jekyll 这个站点生成器生成静态页面，有兴趣的自行查阅资料了解。我们应该使用 Hugo 生成静态页面，因此直接将静态页面部署到 GitHub Pages。</p>
<h3 id="创建一个特殊的仓库">创建一个特殊的仓库</h3>
<p>在 GitHub 上创建一个仓库，不过仓库名有特殊要求。如果是个人账号，比如我的 GitHub ID 是 polaris1119，则仓库名是：polaris1119.github.io；如果是组织账号，比如 studygolang 这个组织，则仓库名是：studygolang.github.io。</p>
<h3 id="配置仓库">配置仓库</h3>
<p>进入仓库的 Settings 页面，有一个区块叫 GitHub Pages，可以配置站点信息，比如内容来源、自定义域名、是否启用 HTTPS 等。</p>
<p><p class="md__image">
  <img src="../imgs/hugo06.png"
    alt=""  />
</p>
</p>
<p>说明如下：</p>
<ul>
<li>数据源默认使用主分支下的根目录，我个人建议改为 docs 目录；</li>
<li>自定义域名如果留空，则默认仓库名就是你的域名，比如我这里的 polaris1119.github.io；</li>
<li>如果配置了自定义域名，则需要在你的域名配置上 CNAME 记录。我这里就是 polarisxu 这个子域名的 CNAME 值是 polaris1119.github.io；</li>
<li>如果配置了自定义域名，启用 HTTPS 需要等待一段时间才能生效；</li>
</ul>
<p>你可以在该仓库上正确的位置放置一个 index.html 文件，测试是否正常。</p>
<blockquote>
<p>小细节：避免 Jekyll 起作用，可以在仓库根目录放一个空文件，文件名： .nojekyll</p>
</blockquote>
<h3 id="部署我们的站点">部署我们的站点</h3>
<p>这里有两种做法。</p>
<p><strong>1）方法一</strong></p>
<p>上面 Hugo 项目的代码直接推送到 GitHub Pages 这个仓库中，在通过 Hugo 生成静态页面时，指定目标目录为 docs：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ hugo -d docs
</code></pre></div><p>这样 docs 下面的内容就是静态页面，是网站最终展示的内容。</p>
<p><strong>2）方法二</strong></p>
<p>Hugo 源网站内容单独放在一个仓，比如我放在了 <a href="https://github.com/polaris1119/polarisxu" target="_blank" rel="noopener">https://github.com/polaris1119/polarisxu</a>
 这个仓库。这样分两个仓库相对麻烦先。但也有一个好处：GitHub Pages 站点有内容大小限制：不能超过 1 GB，这样分开可以节省空间，而且 Hugo 内容和站点解耦。</p>
<p>因此每次在 Hugo 站点项目写完文章后，需要生成静态内容，拷贝到 GitHub Pages 仓库，提交代码等。把这些步骤写成一个脚本，瞬间变简单了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="cp">#!/bin/sh
</span><span class="cp"></span>
hugo

cp -rf public/* ../polaris1119.github.io/docs/

<span class="nb">cd</span> ../polaris1119.github.io/

git add * <span class="o">&amp;&amp;</span> git commit -m <span class="s1">&#39;new article&#39;</span> <span class="o">&amp;&amp;</span> git push

<span class="nb">cd</span> ../polarisxu/
</code></pre></div><h2 id="04-总结">04 总结</h2>
<p>技术人员搞个自己的博客还是不错的，开始时花些时间折腾一个自己喜欢的站点，之后就是抽时间产出内容了。通过上面的介绍可知，现在搭建一个站点，完全不需要投入任何 money。</p>
<p>怎么样？有没有冲动自己搞一个。欢迎交流~</p>
]]></content>
		</item>
		
		<item>
			<title>Russ Cox 又有动态了：开源了一个 Go 工具</title>
			<link>https://polarisxu.studygolang.com/posts/talk/go-rsc-dynamic/</link>
			<pubDate>Sat, 21 Nov 2020 21:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/go-rsc-dynamic/</guid>
			<description>前天发了一篇文章，介绍了 Go 的名人，Go Team 现在的 Leader Russ Cox 。 01 这两天在大牛的 GitHub 上看到他开源了一个新的工具：一个实验性的，用于 Go 语言的重构工具。 项目地址：https://github.com/rsc/rf 。 开源后，立马有人跟进：https://changelog.com/news/russ-coxs-experimental-new-refactoring-tool</description>
			<content type="html"><![CDATA[<p>前天发了一篇文章，介绍了 Go 的名人，<a href="https://mp.weixin.qq.com/s/kmcJRBahAl4gtPzZUvd5bg" target="_blank" rel="noopener">Go Team 现在的 Leader Russ Cox</a>
。</p>
<h2 id="01">01</h2>
<p>这两天在大牛的 GitHub 上看到他开源了一个新的工具：一个实验性的，用于 Go 语言的重构工具。</p>
<p>项目地址：<a href="https://github.com/rsc/rf" target="_blank" rel="noopener">https://github.com/rsc/rf</a>
。</p>
<p>开源后，立马有人跟进：<a href="https://changelog.com/news/russ-coxs-experimental-new-refactoring-tool-for-go-NoN0" target="_blank" rel="noopener">https://changelog.com/news/russ-coxs-experimental-new-refactoring-tool-for-go-NoN0</a>
</p>
<blockquote>
<p>It’s just 18 commits deep at the time of logging, but when one of Go’s authors fires up a new project (and a refactoring tool at that), it’s worth following along to see what develops.</p>
</blockquote>
<p>目前该工具还不成熟。我初步猜测，如果成熟了，可能会被用于各大文本编辑器，辅助进行 Go 代码重构。</p>
<p>目前项目的 README.md 上没什么说明，但有一个 doc.go 文件。我尝试使用 pkg.go.dev 查看，发现 404：<a href="https://pkg.go.dev/github.com/rsc/rf" target="_blank" rel="noopener">https://pkg.go.dev/github.com/rsc/rf</a>
</p>
<p><p class="md__image">
  <img src="../imgs/rf.png"
    alt=""  />
</p>
</p>
<p>这时点击下方的 Request “github.com/rsc/rf”，页面提示：</p>
<blockquote>
<p>“github.com/rsc/rf” is not a valid package or module. Were you looking for “rsc.io/rf”?</p>
</blockquote>
<p>因此改为 <a href="https://pkg.go.dev/rsc.io/rf" target="_blank" rel="noopener">https://pkg.go.dev/rsc.io/rf</a>
 即可正常访问。在该项目的 go.mod 文件中开头有这一行：</p>
<blockquote>
<p>module rsc.io/rf</p>
</blockquote>
<p>官方号称 pkg.go.dev 是更懂 go mod 的，我觉得访问 <a href="https://pkg.go.dev/github.com/rsc/rf" target="_blank" rel="noopener">https://pkg.go.dev/github.com/rsc/rf</a>
 应该能自动重定向到 <a href="https://pkg.go.dev/rsc.io/rf" target="_blank" rel="noopener">https://pkg.go.dev/rsc.io/rf</a>
 才对。有兴趣的可以看看 rf 的文档。</p>
<blockquote>
<p>知识点：上面 github.com/rsc/rf 之所以可以定义为 rsc.io/rf，是因为 rsc.io/rf 做了自定义包导入路径。你可以通过 <code>curl https://rsc.io/rf</code> 命令，查看输出结果，其中有这么一行代码：<code>&lt;meta name=&quot;go-import&quot; content=&quot;rsc.io/rf git https://github.com/rsc/rf&quot;&gt;</code> 这是关键。</p>
</blockquote>
<h2 id="02">02</h2>
<p>借此，介绍 Russ Cox 另外两个开源项目，当然是 Go 语言实现的。</p>
<ul>
<li>Two-factor 验证命令行工具，Star 数 1.1k+，项目地址：<a href="https://github.com/rsc/2fa" target="_blank" rel="noopener">https://github.com/rsc/2fa</a>
；</li>
<li>大型文件树上的快速索引正则表达式搜索工具，Star 数 2.5k+，项目地址：<a href="https://github.com/google/codesearch" target="_blank" rel="noopener">https://github.com/google/codesearch</a>
，他还专门写了文章介绍。Google 代码搜索是如何工作的？<a href="https://swtch.com/~rsc/regexp/regexp4.html" target="_blank" rel="noopener">https://swtch.com/~rsc/regexp/regexp4.html</a>
</li>
</ul>
<h2 id="03">03</h2>
<p>借用曹大（Xargin）的话，你应该在 GitHub 上关注那些大神，通过他们的动态可以发现好玩的东西，更可以学习到新东西！</p>
<p>我不是大牛，但我会经常 Star 一些 Go 项目，欢迎大家去 GitHub 关注我：<a href="https://github.com/polaris1119" target="_blank" rel="noopener">https://github.com/polaris1119</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 语言名人：除了 Rob Pike，很多人可能不知道他</title>
			<link>https://polarisxu.studygolang.com/posts/talk/go-celebrity-rsc/</link>
			<pubDate>Thu, 19 Nov 2020 19:20:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/go-celebrity-rsc/</guid>
			<description>大家好，我是站长 polarisxu。 今天和大家聊聊 Go 语言名人的那些事。 01 说起 Go 语言，很多人知晓有三个创始人。在 2007 年 09 月 25 日，Rob Pike 发了一封邮件： 所以一般认为 Rob Pike、Robert Griesemer 和 Ken Thompson 是 Go 的创始人，而很长一段时间，Rob Pike 在引领 Go 团队，同时在一些公众场合经常出现，因此大家对 Rob Piike 更熟悉。关于他们三个的情况，网上资料挺多的，这里不说了。 今天说的是另外一个人</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天和大家聊聊 Go 语言名人的那些事。</p>
<h2 id="01">01</h2>
<p>说起 Go 语言，很多人知晓有三个创始人。在 2007 年 09 月 25 日，Rob Pike 发了一封邮件：</p>
<p><p class="md__image">
  <img src="../imgs/rsc01.jpg"
    alt=""  />
</p>
</p>
<p>所以一般认为 Rob Pike、Robert Griesemer 和 Ken Thompson 是 Go 的创始人，而很长一段时间，Rob Pike 在引领 Go 团队，同时在一些公众场合经常出现，因此大家对 Rob Piike 更熟悉。关于他们三个的情况，网上资料挺多的，这里不说了。</p>
<p>今天说的是另外一个人。在 Go 项目启动后不久，Russ Cox 和 Lance Taylor 也加入了 Go 语言的设计团队。他们 5 人一起开发了两款编译器和一个标准库，为 2009 年 11 月 10 日 Go 语言以开源方式发布打下了基础。</p>
<p><p class="md__image">
  <img src="../imgs/rsc02.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>问题：为什么说开发了两款编译器？</p>
</blockquote>
<p>是的，今天要说的这个人就是 Russ Cox，他是现在 Go Team 的 Leader。</p>
<h2 id="02">02</h2>
<p>Russ Cox，网络上的昵称是 rsc，2008 年博士毕业于 MIT（麻省理工学院），毕业后就加入了 Go 核心设计开发团队，非常年轻。下面是毕业证信息，在 MIT 网站可以查到：<a href="https://pdos.csail.mit.edu/~rsc/" target="_blank" rel="noopener">https://pdos.csail.mit.edu/~rsc/</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/rsc03.png"
    alt=""  />
</p>
</p>
<p>关于 Russ Cox 加入 Google 进入 Go Team 团队有一段小故事，这是 Russ Cox 本人在 2018 年 4 月份参加<a href="https://changelog.com/gotime/77" target="_blank" rel="noopener">第 77 期 GoTime</a>
 时讲述的。</p>
<blockquote>
<p>我上大学时就曾与 Rob Pike 合作参与 Plan 9 操作系统的开发，之后在 Google 研究院实习。当我读完研究生（博士）时，Rob 告诉我有关 Go 的内容，大概是说：“我们正在尝试吸收我们在 Plan 9 上开发软件时真正喜欢的所有东西，并使它们能够用于我们在 Google 的日常编程中。你想帮忙吗？”我当时想，“是的，当然。” 就这样我加入了 Go 团队。</p>
<p>有趣的是，我在想这件事（因为你可能会问这个&hellip;那是十年前的事了），我自己不敢相信这有多幸运，因为我完成博士研究生学业的时候，这份工作随之而来，就像是我过去十年所做的所有事情的完美结合。似乎过去做的事情是为做 Go 这件事做铺垫。 然后我和所有这些伟大的人一起工作，比如 Rob，Ken，Robert Griesemer，Ian Taylor。。。我们辛苦了两年，然后 Go 开源了。</p>
<p>然后真正令人惊讶的事情发生了，坦诚地说，我们没有人预料到，我们选择开源后，人们竟然想使用 Go。这对我们来说很震惊。 我在发布（开源发布）前几天对 Rob  说，我希望也许有几个人会注意到，理想的情况是，无论下一个大语言是什么，都会窃取 Go 的并发和接口思想。这将是我们使编程更好一点的微小贡献。</p>
</blockquote>
<p>大牛果然一开始就很厉害！</p>
<p>此外在这个 Go Time 中，Russ Cox 谈到了较多 Plan9 的事情以及大篇幅说道 vgo 的设计。当然还有很多其他内容，虽然过去 2 年了，感兴趣的可以去读一读。</p>
<p>实际上，几年前开始，Russ Cox 就已经是 Go Team 的技术负责人（Leader）。他会做一些领导工作，并帮助确定优先事项等。很多拿不定主意的决策都是 Russ Cox 最后拍板，很多时候他都是力排众议。相信大家印象最深的就是他设计的 vgo，即 Go Module 的前身，在这之前可是已经有了 dep 这个准官方解决方案。为此有一个 Go 的社区贡献者写文说 Go 是 Google 的而非社区的。Russ Cox 对此进行了<a href="https://groups.google.com/g/golang-nuts/c/6dKNSN0M_kg/m/Y1yDJRwQBgAJ" target="_blank" rel="noopener">回应</a>
，同时引用了他 2015 年发表在 <a href="https://docs.studygolang.com/blog/open-source" target="_blank" rel="noopener">Go 官方博客上的文章</a>
（那时候似乎就意识到会有这样的事情发生？）。这里我不做任何评价，相信每个人心里有自己的一杆秤。</p>
<p>在整个 Go 代码仓库中，Russ Cox 提交的代码量是最多的。</p>
<p><p class="md__image">
  <img src="../imgs/rsc04.png"
    alt=""  />
</p>
</p>
<h2 id="03">03</h2>
<p>推荐下 Russ Cox 的博客：<a href="https://research.swtch.com/" target="_blank" rel="noopener">https://research.swtch.com/</a>
，涉猎比较广。其中有一篇文章预测了<a href="https://research.swtch.com/gophercount" target="_blank" rel="noopener">世界上有多少 Go Developers</a>
。你觉得有多少？</p>
<p>Russ Cox 预测，截至 2019 年 11 月，估计是 115 万到 196 万。</p>
<p>他给了一个预测的方法：</p>
<blockquote>
<p>Number of Go Developers    =    Number of Software Developers   ×   Fraction using Go</p>
</blockquote>
<p>所以我们需要回答世界上有多少软件开发人员，以及他们使用 Go 的百分比。这些数据主要通过一些第三方发布的调查、统计得到。有兴趣的可以看看他的预测方法。</p>
<p>最后他得出：</p>
<ul>
<li>
<p>2017 年 7 月，在 1680 万-2100 万的开发者中，有 3%-4.6％  Go 开发者，即 50 万 — 90 万；</p>
</li>
<li>
<p>在 2018 年 7 月，在 1840 万-2300 万的开发者中，有 4.6%-7.1％ Go 开发者，即 85 万 - 163 万；</p>
</li>
<li>
<p>在 2019 年 11 月，在 1890 万-2390 万的开发者中，有 6.1%-8.2％ Go 开发者，即 115 万 - 196 万；</p>
</li>
</ul>
<p>你觉得中国有多少 Go 开发者？</p>
<h2 id="04">04</h2>
<p>Go 有这样的大牛主导开发，未来会越来越好！</p>
<p><p class="md__image">
  <img src="../imgs/rsc05.png"
    alt=""  />
</p>
</p>
<p>看看大牛的书房，除了各种书，我相信吸引你眼光的是那些 gopher 小玩偶吧！</p>
<p>关于 Russ Cox，你还知道哪些事情？欢迎留言交流。</p>
]]></content>
		</item>
		
		<item>
			<title>聊聊 Go 和创业</title>
			<link>https://polarisxu.studygolang.com/posts/talk/go-and-business/</link>
			<pubDate>Wed, 18 Nov 2020 18:40:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/go-and-business/</guid>
			<description>昨天 PingCAP 完成 D 轮 2.7 亿美元融资的消息，相信很多人看到了。PingCAP 今天的成就，对开源界真是极大的鼓舞。祝贺祝贺！ 01 PingCAP 成立于 2015 年，是一家企业级开源分布式数据库厂商，提供包括开源分布式数据库产品、解决方案与咨询、技术支持与培训认证服务，致力于为全球行业用户提供稳定高效、安全可靠、开放兼容的新型数据基础设施，解放企业生产力，加速企业数字化转型升级。 由 PingCAP 创立的分布式</description>
			<content type="html"><![CDATA[<p>昨天 PingCAP 完成 D 轮 2.7 亿美元融资的消息，相信很多人看到了。PingCAP 今天的成就，对开源界真是极大的鼓舞。祝贺祝贺！</p>
<h2 id="01">01</h2>
<p>PingCAP 成立于 2015 年，是一家企业级开源分布式数据库厂商，提供包括开源分布式数据库产品、解决方案与咨询、技术支持与培训认证服务，致力于为全球行业用户提供稳定高效、安全可靠、开放兼容的新型数据基础设施，解放企业生产力，加速企业数字化转型升级。</p>
<p>由 PingCAP 创立的分布式关系型数据库 TiDB，为企业关键业务打造，具备「分布式强一致性事务、在线弹性水平扩展、故障自恢复的高可用、跨数据中心多活」等企业级核心特性，帮助企业最大化发挥数据价值，充分释放企业增长空间。</p>
<p>对 TiDB 有所耳闻的都知道，它是使用 Go 语言实现的，它的创始人兼 CEO 刘奇早期就活跃在 Go 社区，早在豌豆荚，他就主导开源了 <a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener">Codis</a>
。</p>
<p>PingCAP 的员工，一直活跃在各大社区，包括频频出席各种技术交流、分享场所，他们创业早期，刘奇本人都经常分享 TiDB。5 年的时间，做出这样的成绩，真的是开源界特别值得骄傲的事情。这样纯技术驱动的公司，是不是每个技术人员向往的呢？！</p>
<h2 id="02">02</h2>
<p>另一个创业公司，也是和 Go 有关：七牛。相信 Go 圈内知道的更多。我个人的看法，七牛和 Go 是相互成就的。</p>
<p>七牛成立于 2011 年 6 月，那时候 Go1.0 还未发布（Go1.0 是 2012 年 3 月 28 日发布的）。七牛的创始人兼 CEO 许式伟离开盛大创新院创办七牛云时，面临技术选型。尽管 Go 正式版本都还未发布，但他很坚决地选择了 Go 语言。为此他还专门给团队发了一封邮件，邮件中有一段是这么说的：</p>
<blockquote>
<p>在创业过程中我们会面临很多选择，也会有很多选择后来会被证明是错的，但是今天我可以确定的是，选择 Go 将会成为我们最正确的选择。</p>
</blockquote>
<p>在选择了 Go 语言后，考虑到 Go 仍然是一门十分小众的语言，七牛开始有意识地培养 Go 中国社区。为了让更多人能够知道 Go，加入 Go 的行列，他们做了很多工作，比如启动了《Go 语言编程》一书的编写工作，并最终和 Go 1.0 版本同步发布。2012 年 2 月，许老板首次在公开场合说：Go 会超过 C、Java，成为最流行的语言。这一年他到处宣讲，做了不下十场的 Go 语言讲座，平均每个月有一场。讲得最多的一个 PPT 是《Go，Next C》这篇，它基本上算他对 Go 的革命性到底在哪里的一个总结。对于一个初创公司来说，为一个并不属于自己业务的技术这么花时间去宣传，有些人可能会觉得比较不可理解。但是实际上有三个理由支撑他们这么做：</p>
<ul>
<li>Go 真的是一门革命性的语言，它的流行将对产业发展具重大意义。</li>
<li>Go 仍然是一门小众语言，而我们不止要招 Go 程序员，更重要的是要说服他们相信 Go 语言是有远大前景的专业技能方向。</li>
<li>七牛的用户是程序员，我们需要建立在用户心目中的专家形象。</li>
</ul>
<p>大家看到了现在 Go 语言的发展势头，同时作为一个创业公司，七牛云今年 6 月份获得了 F 轮 10 亿人民币的融资。</p>
<p>七牛为 Go 的发展做了很大的贡献，另一方面，我认为，正是因为借助 Go，也让七牛发展的更好。</p>
<h2 id="03">03</h2>
<p>再聊一个和 Go 没啥关系的公司，但相信大家都知晓。</p>
<p>掘金社区，大家不陌生。号称是一个帮助开发者成长的社区，是给开发者用的 Hacker News，给设计师用的 Designer News，和给产品经理用的 Medium。</p>
<p>2015 年阴明（网名 kalasoo） 创办了稀土掘金公司（2014 年底获得天使轮融资），运营掘金社区网站，16 年初获得 Pre-A 轮融资，17 年中旬获得 A 轮融资。之后并没有获得融资，运营很艰难。我记得去年，阴明大佬还做了一次女装直播，还发了文章，据说公司没有开发人员了，自己得学全栈技术，维护网站的运营，感觉随时有倒闭的风险。</p>
<p>今年 8 月份，听字节跳动的朋友说，在公司内部发现了掘金这个部门，而且在内部可以搜到掘金创始人和站长。前段时间，也证实了字节跳动收购了掘金。具体见：<a href="https://xw.qq.com/cmsid/20201104A04LTM00" target="_blank" rel="noopener">https://xw.qq.com/cmsid/20201104A04LTM00</a>
。</p>
<p>被收购，对掘金来说，也许是一个不错的出路。</p>
<h2 id="04">04</h2>
<p>常说创业九死一生，而我自己也一直在创业中（并非 Go 语言中文网），个中滋味只有自己清楚。作为技术人员，PingCAP、七牛 这样技术驱动的公司是很向往的，但自己作为创始人是很难的。</p>
<p>掘金，外面看来，网站做的很不错，但一直却活得很辛苦。我个人也运营了一个网站，投入的时间和心血，只有我自己知晓，它一直还只是我的个人项目，也许一直会是我的个人爱好项目。当时听到掘金被并购的消息，同样作为网站创建者，感触颇多，如果有资本的进入，也许就不能只是爱好了。。。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://www.sohu.com/a/197332119_355140" target="_blank" rel="noopener">https://www.sohu.com/a/197332119_355140</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>通过这个 Runtime 统计信息可视化库学到了什么？</title>
			<link>https://polarisxu.studygolang.com/posts/go/pkg/statsview/</link>
			<pubDate>Tue, 17 Nov 2020 15:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/pkg/statsview/</guid>
			<description>大家好，我是站长 polarisxu。 掌握系统运行状态，知道系统哪些地方可能存在问题，方便进行优化，这是一个实际系统必备的。裸奔，对系统一无所知，迟早是要出大事的。 在 Go 语言中，官方标准库提供了方法，让我们能够获得内存分配、GC 和 Goroutine 等情况。比如内存、GC 等情况，可以通过 runtime.MemStats 获取：https://docs.studygolang.com/pkg/runtime/#M</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>掌握系统运行状态，知道系统哪些地方可能存在问题，方便进行优化，这是一个实际系统必备的。裸奔，对系统一无所知，迟早是要出大事的。</p>
<p>在 Go 语言中，官方标准库提供了方法，让我们能够获得内存分配、GC 和 Goroutine 等情况。比如内存、GC 等情况，可以通过 runtime.MemStats 获取：<a href="https://docs.studygolang.com/pkg/runtime/#MemStats" target="_blank" rel="noopener">https://docs.studygolang.com/pkg/runtime/#MemStats</a>
，Goroutine 数量可以通过 runtime.NumGoroutine() 函数获得。</p>
<p>一般我们我们需要自己解析 MemStats 信息、做展示，也可以做图表。</p>
<p>之前推荐过一个在浏览器中实时查看 Go 应用程序运行时统计信息（GC，MemStats 等）的库：<a href="https://polarisxu.studygolang.com/posts/go/pkg/statsviz/" target="_blank" rel="noopener">statsviz</a>
。今天给大家推荐另外一个库：<a href="https://github.com/go-echarts/statsview" target="_blank" rel="noopener">https://github.com/go-echarts/statsview</a>
，这是这两天刚出来的。</p>
<p>看长什么样：</p>
<p><p class="md__image">
  <img src="../imgs/statsview.png"
    alt=""  />
</p>
</p>
<p>我们可以运行下面这段代码得到类似上面的图：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/go-echarts/statsview&#34;</span>
    <span class="s">&#34;time&#34;</span>
    <span class="s">&#34;math/rand&#34;</span>
    <span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nf">work</span><span class="p">()</span>
    <span class="nx">mgr</span> <span class="o">:=</span> <span class="nx">statsview</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

    <span class="c1">// Start() runs a HTTP server at `localhost:18066` by default.
</span><span class="c1"></span>    <span class="nx">mgr</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>

    <span class="c1">// Stop() will shutdown the http server gracefully
</span><span class="c1"></span>    <span class="c1">// mgr.Stop()
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">work</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Generate some allocations
</span><span class="c1"></span>    <span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">byte</span><span class="p">{}</span>

    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">512</span><span class="o">+</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="p">))</span>
        <span class="nx">m</span><span class="p">[</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">100</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">b</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">byte</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="01-如何使用">01 如何使用</h2>
<blockquote>
<p>都 Go1.15.x 了，请使用 go module。</p>
</blockquote>
<p>statsview 的使用较简单。</p>
<ul>
<li>import &ldquo;github.com/go-echarts/statsview”</li>
<li>mgr := statsview.New()</li>
<li>mgr.Start()</li>
<li>打开浏览器访问：http://localhost:18066/debug/statsview</li>
<li>尽情享受吧~</li>
</ul>
<p>此外，可以通过 <code>viewer.SetConfiguration(opts …Option)</code>改变一些行为，包括：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// WithInterval sets the interval(in millisecond) of collecting and pulling metrics
</span><span class="c1">// default -&gt; 1500
</span><span class="c1"></span><span class="nf">WithInterval</span><span class="p">(</span><span class="nx">interval</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Option</span>

<span class="c1">// WithMaxPoints sets the maximum points of each chart series
</span><span class="c1">// default -&gt; 40
</span><span class="c1"></span><span class="nf">WithMaxPoints</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Option</span>

<span class="c1">// WithTemplate sets the rendered template which fetching stats from the server and
</span><span class="c1">// handling the metrics data
</span><span class="c1"></span><span class="nf">WithTemplate</span><span class="p">(</span><span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Option</span>

<span class="c1">// WithAddr sets the listen address
</span><span class="c1">// default -&gt; &#34;localhost:18066&#34;
</span><span class="c1"></span><span class="nf">WithAddr</span><span class="p">(</span><span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Option</span>

<span class="c1">// WithTimeFormat sets the time format for the line-chart Y-axis label
</span><span class="c1">// default -&gt; &#34;15:04:05&#34;
</span><span class="c1"></span><span class="nf">WithTimeFormat</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Option</span>

<span class="c1">// WithTheme sets the theme of the charts
</span><span class="c1">// default -&gt; Macarons
</span><span class="c1">//
</span><span class="c1">// Optional:
</span><span class="c1">// * ThemeWesteros
</span><span class="c1">// * ThemeMacarons
</span><span class="c1"></span><span class="nf">WithTheme</span><span class="p">(</span><span class="nx">theme</span> <span class="nx">Theme</span><span class="p">)</span> <span class="nx">Option</span>
</code></pre></div><p>例如修改默认端口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">viewer</span><span class="p">.</span><span class="nf">SetConfiguration</span><span class="p">(</span><span class="nx">view</span><span class="p">.</span><span class="nf">WithAddr</span><span class="p">(</span><span class="s">&#34;localhost:8087&#34;</span><span class="p">)</span>
</code></pre></div><p>不像之前介绍的 statsviz，statsview 固定使用 net/http，所以集成到项目中只需要让它在单独的一个 goroutine 中运行，单独的端口即可。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">mgr</span> <span class="o">:=</span> <span class="nx">statsview</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">mgr</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
<span class="p">}()</span>
</code></pre></div><p>其实这也是在介绍 statsviz 时的最佳实践。毕竟 runtime 信息属于系统内部信息，不适合暴露给公网用户。</p>
<h2 id="02-学习相关实现">02 学习相关实现</h2>
<p>和 <a href="https://polarisxu.studygolang.com/posts/go/pkg/statsviz/" target="_blank" rel="noopener">statsviz</a>
 不同，该库没有使用 WebSocket 协议，直接通过轮询的方式不断获取数据。另外，因为 statsview 是 go-echarts 出的，因此画图也使用的是 <a href="https://github.com/go-echarts/go-echarts" target="_blank" rel="noopener">go-echarts</a>
 库。</p>
<h3 id="多参数控制">多参数控制</h3>
<p>关于 statsview，有一个知识点想跟大家讲一下，那就是多参数控制。</p>
<p>上文提到库可以通过 <code>viewer.SetConfiguration(opts …Option)</code> 函数定制一些行为，其中 Option 是一个函数类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Option</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">config</span><span class="p">)</span>
</code></pre></div><p>其中 config 的定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">config</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Interval</span>   <span class="kt">int</span>
	<span class="nx">MaxPoints</span>  <span class="kt">int</span>
	<span class="nx">Template</span>   <span class="kt">string</span>
	<span class="nx">Addr</span>       <span class="kt">string</span>
	<span class="nx">TimeFormat</span> <span class="kt">string</span>
	<span class="nx">Theme</span>      <span class="nx">Theme</span>
<span class="p">}</span>
</code></pre></div><p>该类型的字段用于控制该库的一些行为。它有一个默认的实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">defaultCfg</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">config</span><span class="p">{</span>
	<span class="nx">Interval</span><span class="p">:</span>   <span class="nx">DefaultInterval</span><span class="p">,</span>
	<span class="nx">MaxPoints</span><span class="p">:</span>  <span class="nx">DefaultMaxPoints</span><span class="p">,</span>
	<span class="nx">Template</span><span class="p">:</span>   <span class="nx">DefaultTemplate</span><span class="p">,</span>
	<span class="nx">Addr</span><span class="p">:</span>       <span class="nx">DefaultAddr</span><span class="p">,</span>
	<span class="nx">TimeFormat</span><span class="p">:</span> <span class="nx">DefaultTimeFormat</span><span class="p">,</span>
	<span class="nx">Theme</span><span class="p">:</span>      <span class="nx">DefaultTheme</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>面对这样的需求，通常的解决方案是：</p>
<ul>
<li>将 config 默认实例导出，使用方直接修改对应字段的值；</li>
<li>通过提供一系列函数实现修改，比如 SetInterval(int)</li>
</ul>
<p>方案一封装性不好，暴露太多细节；而方案二的问题在于，config 的字段类型不一致，通常方案不够优雅。该库的实现方式是定义一个 Option 类型，然后提供一系列具有相似签名的函数来控制这些配置，即上文列出来的 WithXXX 类函数，看其中的一个实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// WithAddr sets the listening address
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WithAddr</span><span class="p">(</span><span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Option</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">Addr</span> <span class="p">=</span> <span class="nx">addr</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这样通过 WithXXX 函数得到一系列 Option 实例，而 viewer.SetConfiguration 接收一系列 Option 实例，所以使用是就这样了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">viewer</span><span class="p">.</span><span class="nf">SetConfiguration</span><span class="p">(</span><span class="nx">viewer</span><span class="p">.</span><span class="nf">WithTheme</span><span class="p">(</span><span class="nx">viewer</span><span class="p">.</span><span class="nx">ThemeWalden</span><span class="p">),</span> <span class="nx">view</span><span class="p">.</span><span class="nf">WithAddr</span><span class="p">(</span><span class="s">&#34;localhost:8087&#34;</span><span class="p">))</span>
</code></pre></div><p>还有其他案例吗？</p>
<h3 id="colly-中的案例">colly 中的案例</h3>
<p><a href="https://github.com/gocolly/colly" target="_blank" rel="noopener">Colly</a>
 是一个 Go 语言实现的，快速的、优雅的 Scraper 和 Crawler 框架。它的实例化函数比较“独特”：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCollector</span><span class="p">(</span><span class="nx">options</span> <span class="o">...</span><span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Collector</span><span class="p">))</span> <span class="o">*</span><span class="nx">Collector</span>
</code></pre></div><p>实例化一个类型，一般有以下几种方式：</p>
<ol>
<li>new(T)</li>
<li>T{} 或 &amp;T{}</li>
<li>自定义的工厂函数</li>
</ol>
<p>对于类型中的成员，我们可以在实例化时传递，如第 2、3 种方式；也可以在生成实例后，通过 <code>t.Field</code> 的形式赋值（前提是导出的成员）。</p>
<p>一般地，我们在定义工厂函数时，要为类型成员初始化，会给工厂函数定义相应的参数。而 Collector 类型的工厂函数参数，却是一个或多个函数。这样设计有以下方面的原因：</p>
<ol>
<li>Collector 类型的成员较多；</li>
<li>成员的类型多样；</li>
<li>不要求所有的成员必须指定值；</li>
</ol>
<p>针对这些问题，Collector 工厂类 NewCollector() 巧妙的使用不定参数，而且类型是 <code>func(*Collector)</code>，这样可以有选择的配置一个或多个选项，很好地解决了上面的三个问题。它的源码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCollector</span><span class="p">(</span><span class="nx">options</span> <span class="o">...</span><span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Collector</span><span class="p">))</span> <span class="o">*</span><span class="nx">Collector</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Collector</span><span class="p">{}</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">Init</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">options</span> <span class="p">{</span>
        <span class="nf">f</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">parseSettingsFromEnv</span><span class="p">()</span>

    <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></div><p>同时，通过函数的方式来配置选项，就好比很多面向对象语言中的 Set 方法，可以在里面有其他的一些逻辑判断，而不仅仅是设置一个值。比如以下配置函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Debugger</span><span class="p">(</span><span class="nx">d</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">Debugger</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Collector</span><span class="p">)</span>
</code></pre></div><h3 id="bigcache-中的案例">BigCache 中的案例</h3>
<p><a href="https://github.com/allegro/bigcache" target="_blank" rel="noopener">BigCache</a>
 是一个高性能缓存库。获得它的一个实例是这样的形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">bigcache</span><span class="p">.</span><span class="nf">NewBigCache</span><span class="p">(</span><span class="nx">bigcache</span><span class="p">.</span><span class="nf">DefaultConfig</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">))</span>
</code></pre></div><p>即它的构造函数（New 函数）接收一个 Config 对象，这也是要控制多个配置。</p>
<p>因为 Go 不是完全的面向对象语言。当类型中有较多成员，且可以通过外部控制时，根据封装的原则，一般不建议将这些字段导出（公开），但这样一来构造函数就需要能接收很多参数。在 Go 中有两种较常见的设计方法。</p>
<p>1）通过另外一个结构体来控制</p>
<p>比如 bigcache 包中的 Config 结构体。这么做有什么好处？</p>
<p>一方面控制了 BigCache 类型的行为，避免实例化后可以随意更改，起到了封装的作用。另一方面，让构造函数更简洁，只需要接收一个 Config 即可（注意最好使用 Config 值类型，而不是指针）。而且可以通过提供一些 Config 的默认值来做到更易用，比如 bigcache.DefaultConfig() 函数就是这样的例子。</p>
<p>2）通过一个函数类型来控制</p>
<p>比如我们通过这种方式替换 bigcache 包的 Config 结构体。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BigCacheOption</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">BigCache</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">ShardsNum</span><span class="p">(</span><span class="nx">shards</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">BigCacheOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">BigCache</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">shards</span> <span class="p">=</span> <span class="nx">shards</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">LifeWindow</span><span class="p">(</span><span class="nx">eviction</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">BigCacheOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">BigCache</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">lifeWindow</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">eviction</span><span class="p">.</span><span class="nf">Seconds</span><span class="p">())</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 提供更多的配置选项函数
</span><span class="c1"></span><span class="o">...</span>
</code></pre></div><p>通过定义一个函数类型 BigCacheOption 来控制。对 BigCache 类型中非导出的字段，提供相应的函数，该函数返回 BigCacheOption 类型。</p>
<p>针对这种方式，BigCache 的构造函数需要改为如下的形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewBigCache</span><span class="p">(</span><span class="nx">options</span> <span class="o">...</span><span class="nx">BigCacheOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">BigCache</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">BigCache</span><span class="p">{}</span>
	<span class="c1">// 省略其他，主要处理 options 部分
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">options</span> <span class="p">{</span>
		<span class="nf">f</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h2 id="03-总结">03 总结</h2>
<p>如果你需要实时图表的方式查看系统运行时的一些数据，可能之前介绍的 statsviz 更合适。</p>
<p>该文介绍的通过参数灵活控制系统的方法，希望你能够掌握。</p>
]]></content>
		</item>
		
		<item>
			<title>字节跳动面试真的也会问这样的问题？！</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/bytedance-interview-201112/</link>
			<pubDate>Thu, 12 Nov 2020 18:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/bytedance-interview-201112/</guid>
			<description>大家好，我是站长 polarisxu。 网上看到有人分享去字节跳动的面试 Go 的经验 ，从面试题来看，应该是比较初级的职位。 这份面试经验总结中（其实谈不上总结，只是面试题的记录，并没有总结分析答案），有一道 Go 相关的题，也是一个老生常谈的问题：以下代码有什么问题，怎么解决？ total, sum := 0, 0 for i := 1; i &amp;lt;= 10; i++ { sum += i go func() { total += i }() } fmt.Printf(&amp;#34;total:%d sum %d&amp;#34;, total, sum) 01 考点一 我相信很多人应该一眼看出了其中</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>网上看到有人分享去字节跳动的<a href="https://zhuanlan.zhihu.com/p/132813717" target="_blank" rel="noopener">面试 Go 的经验</a>
，从面试题来看，应该是比较初级的职位。</p>
<p>这份面试经验总结中（其实谈不上总结，只是面试题的记录，并没有总结分析答案），有一道 Go 相关的题，也是一个老生常谈的问题：以下代码有什么问题，怎么解决？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">total</span><span class="p">,</span> <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">total</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="p">}()</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;total:%d sum %d&#34;</span><span class="p">,</span> <span class="nx">total</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
</code></pre></div><h2 id="01-考点一">01 考点一</h2>
<p>我相信很多人应该一眼看出了其中的一个问题，那就是 i 使用的问题。常见的题目是这样的：以下代码，输出什么？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">}()</span>
<span class="p">}</span>
<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
</code></pre></div><p>相信很多人知道，会输出一堆 11（可能还有其他的数字），而不是期望的输出 1 到 10。</p>
<p>怎么改进？你应该也知晓。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
</code></pre></div><p>（当然这里的输出顺序是乱的，大家应该清楚）</p>
<h2 id="02-考点二">02 考点二</h2>
<p>该题的第二个考点：data race。因为存在多 goroutine 同时写 total 变量的问题，所以有数据竞争。可以加上 -race 参数验证：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run -race main.go
<span class="o">==================</span>
WARNING: DATA RACE
Read at 0x00c0001b4020 by goroutine 8:
  main.main.func1<span class="o">()</span>
      /Users/xuxinhua/main.go:12 +0x57

Previous write at 0x00c0001b4020 by main goroutine:
  main.main<span class="o">()</span>
      /Users/xuxinhua/main.go:9 +0x10b

Goroutine <span class="m">8</span> <span class="o">(</span>running<span class="o">)</span> created at:
  main.main<span class="o">()</span>
      /Users/xuxinhua/main.go:11 +0xe7
<span class="o">==================</span>
</code></pre></div><p>这可以通过加锁的方式解决：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">mutex</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="nx">total</span><span class="p">,</span> <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>此外，也可以通过 atomic 包解决：（注意 total 的类型，因为 atomic.AddInt64 需要）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">total</span> <span class="kt">int64</span>
<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">total</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
  <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>通过 -race 你验证，发现 data race 没了。</p>
<p>细心的你不知道发现没有，以上代码我故意把最后的 fmt 输出那一行去掉了，因为它用了 total 变量，避免它导致 data race。这引出考点三。</p>
<h2 id="03-考点三">03 考点三</h2>
<p>我上面都没有给完整的代码，因为经过上面两步，最终的结果还是不对的。从上面说的 fmt 输出代码去掉就说明还有问题。</p>
<p>初学 Go 应该遇到类似这样的问题，下面代码一般没有输出。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
	<span class="p">}()</span>
<span class="p">}</span>
</code></pre></div><p>原因是 main 函数先退出了，开启的 goroutine 根本没有机会执行。所以，常见的解决办法是在最后加一个 Sleep：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
	<span class="p">}()</span>
  
  <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Sleep 会让 main goroutine 休眠，调度器调度其他 goroutine 运行。</p>
<p>回到开头的题目其实也存在这个问题，通过在 fmt 语句之前加上 Sleep，基本能得到正确的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">total</span> <span class="kt">int64</span>
<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">total</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
    <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;total:%d sum %d&#34;</span><span class="p">,</span> <span class="nx">total</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
</code></pre></div><p>但如果加上 -race 发现还是有问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run -race main.go
<span class="o">==================</span>
WARNING: DATA RACE
Read at 0x00c00001c0b0 by main goroutine:
  main.main<span class="o">()</span>
      /Users/xuxinhua/main.go:20 +0xe4

Previous write at 0x00c00001c0b0 by goroutine 7:
  sync/atomic.AddInt64<span class="o">()</span>
      /Users/xuxinhua/.go/current/src/runtime/race_amd64.s:276 +0xb
  main.main.func1<span class="o">()</span>
      /Users/xuxinhua/main.go:15 +0x44

Goroutine <span class="m">7</span> <span class="o">(</span>finished<span class="o">)</span> created at:
  main.main<span class="o">()</span>
      /Users/xuxinhua/main.go:14 +0xa4
<span class="o">==================</span>
total:55 sum 55Found <span class="m">1</span> data race<span class="o">(</span>s<span class="o">)</span>
</code></pre></div><p>所以，这种方式是不靠谱的，这时正确的方式是使用 sync.WaitGroup。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;sync/atomic&#34;</span>
    <span class="s">&#34;sync&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="kd">var</span> <span class="nx">total</span> <span class="kt">int64</span>
    <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">total</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
        <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;total:%d sum %d&#34;</span><span class="p">,</span> <span class="nx">total</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="04-总结">04 总结</h2>
<p>通过上面的分析，发现看起来是一个简单的题目，其实考点好几个。这个题目还是挺好的，字节跳动面试官出的这道题还是有点水平。你觉得呢？</p>
]]></content>
		</item>
		
		<item>
			<title>GitHub 出的这个功能，让开源项目有了自己的社区</title>
			<link>https://polarisxu.studygolang.com/posts/talk/view-github-discussions/</link>
			<pubDate>Thu, 12 Nov 2020 10:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/view-github-discussions/</guid>
			<description>大家好，我是站长 polarisxu。 为了更有利于开源项目的发展，形成自己的社区很重要，作者们可以更好地和使用者交流互动，了解他们需求、问题。虽然 GitHub 有 issue，但毕竟它主要还是用于反馈 bug、提新特性，不是一个社区的感觉。所以一般项目都会有其他的社区，比如会开通 google groups 邮件组、使用 Gitter、Discord、Slack 等。当然，国内的项目通常会使用 QQ 群、微信群</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>为了更有利于开源项目的发展，形成自己的社区很重要，作者们可以更好地和使用者交流互动，了解他们需求、问题。虽然 GitHub 有 issue，但毕竟它主要还是用于反馈 bug、提新特性，不是一个社区的感觉。所以一般项目都会有其他的社区，比如会开通 google groups 邮件组、使用 Gitter、Discord、Slack 等。当然，国内的项目通常会使用 QQ 群、微信群。（我个人认为，QQ 群、微信群对社区沉淀是很不好的，知识输出、讨论没法重用，虽然对提问者友好，可以快速得到回应）</p>
<p>今年年初，GitHub 开始测试一个新功能：Discussions，它想为开源项目打造一个自己的社区，将之前分散的社区聚合在一起。比如一般开源社区是这样的：用 Gitter 作为开源社区聊天的地方，StackOverflow 用于寻求问题的答案，而论坛用于讨论等。有了 Discussions，我们可以在上面开展很多活动。GitHub 官方对 Discussions 的描述是这样的：</p>
<blockquote>
<p>This is a community we build together. Please be welcoming and open minded.</p>
</blockquote>
<p>不过目前该功能还在公测中，具体正式发布时间还未知。如果你想自己的项目试用该功能，可以到 <a href="https://github.com/github/feedback/discussions" target="_blank" rel="noopener">https://github.com/github/feedback/discussions</a>
 提出申请，请求 GitHub 将你的项目加入 Beta 列表中。这里有别人请求加入的交流：<a href="https://github.com/github/feedback/discussions/24" target="_blank" rel="noopener">https://github.com/github/feedback/discussions/24</a>
。</p>
<h2 id="01-一睹-discussions">01 一睹 Discussions</h2>
<p>我们通过一个开通了该功能的 <a href="https://github.com/asim/nitro" target="_blank" rel="noopener">Go 项目：Nitro</a>
（之前的 go-micro，<a href="https://polarisxu.studygolang.com/posts/go/micro/micro-3.0.0-m3o/" target="_blank" rel="noopener">具体详见该文</a>
）来看看 Discussions。</p>
<p>在启用了 Discussions 的项目上，在顶部会有这个 Tab：</p>
<p><p class="md__image">
  <img src="../imgs/nitro-home.png"
    alt=""  />
</p>
</p>
<p>这个功能应该可以通过 Settings 控制是否启用（在有该功能测试资格的情况下）。</p>
<p>进入该 Tab，页面如下：</p>
<p><p class="md__image">
  <img src="../imgs/nitro-discussions.png"
    alt=""  />
</p>
</p>
<p>左侧可以有分类，中间是主题列表，右侧可以有其他一些提示信息。顶部还可以通过 New、Top、Answered、Unanswered 快速筛选，当然也支持搜索。</p>
<h2 id="02-discussions-vs-issues">02 Discussions V.S Issues</h2>
<p>以前，Issues 也常常被用来讨论一些与当前 GitHub 项目相关的问题，但实际上可能 Issues 不太适合作为一个问答的地方，更多应该是反馈 bug 等？！现在有了 Discussions，可以对二者的定位做一个划分：Issues 用来反馈 bug，提出新特性；Discussions 用来讨论其他与项目相关的，当然，它也可以用来讨论新特性。在新特性这一点上，我个人认为 Discussions 适合于新特性不成熟的讨论阶段，基本确认后，通过 issue 提交该新特性，实现后 PR 关闭该 issue。</p>
<h2 id="03-你看好该功能吗">03 你看好该功能吗？</h2>
<p>从该功能看，GitHub 希望为开源项目提供全套的服务？将相关信息聚合在一起，更有利于形成开源项目自己的社区，我个人挺看好它的。你觉得该功能怎么样？</p>
<p>在 2020 年 3 月 28 日，Offer 365 CLI 就在 Twitter 上宣布，他们将关闭公共 Gitter 频道，开始使用 GitHub Discussions 发布相关信息。</p>
<p><p class="md__image">
  <img src="../imgs/office365-twitter.png"
    alt=""  />
</p>
</p>
<p>现在看看它的 Discussions 页面，维护的还不错：<a href="https://github.com/pnp/cli-microsoft365/discussions" target="_blank" rel="noopener">https://github.com/pnp/cli-microsoft365/discussions</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>祝贺 Go 开源 11 周年</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go-opensource-11-years/</link>
			<pubDate>Tue, 10 Nov 2020 09:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go-opensource-11-years/</guid>
			<description>题图来自《了不起的程序员》 今天是 Go 语言开源 11 周年。有些人可能不太知道，简单回顾下 Go 的历史。 2007 年 Rob Pike, Robert Griesemer 和 Ken Thompson 一起创建了 Go 语言。从代码提交记录看，2008 年 3 月 3 日有了 Go 最初的规范 。 2009 年 11 月 10 日，Go 语言以开放源代码的方式向全球发布，当年获得了 TIOBE 年度编程语言称号； 2011 年 3 月 16 日，Go 语言的第一个稳定版本 r56 发布； 2012 年 3 月 28 日，Go 语言的第一个正式版本 Go1 发布，并承诺</description>
			<content type="html"><![CDATA[<p><p class="md__image">
  <img src="../imgs/go-opensource-11.png"
    alt="了不起的程序员"  />
</p>
</p>
<p>题图来自《了不起的程序员》</p>
<p>今天是 Go 语言开源 11 周年。有些人可能不太知道，简单回顾下 Go 的历史。</p>
<p>2007 年 Rob Pike, Robert Griesemer 和 Ken Thompson 一起创建了 Go 语言。从代码提交记录看，2008 年 3 月 3 日有了 <a href="https://github.com/golang/go/blob/18c5b488a3b2e218c0e0cf2a7d4820d9da93a554/doc/go_spec" target="_blank" rel="noopener">Go 最初的规范</a>
。</p>
<ul>
<li>2009 年 11 月 10 日，Go 语言以开放源代码的方式向全球发布，当年获得了 TIOBE 年度编程语言称号；</li>
<li>2011 年 3 月 16 日，Go 语言的第一个稳定版本 r56 发布；</li>
<li>2012 年 3 月  28 日，Go 语言的第一个正式版本 Go1 发布，并承诺 1.x 的 兼容性；</li>
<li>直到 2013 年  5 月 13 日，Go1.1 正式版才发布，距离 1.0 过去了一年多。正式因为经历了这么久，Go 官方团队正式考虑发布周期的问题，并整理成文档：<a href="https://github.com/golang/go/wiki/Go-Release-Cycle" target="_blank" rel="noopener">https://github.com/golang/go/wiki/Go-Release-Cycle</a>
；总的目标是 6 个月发布一个版本，细分为 3 个月的常规开发，然后是 3 个月的测试和优化，即所谓的版本冻结。通过发行小版本来纠正诸如崩溃或安全性等关键问题。同时明确发布周期定于每年的 2 月 1 日和 8 月 1 日；</li>
<li>2013 年 12 月 1 日，Go1.2 正式发布；</li>
<li>2014 年 6 月 18 日，Go1.3 正式发布；</li>
<li>2014 年 12 月 10 日，Go1.4 正式发布；</li>
<li>2015 年 8 月 19 日，Go1.5 正式发布。该版本实现了自举，即移除了 C 代码，使用 Go 开发 Go 语言；开始按发布节奏走了（该版本故意推迟 2 个月发布）；</li>
<li>2016 年 2 月 17 日，Go1.6 正式发布；</li>
<li>2016 年 8 月 15 日，Go1.7 正式发布；引入 context 包；</li>
<li>2017 年 2 月 17 日，Go1.8 正式发布；</li>
<li>2017 年 8 月 24 日，Go1.9 正式发布；引入别名；</li>
<li>2018 年 2 月 16 日，Go1.10 正式发布；</li>
<li>2018 年 8 月 25 日，Go1.11 正式发布。开始支持 Module；</li>
<li>2019 年 3 月 1 日，Go1.12 正式发布；</li>
<li>2019 年 9 月 3 日，Go1.13 正式发布；</li>
<li>2020 年 2 月 25 日，Go1.14 正式发布；goroutine 支持异步抢占调度；</li>
<li>2020 年 8 月 11 日，Go1.15 正式发布；</li>
</ul>
<p>关于以上版本的一些关键改动，可以查看 <a href="https://mp.weixin.qq.com/s/Tzqn5kzdfzcQPUD5NtN2mg" target="_blank" rel="noopener">《你必须了解的 Go 历史：帮助理解 Go 的设计思想和每个版本的优势或弱点》</a>
。</p>
<p>今天是 11 月 10 日，11 年前的今天，Go 语言开源了。在此祝愿 Go 语言越来越好！</p>
<p>Go 语言这两年出版了不少图书，这里分享几本 Go 语言英文图书。</p>
<h3 id="01mastering-go-2nd-edition">01《Mastering Go 2nd Edition》</h3>
<p>使用网络库，并发，机器学习和高级数据结构创建 Golang 生产级应用程序。这本书试用于已经了解语言基础知识并希望成为专家级 Go 实践者的 Go 程序员。</p>
<p><p class="md__image">
  <img src="../imgs/mastering-go.jpg"
    alt=""  />
</p>
</p>
<p>该书目录：</p>
<ol>
<li>Go 和操作系统</li>
<li>了解 Go 内部</li>
<li>使用基本 Go 数据类型</li>
<li>复合类型的用途</li>
<li>如何使用数据结构增强 Go 代码</li>
<li>你可能不了解的 Go 包和功能</li>
<li>反射和接口</li>
<li>告诉 Unix 系统该怎么做</li>
<li>Go 中的并发性：Goroutines，通道和管道</li>
<li>Go 中的并发：高级主题</li>
<li>代码测试，优化和分析</li>
<li>Go中网络编程的基础</li>
<li>网络编程：构建自己的服务器和客户端</li>
<li>Go 中的机器学习</li>
</ol>
<h3 id="02hands-on-system-programming-with-go">02《Hands-On System Programming with Go》</h3>
<p>使用 Golang 为 Unix 和 Linux 系统构建现代和并发应用程序。探索系统编程的基础知识，从内核 API 和文件系统开始，再到网络编程和过程通信。</p>
<p><p class="md__image">
  <img src="../imgs/system-programming-with-go.jpg"
    alt=""  />
</p>
</p>
<p>该书目录：</p>
<ol>
<li>系统编程简介</li>
<li>Unix OS 组件</li>
<li>Go 概述</li>
<li>使用文件系统</li>
<li>处理流</li>
<li>构建伪终端</li>
<li>处理进程和守护程序</li>
<li>退出代码，信号和管道</li>
<li>网络编程</li>
<li>使用 Go 进行数据编码</li>
<li>处理 Channel 和 Goroutines</li>
<li>使用 sync 和 atomic 进行同步</li>
<li>使用 Context 进行协调</li>
<li>实现并发模式</li>
<li>使用反射</li>
<li>使用 CGO</li>
</ol>
<h3 id="03hands-on-high-performance-with-go">03《Hands-On High Performance with Go》</h3>
<p>通过弹性大规模扩展和优化 Golang 应用程序的性能。成熟的方法和并发技术将帮助您使用 Go 编程编写更快更好的代码。</p>
<p><p class="md__image">
  <img src="../imgs/system-programming-with-go.jpg"
    alt=""  />
</p>
</p>
<p>该书目录：</p>
<ol>
<li>Go 性能介绍</li>
<li>数据结构与算法</li>
<li>了解并发</li>
<li>Go 中的 STL 算法等效项</li>
<li>Go 中的矩阵和向量计算</li>
<li>编写可读的 Go 代码</li>
<li>Go 中的模板编程</li>
<li>Go 中的内存管理</li>
<li>Go 中的 GPU 并行化</li>
<li>Go 中的编译时间评估</li>
<li>构建和部署 Go 代码</li>
<li>Profiling Go 代码</li>
<li>Tracing Go 代码</li>
<li>集群和作业队列</li>
<li>跨版本比较代码质量</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>客观、全面的比较 Rust 与 Go</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/rust-vs-go/</link>
			<pubDate>Tue, 10 Nov 2020 00:07:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/rust-vs-go/</guid>
			<description>最近一年，将 Rust 和 Go 进行比较的不少，但不少都不公正，带感情色彩。而这篇文章客观、全面的分析对比了 Rust 和 Go，让你具体项目时选择最合适的。 Rust 还是 Go，哪个更好？你应该为下一个项目选择哪种语言，为什么？两者在性能，简单性，安全性，功能，规模和并发性等方面如何比较？它们有什么共同点，并且在根本上有何不同？来自 For the Go of Love 系列图书的作者，友好而公正的比较 Rust 和 Golang。</description>
			<content type="html"><![CDATA[<blockquote>
<p>最近一年，将 Rust 和 Go 进行比较的不少，但不少都不公正，带感情色彩。而这篇文章客观、全面的分析对比了 Rust 和 Go，让你具体项目时选择最合适的。</p>
</blockquote>
<p>Rust 还是 Go，哪个更好？你应该为下一个项目选择哪种语言，为什么？两者在性能，简单性，安全性，功能，规模和并发性等方面如何比较？它们有什么共同点，并且在根本上有何不同？来自 <a href="https://bitfieldconsulting.com/books/" target="_blank" rel="noopener">For the Go of Love</a>
 系列图书的作者，友好而公正的比较 Rust 和 Golang。</p>
<h2 id="rust-和-go-都很棒">Rust 和 Go 都很棒</h2>
<p>首先，非常重要的一点是，Go 和 Rust 都是绝对优秀的编程语言。它们是现代的，强大的，被广泛采用的，并且具有出色的性能。你可能已经阅读了一些文章和博客文章，目的是说服 Go 比 Rust 更好，反之亦然。但这确实没有道理；每种编程语言都代表一组权衡。每种语言针对不同的事物进行了优化，因此，应根据适合你的语言以及你要解决的问题来确定语言的选择。</p>
<p>在本文中，我将简要概述我认为 Go 是理想的选择，以及我认为 Rust 是更好的选择的地方。不过，理想情况下，你应该对这两种语言都有一定的了解。尽管它们的语法和样式差异很大，但 Rust 和 Go 都是用于构建软件的一流工具。话虽如此，让我们仔细看看这两种语言。</p>
<h2 id="相似之处">相似之处</h2>
<p>Rust 和 Go 有很多共同点，这是你经常听到他们一起被提及的原因之一。两种语言的共同目标是什么？</p>
<blockquote>
<p>Rust 是一种专注于安全性和性能的低级静态类型多范式编程语言。<em>—</em><a href="https://serokell.io/blog/rust-guide" target="_blank" rel="noopener">Gints Dreimanis</a>
</p>
</blockquote>
<blockquote>
<p>Go 是一种开放源代码编程语言，可轻松构建简单，可靠和高效的软件。—<a href="https://golang.org/" target="_blank" rel="noopener">Golang.org</a>
</p>
</blockquote>
<h3 id="内存安全">内存安全</h3>
<p>Go 和 Rust 都属于优先考虑内存安全性的现代编程语言。数十年来，使用 C 和 C++ 等较旧的语言已经很清楚，导致错误和安全漏洞的最大原因之一是不安全或不正确地访问内存。 Rust 和 Go 以不同的方式处理此问题，但是两者的目的都是要比其他有关内存管理的语言更聪明，更安全，并帮助你编写正确且性能良好的程序。</p>
<h3 id="快速紧凑的可执行文件">快速，紧凑的可执行文件</h3>
<p>它们都是编译语言，这意味着你的程序直接转换为可执行的机器代码，因此你可以将程序作为单个二进制文件进行部署；与 Python 和 Ruby 等解释型语言不同，你无需随程序一起分发解释器，大量库和依赖项，这是一大优势。与解释型语言相比，这也使 Rust 和 Go 程序都非常快。</p>
<h3 id="通用语言">通用语言</h3>
<p>Rust 和 Go 都是功能强大，可扩展的通用编程语言，你可以使用它们来开发各种现代软件，从Web应用程序到分布式微服务，或者从嵌入式微控制器到移动应用程序。两者都具有出色的标准库和蓬勃发展的第三方生态系统，以及强大的商业支持和庞大的用户群。它们都已经存在了很多年，并将在未来几年继续被广泛使用。今天学习 Go 或 Rust 将是你的时间和精力的明智投资。</p>
<h3 id="务实pragmatic的编程风格">务实（Pragmatic）的编程风格</h3>
<p>两种语言都不是纯函数式语言（例如 Scala 或 Elixir），也不是全面面向对象的语言（例如 Java 和 C#）。相反，尽管 Go 和 Rust 都具有与函数和面向对象的编程相关的功能，但它们都是务实的语言，旨在以最合适的方式解决问题，而不是强迫你采用特定的处理方式。 （不过，如果你喜欢函数式编程风格，则在 Rust 中会发现更多的函数式特性，因为 Rust 的函数式功能比 Go 多得多。）</p>
<blockquote>
<p>我们可以讨论什么是“面向对象”语言，但是公平地说，Go 或 Rust 中都没有 C++，Java 或 C# 用户期望的面向对象编程风格。—Jack Mott</p>
</blockquote>
<h3 id="大规模发展">大规模发展</h3>
<p>Rust 和 Go 都具有一些有用的特性，这使其适合于大型编程，包括大型团队，大型代码库，或两者兼而有之。</p>
<p>例如，尽管 C 程序员多年来一直在争论括号的位置，以及是否应使用制表符或空格使代码缩进，但 Rust 和 Go 都通过使用标准格式工具（gofmt 用于 Go，rustfmt 用于 Rust）完全消除了此类问题。 它使用规范样式自动格式化你的代码。并不是说这种特殊的样式本身如此出色：而是 Rust 和 Go 程序员所欣赏的标准化。</p>
<blockquote>
<p>gofmt 的风格不是每个人的最爱，但 gofmt 是每个人的最爱。<em>—</em><a href="https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=8m43s" target="_blank" rel="noopener">Rob Pike</a>
</p>
</blockquote>
<p>两种语言得分很高的另一个领域是构建管道（build pipeline）。两者都具有出色的内置高性能标准构建和依赖管理工具。不再需要为复杂的第三方构建系统而费力，也不必每两年学习一次新的。</p>
<blockquote>
<p>在我早期的职业生涯中，具有 Java 和 Ruby 背景的 Go 和 Rust 代码构建工作似乎使我无法承受。当我在 Google 时，遇到用 Go 编写的服务感到很欣慰，因为我知道它易于构建和运行。 Rust 的情况也是如此，尽管我只是在较小的规模上进行了研究。我希望无限可配置的构建系统的日子已经一去不复返了，所有语言都附带了它们自己专用的构建工具，这些工具可以直接使用。<em>—</em><a href="https://samwho.dev/" target="_blank" rel="noopener">Sam Rose</a>
</p>
</blockquote>
<h2 id="那有什么大惊小怪的">那有什么大惊小怪的？</h2>
<p>考虑到所有这些，并且看到这两种语言的设计和功能如此强大，你可能想知道所有的圣战是关于什么的（我也是）。人们为什么对 “Go vs Rust” 如此大惊小怪，陷入愤怒的社交媒体争吵中，并写了很长的博客文章，内容涉及只有白痴才会使用Rust，或者 Go 不是真正的编程语言等等。它可能会让他们感觉更好，但对于试图决定要为项目使用哪种语言的人，或者应该学习哪种语言来促进编程事业的人，这并不能完全为你提供帮助。明智的人不会根据谁喊得最多而做出重要的选择。</p>
<p>现在，让我们继续探讨一些成年人在某些方面可能会比较喜欢一种语言而不是另一种语言的问题。</p>
<h2 id="性能">性能</h2>
<p>我们已经说过，Go 和 Rust 都能生成非常快的程序，因为它们被编译为本机代码，而无需通过解释器或虚拟机。但是，Rust 的性能特别出色，它可与 C 和 C++ 相媲美（C/C++ 通常被认为是性能最高的编译语言），但与这些较旧的语言不同，它还提供了内存安全性和并发安全性，而执行速度却基本没有任何成本。 Rust 还允许你创建复杂的抽象，而无需在运行时付出性能损失。</p>
<p>相比之下，尽管 Go 程序的性能也非常好，但是 Go 的主要目的是提高开发速度（包括编译），而不是提高执行速度。 Go 编译器不会花费很多时间来尝试生成尽可能高效的机器代码；它更关心快速编译大量代码。因此，Rust 通常会在运行时基准测试中击败 Go。</p>
<p>Rust 的运行时性能也始终如一且可预测，因为它不使用垃圾回收。 Go 的垃圾收集器非常高效，并且经过优化，可以使其 STW 的时间尽可能短（并且在每个新的 Go 版本中都变得更短）。但是垃圾回收不可避免地在程序的行为方式中引入了一些不可预测性，这在某些应用程序（例如嵌入式系统）中可能是一个严重的问题。</p>
<p>由于 Rust 旨在使程序员能够完全控制底层硬件，因此有可能将 Rust 程序优化为非常接近机器的最大理论性能。对于执行速度超过所有其他考虑因素的领域（例如游戏编程，操作系统内核，Web 浏览器组件和实时控制系统），Rust 使其成为绝佳的选择。</p>
<h2 id="简单">简单</h2>
<p>如果没有人能弄清楚如何使用它，那么编程语言有多快也没关系。 Go 被故意认为是对 C++ 等语言不断增长的复杂性的一种反应。它的语法很少，关键字也不多，而且功能也很少。这意味着学习 Go 语言并不需要很长时间，你可以在其中编写有用的程序。</p>
<blockquote>
<p>Go 非常容易学习。我知道这是一个经常被吹捧的好处，但是我对能够这么快地提高生产力感到非常惊讶。多亏了语言，文档和工具，我实际上在两天之后就编写了有趣的，可提交的代码。— <a href="https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410" target="_blank" rel="noopener">Rust 程序员对 Go 的早期印象</a>
</p>
</blockquote>
<p>这里的关键词是简单。当然，简单（simple）与容易（easy）并不相同，但是简单的小型语言比复杂的大型语言更容易学习。要做的事情没有太多不同的方式，因此所有编写良好的 Go 代码看起来都一样。深入研究不熟悉的服务并了解其功能很容易。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Gopher&#39;s Diner Breakfast Menu&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">dish</span><span class="p">,</span> <span class="nx">price</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">menu</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dish</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>尽管核心语言很小，但 Go 的标准库功能非常强大。这意味着你的学习曲线还需要包括所需的标准库部分，而不仅仅是Go语法。另一方面，将功能从语言中移出并移入标准库意味着你现在可以专注于仅学习与你相关的库。</p>
<p>Go 还被设计用于具有大型代码库和大型团队的大规模软件开发。在这种情况下，重要的是，新开发人员必须尽快上手。</p>
<blockquote>
<p>使用 Go，你可以快速完成工作。 Go 是我使用过的最具生产力的语言之一。口头禅是：解决今天的实际问题。<em>—</em><a href="https://endler.dev/2017/go-vs-rust/" target="_blank" rel="noopener">Matthias Endler</a>
</p>
</blockquote>
<h2 id="特性">特性</h2>
<blockquote>
<p>与其他几种编程语言相比，Rust 支持更多的复杂特性，因此，你可以用它实现更多的功能。例如，它支持泛型。<em>—</em><a href="https://devathon.com/blog/rust-vs-go-which-programming-language-to-choose/" target="_blank" rel="noopener">Devathon</a>
</p>
</blockquote>
<p>Rust 专门设计为包含许多强大而有用的功能，以帮助程序员以最少的代码完成最多的工作。例如，Rust 的 match 功能使你可以非常简洁地编写灵活的表达逻辑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">0</span><span class="p">...</span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">..</span><span class="n">n</span><span class="p">).</span><span class="n">any</span><span class="p">(</span><span class="o">|</span><span class="n">d</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>由于 Rust 的功能很多，这意味着有很多东西要学习，尤其是在一开始的时候。但这没关系：在 C++ 或 Java 中也有很多东西要学习，而且你没有获得 Rust 附带的高级功能，例如内存安全性。批评 Rust 是一种复杂的语言，没有抓住重点：它被设计成具有表现力，这意味着具有许多功能，并且在许多情况下，这是编程语言所需要的。当然，这是一条学习曲线，但是一旦你开始使用它，就可以了。</p>
<blockquote>
<p>Rust 为准备接受更复杂的语法和语义（可能会带来更高的可读性成本）以换取最大可能的性能的程序员，与 C++ 和 D 竞争思想共享。<em>—</em><a href="https://dave.cheney.net/2015/07/02/why-go-and-rust-are-not-competitors" target="_blank" rel="noopener">Dave Cheney</a>
</p>
</blockquote>
<h2 id="并发">并发</h2>
<p>大多数语言都对并发编程提供某种形式的支持（一次执行多项操作），但是 Go 是专为这项工作而设计的。 Go 不使用操作系统线程，而是提供了一种轻量级的替代方案：goroutines。每个 goroutine 是一个独立执行的 Go 函数，Go 调度程序会将其映射到其控制下的 OS 线程之一。这意味着调度程序仅使用有限数量的 OS 线程即可非常有效地管理大量并发的goroutine。</p>
<p>因此，你可以在一个程序中运行数百万个并发 goroutine，而不会造成严重的性能问题。这使 Go 成为 Web 服务器和微服务等大规模并发应用程序的理想选择。</p>
<p>Go 还提供了快速，安全，有效的方式，goroutine 使用 channel 进行通信和共享数据。 Go 的并发支持设计良好，使用起来很愉快。通常很难对并发程序进行推理，而构建可靠，正确的并发程序对任何语言都是一个挑战。但是，由于它是从一开始就内置在语言中的，而不是事后才想到的，Go 中的并发编程简单、合理、良好的集成进语言中。</p>
<blockquote>
<p>Go 使构建易于分解的应用程序变得非常容易，该应用程序在作为一组微服务部署时充分利用了并发性。 Rust 也可以做这些事情，但是可以说有点困难。从某些方面来说，Rust 对防止与内存相关的安全漏洞的痴迷意味着程序员必须竭尽全力来执行使用其他语言（包括 Go）更简单的任务。<em>—</em><a href="https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/" target="_blank" rel="noopener">Sonya Koptyev</a>
</p>
</blockquote>
<p>相比之下，Rust 中的并发是一个很新的特性，并且还有待稳定中，但是它的发展非常活跃，因此请留意这块。例如，Rust 的 <a href="https://github.com/rayon-rs/rayon" target="_blank" rel="noopener">rayon</a>
 提供了一种非常优雅且轻巧的方法，可以将顺序计算转换为并行计算。</p>
<blockquote>
<p>具有轻量级 Goroutine 和 Channel 语法确实很棒。它确实显示出语法的威力，即如此小的细节使并发编程比其他语言感觉更好。— <a href="https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410" target="_blank" rel="noopener">Rust 程序员对 Go 的早期印象</a>
</p>
</blockquote>
<p>虽然在 Rust 中实现并发程序可能会不太直接，但仍然可以实现，并且这些程序可以利用 Rust 的安全保证。标准库的 Mutex 类就是一个很好的例子：在 Go 中，你可以忘记在访问某些东西之前先获得一个互斥锁，但是 Rust 不允许你这样做。</p>
<blockquote>
<p>Go 将并发作为第一类概念。这并不是说你无法在 Rust 中找到类似 Go 的并发方式，而是留给程序员练习。<em>—</em><a href="https://dave.cheney.net/2015/07/02/why-go-and-rust-are-not-competitors" target="_blank" rel="noopener">Dave Cheney</a>
</p>
</blockquote>
<h2 id="安全性">安全性</h2>
<p>前面我们已经看到，Go 和 Rust 都以不同的方式来防止与内存管理有关的大量常见编程错误。但是，尤其是 Rust 会竭尽全力确保你不会做本不该做的不安全的事情。</p>
<blockquote>
<p>Rust 的程序编辑器非常严格且学究（pedantic），它会检查你使用的每个变量以及引用的每个内存地址。它避免了可能的数据争用情况，并通知你有关未定义行为的信息。从根本上讲，并发和内存安全问题根本不可能进入Rust的安全子集。<em>—</em><a href="https://bitbucket.org/blog/why-rust" target="_blank" rel="noopener">Why Rust?</a>
</p>
</blockquote>
<p>这会使 Rust 中的编程成为几乎所有其他语言的不同体验，而且一开始可能具有挑战性。但对很多人来说，努力工作是值得的。</p>
<blockquote>
<p>对我来说，Rust 的主要优点是感觉编译器成为我的靠山，不会让任何错误漏出（有时感觉像魔术）。<em>—Grzegorz Nosek</em></p>
</blockquote>
<p>包括 Go 在内的许多语言都具有帮助程序员避免错误的功能，但是 Rust 将其提升到了一个新的高度，因此潜在的错误程序甚至无法编译。</p>
<blockquote>
<p>使用 Rust，库程序员可以使用很多工具来防止用户犯错误。 Rust 使我们能够说我们拥有特定的数据。其他任何人都不可能拥有所有权，因此我们知道其他任何人都无法对其进行修改。我想不到曾经有过这么多工具来防止意外滥用。真是太好了。<em>—</em><a href="https://samwho.dev/" target="_blank" rel="noopener">Sam Rose</a>
</p>
</blockquote>
<p>对于新手 Rust 程序员来说，“与借阅检查器（borrow checker）打架”是一个常见的症状，但是在大多数情况下，它发现的问题是代码中的真正错误（或至少是潜在的错误）。这可能会迫使你从根本上重新架构程序，以避免遇到这些问题。当正确性和可靠性是你的重中之重时，这是一件好事。语言不会改变编程方式的重点是什么？当你使用其他语言工作时，Rust 讲授的有关安全性的课程也会很有用。</p>
<blockquote>
<p>如果选择 Rust，通常需要该语言提供的保证：防止空指针和数据竞争的安全性，可预测的运行时行为以及对硬件的完全控制。如果你不需要这些功能，Rust 对于你的下一个项目可能不是一个好的选择。这是因为这些保证要付出一定的代价：学习坡度，时间问题。你将需要学习不良习惯并学习新概念。很有可能，刚开始时，你将与借阅检查器进行很多斗争。<em>—</em><a href="https://endler.dev/2017/go-vs-rust/" target="_blank" rel="noopener">Matthias Endler</a>
</p>
</blockquote>
<p>你发现 Rust 的编程模型的挑战性可能取决于你以前在其他语言中所拥有的经验。 Python 或 Ruby 程序员可能会发现它有限制；而其他人可能很高兴。</p>
<blockquote>
<p>如果你是一位花了数周时间寻找这些语言的内存安全性错误的 C 或 C++ 程序员，那么你将非常感谢 Rust。 “对抗借阅检查器”变为“编译器可以检测到吗？凉！”—Grzegorz Nosek</p>
</blockquote>
<h2 id="规模">规模</h2>
<blockquote>
<p>当今的服务器程序包含数千万行代码，由成百上千的程序员进行处理，并且每天都会更新。 Go 的设计和开发旨在提高在这种环境下的工作效率。 Go 的设计考虑因素包括严格的依赖关系管理，随着系统增长的软件体系结构的适应性以及跨组件边界的鲁棒性。<em>—</em><a href="https://talks.golang.org/2012/splash.article" target="_blank" rel="noopener">Rob Pike</a>
</p>
</blockquote>
<p>当你自己或以小组形式处理问题时，选择简单语言还是丰富语言是你的偏爱。但是随着软件变得越来越大，越来越复杂，以及团队越来越大，这种差异真正开始显现出来。对于大型应用程序和分布式系统，执行速度不如开发速度重要：像 Go 这样的故意最小化的语言减少了新开发人员的启动时间，并使他们更容易使用大型代码库。</p>
<blockquote>
<p>使用 Go，初级开发人员更容易提高工作效率，而中级开发人员更难引入脆弱的抽象，而抽象将导致问题。由于这些原因，Rust 在企业软件开发方面不如 Go 引人注目。<em>—</em><a href="https://kristoff.it/blog/why-go-and-not-rust" target="_blank" rel="noopener">Loris Cro</a>
</p>
</blockquote>
<p>当涉及到大型软件开发时，清晰胜于灵活。 Go 的限制性实际上使它比 Rust 等更复杂、功能更强大的语言更适合企业和大型组织。</p>
<h2 id="差异">差异</h2>
<p>尽管 Rust 和 Go 都是流行的，现代的，广泛使用的语言，但从故意针对完全不同的用例的意义上来说，它们并不是真正的竞争对手。 Go 的整个编程方法与 Rust 的方法完全不同，每种语言都适合某些人，同时又会激怒其他人。绝对很好，而且如果 Rust 和 Go 都以或多或少相同的方式或多或少地完成了相同的事情，那么我们实际上就不需要两种不同的语言。</p>
<p>那么，通过发现它们采取截然不同的方法的问题，我们是否能够了解 Rust 和 Go 的各自性质？让我们找出答案。</p>
<h3 id="垃圾回收">垃圾回收</h3>
<p>“进行垃圾收集或不进行垃圾收集”是没有正确答案的问题之一。垃圾回收和自动内存管理通常使开发可靠，高效的程序变得快速简便，对于某些人来说，这是必不可少的。但是其他人说，垃圾回收的性能开销和停顿，使程序在运行时无法正常运行，并引入了无法接受的延迟。争论不休。</p>
<blockquote>
<p>Go 与 Rust 完全不同。尽管两者都可以模糊地描述为系统语言或 C 语言的替代品，但它们具有不同的目标和应用，语言设计风格以及优先级。垃圾收集确实是一个巨大的区别。在 Go 中使用 GC 可使该语言变得更加简单和小巧。</p>
<p>在 Rust 中不使用 GC 可以使它真正更快（特别是如果你需要保证的等待时间，而不仅仅是高吞吐量），并启用 Go 中无法实现的特性和编程模式（或者至少在不牺牲性能的情况下）。<em>—</em><a href="https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410" target="_blank" rel="noopener">PingCAP</a>
</p>
</blockquote>
<h2 id="更接近金属close-to-the-metal">更接近金属（Close to the metal）</h2>
<p>计算机编程的历史一直是一个越来越复杂的抽象的故事，它使程序员能够解决问题而不必担心底层机器的实际工作原理。这使程序更易于编写，并且可能更具移植性。但是对于许多程序而言，访问硬件以及精确控制程序执行方式更为重要。 Rust 的目标是让程序员拥有更多的控制权，使其“更接近金属”，但是 Go 提取了体系结构的详细信息，以使程序员更加接近问题。</p>
<blockquote>
<p>两种语言有不同的使用范围。 Golang 对于编写微服务和典型的 “DevOps” 任务很有用，但它不是系统编程语言。对于并发性，安全性和/或性能很重要的任务，Rust 更强。但是它的学习曲线比 Go 更陡。<em>—</em><a href="https://endler.dev/2017/go-vs-rust/" target="_blank" rel="noopener">Matthias Endler</a>
</p>
</blockquote>
<h3 id="go-发展更快">Go 发展更快</h3>
<p>我在其他地方写过，对于大多数程序而言，<a href="https://bitfieldconsulting.com/golang/slower" target="_blank" rel="noopener">性能并不如可读性重要</a>
。但是，当性能确实很重要时，它真的很重要。 Rust 进行了许多设计折衷，以实现最佳的执行速度。相比之下，Go 更加关注简单性，并且愿意为此牺牲一些（运行时）性能。但是 Go 的构建速度是无与伦比的，这对于大型代码库而言非常重要。</p>
<blockquote>
<p>Rust 比 Go 快。在上述基准测试中，Rust 速度更快，在某些情况下还快一个数量级。但是在选择使用 Rust 编写所有内容之前，请考虑一下 Go 在许多基准测试中并没有落后很多，并且它仍然比 Java，C#，JavaScript，Python 等同类工具快得多。</p>
<p>如果你需要一流的性能，那么你可以选择这两种语言中的任一种。如果你要构建一个处理高负载的 Web 服务，并且希望能够在垂直和水平方向上进行伸缩，则两种语言都将非常适合你。<em>—</em><a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9" target="_blank" rel="noopener">Andrew Lader</a>
</p>
</blockquote>
<h3 id="正确性">正确性</h3>
<p>另一方面，如果程序没有正常运行，则可以任意快。大多数代码不是长期编写的，但通常令人惊讶的是某些程序可以在生产环境中运行多长时间：在某些情况下需要数十年。在这种情况下，需要花一些额外的时间来开发程序，以确保程序正确，可靠并且将来不需要进行大量维护。</p>
<blockquote>
<p>我的看法：明天将要发布的代码选择 Go，在未来五年内保持不变的代码选择 Rust。<em>—Grzegorz Nosek</em></p>
</blockquote>
<p>尽管 Go 和 Rust 对于任何严肃的项目都是不错的选择，但最好使自己对每种语言及其特征都尽可能了解。最终，其他人的想法无关紧要：只有你可以决定哪种对你和你的团队是合适的。</p>
<blockquote>
<p>如果你想加快开发速度，也许是因为你要编写许多不同的服务，或者你有庞大的开发团队，那么 Go 是你选择的语言。 Go 为你提供了一流的并发性，并且不容许不安全的内存访问（Rust 也不容忍），但不会强迫你管理每个最后的细节。 Go 是快速而强大的工具，但是它避免了使开发人员陷入困境，而专注于简单性和统一性。另一方面，如果需要拧紧块性能，那么 Rust 应该是你的选择。<em>—</em><a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9" target="_blank" rel="noopener">Andrew Lader</a>
</p>
</blockquote>
<h2 id="结论">结论</h2>
<p>我希望本文使你相信，Rust 和 Go 都值得你认真考虑。如果可能的话，你应该力求获得至少两种语言的某种程度的经验，因为它们对你在任何技术职业中都是非常有用的，即使你喜欢将编程作为业余爱好也是如此。如果你只有时间投入精力来学习一种语言，那么请在将 Go 和 Rust 都用于各种大小不同的程序之前，不要做出最终决定。</p>
<p>而且，对编程语言的了解实际上只是成为一名成功的软件工程师的一小部分。到目前为止，您将需要的最重要的技能是设计，工程，体系结构，沟通和协作。如果您擅长这些，那么无论您选择哪种语言，您都将是一名出色的软件工程师。学习愉快！</p>
<blockquote>
<p>原文链接：<a href="https://bitfieldconsulting.com/golang/rust-vs-go" target="_blank" rel="noopener">https://bitfieldconsulting.com/golang/rust-vs-go</a>
</p>
<p>原文作者：John Arundel</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>关于 Go 语言微服务框架 Micro 的一些情况说明</title>
			<link>https://polarisxu.studygolang.com/posts/go/micro/micro-3.0.0-m3o/</link>
			<pubDate>Mon, 09 Nov 2020 15:50:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/micro/micro-3.0.0-m3o/</guid>
			<description>用过或了解过 Micro 这个框架的人，可能有所耳闻，大家对其抱怨比较多，典型的抱怨是升级后不兼容。比如网上有教程是基于 1.x，但新版本是 2.x，完全不一样了，而且似乎官方文档也没有及时更新，使用了它的人“痛苦不堪”。 前些天，有人问我有无其他 Go 微服务框架推荐，说 Micro 3.0.0 开始不能用了！！ 我听了一惊：我只听说它不稳定，总是变来变去，兼容性不好，但没听说不能用。后来了解了下，原来</description>
			<content type="html"><![CDATA[<p>用过或了解过 Micro 这个框架的人，可能有所耳闻，大家对其抱怨比较多，典型的抱怨是升级后不兼容。比如网上有教程是基于 1.x，但新版本是 2.x，完全不一样了，而且似乎官方文档也没有及时更新，使用了它的人“痛苦不堪”。</p>
<p>前些天，有人问我有无其他 Go 微服务框架推荐，说 Micro 3.0.0 开始不能用了！！</p>
<p>我听了一惊：我只听说它不稳定，总是变来变去，兼容性不好，但没听说不能用。后来了解了下，原来 3.0 做了巨大的改变。主要有：</p>
<ul>
<li>Micro 3.0 推荐叫做 M3O，微服务框架成为了云原生开发平台</li>
<li>废弃了 Go-Micro</li>
<li>开源 License 由 Apache 2.0 改为 <a href="https://polyformproject.org/licenses/shield/1.0.0/" target="_blank" rel="noopener">Polyform Shield</a>
</li>
</ul>
<p>说明一点，Micro 是一个公司：Micro Services, Inc。</p>
<h2 id="01-micro-30-叫做-m3o一个云原生开发平台">01 Micro 3.0 叫做 M3O，一个云原生开发平台</h2>
<p>在 11 月 05 日，官方宣布 Micro 3.0.0 发布。这不再是一个微服务框架，而是一个云原生平台。有什么不一样呢？</p>
<p>官方在 3.0 版本对主要工具进行了重大重构，并将其整合到可以从开发人员的角度解决构建、运行、管理和使用这整个工作流的问题。</p>
<h3 id="为什么做这样的改变">为什么做这样的改变</h3>
<p>Micro 最初是作为微服务开发的工具包，它结合了 api 网关，Web dashboard 和 cli 与使用 Go RPC 框架构建的服务进行交互。因为考虑到那时让所有人重新购买 PaaS 感觉就像是一场失败的战斗。因此，官方选择围绕 RPC 框架编写单一用途的工具，以为它可以使人们逐步采用它，直到他们看到对平台的需求为止。</p>
<p>虽然有一个简单的 Go 框架以及一些用于查询和与之交互的周围组件，但是就像任何长期存在的项目一样，随着试图解决瑞士军刀无法做到的那种平台体验，其复杂性也在增加，开发了许多独立的库。这对于用户而言，增加了认知上的负担。</p>
<p>在 2019 年，官方对所有这些库进行了合并，这提供了极大的帮助，但始终仍然存在一个悬而未决的问题。 micro 和 go-micro 有什么区别？一般我们将 go-micro 视为框架，将 micro 视为工具箱，但这样的划分似乎没有意义。</p>
<p>过去 5 年，随着容器和容器编排成为焦点，“云原生”工具激增，世界爆炸了。更具体地说，Docker 和 Kubernetes 重新定义了技术领域，并更加有意识地转向在云中构建软件。</p>
<p>Micro 甚至可以追溯到 2015 年，都具有前瞻性的观点。很明显，分布式系统和云原生将在未来几年内成为后端服务开发的主导模型，但是不清楚要花多长时间花折腾各种工具，例如 docker，kubernetes，grpc，istio 等。这感觉就像重新构建技术栈。Micro 希望解决整个工作流上的事情，而只是在微服务开发上。</p>
<p>M3O 官方认为 PaaS 3.0 不仅是在运行容器甚至是源代码，而且还囊括了整个开发人员的经验，包括用于编写云代码的模型。因此它们打造了 Micro 3.0，或叫 M3O，这是用于云原生开发的平台。</p>
<p>更多信息可以看 <a href="https://micro.mu/blog/2020/11/05/micro-v3-aka-m3o.html" target="_blank" rel="noopener">Micro 3.0.0 的发布公告</a>
。</p>
<h2 id="02-废弃-go-micro">02 废弃 Go-Micro</h2>
<p>这个点上面已经做了一定说明。</p>
<p>官方终止对 go-micro 的支持。这个项目自 2014 年创建至今，已经拥有 14.7k+ Star。作者认为尽管它为许多人解决了一些问题，但它并没有完成它的初衷。</p>
<p>现在这个项目并没有直接放弃，而是转交到个人名下（Micro 公司的 CEO Asim），为了避免混淆，项目名也改了，叫 <a href="https://github.com/asim/nitro" target="_blank" rel="noopener">Nitro</a>
。现在它是一个快速的分布式应用程序开发框架。</p>
<p>虽然 go-micro 2.0 依然可以使用，但已经不维护。更多相信信息可以查看 Nitro 项目的 FAQ。</p>
<h2 id="03-licence-改为-polyform-shield">03 Licence 改为 Polyform Shield</h2>
<p>Polyform Shield 这个 Licence 我是第一次见 ，相信很多人也是。官方的说法是：</p>
<blockquote>
<p>Micro 继续保持开源状态，但使用 Polyform Shield 进行了许可，这可以防止该软件被提取并作为服务运行。这是为了与 AWS 和其他运行开放源代码以谋取利益而不回馈的人抗衡。</p>
</blockquote>
<p>这个 Licence 是为了防止 AWS 这样的云服务部署 Micro 服务，和 Micro 公司进行直接竞争，其他情况下可以免费使用。因此不存在开头网友说的不让用的情况。</p>
<p>值得一提的是，Nitro 项目的 Licence 也改为了 Polyform Shield。</p>
<h2 id="04-总结">04 总结</h2>
<p>Micro 3.0 的出现，可能是顺应时代的产物。但从另一个角度，包括 Licence 的变更，一个靠开源项目活下去的公司不容易。M3O 是一个云原生（m3o.com）托管平台，有兴趣可以了解它的收费模式，这是开源项目公司进行商业化的一种方式。</p>
<p>就像 Micro 的创始人 Asim 在 Nitro 项目的 FAQ 中说的：</p>
<blockquote>
<p>Go Micro 的维护，需要花费很多的时间精力，它属于 Micro Services，Inc. 公司，该公司现在专注于 Micro as a Service，并将此处的所有接口合并到该项目的服务库中。在大多数情况下，Go Micro 都没有资金支持，虽然得到过好评。因此，在坚持了 6 年后，在 3.0 版中，这个项目属于我个人（Asim），我做出了艰难的决定，要重新许可为非商业项目。对于任何商业应用程序，我正在寻找  <a href="https://github.com/sponsors/asim" target="_blank" rel="noopener">github sponsorship</a>
，以便我可以将这些资金用于维护和支持工作。</p>
</blockquote>
<p>所以，如果你曾经喜欢 Micro 这个项目，建议你可以继续喜欢。当然也希望这次之后，版本能够更稳定。而我看了这些后，作为一个开源爱好者，我准备花时间研究研究 Micro，顺便写写笔记，希望为它的推广做一点贡献。</p>
]]></content>
		</item>
		
		<item>
			<title>除了 fmt.Errorf() 之外—Go 中的日常错误对象：CockroachDB errors 库（第4篇）</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/cockroachdb-errors-everyday/</link>
			<pubDate>Wed, 04 Nov 2020 21:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/cockroachdb-errors-everyday/</guid>
			<description>在 Go 中传递错误的惯用方式是使用预定义的类型错误。但是 Go 的标准库仅提供了非常简单的错误对象，errors.New() 和 fmt.Errorf()。 本文介绍了 CockroachDB 的 error 库（它是 Go 标准库库 errors 的直接替代品），Go 程序员如何用它来描述和传播其代码中的错误和错误代号（code）。 Go 标准库 errors 太简单 由 fmt.Errorf() 构造的 Go 中最常见的“简单”错误对象类似于带有错误接口的包含在结构中的字符串：其</description>
			<content type="html"><![CDATA[<p>在 Go 中传递错误的惯用方式是使用预定义的类型错误。但是 Go 的标准库仅提供了非常简单的错误对象，errors.New() 和 fmt.Errorf()。</p>
<p>本文介绍了 CockroachDB 的 error 库（它是 Go 标准库库 errors 的直接替代品），Go 程序员如何用它来描述和传播其代码中的错误和错误代号（code）。</p>
<h2 id="go-标准库-errors-太简单">Go 标准库 errors 太简单</h2>
<p>由 fmt.Errorf() 构造的 Go 中最常见的“简单”错误对象类似于带有错误接口的包含在结构中的字符串：其 Error() 方法返回构造错误时设置的字符串。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// prints &#34;hello&#34;
</span></code></pre></div><p>什么都没有，仅此而已。打印错误对象也会显示该字符串。顺便说一句，使用 Go 的错误包 errors 的构造函数构建错误 errors.New() 结果一样。</p>
<h2 id="日常代码的简单错误">日常代码的简单错误</h2>
<p>如果使用 <a href="https://github.com/pkg/errors" target="_blank" rel="noopener">Dave Cheney 的错误库</a>
，或者甚至更好的 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">CockroachDB 错误库</a>
（通过导入 <code>github.com/cockroachdb/errors</code>），则简单错误也会在构造错误时自动捕获堆栈跟踪。</p>
<p>仅当详细打印错误时才显示堆栈跟踪。这样可以更轻松地排除错误的来源：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;github.com/cockroachdb/errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// still prints just &#34;hello&#34;
</span><span class="c1"></span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// verbose mode
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这会打印：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">hello
<span class="o">(</span>1<span class="o">)</span> attached stack trace
  -- stack trace:
  <span class="p">|</span> main.main
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:10
  <span class="p">|</span> runtime.main
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/proc.go:203
  <span class="p">|</span> runtime.goexit
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/asm_amd64.s:1373
Wraps: <span class="o">(</span>2<span class="o">)</span> hello
Error types: <span class="o">(</span>1<span class="o">)</span> *withstack.withStack <span class="o">(</span>2<span class="o">)</span> *errutil.leafError
</code></pre></div><p>此详细输出包括第一行的 <code>.Error()</code> 结果，后跟堆栈跟踪内容。</p>
<p>经验一次又一次地表明，在程序中出现意外情况的确切点提取堆栈跟踪的能力对于查明确切原因并成功解决问题至关重要。没有这种能力，程序员会毫无线索，麻木排查，浪费大量时间。</p>
<p>仅出于这个原因，我不鼓励任何人使用 Go 自己的 fmt.Errorf() 或 errors.New()。相反，请导入 github.com/cockroachdb/errors 并仔细阅读以下内容：</p>
<ul>
<li>errors.New()：直接替换 Go 标准库的 errors.New()，但它会带有堆栈跟踪；</li>
<li>errors.Errorf() 或 errors.Newf()：用堆栈跟踪的方式替换 Go 标准库的 fmt.Errorf()；</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">cockroachdb</span><span class="o">/</span><span class="nx">errors</span>

<span class="c1">// New constructs a simple error and attaches a stack trace.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>

<span class="c1">// Newf constructs a simple error whose message is composed using printf-like formatting.
</span><span class="c1">// It also attaches a stack trace.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Newf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>

<span class="c1">// Errorf is an alias for Newf for convenience
</span><span class="c1">// and drop-in compatibility with github.com/pkg/errors.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Errorf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></div><h2 id="在错误中添加消息前缀以识别上下文">在错误中添加消息前缀以识别上下文</h2>
<p>当从多个位置调用相同的逻辑，并且可能因错误而失败时，则希望将消息前缀添加到任何返回的错误对象。</p>
<p>这有助于提供有关“错误发生的位置”的更多上下文，以便在运行时出现错误时（何时出现错误），可以清楚地了解哪个代码路径产生了错误。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;github.com/cockroachdb/errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;boo&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;bar&#34;</span><span class="p">)</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">baz</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;baz&#34;</span><span class="p">)</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="nx">r</span> <span class="o">:=</span> <span class="nf">rollDice</span><span class="p">()</span>
     <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
     <span class="k">if</span> <span class="p">(</span><span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nf">bar</span><span class="p">()</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nf">baz</span><span class="p">()</span>
     <span class="p">}</span>
     <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>多亏了 errors.Wrap()，它为消息添加了前缀，main 函数可能报告 bar:boo 或 baz:boo，并且人可以很方便的知晓是调用了哪个函数导致的错误。如果没有 errors.Wrap()，则导致错误的调用路径将是无法发现的。</p>
<p>为方便起见，当提供 nil 错误作为输入时，errors.Wrap() 返回nil。在许多情况下，这使我们可以消除 if err != nil 条件。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nf">foo</span><span class="p">(),</span> <span class="s">&#34;bar&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">baz</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nf">foo</span><span class="p">(),</span> <span class="s">&#34;baz&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>最后，errors.Wrap() 还将辅助堆栈跟踪附加到错误对象，从而在对错误的来源进行故障排除时提供了额外的上下文。在 channel 的场景出现错误是特别有用。</p>
<p>对于 errors.New()，此堆栈跟踪仅在显示详细错误时可见。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;github.com/cockroachdb/errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;world&#34;</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">bar</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;hello&#34;</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">baz</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">bar</span><span class="p">(</span><span class="nf">foo</span><span class="p">())</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nf">baz</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// still prints just &#34;hello: world&#34;
</span><span class="c1"></span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// verbose mode
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>将打印：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">hello: world
<span class="o">(</span>1<span class="o">)</span> attached stack trace
  -- stack trace:
  <span class="p">|</span> main.bar
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:10
  <span class="p">|</span> <span class="o">[</span>...repeated from below...<span class="o">]</span>
Wraps: <span class="o">(</span>2<span class="o">)</span> hello
Wraps: <span class="o">(</span>3<span class="o">)</span> attached stack trace
  -- stack trace:
  <span class="p">|</span> main.foo
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:9
  <span class="p">|</span> main.baz
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:11
  <span class="p">|</span> main.main
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:14
  <span class="p">|</span> runtime.main
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/proc.go:203
  <span class="p">|</span> runtime.goexit
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/asm_amd64.s:1373
Wraps: <span class="o">(</span>4<span class="o">)</span> world
Error types: <span class="o">(</span>1<span class="o">)</span> *withstack.withStack <span class="o">(</span>2<span class="o">)</span> *errutil.withPrefix <span class="o">(</span>3<span class="o">)</span> *withstack.withStack <span class="o">(</span>4<span class="o">)</span> *errutil.leafError
</code></pre></div><p>和以前一样，<code>.Error()</code> 的结果显示在第一行。然后，打印出最外层的堆栈跟踪（errors.Wrap() 的结果）。这表明错误被包裹在第 10 行，但调用跟踪与下面显示的一样。</p>
<p>然后，详细显示将显示内部错误，并显示消息 <code>world</code> 及其自身的堆栈跟踪。此内部堆栈跟踪显示内部错误是在第 9 行生成的。</p>
<p>错误包装工具用途广泛：可以使用类似于 printf 的格式来编写消息前缀。这是完整的 API：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">cockroachdb</span><span class="o">/</span><span class="nx">errors</span>

<span class="c1">// Wrap adds a message prefix and also attaches an additional stack trace.
</span><span class="c1">// If the first argument is nil, it returns nil.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Wrap</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>

<span class="c1">// Wrap adds a message prefix composed using printf-like formatting,
</span><span class="c1">// and also attaches an additional stack trace.
</span><span class="c1">// If the first argument is nil, it returns nil.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></div><p>此外，为了兼容 Go 1.13 的 fmt.Errorf()，上面看到的 errors.Newf() 和 errors.Errorf() 函数，它们还能识别出格式化动词 ％w，从而触发 wrap 逻辑。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The following is similar to errors.Wrapf(err, &#34;hello&#34;).
</span><span class="c1">// However, it does not return nil if err is nil!
</span><span class="c1"></span><span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Newf</span><span class="p">(</span><span class="s">&#34;hello: %w&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</code></pre></div><p>请注意，只有 Newf()/Errorf() 可以识别 ％w：errors.Wrap() 无法识别。</p>
<blockquote>
<p>提示：应该优先使用 errors.Wrap() 代替特殊动词 ％w：因为它会正确忽略作为输入给出的 nil 错误。</p>
</blockquote>
<h2 id="次要错误注解">次要错误注解</h2>
<p>每个中级 Go 程序员都会迅速陷入这一痛苦的境地：如果在处理错误时遇到错误，该怎么办？</p>
<p>一个常见的示例是在处理文件时遇到错误后清理文件系统：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">writeConfig</span><span class="p">(</span><span class="nx">out</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cfgA</span><span class="p">,</span> <span class="nx">cfgB</span> <span class="nx">Config</span><span class="p">)</span> <span class="p">(</span><span class="nx">resErr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Create the destination directory.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">MkDir</span><span class="p">(</span><span class="nx">out</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
       <span class="c1">// If an error is encountered below, remove
</span><span class="c1"></span>       <span class="c1">// the destination directory upon exit.
</span><span class="c1"></span>       <span class="k">if</span> <span class="nx">resErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">if</span> <span class="nx">dirErr</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">RemoveAll</span><span class="p">(</span><span class="nx">out</span><span class="p">);</span> <span class="nx">dirErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
             <span class="c1">// now... what?
</span><span class="c1"></span>             <span class="o">...</span>
         <span class="p">}</span>
       <span class="p">}</span>
    <span class="p">}()</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">writeCfg</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">cfgA</span><span class="p">,</span> <span class="s">&#34;a.json&#34;</span><span class="p">,</span> <span class="s">&#34;config A&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">writeCfg</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">cfgB</span><span class="p">,</span> <span class="s">&#34;b.json&#34;</span><span class="p">,</span> <span class="s">&#34;config B&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">writeCfg</span><span class="p">(</span><span class="nx">outDir</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">cfg</span> <span class="nx">Config</span><span class="p">,</span> <span class="nx">filename</span><span class="p">,</span> <span class="nx">desc</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">j</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">cfg</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;marshaling %s&#34;</span><span class="p">,</span> <span class="nx">desc</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">WriteFile</span><span class="p">(</span><span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">filename</span><span class="p">),</span> <span class="nx">j</span><span class="p">,</span> <span class="mo">0777</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>本示例中的函数创建一个输出目录，以将两个配置对象写入其中。但是，在写入某些配置对象时可能会发生错误。在这种情况下，该函数希望通过删除刚刚创建的目录来对其进行清理。</p>
<p>如果在目录删除过程中发生错误，该怎么办？应该返回哪个错误？</p>
<ul>
<li>如果返回原始错误，我们将看不到目录删除错误。</li>
<li>如果返回目录删除错误，我们将看不到文件生成错误。</li>
</ul>
<p>我们希望以某种方式返回有关这两个错误的详细信息，以帮助进行故障排除。同时，出于原因分析的目的，我们要谨慎地将遇到的第一个错误保留为“主要”错误。</p>
<p>我们可以通过如下调整代码来实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
   <span class="c1">// If an error is encountered below, remove
</span><span class="c1"></span>   <span class="c1">// the destination directory upon exit.
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">resErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">dirErr</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">RemoveAll</span><span class="p">(</span><span class="nx">out</span><span class="p">);</span> <span class="nx">dirErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="c1">// This attaches dirErr as an ancillary error
</span><span class="c1"></span>         <span class="c1">// to the error object that was already stored in resErr.
</span><span class="c1"></span>         <span class="nx">resErr</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">WithSecondaryError</span><span class="p">(</span><span class="nx">resErr</span><span class="p">,</span> <span class="nx">dirErr</span><span class="p">)</span>
     <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}()</span>
</code></pre></div><p>通过这种编程模式，我们可以确信，在处理另一个错误时，我们可以保留遇到错误时所发生事件的全部情况。</p>
<p>次要错误注解不会影响主要错误上 <code>.Error()</code> 返回的文本。从相关代码以及标准 API error.Is() 的角度来看，代码的行为就像仅发生了主要错误一样。</p>
<p>但是，在详细打印过程中会发现第二个错误。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;github.com/cockroachdb/errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
  <span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">WithSecondaryError</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;friend&#34;</span><span class="p">))</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// prints just &#34;hello&#34;
</span><span class="c1"></span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// verbose mode
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>打印：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">hello
<span class="o">(</span>1<span class="o">)</span> secondary error attachment
  <span class="p">|</span> friend
  <span class="p">|</span> <span class="o">(</span>1<span class="o">)</span> attached stack trace
  <span class="p">|</span>   -- stack trace:
  <span class="p">|</span>   <span class="p">|</span> main.main
  <span class="p">|</span>   <span class="p">|</span>         /home/kena/src/errors-tests/test.go:11
  <span class="p">|</span>   <span class="p">|</span> runtime.main
  <span class="p">|</span>   <span class="p">|</span>         /usr/lib/go-1.14/src/runtime/proc.go:203
  <span class="p">|</span>   <span class="p">|</span> runtime.goexit
  <span class="p">|</span>   <span class="p">|</span>         /usr/lib/go-1.14/src/runtime/asm_amd64.s:1373
  <span class="p">|</span> Wraps: <span class="o">(</span>2<span class="o">)</span> friend
  <span class="p">|</span> Error types: <span class="o">(</span>1<span class="o">)</span> *withstack.withStack <span class="o">(</span>2<span class="o">)</span> *errutil.leafError
Wraps: <span class="o">(</span>2<span class="o">)</span> attached stack trace
  -- stack trace:
  <span class="p">|</span> main.main
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:10
  <span class="p">|</span> runtime.main
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/proc.go:203
  <span class="p">|</span> runtime.goexit
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/asm_amd64.s:1373
Wraps: <span class="o">(</span>3<span class="o">)</span> hello
Error types: <span class="o">(</span>1<span class="o">)</span> *secondary.withSecondaryError <span class="o">(</span>2<span class="o">)</span> *withstack.withStack <span class="o">(</span>3<span class="o">)</span> *errutil.leafError
</code></pre></div><p>像以前一样，我们在第一行看到 <code>.Error()</code> 的文本。然后，我们看到附加的次要错误的详细打印输出，相对于主要错误向右缩进。次要错误自己的 <code>.Error()</code> 是 <code>friend</code>，首先打印它，然后打印次要错误的嵌入式堆栈跟踪。</p>
<p>然后，打印输出继续，不缩进地显示主要错误的堆栈跟踪。</p>
<p>API 概览：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">cockroachdb</span><span class="o">/</span><span class="nx">errors</span>

<span class="c1">// WithSecondaryError attaches secondary as an annotation
</span><span class="c1">// to the primary error. If primary is nil, nil is returned.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WithSecondaryError</span><span class="p">(</span><span class="nx">primary</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">secondary</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span>

<span class="c1">// CombineErrors attaches err2 to err1 as secondary error
</span><span class="c1">// if both err1 and err2 are not nil. If err1 is nil, err2
</span><span class="c1">// is returned instead.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">CombineErrors</span><span class="p">(</span><span class="nx">err1</span><span class="p">,</span> <span class="nx">err2</span> <span class="kt">error</span><span class="p">)</span> <span class="nx">errors</span>
</code></pre></div><h2 id="子任务更智能的错误处理">子任务更智能的错误处理</h2>
<p>扩展包 <a href="https://godoc.org/golang.org/x/sync/errgroup" target="_blank" rel="noopener">errgroup</a>
 提供了一个可重复使用的库，用于“为处理共同任务的子任务的 goroutine 组进行同步，错误传播和上下文取消”。</p>
<p>它的实现可以在这里找到：<a href="https://github.com/golang/sync/blob/master/errgroup/errgroup.go" target="_blank" rel="noopener">https://github.com/golang/sync/blob/master/errgroup/errgroup.go</a>
。</p>
<p>在较高的级别上，它使用 sync.WaitGroup 运行多个 goroutine，并在末尾添加一个屏障。此外，一旦它们中的任何一个因错误终止，它将取消该组中的所有其他 goroutine。</p>
<p>逻辑问题在于，如果两个或多个 goroutine 因错误而失败，则仅报告第一个错误。其他错误是“被遗忘的”：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">g</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

     <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
             <span class="k">defer</span> <span class="nx">g</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>

             <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">f</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                     <span class="c1">// errOnce.Do executes its argument just once. The second time an
</span><span class="c1"></span>                     <span class="c1">// error is encountered, it is simply forgotten altogether! Not nice.
</span><span class="c1"></span>                     <span class="nx">g</span><span class="p">.</span><span class="nx">errOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                             <span class="nx">g</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">err</span>
                             <span class="k">if</span> <span class="nx">g</span><span class="p">.</span><span class="nx">cancel</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                                     <span class="nx">g</span><span class="p">.</span><span class="nf">cancel</span><span class="p">()</span>
                             <span class="p">}</span>
                     <span class="p">})</span>
             <span class="p">}</span>
     <span class="p">}()</span>
<span class="p">}</span>
</code></pre></div><p>我们可以按以下方式解决此问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Group</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="o">...</span>
     <span class="nx">errOnce</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
     <span class="nx">mu</span> <span class="p">{</span>
        <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// makes .err race-free.
</span><span class="c1"></span>        <span class="nx">err</span>     <span class="kt">error</span>
     <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="o">...</span>
   <span class="k">return</span> <span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
     <span class="o">...</span>
     <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
             <span class="o">...</span>
             <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">f</span><span class="p">();</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Canceled</span><span class="p">)</span> <span class="p">{</span>
                   <span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
                   <span class="k">defer</span> <span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
                   <span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">CombineErrors</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">err</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
             <span class="p">}</span>
     <span class="p">}()</span>
<span class="p">}</span>
</code></pre></div><p>使用 errgroup.Group 的此备用版本，如果子任务中有两个或多个错误，则第一个将成为“主要”错误，而第一个之后的所有其他错误将作为辅助错误注解附加。</p>
<p>该代码还使用 errors.Is(err, context.Canceled) 来排除由组调用共享上下文的 cancel() 函数而产生的错误对象，这些对象只是噪音，可能在故障排除期间没有用。</p>
<h2 id="检查错误的身份">检查错误的身份</h2>
<p>在最常见的情况下，错误会传播，最终通过网络连接返回，或打印到日志文件。</p>
<p>但是，有时代码需要检查错误对象以决定其他行为。</p>
<p>为此，库可以定义一些特定的函数来处理这种情况。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">os</span>

<span class="c1">// IsExist returns a boolean indicating whether the error is known to report
</span><span class="c1">// that a file or directory already exists. It is satisfied by ErrExist as
</span><span class="c1">// well as some syscall errors.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">IsExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></div><p>可以这样使用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ensureDirectoryExists</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Mkdir</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// The directory already exists. This is OK,
</span><span class="c1"></span>         <span class="c1">// no need to report an error.
</span><span class="c1"></span>         <span class="nx">err</span> <span class="p">=</span> <span class="kc">nil</span>
       <span class="p">}</span>
       <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;directory created&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>此函数尝试创建目录。如果已经存在，它将不执行任何操作。如果遇到另一个错误（例如磁盘损坏等），则会报告该错误。</p>
<p>另一种技术是使用“前哨”错误，并将返回的错误对象与那些标记进行比较以检测特定情况。</p>
<p>我们看到了上面带有 error.Is(err, context.Canceled) 的示例。这是来自 SQL 客户端程序的另一个示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">sqlConn</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">sqlRows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ensureConn</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
             <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
     <span class="p">}</span>
     <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
     <span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span><span class="p">)</span> <span class="p">{</span>
             <span class="c1">// If the connection has been closed by the server or
</span><span class="c1"></span>             <span class="c1">// there was some other kind of network error, close
</span><span class="c1"></span>             <span class="c1">// the connection on our side so that the call to
</span><span class="c1"></span>             <span class="c1">// ensureConn() above establishes a new connection
</span><span class="c1"></span>             <span class="c1">// during the next query.
</span><span class="c1"></span>             <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
             <span class="nx">c</span><span class="p">.</span><span class="nx">reconnecting</span> <span class="p">=</span> <span class="kc">true</span>
     <span class="p">}</span>
     <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
             <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="o">&amp;</span><span class="nx">sqlRows</span><span class="p">{</span><span class="nx">rows</span><span class="p">:</span> <span class="nx">rows</span><span class="p">.(</span><span class="nx">sqlRowsI</span><span class="p">),</span> <span class="nx">conn</span><span class="p">:</span> <span class="nx">c</span><span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>此代码检测 SQL 驱动程序何时返回 driver.ErrBadConn 并在这种情况下选择特殊行为。任何其他错误均按原样返回，并导致程序在此函数的调用程序中的某处停止。</p>
<blockquote>
<p>errors.is() 可以通过重复调用  Unwrap() 方法来检测整个错误的直接因果链中的前哨错误。因此，将忽略“在途中”发现的任何次要错误注解。这种行为是有意设计的：类似树的行为将使人们难以推理出错误是另一个“原因”的含义。还会在其他 API errors.As() 错误中引发有关遍历顺序的难题。就个人而言，经验还没有向我表明，除线性因果链之外，其他任何东西在实践中有用。</p>
</blockquote>
<h2 id="和-pkgerrors-的不同">和 pkg/errors 的不同</h2>
<p>自 2016 年以来，事实上是 Go 的错误包的标准替代品是 Dave Cheney 的 pkg/errors 库，该库位于 <a href="https://github.com/pkg/errors" target="_blank" rel="noopener">https://github.com/pkg/errors</a>
。</p>
<p>该包最初引入了链接列表错误对象的概念，自动包装错误并添加堆栈跟踪以在故障排除期间提供更多上下文。</p>
<p>不幸的是，Go 1.13 的发布使 pkg/errors 过时了：Dave Cheney 定义了自己的库，使用一种名为 Cause() 的方法来提取错误链的线性原因。当 Go 1.13 采纳用链接列表出错的想法时，它定义了另一个方法 Unwrap() 来提取原因。因此，Go 的errors.Is()和其他 API 无法理解源自 pkg/errors 的错误。</p>
<p>此外，来自 pkg/errors 的对象将严重遭受 Go Error 打印灾难，因此该库使自定义错误类型的实现非常困难。</p>
<p>CockroachDB 错误库接管了 pkg/errors：它采用 Go 1.13 约定，提供了 Go 1.13 标准 API 的直接替代品，并避免了 Go 错误打印灾难。它还实现了大多数 pkg/errors 接口，因此可以用作以前使用 Dave Cheney 库的程序的直接替代。</p>
<h2 id="总结">总结</h2>
<p>Go 库通过 Go 自己的错误包中的 fmt.Errorf() 和 errors.New() 提供了错误接口的简化实现。</p>
<p>改用 CockroachDB 错误库，代替 Go 的错误包和 Dave Cheney的 pkg/errors，可以获得更好的体验。</p>
<p>它的错误构造函数 errors.New()/errors.Newf()（别名为 errors.Errorf()）自动在错误对象中包含堆栈跟踪，可以使用 <code>fmt.Printf(&quot;％+v&quot; ,err)</code> 打印堆栈追踪。</p>
<p>它还提供了错误包装器的词汇表。最常见的是带有 errors.Wrap()/errors.Wrapf() 的消息前缀注释，用于注释从多个位置调用的函数的调用路径。这还包括幕后的堆栈跟踪。</p>
<p>另一个常见的包装器解决了在处理另一个错误时遇到错误时如何在 Go 中执行的令人困惑的问题：使用辅助原因注解，并使用 errors.WithSecondaryCause() 或 errors.CombineErrors() 附加，Go 代码可以保留两个错误，因此程序员在故障排除期间可以同时看到两者。</p>
<p>CockroachDB 错误库中的错误还提供了一致的行为，并且在详细格式化错误时提供了有用的显示结构，从而避免了巨大的 Go 错误打印灾难。我们将在本系列的后续文章中专门探讨实现自定义错误，以进一步探讨该主题。</p>
]]></content>
		</item>
		
		<item>
			<title>从来没有这么强烈想推荐一个工具</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/cheat-sh/</link>
			<pubDate>Tue, 03 Nov 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/cheat-sh/</guid>
			<description>大家好，我是站长 polarisxu。 在逛 GitHub Trending 时看到了这个项目：https://github.com/chubin/cheat.sh ，因为之前我整理过一系列 cheatsheet，因此好奇的打开了这个项目。于是被它吸引了。。。 01 是什么 该项目的描述是： the only cheat sheet you need 简单一句话却很吸引人：这么强大，这一个 cheatsheet 就够了？ 因为在这一份清单中，包含了几乎所有开发者常见的东西，不</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>在逛 GitHub Trending 时看到了这个项目：<a href="https://github.com/chubin/cheat.sh" target="_blank" rel="noopener">https://github.com/chubin/cheat.sh</a>
，因为之前我整理过一系列 cheatsheet，因此好奇的打开了这个项目。于是被它吸引了。。。</p>
<h2 id="01-是什么">01 是什么</h2>
<p>该项目的描述是：</p>
<blockquote>
<p>the only cheat sheet you need</p>
</blockquote>
<p>简单一句话却很吸引人：这么强大，这一个 cheatsheet 就够了？</p>
<p>因为在这一份清单中，包含了几乎所有开发者常见的东西，不仅如此，它还提供了很好的获取接口，让你轻松的找到你想要的。它是一个统一访问世界上最好的、社区驱动的备忘单（cheat sheet）存储库。</p>
<h2 id="02-有什么">02 有什么</h2>
<p>让我们想象一下，有一种理想的备忘单。看起来像什么？它应该具有什么功能？</p>
<ul>
<li><strong>简洁</strong>—它只应包含你需要的东西，而不能包含其他任何东西；</li>
<li><strong>快速</strong>—想使用时就能立马使用；</li>
<li><strong>全面</strong>—它应该包含每个可能问题的答案；</li>
<li><strong>通用</strong>—它应该随处可用，无需任何准备；</li>
<li><strong>不打扰</strong>—它不应分散你的主要任务；</li>
<li><strong>辅导</strong>—它应该可以帮助你学习该主题；</li>
<li><strong>不起眼</strong>—完全可以忽略使用它；</li>
</ul>
<p>作者认为 cheat.sh 做到了。我也认为做到了。</p>
<p><strong>那它具体有哪些特性呢？</strong></p>
<ul>
<li>具有简单的 curl/browser 界面；</li>
<li>涵盖 56 种编程语言，若干 DBMS 和 1000 多种最重要的 UNIX/Linux 命令；</li>
<li>与 StackOverflow 一样，提供对世界上最好的社区驱动的备忘单存储库的访问；</li>
<li>随处可用，无需安装；</li>
<li>超快，通常会在 100 毫秒内返回答案；</li>
<li>有一个方便的命令行客户端 cht.sh，虽然不是必须的，但它非常有用且很有帮助；</li>
<li>可以直接从代码编辑器中使用，而无需打开浏览器并且不切换您的思维环境；</li>
<li>支持特殊的隐形模式，在这种模式下，无需触摸按键和发出声音即可完全隐身使用；</li>
</ul>
<h2 id="03-如何使用">03 如何使用</h2>
<p>使用 cheat.sh 有以下几种方式：（可以是 HTTP 或 HTTPS，也可以是 cheat.sh 或 cht.sh）</p>
<ul>
<li>在终端使用 curl 工具；</li>
<li>使用其他 HTTP/HTTPS 客户端；</li>
<li>浏览器访问 cheat.sh；</li>
<li>终端使用 cht.sh 客户端；</li>
<li>在你的编辑器中集成；</li>
</ul>
<p>一般建议通过 curl 工具、cht.sh 客户端或编辑器插件来使用。使用示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ curl cheat.sh/tar
$ curl cht.sh/go
$ curl https://cheat.sh/php
$ curl https://cht.sh/redis
</code></pre></div><p>上面例子中，tar、go、php、redis 等可以是 Linux 命令，也可以是语言的命令等。</p>
<p>如果你记不起来命令准确名称，则可以使用 〜KEYWORD 表示法进行搜索。例如，查看如何制作文件系统/卷/其他内容的快照：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ curl cht.sh/~snapshot
</code></pre></div><p>官方的一张图看看相关说明：</p>
<p><p class="md__image">
  <img src="../imgs/cheat01.png"
    alt=""  />
</p>
</p>
<p>关于选项（options），可以通过 <code>/:help</code> 查看。对于开发来说，经常会加上 Q 选项，比如上面命令加上 Q 选项后的结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ curl <span class="s2">&#34;http://cheat.sh/go/execute+external+program?Q&#34;</span>
cmd :<span class="o">=</span> exec.Command<span class="o">(</span><span class="s2">&#34;yourcommand&#34;</span>, <span class="s2">&#34;some&#34;</span>, <span class="s2">&#34;args&#34;</span><span class="o">)</span>
<span class="k">if</span> err :<span class="o">=</span> cmd.Run<span class="o">()</span><span class="p">;</span> err !<span class="o">=</span> nil <span class="o">{</span>
    fmt.Println<span class="o">(</span><span class="s2">&#34;Error: &#34;</span>, err<span class="o">)</span>
<span class="o">}</span>
</code></pre></div><p>关于更多使用在客户端工具 cht.sh 中介绍。</p>
<h2 id="04-客户端工具-chtsh">04 客户端工具 cht.sh</h2>
<p>cheat.sh 服务有自己的命令行客户端（cht.sh），与使用 curl 直接查询该服务相比，它具有几个有用的功能：</p>
<ul>
<li>特殊的 shell 模式，具有持久查询上下文和 readline 支持；</li>
<li>查询历史；</li>
<li>粘贴板整合；</li>
<li>shell 的 tab 完成支持（bash、zsh、fish）；</li>
<li>stealth 模式；</li>
</ul>
<h3 id="安装">安装</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">mkdir -p ~/bin/
curl https://cht.sh/:cht.sh &gt; ~/bin/cht.sh
chmod +x ~/bin/cht.sh
</code></pre></div><p>确保 cht.sh 在 PATH 中，方便使用。</p>
<p>shell 模式需要 rlwrap，这是 readline 的包装。Mac 下可以通过 brew install rlwrap 安装。</p>
<h3 id="使用">使用</h3>
<p>有了 cht.sh，之前 curl 的方式可以用更自然的方式。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ cht.sh go execute external program
</code></pre></div><p>个人更推荐采用交互式 shell 模式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ cht.sh --shell <span class="o">[</span>LANG<span class="o">]</span>
</code></pre></div><p>其中 [LANG] 可以指定具体的编程语言，比如 go。</p>
<p>因此 cheat.sh 命令有两种上下文：特定语言和非特定语言（全局）。<code>:help</code> 在这两种上下文下显示的内容是不一样的。</p>
<ul>
<li>在特定语言下，有 hello、<code>:list</code> 和 <code>:learn</code>，其中 <code>:learn</code> 是该语言的一个简短教程；</li>
<li>通过 <code>/</code> 可以切换上下文。比如：/go  表示在 go 这个语言上下文查找；/tar 表示在全局上下文查找 tar 命令；</li>
<li>查找当前所在语言的内容，直接查询即可，比如当前如果是 Go 上下文，直接输入 int，可以查看 int 类型的信息；</li>
</ul>
<p>在交互式 shell 下通过 help 命令可以查看帮助：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">cht.sh&gt; <span class="nb">help</span>
<span class="nb">help</span>    - show this <span class="nb">help</span>
hush    - <span class="k">do</span> not show the <span class="s1">&#39;help&#39;</span> string at start anymore
<span class="nb">cd</span> LANG - change the language context
copy    - copy the last answer in the clipboard <span class="o">(</span>aliases: yank, y, c<span class="o">)</span>
ccopy   - copy the last answer w/o comments <span class="o">(</span>cut comments<span class="p">;</span> aliases: cc, Y, C<span class="o">)</span>
<span class="nb">exit</span>    - <span class="nb">exit</span> the cheat shell <span class="o">(</span>aliases: quit, ^D<span class="o">)</span>
id <span class="o">[</span>ID<span class="o">]</span> - set/show an unique session id <span class="o">(</span><span class="s2">&#34;reset&#34;</span> to reset, <span class="s2">&#34;remove&#34;</span> to remove<span class="o">)</span>
stealth - stealth mode <span class="o">(</span>automatic queries <span class="k">for</span> selected text<span class="o">)</span>
update  - self update <span class="o">(</span>only <span class="k">if</span> the scriptfile is writeable<span class="o">)</span>
version - show current cht.sh version
/:help  - service <span class="nb">help</span>
QUERY   - space separated query staring <span class="o">(</span>examples are below<span class="o">)</span>
              cht.sh&gt; python zip list
              cht.sh/python&gt; zip list
              cht.sh/go&gt; /python zip list
</code></pre></div><p>其中 cd 用来切换语言上下文；copy 和 ccopy 用来复制内容。</p>
<h3 id="定制">定制</h3>
<p>如果你想要定制 cht.sh，可以编辑文件：<code>~/.cht.sh/cht.sh.conf</code>。我觉得用默认即可。</p>
<h2 id="05-编辑器集成">05 编辑器集成</h2>
<p>这方面对 Vim 的支持是最好的。见下图：</p>
<p><p class="md__image">
  <img src="../imgs/cheat02.png"
    alt=""  />
</p>
</p>
<p>项目首页提供了这些编辑器对应的插件和配置、使用方法。请自行根据需要按照、配置。</p>
<h2 id="06-搜索">06 搜索</h2>
<p>cheat.sh 包含内容众多，方便的搜索是必不可少的。除了上文介绍的 ~KEYWORD 方式，还支持其他一些选项（辅助功能）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">i   <span class="k">case</span> insensitive search
b   word boundaries
r   recursive search
</code></pre></div><p>比如：</p>
<pre tabindex="0"><code>/~shot/bi
</code></pre><h2 id="07-实际用途">07 实际用途</h2>
<p>比如我想查询某们语言 MD5 怎么用？</p>
<p><strong>Go 语言</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">cht</span><span class="p">.</span><span class="nx">sh</span><span class="p">&gt;</span><span class="o">/</span><span class="k">go</span> <span class="nx">md5</span>

<span class="cm">/*
</span><span class="cm"> * cryptography - How to get a MD5 hash from a string in Golang ...
</span><span class="cm"> *
</span><span class="cm"> * From crypto/md5 doc (http:golang.org/pkg/crypto/md5/#New):
</span><span class="cm"> */</span>

<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;crypto/md5&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;io&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">md5</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="s">&#34;The fog is getting thicker!&#34;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%x&#34;</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// [Stephen Hsu] [so/q/2377881] [cc by-sa 3.0]
</span></code></pre></div><p><strong>PHP 语言</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="nx">cht</span><span class="o">.</span><span class="nx">sh</span><span class="o">&gt;/</span><span class="nx">php</span> <span class="nx">md5</span>

<span class="cm">/*
</span><span class="cm"> * php - Using MD5 on login page
</span><span class="cm"> *
</span><span class="cm"> * Simply wrap $_POST[&#39;password&#39;] into md5() like so:
</span><span class="cm"> */</span>

<span class="nv">$mypassword</span> <span class="o">=</span> <span class="nx">md5</span> <span class="p">(</span><span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;password&#39;</span><span class="p">]);</span>
</code></pre></div><p><strong>Java 语言</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">cht</span><span class="o">.</span><span class="na">sh</span><span class="o">&gt;/</span><span class="n">java</span> <span class="n">md5</span>

<span class="cm">/*
</span><span class="cm"> * java - How can I generate an MD5 hash?
</span><span class="cm"> *
</span><span class="cm"> * The MessageDigest class can provide you with an instance of the MD5
</span><span class="cm"> * digest.
</span><span class="cm"> *
</span><span class="cm"> * When working with strings and the crypto classes be sure to always
</span><span class="cm"> * specify the encoding you want the byte representation in. If you just
</span><span class="cm"> * use string.getBytes() it will use the platform default. (Not all
</span><span class="cm"> * platforms use the same defaults)
</span><span class="cm"> */</span>

<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>

<span class="o">..</span>

<span class="kt">byte</span><span class="o">[]</span> <span class="n">bytesOfMessage</span> <span class="o">=</span> <span class="n">yourString</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">&#34;UTF-8&#34;</span><span class="o">);</span>

<span class="n">MessageDigest</span> <span class="n">md</span> <span class="o">=</span> <span class="n">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">&#34;MD5&#34;</span><span class="o">);</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">thedigest</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="na">digest</span><span class="o">(</span><span class="n">bytesOfMessage</span><span class="o">);</span>

<span class="o">/*</span>
 <span class="o">*</span> <span class="n">If</span> <span class="n">you</span> <span class="n">have</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span> <span class="n">take</span> <span class="n">a</span> <span class="n">look</span> <span class="n">at</span> <span class="n">the</span> <span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="kt">byte</span><span class="o">[])</span> <span class="n">method</span>
 <span class="o">*</span> <span class="n">which</span> <span class="n">can</span> <span class="n">be</span> <span class="n">called</span> <span class="n">repeatedly</span><span class="o">.</span> <span class="n">Then</span> <span class="n">call</span> <span class="o">.</span><span class="na">digest</span><span class="o">()</span> <span class="n">to</span> <span class="n">obtain</span> <span class="n">the</span>
 <span class="o">*</span> <span class="n">resulting</span> <span class="n">hash</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="o">[</span><span class="n">koregan</span><span class="o">]</span> <span class="o">[</span><span class="n">so</span><span class="o">/</span><span class="n">q</span><span class="o">/</span><span class="n">415953</span><span class="o">]</span> <span class="o">[</span><span class="n">cc</span> <span class="n">by</span><span class="o">-</span><span class="n">sa</span> <span class="n">3</span><span class="o">.</span><span class="na">0</span><span class="o">]</span>
</code></pre></div><p>再比如你需要反转一个数组，不知道怎么写，可以找 cheat.sh 帮忙：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">cht</span><span class="p">.</span><span class="nx">sh</span><span class="p">&gt;</span> <span class="o">/</span><span class="k">go</span> <span class="nx">reverse</span> <span class="nx">list</span>

<span class="cm">/*
</span><span class="cm"> * How do I reverse an array in Go?
</span><span class="cm"> *
</span><span class="cm"> * Honestly this one is simple enough that I&#39;d just write it out like
</span><span class="cm"> * this:
</span><span class="cm"> */</span>

<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>

    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
        <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="08-数据来源">08 数据来源</h2>
<p>目前 cheat.sh 的数据来源如下：</p>
<p><p class="md__image">
  <img src="../imgs/cheat03.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/cheat04.png"
    alt=""  />
</p>
</p>
<p>你也可以为 cheat.sh 做贡献，输入 <code>:post</code> 看看。</p>
<h2 id="09-总结">09 总结</h2>
<p>这个项目在 GitHub 近 21k Star，觉得不错可以点个 Star，让更多人知晓这个优秀的项目。希望它能够为你的工作带来便利，通过查这个手册，能够提升你的效率，同时增强你的能力。</p>
]]></content>
		</item>
		
		<item>
			<title>提前试用将在 Go1.16 中发布的内嵌静态资源功能</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go-embed-try/</link>
			<pubDate>Sun, 01 Nov 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go-embed-try/</guid>
			<description>大家好，我是站长 polarisxu。 喜欢 Go 语言有很多理由，其中有一点“因为编译为一个二进制文件，直接运行，没有其他依赖，使得部署特别容易。”我想是很多人喜欢的。 然而一个项目，很可能会包含一些静态资源文件，这样一来，一个 Go 二进制文件就不能解决了，需要将静态资源文件一起带上。于是有了很多第三方解决方案，将静态资源文件“嵌入”最终的 Go 二进制文件中。最知名的应该是 go-bindata</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>喜欢 Go 语言有很多理由，其中有一点“因为编译为一个二进制文件，直接运行，没有其他依赖，使得部署特别容易。”我想是很多人喜欢的。</p>
<p>然而一个项目，很可能会包含一些静态资源文件，这样一来，一个 Go 二进制文件就不能解决了，需要将静态资源文件一起带上。于是有了很多第三方解决方案，将静态资源文件“嵌入”最终的 Go 二进制文件中。最知名的应该是 <a href="https://pkg.go.dev/github.com/jteeuwen/go-bindata" target="_blank" rel="noopener">go-bindata</a>
，此外还有很多其他的：</p>
<ul>
<li><a href="https://pkg.go.dev/github.com/alecthomas/gobundle" target="_blank" rel="noopener">github.com/alecthomas/gobundle</a>
</li>
<li><a href="https://pkg.go.dev/github.com/GeertJohan/go.rice" target="_blank" rel="noopener">github.com/GeertJohan/go.rice</a>
</li>
<li><a href="https://pkg.go.dev/github.com/go-playground/statics" target="_blank" rel="noopener">github.com/go-playground/statics</a>
</li>
<li><a href="https://pkg.go.dev/github.com/gobuffalo/packr" target="_blank" rel="noopener">github.com/gobuffalo/packr</a>
</li>
<li><a href="https://pkg.go.dev/github.com/knadh/stuffbin" target="_blank" rel="noopener">github.com/knadh/stuffbin</a>
</li>
<li><a href="https://pkg.go.dev/github.com/mjibson/esc" target="_blank" rel="noopener">github.com/mjibson/esc</a>
</li>
<li><a href="https://pkg.go.dev/github.com/omeid/go-resources" target="_blank" rel="noopener">github.com/omeid/go-resources</a>
</li>
<li><a href="https://pkg.go.dev/github.com/phogolabs/parcello" target="_blank" rel="noopener">github.com/phogolabs/parcello</a>
</li>
<li><a href="https://pkg.go.dev/github.com/pyros2097/go-embed" target="_blank" rel="noopener">github.com/pyros2097/go-embed</a>
</li>
<li><a href="https://pkg.go.dev/github.com/rakyll/statik" target="_blank" rel="noopener">github.com/rakyll/statik</a>
</li>
<li><a href="https://pkg.go.dev/github.com/shurcooL/vfsgen" target="_blank" rel="noopener">github.com/shurcooL/vfsgen</a>
</li>
<li><a href="https://pkg.go.dev/github.com/UnnoTed/fileb0x" target="_blank" rel="noopener">github.com/UnnoTed/fileb0x</a>
</li>
<li><a href="https://pkg.go.dev/github.com/wlbr/templify" target="_blank" rel="noopener">github.com/wlbr/templify</a>
</li>
<li><a href="https://pkg.go.dev/perkeep.org/pkg/fileembed" target="_blank" rel="noopener">perkeep.org/pkg/fileembed</a>
</li>
</ul>
<p>从这个列表足以看出需求的广泛性。于是官方决定提供实现，在 go 命令中实现该功能。因为在 Go 命令中添加对嵌入基本功能的直接支持将消除对某些工具的需求，至少可以简化其他工具的实现。</p>
<p>2020 年 10 月 30 日，Russ Cox 提交了最终的实现：<a href="https://github.com/golang/go/commit/25d28ec55aded46e0be9c2298f24287d296a9e47" target="_blank" rel="noopener">cmd/go: add //go:embed support</a>
，意味着你在 tip 版本可以试用该功能了。Go1.16 版本会包含该功能。欢迎大家试用，反馈建议。</p>
<h2 id="01-试用-go-embed">01 试用 go embed</h2>
<p>通过几个示例快速了解 go embed 的用法。</p>
<h3 id="例-1内嵌文件--web-应用">例 1：内嵌文件 — Web 应用</h3>
<p>基于 Echo 框架：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">_</span> <span class="s">&#34;embed&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/labstack/echo&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static/logo.png
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">content</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Blob</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;image/png&#34;</span><span class="p">,</span> <span class="nx">content</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>目录结构如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">.
├── main.go
└── static
    └── logo.png
</code></pre></div><p>编译运行后，可以将二进制文件移到任何地方运行，浏览器访问 http://localhost:8989，能够正确显示 logo 图片表示成功了。</p>
<p>基于 Gin 框架，代码类似：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="nx">_</span> <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;net/http&#34;</span>

    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static/logo.png
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">content</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">router</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
    <span class="nx">router</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ctx</span><span class="p">.</span><span class="nf">Data</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;image/png&#34;</span><span class="p">,</span> <span class="nx">content</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">router</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>直接使用 net/http 库，代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="nx">_</span> <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static/logo.png
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">content</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;image/png&#34;</span><span class="p">)</span>
        <span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">content</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h3 id="例-2内嵌文件--命令行应用">例 2：内嵌文件 — 命令行应用</h3>
<p>简单的 Hello World：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="nx">_</span> <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed message.txt
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">message</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>其中 messaeg.txt 中的内容是 Hello World。目录结构如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">.
├── main.go
└── message.txt
</code></pre></div><p>编译后，可以将二进制移到任何地方，运行输出 Hello World（即 messaeg.txt 中的内容）。</p>
<h3 id="例-3内嵌目录---命令行应用">例 3：内嵌目录 - 命令行应用</h3>
<p>以下程序将 static 目录内嵌到二进制程序中，然后在当前目录创建 static 目录中的所有文件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;embed&#34;</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;path&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">local</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">local</span><span class="p">.</span><span class="nf">ReadDir</span><span class="p">(</span><span class="s">&#34;static&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fi</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fis</span> <span class="p">{</span>
		<span class="nx">in</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">local</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">&#34;static&#34;</span><span class="p">,</span> <span class="nx">fi</span><span class="p">.</span><span class="nf">Name</span><span class="p">()))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">out</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="s">&#34;embed-&#34;</span> <span class="o">+</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Base</span><span class="p">(</span><span class="nx">fi</span><span class="p">.</span><span class="nf">Name</span><span class="p">()))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
		<span class="nx">out</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="nx">in</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;exported&#34;</span><span class="p">,</span> <span class="s">&#34;embed-&#34;</span><span class="o">+</span><span class="nx">path</span><span class="p">.</span><span class="nf">Base</span><span class="p">(</span><span class="nx">fi</span><span class="p">.</span><span class="nf">Name</span><span class="p">()))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>该示例的目录结构和例 1 一样。编译后，可以将二进制文件移到任何地方，运行后，会在当前目录输出以 embed- 开头的文件。</p>
<h3 id="例-4内嵌目录--web-应用">例 4：内嵌目录 — Web 应用</h3>
<p>基于 Echo 框架：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;net/http&#34;</span>

    <span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">local</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/*&#34;</span><span class="p">,</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FS</span><span class="p">(</span><span class="nx">local</span><span class="p">))))</span>
    <span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>同样，目录结构和 example1 一致。编译后运行，访问 http://localhost:8989，看到如下界面：</p>
<p><p class="md__image">
  <img src="../imgs/try-embed01.png"
    alt=""  />
</p>
</p>
<p>注意上面使用的是 <code>/*</code>，如果直接使用 <code>/</code>，点击链接会是 404。</p>
<p>换成 Gin，代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;net/http&#34;</span>

    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static/*
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">local</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">router</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
    <span class="nx">router</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/*filepath&#34;</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">WrapH</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FS</span><span class="p">(</span><span class="nx">local</span><span class="p">))))</span>

    <span class="nx">router</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果和 Echo 框架一样。同样要注意是 <code>/*filepath</code>，不能是 <code>/</code>。</p>
<p>换成标准库 net/http 试试？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">local</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FS</span><span class="p">(</span><span class="nx">local</span><span class="p">)))</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>标准库中 <code>/</code> 会自动处理所有的请求。</p>
<h2 id="02-goembed-指令">02 //go:embed 指令</h2>
<p>之前第三方的现实，基本是基于 go generate，将静态资源文件生成 go 源文件，最后编译进二进制文件中。官方的实现，通过 <code>//go:embed</code> 指令，在编译时将静态资源嵌入二进制文件中。然后，Go 通过标准库，让用户能够访问这些内嵌的资源。因此，先介绍下 <code>//go:embed</code> 指令的用法。</p>
<h3 id="相关规则">相关规则</h3>
<p>在变量声明上方，通过 <code>//go:embed</code> 指令指定一个或多个符合 path.Match 模式的要嵌入的文件或目录。相关规则或使用注意如下：</p>
<p>1）跟其他指令一样，// 和 go:embed 之间不能有空格。（不会报错，但该指令会被编译器忽略）</p>
<p>2）指令和变量声明之间可以有空行或普通注释，不能有其他语句；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:embed message.txt
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">message</span> <span class="kt">string</span>
</code></pre></div><p>以上代码是允许的，不过建议紧挨着，而且建议变量声明和指令之间也别加注释，注释应该放在指令上方。</p>
<p>3）变量的类型只能是 string、[]byte 或 embed.FS，即使是这三个类型的别名也不行；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mystring</span> <span class="p">=</span> <span class="kt">string</span>

<span class="c1">//go:embed hello.txt
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">message</span> <span class="nx">mystring</span>	<span class="c1">// 编译不通过：go:embed cannot apply to var of type mystring
</span></code></pre></div><p>4）允许有多个 <code>//go:embed</code> 指令。多个文件或目录可以通过空格分隔，也可以写多个指令。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:embed image template
</span><span class="c1">//go:embed html/index.html
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">content</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>
</code></pre></div><p>5）文件或目录使用的是相对路径，相对于指令所在 Go 源文件所在的目录，路径分隔符永远使用 <code>/</code>；当文件或目录名包含空格时，可以使用双引号或反引号括起来。</p>
<p>6）对于目录，会以该目录为根，递归的方式嵌入所有文件和子目录；</p>
<p>7）变量的声明可以是导出或非导出的；可以是全局也可以在函数内部；但只能是声明，不能给初始化值；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:embed message.txt
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">message</span> <span class="kt">string</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>	<span class="c1">// 编译不通过：go:embed cannot apply to var with initializer
</span></code></pre></div><p>8）只能内嵌模块内的文件，比如 <code>.git/*</code> 或软链接文件无法匹配；空目录会被忽略；</p>
<p>9）模式不能包含 <code>.</code> 或 <code>..</code>，也不能以 <code>/</code> 开始，如果要匹配当前目录所有文件，应该使用 <code>*</code> 而不是 <code>.</code>；</p>
<h2 id="03-标准库">03 标准库</h2>
<p>和 embed 相关的标准库有 5 个，其中 2 个是新增的：embed 和 io/fs；net/http，text/template 和 html/template 包依赖 io/fs 包，而 embed.FS 类型实现了 io/fs 包的 FS 接口，因此这 3 个包可以使用 embed.FS。（Go1.16 发布时可能还会增加其他包或修改一些包的内容）</p>
<h3 id="iofs-包">io/fs 包</h3>
<p>该包定义了文件系统的基本接口。文件系统既可以由主机操作系统提供，也可以由其他包提供。本文我们主要介绍和 embed 密切相关的内容。</p>
<p>先看 <strong>FS 接口</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FS</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Open opens the named file.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// When Open returns an error, it should be of type *PathError
</span><span class="c1"></span>    <span class="c1">// with the Op field set to &#34;open&#34;, the Path field set to name,
</span><span class="c1"></span>    <span class="c1">// and the Err field describing the problem.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Open should reject attempts to open names that do not satisfy
</span><span class="c1"></span>    <span class="c1">// ValidPath(name), returning a *PathError with Err set to
</span><span class="c1"></span>    <span class="c1">// ErrInvalid or ErrNotExist.
</span><span class="c1"></span>    <span class="nf">Open</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>FS 提供对分层文件系统的访问。像操作系统使用的文件系统就是一种分层文件系统。</p>
<p>FS 接口是文件系统所需的最小实现。文件系统可以实现其他接口，比如 fs.ReadFileFS，以提供其他或优化的功能。</p>
<p><strong>File 接口</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">File</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Stat</span><span class="p">()</span> <span class="p">(</span><span class="nx">FileInfo</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nf">Read</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>该接口定义对单个文件的访问。这是文件的最小实现要求。文件可以实现其他接口，例如 fs.ReadDirFile，io.ReaderAt 或 io.Seeker，以提供其他或优化的功能。</p>
<p>因为有了 FS、File 等的接口抽象，之前在 os 包中的一些内容移到了 io/fs 包中，比如 fs.FileInfo 接口、fs.FileMode 类型，os 中原有的定义改成了它们的别名。</p>
<p><strong>DirEntry 接口</strong>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">DirEntry</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Name returns the name of the file (or subdirectory) described by the entry.
</span><span class="c1"></span>    <span class="c1">// This name is only the final element of the path (the base name), not the entire path.
</span><span class="c1"></span>    <span class="c1">// For example, Name would return &#34;hello.go&#34; not &#34;/home/gopher/hello.go&#34;.
</span><span class="c1"></span>    <span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// IsDir reports whether the entry describes a directory.
</span><span class="c1"></span>    <span class="nf">IsDir</span><span class="p">()</span> <span class="kt">bool</span>

    <span class="c1">// Type returns the type bits for the entry.
</span><span class="c1"></span>    <span class="c1">// The type bits are a subset of the usual FileMode bits, those returned by the FileMode.Type method.
</span><span class="c1"></span>    <span class="nf">Type</span><span class="p">()</span> <span class="nx">FileMode</span>

    <span class="c1">// Info returns the FileInfo for the file or subdirectory described by the entry.
</span><span class="c1"></span>    <span class="c1">// The returned FileInfo may be from the time of the original directory read
</span><span class="c1"></span>    <span class="c1">// or from the time of the call to Info. If the file has been removed or renamed
</span><span class="c1"></span>    <span class="c1">// since the directory read, Info may return an error satisfying errors.Is(err, ErrNotExist).
</span><span class="c1"></span>    <span class="c1">// If the entry denotes a symbolic link, Info reports the information about the link itself,
</span><span class="c1"></span>    <span class="c1">// not the link&#39;s target.
</span><span class="c1"></span>    <span class="nf">Info</span><span class="p">()</span> <span class="p">(</span><span class="nx">FileInfo</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>DirEntry 是从目录读取的条目（使用 ReadDir 函数或 ReadDirFile 的 ReadDir方法）。比如下面 embed 包中的 embed.FS 有一个方法 ReadDir 就返回了 DirEntry 类型的切片。这样可以遍历 embed.FS 这个文件系统。</p>
<h3 id="embed-包">embed 包</h3>
<p>资源文件嵌入 Go 二进制程序后，我们通过 embed 包可以访问它们。</p>
<h4 id="string-和-byte">string 和 []byte</h4>
<p>当指令用于 string 或 []byte 时，只能有一个模式，匹配一个文件，字符串或 []byte 的内容是该文件的内容。这时虽然不需要使用 embed 包，但必须导入，因此采用空导入：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;embed&#34;</span> 
</code></pre></div><h4 id="fsfile-system">FS（File System）</h4>
<p>一般内嵌单个文件，采用 string 或 []byte 是最好的选择；但内嵌很多文件或目录树，应该使用 embed.FS 类型，这也是该包目前唯一的类型。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FS</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// The compiler knows the layout of this struct.
</span><span class="c1"></span>	<span class="c1">// See cmd/compile/internal/gc&#39;s initEmbed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The files list is sorted by name but not by simple string comparison.
</span><span class="c1"></span>	<span class="c1">// Instead, each file&#39;s name takes the form &#34;dir/elem&#34; or &#34;dir/elem/&#34;.
</span><span class="c1"></span>	<span class="c1">// The optional trailing slash indicates that the file is itself a directory.
</span><span class="c1"></span>	<span class="c1">// The files list is sorted first by dir (if dir is missing, it is taken to be &#34;.&#34;)
</span><span class="c1"></span>	<span class="c1">// and then by base, so this list of files:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//	p
</span><span class="c1"></span>	<span class="c1">//	q/
</span><span class="c1"></span>	<span class="c1">//	q/r
</span><span class="c1"></span>	<span class="c1">//	q/s/
</span><span class="c1"></span>	<span class="c1">//	q/s/t
</span><span class="c1"></span>	<span class="c1">//	q/s/u
</span><span class="c1"></span>	<span class="c1">//	q/v
</span><span class="c1"></span>	<span class="c1">//	w
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// is actually sorted as:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//	p       # dir=.    elem=p
</span><span class="c1"></span>	<span class="c1">//	q/      # dir=.    elem=q
</span><span class="c1"></span>	<span class="c1">//	w/      # dir=.    elem=w
</span><span class="c1"></span>	<span class="c1">//	q/r     # dir=q    elem=r
</span><span class="c1"></span>	<span class="c1">//	q/s/    # dir=q    elem=s
</span><span class="c1"></span>	<span class="c1">//	q/v     # dir=q    elem=v
</span><span class="c1"></span>	<span class="c1">//	q/s/t   # dir=q/s  elem=t
</span><span class="c1"></span>	<span class="c1">//	q/s/u   # dir=q/s  elem=u
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This order brings directory contents together in contiguous sections
</span><span class="c1"></span>	<span class="c1">// of the list, allowing a directory read to use binary search to find
</span><span class="c1"></span>	<span class="c1">// the relevant sequence of entries.
</span><span class="c1"></span>	<span class="nx">files</span> <span class="o">*</span><span class="p">[]</span><span class="nx">file</span>
<span class="p">}</span>
</code></pre></div><p>FS 是文件的只读集合，通常使用 <code>//go:embed</code> 指令进行初始化。如果不使用 <code>//go:embed</code> 指令声明 FS，则它是一个空文件系统。</p>
<p>FS 是只读值，因此可以安全地同时使用多个 goroutine，也可以将 FS 类型的值相互赋值。</p>
<p>FS 实现了 fs.FS，因此它可以与任何使用文件系统接口（fs.FS）的包一起使用，包括 net/http，text/template 和 html/template。</p>
<p>此外，FS 还是实现了 fs.ReadDirFS 和 fs.ReadFileFS 这两个接口。</p>
<p>所以，FS 实现了 3 个接口，一共 3 个方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">FS</span><span class="p">)</span> <span class="nf">Open</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">FS</span><span class="p">)</span> <span class="nf">ReadDir</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="nx">fs</span><span class="p">.</span><span class="nx">DirEntry</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">FS</span><span class="p">)</span> <span class="nf">ReadFile</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>关于它们的用法，在上文例子中有所涉及。</p>
<h2 id="04-实际项目使用">04 实际项目使用</h2>
<p>本节模拟一个实际项目，看怎么使用 embed，主要两个方面：嵌入静态资源；嵌入模板文件。本节示例代码地址：<a href="https://github.com/polaris1119/embed-example" target="_blank" rel="noopener">https://github.com/polaris1119/embed-example</a>
，采用 Echo 框架。</p>
<p>因为是演示 embed 的实际用法，因此项目做了尽可能简化，目录结构如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">.
├── LICENSE
├── README.md
├── cmd
│   └── blog
│       └── main.go
├── embed.go
├── go.mod
├── go.sum
├── static
│   └── css
│       └── style.min.css
└── template
    └── index.html
</code></pre></div><p>做个说明：</p>
<ul>
<li>因为 <code>go:embed</code> 指令只能从相对源码所在目录的位置引用资源，这里特意采用了 main.go 放在 cmd/blog 中这种方式，看这样如何处理资源嵌入；</li>
<li>static 和 template 目录是需要嵌入的目录；</li>
</ul>
<p>因为 main.go 和 static/template 不在同一个目录，因此 main.go 中没法直接使用 <code>go:embed</code> 指令。我们在 static 的同级目录下创建一个文件：embed.go，专门用来写该指令。代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">embedexample</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;embed&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">StaticAsset</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="c1">//go:embed template
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">TemplateFS</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>
</code></pre></div><p>这样，项目中所有其他的地方都可以通过引用该包来使用内嵌的资源。</p>
<p>接着看 main.go 的代码如何使用它的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;html/template&#34;</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
	<span class="s">&#34;github.com/labstack/echo/v4/middleware&#34;</span>
	<span class="s">&#34;github.com/polaris1119/embedexample&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Recover</span><span class="p">())</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Logger</span><span class="p">())</span>

	<span class="nx">tpl</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Template</span><span class="p">{</span>
		<span class="nx">templates</span><span class="p">:</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;index&#34;</span><span class="p">).</span><span class="nf">ParseFS</span><span class="p">(</span><span class="nx">embedexample</span><span class="p">.</span><span class="nx">TemplateFS</span><span class="p">,</span> <span class="s">&#34;template/*.html&#34;</span><span class="p">)),</span>
	<span class="p">}</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Renderer</span> <span class="p">=</span> <span class="nx">tpl</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/static/*&#34;</span><span class="p">,</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FS</span><span class="p">(</span><span class="nx">embedexample</span><span class="p">.</span><span class="nx">StaticAsset</span><span class="p">))))</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;index.html&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Template</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">templates</span> <span class="o">*</span><span class="nx">template</span><span class="p">.</span><span class="nx">Template</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">templates</span><span class="p">.</span><span class="nf">ExecuteTemplate</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>模板的引用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tpl</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Template</span><span class="p">{</span>
  <span class="nx">templates</span><span class="p">:</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;index&#34;</span><span class="p">).</span><span class="nf">ParseFS</span><span class="p">(</span><span class="nx">embedexample</span><span class="p">.</span><span class="nx">TemplateFS</span><span class="p">,</span> <span class="s">&#34;template/*.html&#34;</span><span class="p">)),</span>
<span class="p">}</span>
</code></pre></div><p>通过 ParseFS 方法来实现，支持 path.Match 格式。</p>
<p>而静态资源这样引用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/static/*&#34;</span><span class="p">,</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FS</span><span class="p">(</span><span class="nx">embedexample</span><span class="p">.</span><span class="nx">StaticAsset</span><span class="p">))))</span>
</code></pre></div><p>这样，在模板文件 index.html 中就可以访问到样式文件了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/static/css/style.min.css&#34;</span><span class="p">&gt;</span>
</code></pre></div><p>可以将编译后的二进制文件移到任何地方，然后运行，访问 http://localhost:2020 看到如下界面表示成功了。</p>
<p><p class="md__image">
  <img src="../imgs/try-embed02.png"
    alt=""  />
</p>
</p>
<h2 id="05-总结">05 总结</h2>
<p>本文通过几个例子快速了解官方内嵌静态资源的用法，然后讲解一些关键的标准库，最后是一个实际项目中使用的例子。</p>
<p>纵观官方的实现，使用起来很方便，通过一个 <code>go:embed</code> 指令，让很多细节都不需要关注。当然，如果你对它的实现感兴趣，可以阅读设计提案和源码。</p>
<h2 id="06-参考资料">06 参考资料</h2>
<ol>
<li>Embed 设计提案：<a href="https://github.com/golang/proposal/blob/master/design/draft-embed.md" target="_blank" rel="noopener">https://github.com/golang/proposal/blob/master/design/draft-embed.md</a>
</li>
<li>示例参考：<a href="https://github.com/mattn/go-embed-example" target="_blank" rel="noopener">https://github.com/mattn/go-embed-example</a>
</li>
<li>tip 相关文档：<a href="https://tip.golang.org" target="_blank" rel="noopener">https://tip.golang.org</a>
</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>这个调查显示 Go 竟然是 2020 年最受欢迎的编程语言</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/hackerearth-developer-survey/</link>
			<pubDate>Fri, 30 Oct 2020 15:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/hackerearth-developer-survey/</guid>
			<description>大家好，我是站长 polarisxu。 今天看到一个 2020 年开发者调查报告，看到了 Go 的前景，忍不住想跟大家分享一下。 01 这份调查报告来自 HackerEarth 。简单介绍下它。 HackerEarth 的口号是：远程雇用最优秀的技术人才。拥有 400 万+ 开发人员（注册用户），上千家企业信赖，他们帮助公司准确评估，面试和雇用顶尖技术人才。 他们提供编程练习、黑客挑战，号称能够进行准确的编码评估并远程聘用最好的技术人才。根据</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天看到一个 2020 年开发者调查报告，看到了 Go 的前景，忍不住想跟大家分享一下。</p>
<h2 id="01">01</h2>
<p>这份调查报告来自 <a href="https://www.hackerearth.com/" target="_blank" rel="noopener">HackerEarth</a>
。简单介绍下它。</p>
<p>HackerEarth 的口号是：远程雇用最优秀的技术人才。拥有 400 万+ 开发人员（注册用户），上千家企业信赖，他们帮助公司准确评估，面试和雇用顶尖技术人才。</p>
<p>他们提供编程练习、黑客挑战，号称能够进行准确的编码评估并远程聘用最好的技术人才。根据官网介绍，创始人是大学时候的两个朋友。</p>
<h2 id="02">02</h2>
<p>为什么要做开发者调查？HackerEarth 是这么认为的：</p>
<p>过去十年来技术的飞速发展改变了一切。它改变了我们的生活方式，工作方式以及彼此之间的互动方式—实际上，很难找到没有被技术改变的事物。</p>
<p>然而，全球的组织都感觉到技术人才短缺。但是这种短缺可能比您预期的还要严重。根据最近的一项调查，今天的技术人才短缺是自 2008 年以来的最高水平。因此，招聘人员和招聘经理必须了解开发人员的状况并了解当今技术人员的心态，这样才能更好地满足开发人员的要求、需求。</p>
<p>组织要想更好地招聘，需要做的关键改变之一就是将重点从传统的招聘方法转移到基于技能的招聘过程。如果我们超越目前对简历或学位的关注，将所有中学后课程都包括在内，那么将会出现更多的选择。基于技能的招聘实践可以帮助您降低招聘成本和雇用时间，提高多样性，更快地填补空缺职位，并在紧张的劳动力市场中找到组织所需的合适技术人才。</p>
<p>在 HackerEarth，我们拥有 400 万强大的开发者社区，我们的使命是为他们提供合适的机会。为继续支持我们的使命，我们很高兴为您带来 2020 HackerEarth 开发人员调查。 HackerEarth 有史以来第一次分享了对来自 76 个国家/地区的 16,000 多名开发人员（其中女性占受访者的 20％ 以上）的调查所收集的反馈。</p>
<p>我们认为，调查中提供的数据和见解将帮助招聘者更好地了解开发人员生态系统，采用基于技能的招聘方法。此外，这项调查将为开发人员提供一个机会，使他们能够了解当今市场的情况，了解趋势以及如何提高自己的技能。</p>
<p>希望这份调查能够对你的技术招聘有帮助，对你的职业发展能有一点帮助。</p>
<h2 id="03">03</h2>
<p>调查结果的一些关键结论。</p>
<h3 id="到了-2020-年数据科学仍然占据统治地位">到了 2020 年，数据科学仍然占据统治地位</h3>
<p>数据科学无止境！从学生开发人员（63％）到在职专业人员（61％），每个人都想占有一席之地。学生开发人员感兴趣的其他领域包括网络安全和物联网，而在职专业人员对物联网和区块链感兴趣。</p>
<p><p class="md__image">
  <img src="../imgs/hackerearth-survey01.png"
    alt=""  />
</p>
</p>
<h3 id="go-是今年最受欢迎的编程语言">Go 是今年最受欢迎的编程语言</h3>
<p>在学生（29％）和经验丰富的开发人员（32％）中，Go 已成为最受欢迎的编程语言的明显赢家。</p>
<p><p class="md__image">
  <img src="../imgs/hackerearth-survey02.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/hackerearth-survey03.png"
    alt=""  />
</p>
</p>
<h3 id="开发人员在全栈开发方面经验最丰富而在机器学习方面经验最少">开发人员在全栈开发方面经验最丰富，而在机器学习方面经验最少</h3>
<p>大多数开发人员（无论是初学者还是经验丰富的人员）都具有全栈开发以及前端和后端开发的专业知识。</p>
<p>尽管大多数开发人员都表示希望从事数据科学项目，但在机器学习方面经验不足。</p>
<p>可见机器学习方面还有很大的潜力。</p>
<p><p class="md__image">
  <img src="../imgs/hackerearth-survey04.png"
    alt=""  />
</p>
</p>
<h3 id="您要让开发人员挂了吗">您要让开发人员挂了吗？</h3>
<p>技术面试可能会让人感到压力，招聘人员有责任使求职者的面试过程变得更加轻松。可悲的是，大多数开发人员在面试后都没有收到建设性的反馈。</p>
<p>使他们对技术招聘过程感到不满意的其他原因包括：面试次数过多（14％），误导性的职位描述（14％），面试之间的等待时间（12％）和缺乏相关的技术问题（10％）。（不能同意更多，很多企业面试完全不考虑候选人的面试体验）</p>
<h3 id="你对开会怎么看">你对开会怎么看？</h3>
<p>当问及要实现 100％ 的工作效率需要什么时，70％的开发人员选择了更少的会议。</p>
<p>此外，大多数开发人员还选择了多显示器（61％），无杂物的工作空间（59％）以及戴耳机时不打扰的方式（59％）。</p>
<h3 id="开发人员的幸福感与工作时间不成比例">开发人员的幸福感与工作时间不成比例</h3>
<p>所有的工作，没有乐趣，会削弱开发人员的幸福感吗？我们认为不是！在接受调查的所有开发人员中，有 70％ 对当前工作不满意的开发人员每周工作 40 至 50 个小时。大家还是希望能够按时上下班~</p>
<p>考虑到大多数员工每周工作 40 小时是标准的工作，因此可以肯定地说，开发人员正在寻找有意义的工作，而坐在办公桌前并不能增加他们的幸福感。</p>
<p>这一点国内似乎谈不上？</p>
<p><p class="md__image">
  <img src="../imgs/hackerearth-survey05.png"
    alt=""  />
</p>
</p>
<p>其他更多内容，包括程序员业余都喜欢做什么？喜欢从哪获取知识等，可以访问这里查看：<a href="https://www.hackerearth.com/recruit/developer-survey/" target="_blank" rel="noopener">https://www.hackerearth.com/recruit/developer-survey/</a>
。</p>
<h2 id="04">04</h2>
<p>虽然这份报告不能完全反馈出国内的情况，但有一点，那就是 Go 在国外也收到越来越多的关注，很多人都希望学习 Go 语言。是的，你别犹豫了~</p>
]]></content>
		</item>
		
		<item>
			<title>AI 和 数据科学领域，Go 语言可能很快会取代 Python。最后的原因有点迷</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/golang-ai-programming-language/</link>
			<pubDate>Thu, 29 Oct 2020 21:40:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/golang-ai-programming-language/</guid>
			<description>30 年前，Python 首次出现。但是花了 20 年时间才能获得开发人员的赏识。快进到 2019 年，它成为开发人员中第二受欢迎的语言。（来自 Stackoverflow 开发人员 2019 调查结果 ） 过去，尤其是在过去的 5 年中，它的增长是巨大的。Python 成为机器学习和数据科学开发人员的首选语言。 在接下来的几年中，Python 在这些领域的主导地位无疑会持续。但是与更新的语言相比，它具有一些严重的缺点。对于 21 实际</description>
			<content type="html"><![CDATA[<p>30 年前，Python 首次出现。但是花了 20 年时间才能获得开发人员的赏识。快进到 2019 年，它成为开发人员中第二受欢迎的语言。（来自 <a href="https://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted" target="_blank" rel="noopener">Stackoverflow 开发人员 2019 调查结果</a>
）</p>
<p>过去，尤其是在过去的 5 年中，它的增长是巨大的。Python 成为机器学习和数据科学开发人员的首选语言。</p>
<p>在接下来的几年中，Python 在这些领域的主导地位无疑会持续。但是与更新的语言相比，它具有一些严重的缺点。对于 21 实际 20 年代的开发者来说，这可能是一个障碍。</p>
<p>现在是检查 Python 问题并将其替换为更好的替代方法的正确时机。就 AI 开发和数据科学而言，我们的下一个入门语言可能是 Golang。</p>
<h2 id="python-受欢迎的原因">Python 受欢迎的原因</h2>
<p>Python 受欢迎的主要原因是：它易于学习。与其他语言相比，它的语法很简单，任何人都可以在几小时或几天内学习 Python 的基础知识。</p>
<p>即使在学习了其他语言（例如 C++ 或 Java）之后，开发人员通常还是更喜欢使用 Python。那是因为有一个 Python 库，几乎可以满足所有人的要求。</p>
<p>库和简单的语法使使用 Python 开发软件既简单又高效。这些优势使 Python 成为了初学者的语言。</p>
<h2 id="python-问题">Python 问题</h2>
<h3 id="速度">速度</h3>
<p>Python 是一种解释型语言，这会引起 Python 的最大问题：执行缓慢。与其他编译语言（例如 C++ 和 Go）相比，Python 的执行速度很慢，非常慢。</p>
<p>Python 是一种动态类型的语言。在运行期间会自动分配变量的数据类型。这使执行速度大大降低。</p>
<h3 id="使用-cc">使用 C/C++</h3>
<p>为了克服 Python 运行慢的缺点，Tensorflow，Numpy 和 Pandas 之类的库部分用 C 或 C++ 编写。它们有助于显著提高执行速度。</p>
<p>基本上，Python 需要其他语言的帮助才能克服其问题。</p>
<h3 id="全局解释器锁global-interpreter-lock">全局解释器锁（Global Interpreter Lock）</h3>
<p>Python 的<a href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener">全局解释器锁</a>
（GIL）一次只能执行一个线程，同时提高了单线程性能。Python 的多线程并没有真正让多个线程同时运行。</p>
<p>实际上，Python 无法执行真正的多线程。</p>
<p>（注意：Python 的非 CPython 实现（例如 Jython 和 IronPython 没有 GIL））</p>
<h2 id="为什么要使用-go-语言">为什么要使用 Go 语言？</h2>
<blockquote>
<p>Go 是一种开放源代码编程语言，可轻松构建，简单，可靠和高效。</p>
</blockquote>
<p>“ Go” 在 10 年前首次亮相。它是 Google 开发的通用性编程语言。</p>
<p>与 Python 和其他编程语言相比，它具有多个优势，这就是我们感兴趣的原因。</p>
<h3 id="快速">快速</h3>
<p>Go 是静态类型化和编译的语言。这意味着执行速度将比 Python 快几倍。与 Python 不同，Go 不需要其他语言的帮助就可以更快。</p>
<p>这是 Go 和 Python 之间的一个<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-python3.html" target="_blank" rel="noopener">小型基准测试游戏比较</a>
。Go 几乎与 C++ 和 Java 一样快。而且，Go 的代码编译速度比 C/C++ 和 Java 快得多。</p>
<h3 id="简单易学">简单易学</h3>
<p>Go 的语法很简单，类似于 C。它是一种易于学习的编程语言，特别是已经了解 C 或 Java 语言的基础知识。</p>
<p>要了解 Go 的基础知识，请访问 <a href="http://tour.studygolang.com/welcome/1" target="_blank" rel="noopener">Go 指南</a>
 进行交互式之旅或访问<a href="https://docs.studygolang.com/doc/" target="_blank" rel="noopener">官方文档</a>
。</p>
<h3 id="越来越受欢迎">越来越受欢迎</h3>
<p>根据此次 Hackearth 对来自 76 个国家/地区的 16,000 多名开发人员的<a href="https://www.hackerearth.com/recruit/developer-survey/" target="_blank" rel="noopener">调查</a>
，Go 是 2020 年最受欢迎的编程语言。</p>
<p>32％ 的经验丰富的开发人员和 29％ 的学生说他们想学习 Go 不足为奇。</p>
<p><p class="md__image">
  <img src="../imgs/go-for-ai-ds.png"
    alt=""  />
</p>
</p>
<h3 id="并发">并发</h3>
<p>并发是 Go 的主要优势之一。Go 具有 <a href="http://tour.studygolang.com/concurrency/1" target="_blank" rel="noopener">Goroutines</a>
 以实现并发。Goroutines 是可以同时独立运行的函数。</p>
<p>Goroutine 重量轻，仅占用 2KB（依赖于不同实现，目前 Go1.15 是 2KB） 的内存。由于 Goroutine 轻巧，因此可以同时运行成千上万个。</p>
<p>Goroutine 还有很多其他优点，比如：</p>
<ul>
<li>Goroutine 具有可增长的分段堆栈。这意味着它们仅在需要时才使用更多的内存。</li>
<li>Goroutine 具有比线程更快的启动时间。</li>
<li>Goroutine 带有内置原语，以在它们自己（通道）之间安全地通信。</li>
<li>使用 Goroutines 可以避免共享数据结构时不得不使用互斥锁。</li>
<li>此外，goroutine 和 OS 线程没有 1:1 映射。一个 goroutine 可以在多个线程上运行。 Goroutines 被多路复用到少量的 OS 线程中。</li>
</ul>
<p>参考文章：<a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65" target="_blank" rel="noopener">为什么要学习 Go？</a>
。</p>
<h2 id="是什么使-go-适用于-ai-研究">是什么使 Go 适用于 AI 研究</h2>
<p>将 Go 专门用于 AI 研究或数据科学并没有什么特别的。为什么应将 Go 用于 AI 和数据科学？我会告诉你的&hellip;但是等一下。</p>
<p>30 年前，尚未开发 Python 来构建机器学习或深度学习算法或进行数据可视化。</p>
<p>之所以是今天，是因为开发人员和学生们喜欢用 Python 进行代码编写，并且支持<em>开发该开发人员意图</em>的语言。</p>
<p>Go 旨在提高程序员的生产力。与 Python 相比，它具有多个优点。它很可能会在未来几年中成功取代 Python，成为最受欢迎的语言。</p>
<p>因此，它可以归结为 1 行：</p>
<p><strong>Go 可以支持 “21 世纪 20 年代的开发人员”发展他们的思想，这比任何其他语言都要好得多。</strong></p>
<blockquote>
<p>原文链接：<a href="https://towardsdatascience.com/golang-ai-programming-language-for-the-20s-71890baa8c47" target="_blank" rel="noopener">https://towardsdatascience.com/golang-ai-programming-language-for-the-20s-71890baa8c47</a>
</p>
<p>本文作者：Dasaradh Saran</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>闲聊昨晚极客时间的直播</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/talk-geek-time-live/</link>
			<pubDate>Mon, 26 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/talk-geek-time-live/</guid>
			<description>昨天晚上（10 月 25 日）极客时间进行了一场直播，主题是：《未来 5 年将是 Go 语言的天下》。 客观说，这个主题还是挺唬人的，而直播的内容跟这个主题关系不大。有三个嘉宾，只有左耳朵耗子谈了 Go 的未来，他的判断，Go 会成为主流，只会 PHP 肯定行不通。 在提问环节，有人问到耗子哥关于 Python 的看法，他直言：Python 会成为新手语言。不管你认不认同，耗子哥的一些观点还是有一定道理的。 耗子</description>
			<content type="html"><![CDATA[<p>昨天晚上（10 月 25 日）极客时间进行了一场直播，主题是：《未来 5 年将是 Go 语言的天下》。</p>
<p>客观说，这个主题还是挺唬人的，而直播的内容跟这个主题关系不大。有三个嘉宾，只有左耳朵耗子谈了 Go 的未来，他的判断，Go 会成为主流，只会 PHP 肯定行不通。</p>
<p>在提问环节，有人问到耗子哥关于 Python 的看法，他直言：Python 会成为新手语言。不管你认不认同，耗子哥的一些观点还是有一定道理的。</p>
<p>耗子哥的部分，我只听了结尾一点。另外两位的分享，我都听完了。简单聊聊。</p>
<h2 id="01-go-在字节跳动的地位">01 Go 在字节跳动的地位</h2>
<p>秦岩老师 PPT 第一页：</p>
<p><p class="md__image">
  <img src="../imgs/geektime01.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>提到的文章地址：<a href="https://www.infoq.cn/article/fEa7CHf9MOohbxbTYReS" target="_blank" rel="noopener">https://www.infoq.cn/article/fEa7CHf9MOohbxbTYReS</a>
</p>
</blockquote>
<p>据我了解，字节当前后端服务超过 80% 的流量是跑在 Go 构建的服务上。高峰 QPS 超过 700 万，日处理请求量超过3000 亿，是业内最大规模的 Go 应用。</p>
<p>对于 Go 爱好者来说，如果能够进入字节跳动，在项目中进行历练，自己上进，相信 Go 水平会有一个质的提升；而应届生，我个人也强烈建议努力朝着进入字节跳动努力。</p>
<p><p class="md__image">
  <img src="../imgs/geektime02.png"
    alt=""  />
</p>
</p>
<p>如上图，Go 在这样量级的公司占据第一使用率，无论从哪方面讲，对 Go 来说都是巨大的成功，也证明了 Go 的可靠性。</p>
<h2 id="02-直播的故障">02 直播的故障</h2>
<p>抖音的老师刚开个头，突然直播故障了，持续了几分钟。</p>
<p>大家的吐槽来了：</p>
<p><p class="md__image">
  <img src="../imgs/geektime03.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/geektime04.png"
    alt=""  />
</p>
</p>
<p>秦岩老师是负责抖音、直播稳定性的，他一来不稳定了？！</p>
<p>对于这个突发的故障，不用太较真，各种系统应该常遇到。正式因为这样那样的故障，催生出各种应对办法，各种高可用、稳定性架构。</p>
<p>对此，我想说的是，如果你一直在一个小公司，没有大流量，很多问题你是没法遇到的，这些问题只学理论是不够的。你写的代码，你的架构，可能在你的公司运行的很好，但只要流量一大，他们可能就崩溃了。一定阶段，技术的提升，需要环境、需要大项目、大流量的历练。又回到那句话：趁年轻，能进大厂，一定要到大厂去历练，现在能力不够，恶补下，朝着大厂的目标去努力。</p>
<h2 id="03-毛剑老师的分享">03 毛剑老师的分享</h2>
<p>毛剑老师这次主要站在面试官的角度分享大厂面试 Go 工程师更看重哪些能力。他提到了软实力、硬实力，以及他喜欢问候选人哪些题。</p>
<p>这方面，每个人的喜好不一样，有些面试官喜欢问这个，有些喜欢问那个。就技术能力来说，大厂一般会有规范的流程，有些可能有面试考察能力的要求。所以，除了 Go 语言本身使用掌握外，还需要对核心的一些设计有所了解。比如调度、内存、并发等，此外服务端相关的其他技能，也是必须掌握的。</p>
<p>对此，我个人的看法：</p>
<ul>
<li>根据职位不同，可能侧重点不一样；不同公司、不同部门，面试的喜好也会有所区别，需要有针对性的准备；</li>
<li>Go 语言本身的基本功，底层的一些实现，作为一个 Gopher，你应该不断探索；</li>
<li>操作系统、网络、数据库、缓存等服务端相关的技能得不断加深；</li>
<li>适当刷刷题，比如 LeetCode；手写代码也可以练练。比如字节面试都会让手写代码；</li>
</ul>
<h2 id="04-未来-5-年将是-go-语言的天下">04 未来 5 年将是 Go 语言的天下？</h2>
<p>这个定义有点夸张，但 Go 确实受到越来越多的关注。别的不说，很多 PHPer 都在学习 Go。从我的网站：https://studygolang.com 流量看，这些年上升还是挺厉害的。</p>
<p>一直以来，国内的技术和国外是不太一样的。Go 语言也很明显，在国内的热度明显高于国外。因为有字节跳动、腾讯（据说 Go 在腾讯今年有望成为第二大编程语言，去年是第三大）、滴滴、B 站等大厂的大规模使用（圈内人应该发现，曾经 PHP 一统天下的好未来，这段时间也是各种 Go），Go 必然会受到越来越多的关注。从目前在线教育对 Go 的投入来看，他们也看到了 Go 的潜力。所以，我看好 Go，你呢？！</p>
]]></content>
		</item>
		
		<item>
			<title>Go error 打印灾难 —  CockroachDB errors 库（第3篇）</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-error-printing-catastrophe/</link>
			<pubDate>Mon, 26 Oct 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-error-printing-catastrophe/</guid>
			<description>这篇文章是关于 “CockroachDB errors 库” 的系列文章的第 3 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。 Go 1.13 的标准库采用了 Dave Cheney 自 2015 年以来对错误处理的主要贡献：将 Go 错误对象构造为链表的想法。 唉，这种方式给 Go 开发人员造成了巨大的障碍：使打印错误对象变得困难、几乎不可能。 这就是我所说的 “Go error 打印灾难&amp;quot;，下面我们将准确</description>
			<content type="html"><![CDATA[<p>这篇文章是关于 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">“CockroachDB errors 库”</a>
的系列文章的第 3 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</p>
<p>Go 1.13 的标准库采用了 Dave Cheney 自 2015 年以来对错误处理的主要贡献：将 Go 错误对象构造为链表的想法。 唉，这种方式给 Go 开发人员造成了巨大的障碍：使打印错误对象变得困难、几乎不可能。</p>
<p>这就是我所说的 “Go error 打印灾难&quot;，下面我们将准确地看到它是什么。</p>
<h2 id="提醒go-错误为什么是链表怎么做的">提醒：Go 错误为什么是链表，怎么做的</h2>
<p>Go 的错误 API，从 v1.13 开始，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// error is a pre-defined type.
</span><span class="c1"></span><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
   <span class="c1">// Error returns an error&#39;s short message string.
</span><span class="c1"></span>   <span class="c1">// This is used e.g. when formatting an error with %s/%v.
</span><span class="c1"></span>   <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// wrapper can be implemented by additional error
</span><span class="c1">// “layers”, to decorate an error. This interface
</span><span class="c1">// is not pre-defined in the language but should be
</span><span class="c1">// implemented by API-conformant error decorators.
</span><span class="c1">//
</span><span class="c1">// This is the interface that powers the error identification
</span><span class="c1">// facilities errors.Is() and errors.As().
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">wrapper</span> <span class="kd">interface</span> <span class="p">{</span>
   <span class="c1">// Unwrap accesses the next layer in the error object.
</span><span class="c1"></span>   <span class="c1">// This used to be called “Cause” in Dave Cheney&#39;s
</span><span class="c1"></span>   <span class="c1">// pkg/errors library.
</span><span class="c1"></span>   <span class="nf">Unwrap</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>使用此 API，Go 生态系统中的代码可以通过两种方式构造 error 对象：</p>
<ul>
<li>使用类似 fmt.Errorf() 或 errors.New() 构造&quot;叶”错误；</li>
<li>使用修饰层 &ldquo;包装&rdquo; 错误，例如使用 errors.Wrap() 为错误增加前缀信息，errors.WithStack() 附加堆栈跟踪或使用 %w 动词的 fmt.Errorf() ，这是 1.13 新增的：<code>err = fmt.Errorf(&quot;some context: %w&quot;, err)</code></li>
<li>包装类型通过实现 Unwrap() 方法来声明其&quot;剥离&quot;的能力。这是由 Go 的标准库检查和使用的，特别是 errors.Is()，它可以通过查看所有中间层来识别错误是否为特定类型的错误。</li>
</ul>
<p>抽象的链表使得使用来自不相关的 Go 包的修饰类型将修饰附加到任何错误对象成为可能。通过将层之间的关系定义为”只是 error&quot;，没有包依赖项，也不会有循环导入的问题。它还使得可以跨不同的项目分离装饰器/包装器的开发，同时保持互操作性。</p>
<p>有关这个主题的详细信息，请阅读本系列中的上一篇文章：<a href="https://dr-knz.net/cockroachdb-errors-std-api.html" target="_blank" rel="noopener">Go 标准错误 API</a>
。</p>
<h2 id="提醒go-的格式化设施">提醒：Go 的格式化设施</h2>
<p>Go 库中最常用的、功能最全的打印设施是标准 fmt 包。它包含格式化各种 Go 为字符串，或输出到文件、buffer、终端。</p>
<p>例如 fmt.Println(v) 将 v 的值打印到终端。</p>
<p>fmt 中的大多数打印函数共享基础逻辑，为更强大的 Printf() API 提供支持。Printf() 使用格式字符串和变量参数列表，并显示根据格式的参数。这直接派生自 C 中类似的<a href="https://en.wikipedia.org/wiki/C_file_input/output" target="_blank" rel="noopener">标准 API</a>
。</p>
<p>Go 的 fmt 可以打印任意数据类型，但 C 的 stdio 不能。</p>
<p>这是使用预定义逻辑的组合来处理 Go 自己的基本类型，能智能递归地打印结构类型、指针和数组类型，以及自定义类型：fmt 尝试在传递给 Print 样式函数的值上使用四个接口。</p>
<ul>
<li>fmt .Formatter 接口定义了 Format(…) 方法，可以通过实现该方法以完全覆盖格式。</li>
<li>如果 fmt.Formatter 不存在，然后 fmt 会识别预定义的 error 接口。在这种情况下，它调用 Error() 方法并打印该方法。</li>
<li>如果 fmt.Formatter 或 error 都不可用，则根据使用的格式动词，自定义类型可以实现 fmt.Stringer（一个 String() 方法）或 fmt.GoStringer（一个 GoString() 方法）用于驱动更简单、不太灵活的格式输出。</li>
</ul>
<p>只有当这些接口都未实现时，fmt 才回退到使用其预定义逻辑。</p>
<p>有关本主题的详细信息，请阅读本系列中的上一篇文章：<a href="https://dr-knz.net/go-formatting-apis.html" target="_blank" rel="noopener">Go 的格式化 API。</a>
</p>
<h2 id="提醒error-的简单打印">提醒：error 的简单打印</h2>
<p>fmt 检测 error 参数并自动调用 Error() 方法。这工作得很好，即使对于包装错误：Error() 在最外层的包装器（链接列表的头部）上调用。因此，该包装器的 Error() 实现可以覆盖其尾部图层的错误。</p>
<p>例如：</p>
<ul>
<li><code>errors.New(&quot;world&quot;).Error()</code> 返回 <code>world</code>。</li>
<li><code>errors.Wrap(errors.New(&quot;world&quot;), &quot;hello&quot;)</code> 返回 <code>hello: world</code>。</li>
<li>同上，<code>fmt.Errorf(&quot;hello %w&quot;, errors.New(&quot;world&quot;))</code> 也构造了一个包装错误。</li>
</ul>
<p>这样，当将错误传递到 fmt 时，我们会自动获得自然的&quot;更长&quot;，&ldquo;更完整”的 Error() 结果。</p>
<p>一切似乎都很好，而且自从 Go v1.0 以来一直很好，但是详细的打印又如何呢？</p>
<h2 id="提醒详细的打印模式">提醒：详细的打印模式</h2>
<p>当使用 %+v 格式参数时，fmt 内部逻辑将采用&quot;详细&quot;模式，以显示参数列表中的相应值。默认情况下，详细模式会触发例如在结构类型中显示字段名称。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">a</span> <span class="kt">int</span> <span class="p">}{</span><span class="mi">123</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>  <span class="c1">// prints {123}
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="c1">// verbose mode: prints {a:123}
</span></code></pre></div><p>&ldquo;详细模式”的定义有一个新的抽象：某些数据在常见情况下不可见，但可根据请求变为可见。</p>
<p>这在进行 “printf debugging” 或事件日志记录时非常有用，因为查看调试或日志记录输出是给专业用户查看的，可以查看比程序常规输出中显示更多的信息。</p>
<p>自定义类型只能通过实现 fmt.Formatter 接口来自定义详细模式的输出。formatter 接口。只有该接口的 Format() 方法能获取有关是否请求详细模式的信息。fmt 包的其他接口不够强大。</p>
<p>特别是，error 接口和隐式 wrapper 接口都没有为错误类型提供一种自定义 fmt 中显示方式的方法。</p>
<h2 id="详细打印-go-错误的可取之处">详细打印 Go 错误的可取之处</h2>
<p>除了调用 Error() 方法提供的简单模式外，Go 生态系统还构建了单独的详细模式来打印错误对象的需求。</p>
<p>例如，Dave Cheney 的 pkg/errors 包和 CockroachDB 的 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">errors</a>
 库都会自动在错误对象中嵌入堆栈跟踪。此堆栈跟踪不会出现在 Error() 的输出中，因此在简单模式下打印错误对象时不包括此堆栈跟踪。当程序遇到错误，发现自己无法令人满意地处理它时，程序员可以使用 %+v 进入详细模式以查看堆栈跟踪。这有助于了解错误的来源和在程序中的位置。</p>
<p>此外，程序可以选择使用错误包装器将不是错误消息的控制信息嵌入到程序中，例如，指示调用方函数中错误处理期间应执行操作的特殊数字代码。调用方函数可以使用标准 API errors.As() 从错误链接链表中提取此数据。</p>
<p>如果程序员在排除的疑难 Bug 时想要可视化此信息，该信息不包括在 Error() 的输出中，怎么办？同样，将此信息输出为&quot;详细模式”的一部分，似乎这是一种自然的选择。</p>
<p>不幸的是，实现这个目标是相当困难的。</p>
<h2 id="基本缺陷-1在包装器中无法自定义">基本缺陷 1：在包装器中无法自定义</h2>
<p>我们试验和设计自己的错误类型，其中一些隐藏的信息只在详细模式下显示。我们可以这样做，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myError</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">msg</span> <span class="kt">string</span> <span class="c1">// public message
</span><span class="c1"></span>   <span class="nx">code</span> <span class="kt">int</span> <span class="c1">// hidden code
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Error implements the error interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>

<span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myError</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">verb</span> <span class="o">==</span> <span class="sc">&#39;v&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Verbose mode.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;(code: %d) %s&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">code</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>说明：当我们用 %v 打印 <code>*myError</code> 的实例时，我们得到 msg 的值；使用 %+v 时，我们得到相同的内容，但有前缀 (code: NNN)  和字段 code 的值。</p>
<p>精明的读者可能会注意到此代码看起来不完整，因为它不处理 %q 等格式动词。这在本节中不直接相关，因此我们暂时忽略它。</p>
<p>除了最后一点， 代码似乎工作正常？</p>
<p>唉！</p>
<p>尝试以下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">myError</span><span class="p">{</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">123</span><span class="p">}</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;wazaa: %w&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>         <span class="c1">// simple mode: prints just &#34;wazaa: hello&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// verbose: prints... what?
</span></code></pre></div><p>我们希望本示例中的代码打印 <code>zawaa: (code: 213) hello</code>。不幸的是，它不是：由 fmt.Errorf 返回的错误类型，fmt.Formatter 接口不起作用。因此，使用 fmt.Errorf 时，myError 中的自定义信息丢失了！</p>
<p>换句话说，在 “标准 Go” 中，通过 <code>Unwrap()</code> 方法创建良好的包装错误类型还不够；因此，在&quot;标准 Go&quot;中创建成形良好的错误包装类型是不够的。还必须实现适当的 Format() 方法，在包装错误中，通过 fmt.Formatter  处理任何可能的自定义格式。</p>
<p>这样有两个主要问题：</p>
<ul>
<li>有一点很明确：必须实现 Format() 方法，即使自定义包装不需要自定义格式，以免 fmt.Formatter 接口对于所有参与者都毫无用处。</li>
<li>Go 库中没有文档说明此问题。所以大家根本不了解也不知道。实际上，粗略的检查显示，Go 生态系统中的许多自定义错误包装器类型均未实现 Format()，因此会在其 “尾巴” 中破坏格式自定义。</li>
</ul>
<h2 id="基本缺陷-2转发forwarding-fmtformatter-的困难">基本缺陷 2：转发（forwarding） fmt.Formatter 的困难</h2>
<p>如果我们愿意支付抽象税，并同意所有包装错误类型也将实现 fmt.Formatter，那又会这样？怎么会这样呢？</p>
<p>作为支持示例，让我们尝试一个非常简单的包装，它没有任何特殊功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myWrapper</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">cause</span> <span class="kt">error</span> <span class="c1">// tail of linked list
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Error implements the error interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span> <span class="p">}</span>

<span class="c1">// Unwrap implements the unwrap interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Unwrap</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span> <span class="p">}</span>
</code></pre></div><p>然后，我们可以开始实现 fmt.Formatter。至少，它应该区分冗长和非冗长模式。</p>
<p>但是，如果我们不确定错误原因（error cause）是否实际实现 fmt.Formatter？也许没有。因此，为了减少的惊讶，我们需要做&quot;与 fmt 相同的一些事&rdquo;。实现此目的的最佳方法是调用 fmt 本身逻辑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">verb</span> <span class="o">==</span> <span class="sc">&#39;v&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Verbose mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself verbosely.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;%+v&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Simple mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself simply.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这是一个繁琐的模式，只是为了确保 e. cause 得到打印。</p>
<p>此外，如果 e.cause 想要了解有关原始格式的信息，那该内容会如何呢？如果与 %#v 一起使用时，使用 #v？还是 %#+v？还是 %q？</p>
<p>遗憾的是，fmt 中没有标准 API 来正确将所有状态转发到递归调用。自 Go 1.15 起，将所有格式状态（formatting state）完全转发到错误原因而不打印任何其他内容的代码量最低如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">f</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Builder</span>
    <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;%&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">wp</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Width</span><span class="p">();</span> <span class="nx">wp</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">w</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">pp</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Precision</span><span class="p">();</span> <span class="nx">pp</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">)</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="nx">f</span><span class="p">.</span><span class="nf">WriteRune</span><span class="p">(</span><span class="nx">verb</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这看起来非常不方便，容易出错。</p>
<p>即使是 Dave Cheney 的 pkg/errors 包也没有做到这一点，它仅在包装器中按如下方式实现 Format()，如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">withMessage</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">verb</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;v&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Cause</span><span class="p">())</span>
            <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="k">fallthrough</span>
    <span class="k">case</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="sc">&#39;q&#39;</span><span class="p">:</span>
        <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>此代码对于谓词 %q 不正确，同时完全省略其他格式标记（如 %#v 等），并且无法识别除 v、s 或 q 以外的任何谓词。</p>
<p>在 Go 生态系统中探索发现，很少有自定义错误包装类型实现 Format()。</p>
<p>实现适当的自定义 Format()， 以及没有预定义 （也不建议） 机制在 fmt 中转发 Format() 调用这一事实是如此困难，这是 Go 标准库的基本限制。</p>
<p>（安利：上面的正确代码的副本可作为可重用的 fmtfwd.MakeFormat() 函数，在 <a href="https://github.com/knz/go-fmtfwd" target="_blank" rel="noopener">go-mtfwd</a>
 包中。然而，这不是万能药。）</p>
<h2 id="基本缺陷-3不更改-api-无法修复的问题">基本缺陷 3：不更改 API 无法修复的问题</h2>
<p>Go 的团队称自己构建的语言可以最大限度地保持向后兼容性。标准库的添加是通过引入或替换功能，但不会影响现有代码的语义。</p>
<p>在这种情况下，Go 开发人员可以做什么来&quot;修复&quot;上面确定的问题，而不破坏现有的 error 代码，也不需要现有包添加&quot;缺失&quot;的粘附代码，如缺少的 Format() 转发器？</p>
<p>事实证明，在 fmt 包中可以直接做的工作不多。</p>
<p>在高级别上，不可能的任务是确保错误链中的所有细节以详细模式打印，同时考虑 Format() 方法中的自定义行为。</p>
<p>由于不是链中的每一个错误都提供 Format() 方法，因此 fmt 代码需要使用 Unwrap() 方法迭代自身。然后在每个层上都需要打印&hellip;东西。但究竟是什么？</p>
<ul>
<li>它无法调用 Error()，因为包装器上的 Error() 本身将递归，并获取链中其他层的字符串片段；</li>
<li>它无法调用 Format()，因为包装器上的 Format() 已经（根据当前生态系统）对错误原因递归递处理。</li>
</ul>
<p>因为 fmt.Formatter 接口 Format() 方法的第一个参数 fmt.State，是一个接口类型，因此实际在 fmt 中会是一个特定的 State 实例，可以&quot;分离&quot;当前错误层内的直接打印，从进一步递归执行打印。</p>
<p>例如，如下 Format() 实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">verb</span> <span class="o">==</span> <span class="sc">&#39;v&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Verbose mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself verbosely.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;(code %d) %+v&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">code</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Simple mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself simply.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>通过此代码可见，在 Format 内部调用的 fmt.Fprintf 或 fmt.Fprint 的第一参数是 fmt.State 的实例，这是 fmt 包负责注入的。简单字符串和非错误值可以传递，每次看到错误值时，它都会被”忽略”，以便外部 fmt 循环可以转到下一层，而不会重复输出。</p>
<p>这个想法的问题， 要知晓 Format() 方法中是怎么使用 fmt.State 的。它不适用于实现以下函数的软件包：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">withMessage</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">verb</span> <span class="p">{</span>
        <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">case</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="sc">&#39;q&#39;</span><span class="p">:</span>
        <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>（这个例子来自 pkg/errors）。</p>
<p>请注意，与 Go 生态系统中的许多其他实现一样，此实现也挫败了我们的想法：某些打印使用 fmt.State 的 io.Writer 子接口并将 <code>.Error()</code> 字符串直接传递给它。当包装器的 Format() 正在打印下一层错误时，无法可靠地从 fmt.State 中进行检测，从而捕获该错误以执行其他操作。</p>
<p>因此，Go 生态系统中“将错误作为链接列表”的集成与 fmt.Formatter 抽象发生冲突，并创建了一个坑，社区中的每个人都陷入困境，而 Go 标准库无法帮助任何人在 fmt 中使用魔术。</p>
<h2 id="也许是救星pre-113-xerrors">也许是救星：pre-1.13 xerrors</h2>
<p>在进行 Go 1.13 的工作中，2017 年成立了一个工作组，研究采用“错误作为链接列表”的方法，并基本上接管了 Dave Cheney 在 pkg/errors 中的工作。</p>
<p>这就是由 Jonathan Amsterdam，Russ Cox，Marcel van Lohuizen 和 Damien Neil 组成的小组开始开发 <a href="https://github.com/golang/xerrors" target="_blank" rel="noopener">xerrors</a>
 包，以作为新抽象的原型和研究依据。</p>
<p>这项工作指导作者提出了一些建议：</p>
<ul>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/go2draft-error-printing.md" target="_blank" rel="noopener">Marcel van Lohuizen: Error Printing — Draft Design</a>
 (August 2018)</li>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/29934-error-values.md" target="_blank" rel="noopener">Jonathan Amsterdam, Russ Cox, Marcel van Lohuizen, Damien Neil: Proposal: Go 2 Error Inspection</a>
 (January 2019)</li>
</ul>
<p>他们的工作主要集中在 Unwrap() 的语义以及新 API error.Is() 和 errors.As() 的创建上，以可靠地从错误对象中识别和提取信息。</p>
<p>Marcel van Lohuizen 更加关注错误处理的打印方面，并设计了以下提案：</p>
<ul>
<li>
<p>除了 fmt.Formatter，error，fmt.Stringer 和 fmt.GoStringer 外，fmt 包支持一个新接口：errors.Formatter。</p>
</li>
<li>
<p>新接口将通过错误包装和叶类型实现。</p>
</li>
<li>
<p>提议的接口如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">errors</span>

<span class="kd">type</span> <span class="nx">Formatter</span> <span class="p">{</span>
     <span class="kt">error</span>

     <span class="c1">// FormatError can be implemented to customize the formatting
</span><span class="c1"></span>     <span class="c1">// of errors, instead of fmt.Formatter&#39;s Format.
</span><span class="c1"></span>     <span class="c1">//
</span><span class="c1"></span>     <span class="c1">// It has access to an errors.Printer (see below)
</span><span class="c1"></span>     <span class="c1">// to actually produce output.
</span><span class="c1"></span>     <span class="c1">//
</span><span class="c1"></span>     <span class="c1">// In the common case, the code in FormatError details
</span><span class="c1"></span>     <span class="c1">// the current layer and returns the next error layer
</span><span class="c1"></span>     <span class="c1">// to print, or `nil` to indicate the tail of the
</span><span class="c1"></span>     <span class="c1">// linked list has been reached.
</span><span class="c1"></span>     <span class="c1">//
</span><span class="c1"></span>     <span class="c1">// Optionally, the code for a wrapper&#39;s FormatError
</span><span class="c1"></span>     <span class="c1">// can take over formatting of both itself *and all
</span><span class="c1"></span>     <span class="c1">// subsequent layers* by producing its custom
</span><span class="c1"></span>     <span class="c1">// representation for all and then returning `nil`,
</span><span class="c1"></span>     <span class="c1">// even though its Unwrap() method is still used
</span><span class="c1"></span>     <span class="c1">// by errors.Is() to iterate through the tail.
</span><span class="c1"></span>     <span class="nf">FormatError</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Printer</span><span class="p">)</span> <span class="p">(</span><span class="nx">next</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Printer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1">// can be used to output stuff
</span><span class="c1"></span>    <span class="nf">Printf</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1">// can be used to output stuff
</span><span class="c1"></span>
    <span class="c1">// Detail is a “magic” predicate which both indicates whether
</span><span class="c1"></span>    <span class="c1">// verbose mode is requested via %+v, and also starts indenting
</span><span class="c1"></span>    <span class="c1">// the output performed by subsequent Print()/Printf() calls in
</span><span class="c1"></span>    <span class="c1">// the interface, so that the details are visually “pushed to
</span><span class="c1"></span>    <span class="c1">// the right”.
</span><span class="c1"></span>    <span class="nf">Detail</span><span class="p">()</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<p>一个示例用法如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// FormatError implements the errors.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">FormatError</span><span class="p">(</span><span class="nx">p</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">Printer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;always&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Detail</span><span class="p">()</span> <span class="p">{</span>
       <span class="nx">p</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;hidden: &#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">code</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span>
<span class="p">}</span>
</code></pre></div><p>使用此代码，我们将得到以下行为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">myWrapper</span><span class="p">{</span><span class="nx">cause</span><span class="p">:</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">code</span><span class="p">:</span> <span class="mi">123</span><span class="p">}</span>
<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">myWrapper</span><span class="p">{</span><span class="nx">cause</span><span class="p">:</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">code</span><span class="p">:</span> <span class="mi">456</span><span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// simple mode: prints &#34;always: always: hello&#34;
</span><span class="c1"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="c1">// prints:
</span><span class="c1">//
</span><span class="c1">//   always:
</span><span class="c1">//      hidden: 456
</span><span class="c1">//   always:
</span><span class="c1">//      hidden: 123
</span><span class="c1">//   hello
</span></code></pre></div><p>（请注意一些特性：错误是从最外层/头部到最内层/尾部打印的，并且在每个前缀之后，细节之前插入了冒号）。</p>
<p>因此，将 fmt 代码修改为使用新接口的方式是：</p>
<ol>
<li>检测 Format() 方法是否可用。如果是这样，它被调用，结束。</li>
<li>否则，如果要打印的对象是错误，它将对其进行迭代：调用 FormatError()（如果存在）并使用其返回值作为下一次迭代的输入进行迭代。</li>
<li>当错误对象上不存在 FormatError() 或返回 nil 时，迭代将停止。</li>
<li>如果在迭代结束时仍有 Format() 或 Error() 方法可供调用，则将调用该方法以“完成”格式化。</li>
</ol>
<p>xerror 原型能够集中精力仅格式化一层包装器，而又不知道如何正确地将 Format() 调用转发给其他层。</p>
<p>因此，这是解决上述第二个基本限制的尝试。</p>
<p>哎，它根本无法解决第一个基本限制：如果包装层未实现 FormatError()，则 fmt 代码将仅停止在该级别尝试，并且在错误中进一步进行任何 FormatError() 或 Format() 定制链会被丢弃。</p>
<p>此外，许多人不喜欢“从前到后”打印错误的方式：在对错误详细信息进行故障排除时，开发人员发现重要是首先显示链接列表的“最内层”（尾部），然后才是“最外层”（头）。 xerrors 实现不允许这样做。</p>
<p>最后，无论如何，所有讨论都是没有争议的：没有选择将 xerror 打印抽象（包括 errors.Formatter，errors.Printer 和相应的 fmt 更改）包含在 Go 1.13 中。从 Go 1.16 开始，<a href="https://github.com/golang/go/issues/29934#issuecomment-591488854" target="_blank" rel="noopener">朝着这个方向进行的任何进一步工作都被推迟</a>
，具体另行通知。</p>
<h2 id="战略失误打破与pkgerrors-的兼容性">战略失误：打破与pkg/errors 的兼容性</h2>
<p>依赖于 Dave Cheney 的 pkg/errors 的社区项目超过 50,000 个，该软件包已成为事实上的扩展，能够提供错误包装程序的基本库，并作为错误打印自定义示例，尽管不完善。</p>
<p>甚至有一个扩展的生态系统，它依靠基本的链表抽象，使用一种名为 Cause() 的方法来接受链中的下一个层次。</p>
<p>Go 团队可能已经接受了这种方法，并且可以在“所有错误包装程序都必须以类似于 pkg/errors 的方式实现 Format”的方式进行区分。然后，errors.Is()/errors.As() 可能选择了 pkg/errors 的 Cause() 抽象。</p>
<p>遗憾的是，Go 团队选择了不同的方法名称：Unwrap()。因此，Go 1.13 发布后开发的新一代错误包已无法重用 pkg/errors。</p>
<p>因此，1.13 不仅引入了基本限制；这也阻止了 Go 社区继续可靠地使用 pkg/errors。</p>
<h2 id="总结go-error-打印灾难">总结：Go error 打印灾难</h2>
<p>在 2019 年，Go 1.13 采纳了 Dave Cheney 的 2015 年建议，将错误对象视为链表。因此，对 Unwrap() 方法进行了标准化，并使用 Is() 和 As() 函数增强了错误包，这些函数可以从以这种方式构造的错误中可靠地提取信息。</p>
<p>不幸的是，fmt 软件包没有学习如何打印这种错误的新形状，并且可靠地自定义错误对象的显示已变得不可能。</p>
<p>这是因为与以前的版本一样，fmt 仅了解 Format()，Error() 和 String()，并且仅在错误链的顶端或“头”考虑这些方法。</p>
<p>如果一个包定义了自定义包装错误类型，但忘记定义了自定义 Format() 方法，则 fmt 将忽略链接列表“尾部”中的任何其他 Format() 方法，并且自定义项将丢失。</p>
<p>此外，只有 Format() 方法可以为“详细”和“简单”格式（％v /％+v）提供不同的实现。在实践中，以递归方式在错误链尾部调用进一步的自定义方式，几乎不可能实现包装错误的 Format()。</p>
<p>简而言之，错误打印的自定义变得容易出错，并且在 Go 1.13 中基本上不可靠。Go 1.13 中放弃了的关键 Cause() 接口，导致与另一个具有某些人们可以达成共识的逻辑的程序包 Dave Cheney 的 pkg/errors 不兼容。 Go 团队通过 xerrors 包来尝试修复 Go 标准库中的这种情况，实际上并没有成功解决这些问题，存在重大的新缺陷，最终不令人满意。</p>
<p>这就是我们程序员无所适从的方式。</p>
<p>这是 Go error 打印灾难，它的悬念留在 Go 1.16 中。</p>
<h2 id="接下来">接下来</h2>
<p>CockroachDB error 库在错误打印方面花费了大量精力。尽管它不能填补所有空白，但确实可以减轻很多的痛苦。</p>
<p>本系列的下一篇文章进一步说明。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">Dave Cheney: Don’t just check errors, handle them gracefully</a>
.</li>
<li><a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">The Go Blog: Working with errors in Go 1.13</a>
.</li>
<li><a href="https://github.com/golang/go/issues/29934" target="_blank" rel="noopener">Jonathan Amsterdam, et al: Go 2 error values</a>
.</li>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/go2draft-error-printing.md" target="_blank" rel="noopener">Marcel van Lohuizen: Error Printing — Draft Design</a>
.</li>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/29934-error-values.md" target="_blank" rel="noopener">Jonathan Amsterdam, Russ Cox, Marcel van Lohuizen, Damien Neil: Proposal: Go 2 Error Inspection</a>
.</li>
</ul>
<blockquote>
<p>原文链接：https://dr-knz.net/go-error-printing-catastrophe.html</p>
<p>本文作者：Raphael ‘kena’ Poss</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Go 格式化 API —  CockroachDB errors 库（第2篇）</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-formatting-apis/</link>
			<pubDate>Sat, 24 Oct 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-formatting-apis/</guid>
			<description>这篇文章是关于 “CockroachDB errors 库” 的系列文章的第 2 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。 以下面的代码为例： import &amp;#34;fmt&amp;#34; type T struct { x int } func main() { v := T{123} fmt.Println(v) } 这个程序打印 {123}，尽管我们没有教 Go 如何打印我们的 T 类型。它是如何做到这一点的？ printer 的等效性 fmt 包中的逻辑在所有 printer 之间共享，因此以下调用都保证等效： fmt.Print(x) fmt.Printf(&amp;quot;%v&amp;quot;, x) os.Stdout.Write([]byte(fmt.Sprint(x))) os.Stdout.Write([]byte(fmt.Sprintf(&amp;quot;%v&amp;quot;, x))) 换句话说</description>
			<content type="html"><![CDATA[<p>这篇文章是关于 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">“CockroachDB errors 库”</a>
的系列文章的第 2 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</p>
<p>以下面的代码为例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">x</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">v</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="mi">123</span><span class="p">}</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这个程序打印 {123}，尽管我们没有教 Go 如何打印我们的 T 类型。它是如何做到这一点的？</p>
<h2 id="printer-的等效性">printer 的等效性</h2>
<p>fmt 包中的逻辑在所有 printer 之间共享，因此以下调用都保证等效：</p>
<ul>
<li><code>fmt.Print(x)</code></li>
<li><code>fmt.Printf(&quot;%v&quot;, x)</code></li>
<li><code>os.Stdout.Write([]byte(fmt.Sprint(x)))</code></li>
<li><code>os.Stdout.Write([]byte(fmt.Sprintf(&quot;%v&quot;, x)))</code></li>
</ul>
<p>换句话说，fmt.Print 的逻辑始终与将 Printf 与动词 %v 一起使用相同，前者实际使用后者作为实现。</p>
<p>同样，fmt.Println 使用 fmt.Print，外加 %v 动词，<code>fmt.Sprintln</code> 和 <code>fmt.Sprint</code> 是同样的道理。</p>
<h2 id="fmtstringer-和-fmtformatter">fmt.Stringer 和 fmt.Formatter</h2>
<p>现在，在上面的代码底部添加以下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
</code></pre></div><p>再次运行程序。会发生什么？它打印 <code>boo</code>。值 123 没有了。</p>
<p>这里发生的情况是，方法 String() 返回字符串实现了标准接口 fmt.Stringer，fmt 中的函数如果发现有它就会使用它。另外，尝试删除上面的 String() 函数定义，并将其替换为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>现在会发生什么？程序打印 <code>baa</code>。值 123 依然没有了。</p>
<p>如果这两个方法都可用怎么办？程序会打印 baa： fmt.Formatter 优先 fmt.Stringer。</p>
<p>当两个方法都不可用时，fmt 的逻辑会&quot;回&quot;在它自己的内部显示代码上，从而在表示值方面尽最大努力。</p>
<h2 id="fmt-对-error-知道多少">fmt 对 error 知道多少？</h2>
<p>Go 的标准 error 接口只提供返回字符串的 Error() 方法，而没有别的。</p>
<p>fmt 的逻辑知道 error，并知道如何使用其 Error() 方法，扩展上面解释的偏好规则：</p>
<ul>
<li>fmt.Formatter 优先级最高；</li>
<li>如果 fmt.Formatter 不存在，但是 error，则会使用 Error() 方法；</li>
<li>否则如果存在 fmt.Stringer，则使用它。</li>
</ul>
<h2 id="svq-和-xx-的关系">%s、%v、%q 和 %x/%X 的关系</h2>
<p>到目前为止，我们已经看到了，针对 %v 动词，fmt 的逻辑是如何可选地使用 fmt.Formatter、error 和 fmt.Stringer。</p>
<p>然而，在 Go 代码中使用的更常见的动词可能是 %s。%s 与 %v 的关系如何？</p>
<p>通常，%s 使用的逻辑与 %v 大致相同：如果 fmt.Stringer、error 或 fmt.Formatter 存在，将使用相同的偏好使用它。</p>
<p>当对象既不实现 String()，Error() 也不实现 Format() 时，就会出现区别。在这种情况下，％v 具有一些预定义的表示形式（例如，上例中的{123}），而 ％s 会提示“参数的类型错误”并且无法表示任何内容。</p>
<p>这就是为什么除非代码使用特定类型的字符串操作值，否则 Go 习惯用法通常是使用 ％v 而不是 ％s。</p>
<p>附加动词 ％q 和 ％x/％X 是 ％s 的变体（当 String()，Error() 和 Format() 都不可用时具有相同的限制）：</p>
<ul>
<li>%q 用引号引起来字符串，所以 fmt.Printf(&quot;%q&quot;, <code>he said &quot;hi&quot;</code>) 打印出 <code>he said &quot;hi&quot;</code>。</li>
<li>％x/％X 显示字符串中字节的十六进制表示形式。在实践中很少使用该方法（该方法更多用于整数）。</li>
</ul>
<h2 id="打印值指针方法集">打印值，指针方法集</h2>
<p>现在考虑上面的程序，以及以下实现的组合（注意接收器的类型）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>现在打印的是 boo。为什么是这样？上面的代码按值传递 T 实例。根据方法集的概念，只实现了 fmt.Stringer 接口，因此输出 boo。如果现在改为这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>输出什么？这次再次输出：{123}，因为 fmt 的逻辑“看不到”上面的方法。</p>
<p>因此有如下规则：如果对象按值打印，则只考虑其按值方法。（其实就是方法集问题）</p>
<h2 id="打印引用值方法集">打印引用，值方法集</h2>
<p>现在，让我们用以下主程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">v</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span><span class="mi">123</span><span class="p">}</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>现在考虑以下程序变体：</p>
<ul>
<li>
<p>变体 A：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
<li>
<p>变体 B：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
<li>
<p>变体 C：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
<li>
<p>变体 D：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
</ul>
<p>针对这些情况，上面的程序输出什么？都是 &ldquo;baa&rdquo;。</p>
<p>指针接收器 <code>*T</code> 的方法集包含 T 和 <code>*T</code> 的方法集。（原文作者写的不对，说变体 C 输出 &ldquo;boo&rdquo;）。</p>
<h2 id="使用-v-动词打印">使用 %+v 动词打印</h2>
<p>数字类型的 + 标志强制显示正值的加号，以便始终显示符号位。</p>
<p>然而，与 v 结合，它会触发&quot;详细打印&quot;。</p>
<p>根据 fmt 的默认逻辑，这会将字段的名称添加到结构中。</p>
<p>如果实现了 <code>fmt.Stringer</code> 接口，+ 不会对结果有任何改变， 如果实现了 fmt.Formatter 接口，根据约定，Format() 方法输出的信息比未指定 + 时的信息更详细。</p>
<p>Go 库没有规定应如何实现：不同的包往往以不同的方式实现。然而，缺乏规范不是问题；在这两种情况下，输出都供人眼使用，因此小显示不一致并不被视为问题。</p>
<h2 id="go-语法表示和-v-动词">Go 语法表示和 %#v 动词</h2>
<p>最后，将原来的主程序改为使用 %#v 动词：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">v</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="mi">123</span><span class="p">}</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这会打印什么？</p>
<ul>
<li>如果 String() 方法可用，会忽略它；</li>
<li>如果 Format() 方法可用，则使用它；</li>
<li>如果 GoString() 方法可用（fmt.GoStringer 接口），则使用它；</li>
<li>否则，将使用 Go 语法结构的打印输出。</li>
</ul>
<p>这里发生的情况是，%#v 说明符打算打印值的 “Go表示”，而不是它的“人类可读表示”。fmt 逻辑知道如何这样做，但是自定义类型可以用 fmt 自定义这种行为：即实现 fmt.Formatter 或 GoStringer 接口。</p>
<p>注意，出于完整性考虑，上面解释了 GoStringer，但在实践中，发现它很少被使用。</p>
<p>我个人推荐 <a href="https://github.com/kr/pretty" target="_blank" rel="noopener">https://github.com/kr/pretty</a>
 这个工具，它比 Go 的标准库更清晰地打印 Go 语法表示。例如：<code>fmt.Printf(&quot;%# v&quot;, pretty.Formatter(x))</code>。</p>
<h2 id="格式化动词标识和修改器">格式化动词、标识和修改器</h2>
<p>到目前为止，我们已经看到 %v 与 %s 在意图和目的上的不同，以及例 %v 与 %+v 的不同。</p>
<p>如果我们想用不同的结果来定义我们自己的定制呢？</p>
<p>对于上面三种情况，可靠的定制机制是 fmt.Formatter 接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">fmt</span>

<span class="c1">// Formatter can be implemented by your custom types.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Formatter</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// An object of type State is provided by the fmt
</span><span class="c1">// logic to your custom Format() method.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">State</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="c1">// inherits the Write() method
</span><span class="c1"></span>
     <span class="nf">Flag</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>

     <span class="nf">Width</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
     <span class="nf">Precision</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>最让我感兴趣的是：</p>
<ul>
<li>参数 verb 直接传递给我们自定义的 Format() 方法。这表示主“格式化动词”：对于 %v，verb == ‘v’。对于 %#v，依然是 verb == ‘v’。对于 %s，verb 是 s，以此类推。</li>
<li>有 Flag() 方法的 fmt.State 作为参数传递给 Format() 方法。如果设置了相应的格式化标志，Flag() 返回 true。例如，对于 %v，<code>Flag('#') == false</code>，而对于 %#v，<code>Flag('#') == true</code>。</li>
<li>此外，fmt.State 也实现了 io.Writer 接口。这样就可以直接将状态变量作为第一个参数传递给另一个对 fmt.Fprint 的调用，进一步简化了自定义 Format() 方法的实现。</li>
</ul>
<p>fmt.State 上的 Width() 和 Precision() 方法也很有趣，因为它们允许访问格式化字符串中的附加数值参数或修饰符。例如，在 %3.2f 中，我们有宽度 3 和精度 2。然而，这些在实践中很少被使用。</p>
<p>下面是一个符合 Go 习惯的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Response</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">code</span> <span class="kt">int</span>
     <span class="nx">msg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Response</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="nx">verb</span> <span class="p">{</span>
   <span class="k">case</span> <span class="sc">&#39;v&#39;</span><span class="p">:</span>
       <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// With %+v, we print both the message and the code.
</span><span class="c1"></span>          <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;%s (%d)&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">code</span><span class="p">)</span>
       <span class="p">}</span>
       <span class="k">fallthrough</span>
   <span class="k">case</span> <span class="sc">&#39;s&#39;</span><span class="p">:</span>
       <span class="c1">// For %s, or %v without +, we just print the message.
</span><span class="c1"></span>       <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// String is provided for convenience.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Response</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>简单解释下：</p>
<ul>
<li>以上实现中，对于 %+v，它将同时输出 msg 和 code。当只有 %v/%s，它只打印 msg。</li>
<li>为了让类型兼容 fmt.Stringer 接口，以便用于其他需要 String() 方法的地方，通过调用 fmt.Sprint 实现 String()。</li>
</ul>
<p>下面会进一步讨论。</p>
<p>上面代码一个有趣的点是，它不处理 %q/%x/%x。对于这些动词，它不输出任何内容。</p>
<p>它也不支持除了 + 之外的其他标志，例如，它对待 %#v 和 %v 是相同的。</p>
<p>事实上，Go API 并没有使实现与自身内部逻辑一样通用和强大的自定义 Format() 变得容易，而且“野生的” Go 包常常包含像上面那样的不完整实现。</p>
<h2 id="实践中自定义-formatter">实践中自定义 Formatter</h2>
<p>我在实践中发现，在整个生态系统的包经常按如下方式处理：</p>
<ul>
<li>自定义 Format() 方法总是为 v 动词做一些有效和有用的事情，而不考虑提供的标志。</li>
<li>带有动词 v 但没有标志的 Format() 的行为（即一个简单的 %v），通常与 String() 的行为保持一致。</li>
<li>如果自定义格式化程序同时具有“简单”和“详细”模式，那么它通常将 + 识别为访问详细模式的标志。</li>
<li>如果 %s 和 %v（没有标志）都被识别，它们通常输出相同的内容。</li>
<li>在自定义 Format() 方法中正确处理 %q、%x 和 %X 的情况并不常见。</li>
<li>非数值类型的自定义格式化程序几乎从不处理宽度和精度修饰符。</li>
</ul>
<p>最后一点特别说明了为什么关心固定宽度字符串格式的代码应该在以下两个步骤中拼写输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%30s&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>  <span class="c1">// instead of printing v directly
</span></code></pre></div><h2 id="在-fmtstringerfmtformatter-和-error-之间重用代码">在 fmt.Stringer、fmt.Formatter 和 error 之间重用代码</h2>
<p>上面的一个例子是通过调用 fmt.Sprint 实现 String()。它又在同一类型上使用 Format() 方法。简化为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
   <span class="c1">// This causes fmt to call Format() above and ultimately
</span><span class="c1"></span>   <span class="c1">// print r.msg.
</span><span class="c1"></span>   <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在这种情况下，为什么人们会选择通过返回 fmt.Sprint(r) 而不是返回 r.msg 来实现 String() 呢?</p>
<p>这是遵循 DRY 原则的实例：如果以后逻辑需要更改为&quot;打印更多内容&quot;，则只需修改 Format() 方法；String() 方法会自动从中受益。</p>
<p>这种模式比较常见。以下是另一种形式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span> <span class="c1">// or: s.Write([]byte(r.String()))
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>同样，一个方法实现&quot;使用另一个&quot;，因此一个方法只需要更改其中任何一个，在两者中获得相同的行为。</p>
<p>同样，如果涉及 error 接口，我们会在实践中看到所有重用组合：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">U</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">U</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">U</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">U</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">V</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">V</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">V</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">V</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>Q：为什么我们看到如此多样性？</p>
<p>A：我不太确定，但我责怪 Go 库文档中缺乏方案。另请参阅下面的两个答案。</p>
<p>Q：既然我们在每个情况下都得到相同的结果，这有关系吗？</p>
<p>A：从功能的角度来看，这些示例都是等效的。从性能角度来看，应考虑在程序中更经常使用哪些变体。如果常用 String() 方法，比打印出对象更是如此，那么让 String() 包含最简单的实现可能会产生更好的性能。这是因为 fmt 包中的逻辑有点重量级。然而请注意，在实践中，我并没有发现这种情况经常发生，所以我要说，这并不重要。</p>
<p>Q：我正在实现自己的自定义类型。我应该瞄准什么模式？</p>
<p>A：如果您的类型只有一个表示形式，直接使用 String() 即可；如果您实现错误类型，自然使用 Error() 更合适，一般都不需要实现 Format()。但如果需要区分&quot;简单&quot;和&quot;详细&quot;显示，则首先实现 Format() 然后从中派生 String() 或 Error()。</p>
<h2 id="总结">总结</h2>
<p>Go 在其标准 fmt 包中提供了通用格式 API。</p>
<p>该 API 中的所有函数都由通用逻辑提供支持，这是 Print/Sprintf 在引擎下使用的逻辑：每个对象都显示在某种格式&quot;动词&quot;的上下文中。</p>
<p>最常见和可靠的动词是 v（提示：它是 &ldquo;v&rdquo;，如&quot;value&quot;），也被 Print() 和 Println() 使用。它可以打印几乎任何东西，并不挑剔的值是零或实现一个特定的接口。</p>
<p>同时，在实现自己的类型时，可以通过实现某些接口自定义 fmt 的行为：</p>
<ul>
<li>fmt.Stringer，一个简单的 String() string 方法；</li>
<li>error，一个简单的 Error() string 方法；</li>
<li>fmt.Formatter，一个 Format() 方法。当通过 %v 与 %+v 以及其他动词和标志组合使用时，这可用于显示不同的东西。</li>
</ul>
<p>在实践中，我们看到同时提供 String() 和 Format() 方法或 Error() 和 Format() 方法的包。一个通常是通过调用另一个来实现的，以避免代码重复。Go 的标准库允许所有的组合重用，实际上我们可以在生态系统中找到所有变体。</p>
<blockquote>
<p>原文链接：https://dr-knz.net/go-formatting-apis.html</p>
<p>本文作者：Raphael ‘kena’ Poss</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Go 标准错误 API — CockroachDB errors 库（第1篇）</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/cockroachdb-errors-std-api/</link>
			<pubDate>Fri, 23 Oct 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/cockroachdb-errors-std-api/</guid>
			<description>这篇文章是关于 “CockroachDB errors 库” 的系列文章的第 1 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。 那本篇文章主要谈论什么呢？ 基本的 Go 错误：error 是值 Go 生态有一些非常流行、也非常基本的学习资源（文档）： A Tour of Go: Errors 。这是 Go 的官方教程。 Go By Example: errors 。Go By Example 是一些系列文章，推荐给那些希望通过示例学习 Go 的朋友们。 Goland Docs: Errors and Exception handling</description>
			<content type="html"><![CDATA[<p>这篇文章是关于 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">“CockroachDB errors 库”</a>
的系列文章的第 1 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</p>
<p>那本篇文章主要谈论什么呢？</p>
<h2 id="基本的-go-错误error-是值">基本的 Go 错误：error 是值</h2>
<p>Go 生态有一些非常流行、也非常基本的学习资源（文档）：</p>
<ul>
<li><a href="http://tour.studygolang.com/methods/19" target="_blank" rel="noopener">A Tour of Go: Errors</a>
。这是 Go 的官方教程。</li>
<li><a href="http://books.studygolang.com/gobyexample/errors/" target="_blank" rel="noopener">Go By Example: errors</a>
。Go By Example 是一些系列文章，推荐给那些希望通过示例学习 Go 的朋友们。</li>
<li><a href="https://golangdocs.com/errors-exception-handling-in-golang" target="_blank" rel="noopener">Goland Docs: Errors and Exception handling in GoLang</a>
。“Golang Docs” 是一系列文章，它涵盖了 Go 中的常见软件模式。</li>
</ul>
<p>我们可以从这些文章中学到什么？</p>
<ul>
<li>
<p>Go 提供了一个预定义的接口类型 error，定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// an &#34;error&#34; is an object with an `Error()` method
</span><span class="c1">// which describes the situation that occurred.
</span><span class="c1"></span><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>编写 Go 函数/方法的惯用方法是让它们在常规返回值之外，再返回一个 error 类型值，并在每个调用点上进行测试</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">div</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
       <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;boo&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">/</span> <span class="nx">y</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">div</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;woops: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
       <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;result:&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>如上面的示例所示，fmt.Printf 会知道如何调用 error 的 Error() 方法来显示错误文本。如果错误是通过%s、%q、%x/%X 打印的，它也会这样做。</p>
</li>
</ul>
<h2 id="error-也是链表">error 也是链表</h2>
<p>如果你还不知道 <a href="https://dave.cheney.net/" target="_blank" rel="noopener">Dave Cheney</a>
 是谁，现在是时候去了解下这位及其高产的 Go 大师程序员。</p>
<p>2015 年，Dave 创建了 pkg/errors 包（<a href="https://github.com/pkg/errors" target="_blank" rel="noopener">源代码</a>
，<a href="https://pkg.go.dev/github.com/pkg/errors" target="_blank" rel="noopener">文档</a>
），随后在 2016 年东京举行的 GoCon 春季会议上展示了它。下面这篇文章用散文的形式解释了这个故事：</p>
<p><a href="https://studygolang.com/articles/12484" target="_blank" rel="noopener">Dave Cheney：优雅的处理错误，而不仅仅只是检查错误</a>
</p>
<p>以下是 Dave 提到的主要创新：</p>
<ul>
<li>Go error 对象像链表一样构建，而且是不可变的。</li>
<li>err 在任何时候都会指向列表的头部。</li>
<li>在首次发生错误时，将构造一个原子或&quot;叶&quot;错误对象，该对象将在列表的尾部。</li>
<li>当错误通过调用堆栈和软件组件返回时，通过向错误添加更多&quot;层&quot;、在现有错误列表的头部 push 更多列表元素或&quot;包装器&quot;来增加错误。</li>
</ul>
<p>这在实践中给我们什么启发呢？主要用途是向错误对象添加消息前缀，以给出有关&quot;错误发生在哪&quot;的更多上下文。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;github.com/pkg/errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;boo&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nf">foo</span><span class="p">(),</span> <span class="s">&#34;bar&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">baz</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nf">foo</span><span class="p">(),</span> <span class="s">&#34;baz&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="nx">r</span> <span class="o">:=</span> <span class="nf">rollDice</span><span class="p">()</span>
     <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
     <span class="k">if</span> <span class="p">(</span><span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nf">bar</span><span class="p">()</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nf">baz</span><span class="p">()</span>
     <span class="p">}</span>
     <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>使用 <code>errors.Wrap()</code>，添加一个前缀到错误消息，main 函数能报告：<code>bar: boo</code> 或 <code>baz:boo</code> 这样人类可读错误消息，方便知晓哪个函数被调用。如果没有 <code>errors.Wrap()</code>，哪个调用路径导致错误将不容易知晓。</p>
<p>在实践中，这是如何工作的，看起来有点像这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// errorString represents a leaf error. This
</span><span class="c1">// is what gets constructed by e.g. fmt.Errorf().
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">errorString</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">msg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Error implements the error interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">errorString</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>

<span class="c1">// msgWrap represents a wrapper which adds a prefix
</span><span class="c1">// to an error. This is what gets constructed
</span><span class="c1">// by e.g. pkg/errors.Wrap().
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">msgWrap</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">cause</span> <span class="kt">error</span>
     <span class="nx">msg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// instances of msgWrap are also instances of the error
</span><span class="c1">// interface, by implementing the Error() method.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">msgWrap</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s: %v&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="错误消息包装注释和-cause-发现">错误消息、包装注释和 cause 发现</h2>
<p>Dave Cheney 的基础逻辑是：</p>
<blockquote>
<p>The <code>Error</code> method on the <code>error</code> interface exists for humans, not code.</p>
</blockquote>
<p>换句话说，程序代码不应检查或比较 Error() 方法的结果。</p>
<p>Dave 继续谴责两种 Go 编程模式，他认为令人厌恶，现在仍然不赞成：</p>
<ul>
<li>“哨兵错误（sentinel errors）&ldquo;的概念，这是在代码中通过 error 实例进行比较。例如，<code>if err == ErrNotExists</code>。这种方式的主要问题是，如果错误是链表，也许是在列表的尾部找到哨兵，而头部有其他内容（例如，消息前缀）。Sentinel 的另一个更实际的问题是，为了能够执行比较，发生比较的包必须导入定义 sentinel 所在的包。这将导致依赖项。这种类型的硬依赖性使软件组合更加困难。</li>
<li>引用 &ldquo;error types&rdquo;（或错误包装类型）的概念，进行错误类型断言，例如，<code>if e, ok := err.(SomeType); ok</code>。此处的问题与上述问题相同：如果错误是链表，则它可能不起作用，并且还导致了包依赖。</li>
</ul>
<p>Dave 建议应该采用这两种方式：</p>
<ul>
<li>为调用者感兴趣的错误对象的属性定义接口。例如，错误是否可恢复可以通过 IsRecoverable() 方法来定义。然后，在任何包都可以断言此接口的实现，没有依赖关系：在 Go 中，接口断言基于结构相等，而不是命名相等。</li>
<li>注意错误链接列表结构，并在检查错误对象时正确遍及链表层级。</li>
</ul>
<p>为了实现后一点，Dave Cheney 在 pkg/errors 中引入了 causer 接口，从而有了以下可重用的代码模式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NB: causer is not exported by pkg/errors; instead
</span><span class="c1">// any package can re-defined it as needed
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">causer</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Cause</span><span class="p">()</span> <span class="kt">error</span> <span class="p">}</span>

<span class="o">...</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">{</span>
       <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">SomeInterfaceWithProperty</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
          <span class="c1">// ... do something ...
</span><span class="c1"></span>       <span class="p">}</span>

       <span class="c1">// Peel one layer, if wrapped.
</span><span class="c1"></span>       <span class="k">if</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.(</span><span class="nx">causer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
          <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Cause</span><span class="p">()</span>
          <span class="k">continue</span>
       <span class="p">}</span>
       <span class="k">break</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>此模式会将错误展开，根据错误链访问，直到叶子节点或链表尾部。</p>
<h2 id="在-errors-中内嵌堆栈追踪">在 errors 中内嵌堆栈追踪</h2>
<p>包 pkg/errors 的一个被低估的特性是，每次构造错误或包装错误时，它都会自动保留堆栈跟踪的副本。</p>
<p>这一点很重要，因为它使得在排除问题时能够分析”错误发生在哪里&rdquo;：通常情况下，该错误仅对开发人员可见，或在实例化后很长一段时间，在调用者中的某个地方出现问题。各种 Go 并发模式使这种困难更加复杂，其中错误对象通过通道将错误对象从一个 goroutine 传输到下一个 goroutine。因此，仅仅查看源代码中的&quot;一行&quot;来查找错误的来源是不够的。</p>
<p>为此，pkg/error 使用极其轻量级且相当聪明的机制来在每个错误构造时保留调用堆栈的副本。</p>
<p>此堆栈跟踪不出现在 Error() 方法的结果中；相反，当通过 Printf 中的 %+v 谓词（这是最常见的情况，例如在调试期间）或通过检查错误链接列表某些层（例如与 <a href="https://sentry.io/" target="_blank" rel="noopener">Sentry.io</a>
 集成）上是否存在 StackTrace() 方法时，将显示错误对象。</p>
<p>这种机制特别巧妙的是，堆栈跟踪的所有详细信息（包括函数/包名称）不会直接存储在错误对象中，而是在打印堆栈跟踪时检索它们。通常情况下，错误发生，但可能是无害的，这样可以节省时间和内存。</p>
<h2 id="go-113-中的提升和-api-分裂">Go 1.13 中的提升和 API 分裂</h2>
<p>很难说 pkg/errors 包多么基础和重要。但目前直接依赖它的公开 Go 项目超过 5 万个，还有无法统计的私有 Go 存储库。</p>
<p>Go 语言的设计者认识到了这一点，并<a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">在 2019 年将其语义集成到 Go 标准库</a>
中，从 Go 1.13 开始：</p>
<ul>
<li>Go 1.13 的错误也是链表。</li>
<li>Go 1.13 没有提供 <code>errors.Wrap()</code>，但是为 fmt.Errorf 做了扩充：使用格式化动词 %w，构造一个包装错误，并保持原来的错误对象放在链表尾部供检测；
<ul>
<li>在 <code>pkg/errors</code>: <code>errors.Wrapf(err, &quot;hello %s&quot;, &quot;world&quot;)</code></li>
<li>在 Go 1.13: <code>fmt.Errorf(&quot;hello %s: %w&quot;, &quot;world&quot;, err)</code></li>
</ul>
</li>
<li>Go 1.13 简化了在错误链表的每个中间级别上测试属性的任务，使用以下 api：
<ul>
<li>errors.Is(err1, err2) 检查 err1 中的任何层是否等于 err2（会递归地测试哨兵）。这可以用来识别许多标准库的哨兵，例如 errors.Is(err, os.ErrNotExist) 检查是否由于找不到某个文件/目录而导致错误。</li>
<li><code>errors.As(err1, &lt;type&gt;)</code> 检查 err1 中的任何层是否可以被转换为 <code>&lt;type&gt;</code>（接口或具体类型），并返回转换的结果。这可以用来断言错误属性，就 Dave Cheney 在 2015 年建议的那样。</li>
</ul>
</li>
</ul>
<p>然而存在一些争议，因为 Go 1.13 在社区中引发了 API 的分裂：</p>
<ul>
<li>error 对象上的展开方法称为 Unwrap()，而不是 Cause()。我个人很讨厌 Go 团队选择一个单独的方法名，因为这直接破坏了与所有基于 pkg/errors 构建的包的兼容性，而且没有很好这么做的原因。</li>
<li>Go 1.13 没有提供像 pkg/errors 中的 error.Cause() 那样的 “unwrap 一切”的函数。</li>
<li>另外，遗憾的是，因为 Go 1.13 没有定义 Cause() 方法，所以不可能使用 pkg/errors 中的 error.Cause() 来解包装来自 Go 1.13 项目和为 pkg/errors API 设计的项目的混合错误对象。</li>
<li>非常遗憾的是，Go 1.13 没有像 pkg/errors 那样提供捕获堆栈跟踪的工具。由于上述 API 的不兼容性，不可能将 pkg/errors 与特定于 Go 1.13 的代码混合匹配来获得这种行为。</li>
</ul>
<p>总结为如下表格：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Feature</th>
<th style="text-align:left">Go’s &lt;1.13 <code>errors</code></th>
<th style="text-align:left"><code>github.com/pkg/errors</code></th>
<th style="text-align:left">Go 1.13 <code>errors</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">leaf error constructors (<code>New</code>, <code>Errorf</code> etc)</td>
<td style="text-align:left">✔</td>
<td style="text-align:left">✔</td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">abstraction: errors are linked lists</td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">error causes via <code>Cause()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">error causes via <code>Unwrap()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">best practice: test interfaces, not values/types</td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left">(partial)</td>
</tr>
<tr>
<td style="text-align:left"><code>errors.As()</code>, <code>errors.Is()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left"><code>errors.Wrap()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">automatic error wrap when format ends with : %w</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">standard wrappers with efficient stack trace capture</td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>这种分裂是真实而悲哀的。发生这种情况的原因（也许令人惊讶）是 Go 团队无法确定一种好的方法来标准化打印错误。我们将在本系列的后续文章中了解其中的原因。</p>
<p>然而，pkg/error 社区的用户不能简单地加入到 Go 1.13 的潮流中去。这里有一个缺口，需要一些交叉兼容的库来弥补这个缺口。</p>
<p>这就是为什么 <a href="https://github.com/cockroachdb/errors/" target="_blank" rel="noopener">CockroachDB 错误库</a>
能够做到这一点。您可以使用它作为 pkg/errors 和 Go 1.13 自己的 errors 包的临时替代。</p>
<blockquote>
<p>原文链接：https://dr-knz.net/cockroachdb-errors-std-api.html</p>
<p>本文作者：Raphael ‘kena’ Poss</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>一道关于 json 和 slice 的题难倒了 80% 的人</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/interview-slice-json/</link>
			<pubDate>Sun, 18 Oct 2020 14:18:50 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/interview-slice-json/</guid>
			<description>昨天在 Go语言爱好者周刊：第 65 期 刊首语发了一道题，以下代码输出什么？ package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; ) type AutoGenerated struct { Age int `json:&amp;#34;age&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` Child []int `json:&amp;#34;child&amp;#34;` } func main() { jsonStr1 := `{&amp;#34;age&amp;#34;: 14,&amp;#34;name&amp;#34;: &amp;#34;potter&amp;#34;, &amp;#34;child&amp;#34;:[1,2,3]}` a := AutoGenerated{} json.Unmarshal([]byte(jsonStr1), &amp;amp;a) aa := a.Child fmt.Println(aa) jsonStr2 := `{&amp;#34;age&amp;#34;: 12,&amp;#34;name&amp;#34;: &amp;#34;potter&amp;#34;, &amp;#34;child&amp;#34;:[3,4,5,7,8,9]}` json.Unmarshal([]byte(jsonStr2), &amp;amp;a) fmt.Println(aa) } 结果 80% 的人都答错了。 结果为什么是 [1 2 3] [3 4 5] 呢？ 这道题涉及到两个知识点： json 解析； slice； 1、json 解析 关于 json.Unmarshal 的文档，不少人可能没认真看。借此机会正好一起看下。https://docs.st</description>
			<content type="html"><![CDATA[<p>昨天在 <a href="https://mp.weixin.qq.com/s/CqcOPluw5RFMYRzrnWCoHA" target="_blank" rel="noopener">Go语言爱好者周刊：第 65 期</a>
 刊首语发了一道题，以下代码输出什么？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">AutoGenerated</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Age</span>   <span class="kt">int</span>    <span class="s">`json:&#34;age&#34;`</span>
	<span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
	<span class="nx">Child</span> <span class="p">[]</span><span class="kt">int</span>  <span class="s">`json:&#34;child&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">jsonStr1</span> <span class="o">:=</span> <span class="s">`{&#34;age&#34;: 14,&#34;name&#34;: &#34;potter&#34;, &#34;child&#34;:[1,2,3]}`</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nx">AutoGenerated</span><span class="p">{}</span>
	<span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">jsonStr1</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">aa</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Child</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">aa</span><span class="p">)</span>
	<span class="nx">jsonStr2</span> <span class="o">:=</span> <span class="s">`{&#34;age&#34;: 12,&#34;name&#34;: &#34;potter&#34;, &#34;child&#34;:[3,4,5,7,8,9]}`</span>
	<span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">jsonStr2</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">aa</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果 80% 的人都答错了。</p>
<p><p class="md__image">
  <img src="../imgs/json01.png"
    alt=""  />
</p>
</p>
<p>结果为什么是 [1 2 3] [3 4 5] 呢？</p>
<p>这道题涉及到两个知识点：</p>
<ul>
<li>json 解析；</li>
<li>slice；</li>
</ul>
<h2 id="1json-解析">1、json 解析</h2>
<p>关于 json.Unmarshal 的文档，不少人可能没认真看。借此机会正好一起看下。<a href="https://docs.studygolang.com/pkg/encoding/json/#Unmarshal" target="_blank" rel="noopener">https://docs.studygolang.com/pkg/encoding/json/#Unmarshal</a>
。</p>
<blockquote>
<p>Unmarshal 解析 JSON 编码的数据，并将结果存入 v 指向的值。如果 v 为 nil 或不是指针，则 Unmarshal 返回 InvalidUnmarshalError。</p>
<p>Unmarshal 和 Marshal 做相反的操作，必要时申请 map、slice 或指针，有如下的附加规则：</p>
<ul>
<li>
<p>为了将 JSON 数据解码写入一个指针，Unmarshal 首先处理 JSON 数据为 JSON 字面值 null 的情况。此时，Unmarshal 会将指针设置为 nil。否则，Unmarshal 会将 JSON 数据解码为指针所指向的值。如果指针为 nil，则 Unmarshal 为其分配一个新值并使指针指向它。</p>
</li>
<li>
<p>为了将 JSON 数据解码为实现 Unmarshaler 接口的值，Unmarshal 调用该值的 UnmarshalJSON 方法，包括当输入为 JSON  null 时。否则，如果该值实现 encoding.TextUnmarshaler 且输入是带引号的 JSON 字符串，则 Unmarshal 会使用该字符串的未加引号形式来调用该值的 UnmarshalText 方法。</p>
</li>
<li>
<p>要将 json 数据解码写入一个结构体，函数会匹配输入对象的键和 Marshal 使用的键（结构体字段名或者它的标签指定的键名），优先选择精确的匹配，但也接受大小写不敏感的匹配；</p>
</li>
<li>
<p>为了将 JSON 数据解码到结构中，Unmarshal 将传入的对象键与 Marshal 使用的键（结构字段名称或其 Tag）进行匹配，希望使用精确匹配，但还接受不区分大小写的匹配。默认情况下，没有相应结构字段的对象键将被忽略（有关替代方法，请参见 Decoder.DisallowUnknownFields）。</p>
</li>
<li>
<p>要将 JSON 数据解码写入一个接口类型值，Unmarshal 将其中之一存储在接口值中：</p>
<pre tabindex="0"><code>Bool                   对应JSON布尔类型
float64                对应JSON数字类型
string                 对应JSON字符串类型
[]interface{}          对应JSON数组
map[string]interface{} 对应JSON对象
nil                    对应JSON的null
</code></pre></li>
<li>
<p>要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。</p>
</li>
<li>
<p>为了将 JSON 数组解码为 Go 数组，Unmarshal 将 JSON 数组元素解码为对应的 Go 数组元素。如果 Go 数组长度小于 JSON 数组，则其他 JSON 数组元素将被丢弃。如果 JSON 数组长度小于 Go 数组，则将其他 Go 数组元素会设置为零值。</p>
</li>
<li>
<p>要将 JSON 对象解码到 map 中，Unmarshal 首先要建立将使用的 map。如果 map 为零，Unmarshal 会分配一个新 map。否则，Unmarshal 会重用现有 map，保留现有条目（item）。然后，Unmarshal 将来自 JSON 对象的键/值对存储到 map 中。map 的键类型必须是任意字符串类型、整数或实现了 json.Unmarshaler 或 encoding.TextUnmarshaler 接口的类型。</p>
</li>
<li>
<p>如果 JSON 值不适用于给定的目标类型，或者 JSON 数字写入目标类型时溢出，则 Unmarshal 会跳过该字段并尽最大可能完成解析。如果没有遇到更多的严重错误，则 Unmarshal 返回一个 UnmarshalTypeError 来描述最早的此类错误。但无法确保有问题的字段之后的所有其余字段都将被解析到目标对象中。</p>
</li>
<li>
<p>JSON 的 null 值解码为 Go 的接口、指针、切片时会将它们设为 nil，因为 null 在 JSON 里一般表示“不存在”。 因此将 JSON null 解码到任何其他 Go 类型中不会影响该值，并且不会产生任何错误。</p>
</li>
<li>
<p>解析带引号的字符串时，无效的 UTF-8 或无效的 UTF-16 不会被视为错误。而是将它们替换为 Unicode 字符 U+FFFD。</p>
</li>
</ul>
</blockquote>
<p>跟此题相关的是下面这点：</p>
<blockquote>
<p>要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。</p>
</blockquote>
<p>因此第一次解析时，a.Child 是 [1 2 3]，aa 自然也是 [1 2 3]。第二次解析时，a.Child 的长度会被重置为 0，也就说里面的值会被重置（比如 a.Child = a.Child[:0]），然后将 3,4,5,7,8,9 一个个 append 到 a.Child 中。</p>
<p>而 append 操作可能会涉及到底层数组的扩容：当原来的容量不足时，会进行扩容。怎么扩容的呢？目前的版本（Go1.15.x）按照如下规则扩容：（扩容规则依赖具体实现，不同版本可能不一样）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Get element of array, growing if necessary.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">==</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span> <span class="p">{</span>
  <span class="c1">// Grow slice if necessary
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Cap</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Cap</span><span class="p">()</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Cap</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="mi">4</span> <span class="p">{</span>
      <span class="nx">newcap</span> <span class="p">=</span> <span class="mi">4</span>
    <span class="p">}</span>
    <span class="nx">newv</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">MakeSlice</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Type</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Len</span><span class="p">(),</span> <span class="nx">newcap</span><span class="p">)</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">newv</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="nx">v</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">newv</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v</span><span class="p">.</span><span class="nf">SetLen</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>初始容量最小为 4；</li>
<li>之后按照容量的一半扩容，所以容量是 4、6、9、13、19&hellip;</li>
</ul>
<p>有人问上题为什么 aa 的容量是 4，这里正好解释了。</p>
<p>因此，第一次解析，aa.Child 是：[1 2 3]，cap = 4。第二次解析，aa.Child 先被重置，之后将 3,4,5,7,8,9 一个个 append，最后 aa.Child 是：[3 4 5 6 7 8 9], cap = 6。</p>
<h2 id="2slice">2、slice</h2>
<p>以上就是能从 json Unmarshal 文档能学到的相关知识。接下来关键在于 slice。关于 slice 的知识，网上很多教程，这里只讲解和该题相关的内容。</p>
<p>1）aa := a.Child 意味着什么？</p>
<p>先看 a.Child 的内部结构。</p>
<p><p class="md__image">
  <img src="../imgs/json02.png"
    alt=""  />
</p>
</p>
<p>赋值给 aa 后呢？aa 和 a.Child 共用底层数组。</p>
<p><p class="md__image">
  <img src="../imgs/json03.png"
    alt=""  />
</p>
</p>
<p>这里有引入一个小知识点，aa := a.Child 后，以下代码输出的两个地址是一样的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p,%p\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Child</span><span class="p">,</span> <span class="nx">aa</span><span class="p">)</span>
</code></pre></div><p>它们输出的都是底层数组的地址，这里一定要注意。通过它们，你可以验证底层数组扩容了（地址变了，表明扩容了）。</p>
<p>如果要输出 slice 本身的地址，应该这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p,%p\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">.</span><span class="nx">Child</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">aa</span><span class="p">)</span>
</code></pre></div><p>2）执行第二次 json 解析后</p>
<p>根据上文的讲解，底层数组从索引 0 位置开始依次被 3、4、5、7 填充。因为 aa 的 len 是 3，所以即使底层数组变成了 3、4、5、7，aa 看到却是 3、4、5。</p>
<p>当再继续解析时，底层数组容量不够，因此进行扩容，cap 变成 6，将原底层数组的元素拷贝一份到新的数组中。所以最后 a.Child 的底层数组是这个新的底层数组：[3 4 5 7 8 9]，cap = 6。而 aa 的底层数组还是原来的。最后的内部表示是这样的。</p>
<p><p class="md__image">
  <img src="../imgs/json04.png"
    alt=""  />
</p>
</p>
<h2 id="3小结">3、小结</h2>
<p>总结起来两点：</p>
<ul>
<li>json 解析的规则，文档上明确说明了；（有人评论说跟 json 没关系，但我觉得很多人根本不知道 json 对这块是怎么处理的，正因为有这样的处理，才引出了 slice 扩容的问题）</li>
<li>slice 内部表示和 append 导致扩容。</li>
</ul>
<p>希望你已经彻底掌握了以上知识点。</p>
]]></content>
		</item>
		
		<item>
			<title>你喜欢的 Go 第三方库：一步为系统集成可视化实时运行时统计</title>
			<link>https://polarisxu.studygolang.com/posts/go/pkg/statsviz/</link>
			<pubDate>Thu, 15 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/pkg/statsviz/</guid>
			<description>大家好，我是站长 polarisxu。 掌握系统运行状态，知道系统哪些地方可能存在问题，方便进行优化，这是一个实际系统必备的。裸奔，对系统一无所知，迟早是要出大事的。 在 Go 语言中，官方标准库提供了方法，让我们能够获得内存分配、GC 和 Goroutine 等情况。比如内存、GC 等情况，可以通过 runtime.MemStats 获取：https://docs.studygolang.com/pkg/runtime/#M</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>掌握系统运行状态，知道系统哪些地方可能存在问题，方便进行优化，这是一个实际系统必备的。裸奔，对系统一无所知，迟早是要出大事的。</p>
<p>在 Go 语言中，官方标准库提供了方法，让我们能够获得内存分配、GC 和 Goroutine 等情况。比如内存、GC 等情况，可以通过 runtime.MemStats 获取：<a href="https://docs.studygolang.com/pkg/runtime/#MemStats" target="_blank" rel="noopener">https://docs.studygolang.com/pkg/runtime/#MemStats</a>
，Goroutine 数量可以通过 runtime.NumGoroutine() 函数获得。</p>
<p>一般我们我们需要自己解析 MemStats 信息、做展示，也可以做图表。</p>
<p>今天我给大家推荐一个库：<a href="https://github.com/arl/statsviz" target="_blank" rel="noopener">https://github.com/arl/statsviz</a>
，它是一个在浏览器中实时查看 Go 应用程序运行时统计信息（GC，MemStats 等）的库。</p>
<p>它能展示的信息如下图：</p>
<p><p class="md__image">
  <img src="../imgs/statsviz01.png"
    alt=""  />
</p>
</p>
<p>再看其中 Heap 的实时动图：</p>
<p><p class="md__image">
  <img src="../imgs/statsviz02.gif"
    alt=""  />
</p>
</p>
<p>上面这些通过运行下面这段代码就可以了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/arl/statsviz&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Force the GC to work to make the plots &#34;move&#34;.
</span><span class="c1"></span>	<span class="k">go</span> <span class="nf">work</span><span class="p">()</span>

	<span class="c1">// Register statsviz handlers on the default serve mux.
</span><span class="c1"></span>	<span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">work</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Generate some allocations
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">byte</span><span class="p">{}</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">512</span><span class="o">+</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="p">))</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">100</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">b</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">byte</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="1如何使用">1、如何使用</h2>
<blockquote>
<p>都 Go1.15.x 了，请使用 go module。</p>
</blockquote>
<p>statsviz 的使用很简单。假设基于 net/http 使用。</p>
<ul>
<li>import &ldquo;github.com/arl/statsviz”</li>
<li>注册 statsviz HTTP handlers</li>
<li>启动程序</li>
<li>打开浏览器访问：http://host:port/debug/statsviz</li>
<li>尽情享受吧~</li>
</ul>
<p>具体看看实际中怎么集成到项目中，根据可能的情况分别介绍。</p>
<h3 id="基于-nethttp">基于 net/http</h3>
<p>如果你的项目没有使用框架，直接基于 net/http；或者你的项目并没有提供 HTTP 服务。集成 statsviz 可以按照下面的方式。</p>
<p><strong>1）一个使用 net/http 的 Web 项目</strong></p>
<p>只需要 import statsviz 包后，在注册路由的地方加上如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
</code></pre></div><p>这是使用默认的 http.DefaultServeMux，如果你使用的是自定义 Mux，则加上如下类似如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">mux</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewServeMux</span><span class="p">()</span>
<span class="nx">statsviz</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">mux</span><span class="p">)</span>
</code></pre></div><p>其中，mux 使用你定义好的。</p>
<p>实际上，statsviz.RegisterDefault() 内部是这么实现的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RegisterDefault</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">Register</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">DefaultServeMux</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><strong>2）没有提供 HTTP 服务的项目</strong></p>
<p>这时最简单的方式就是使用 statsviz.RegisterDefault() ，同时需要启动一个 HTTP 服务：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div><h3 id="基于兼容-nethttp-的框架">基于兼容 net/http 的框架</h3>
<p>因为兼容 net/http 框架，因此可以直接将 statsviz 的 Handler 集成进去。比如对于 gorilla/mux 库，可以这么做：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">NewRouter</span><span class="p">()</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Path</span><span class="p">(</span><span class="s">&#34;/debug/statsviz/ws&#34;</span><span class="p">).</span><span class="nf">Name</span><span class="p">(</span><span class="s">&#34;GET /debug/statsviz/ws&#34;</span><span class="p">).</span><span class="nf">HandlerFunc</span><span class="p">(</span><span class="nx">statsviz</span><span class="p">.</span><span class="nx">Ws</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">PathPrefix</span><span class="p">(</span><span class="s">&#34;/debug/statsviz/&#34;</span><span class="p">).</span><span class="nf">Name</span><span class="p">(</span><span class="s">&#34;GET /debug/statsviz/&#34;</span><span class="p">).</span><span class="nf">Handler</span><span class="p">(</span><span class="nx">statsviz</span><span class="p">.</span><span class="nx">Index</span><span class="p">)</span>

<span class="nx">mux</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewServeMux</span><span class="p">()</span>
<span class="nx">mux</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="nx">mux</span><span class="p">)</span>
</code></pre></div><p>这里主要是 statsviz.Ws 和 statsviz.Index，因为 gorilla/mux 库兼容 net/http，所以可以这么做。</p>
<h3 id="不兼容-nethttp-的框架">不兼容 net/http 的框架</h3>
<p>比如集成进 Gin 框架。做法就是和“没有提供 HTTP 服务的项目”一样，另开一个 HTTP 端口。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div><p>因此这里实际上和具体框架没关系。</p>
<h3 id="最佳实践">最佳实践</h3>
<p>因为 runtime 信息属于系统内部信息，不适合暴露给公网用户。因此，实际上中，最佳实践是，不管什么情况下，都单独开一个 HTTP 端口，类似下面这样，对公网不可访问。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div><h2 id="原理简单说明">原理简单说明</h2>
<p>该库使用 WebSocket 协议，定时将系统的 runtime 数据发送给浏览器，浏览器接收到之后，利用 JS 绘制图表，展示出来。Go 核心代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sendStats indefinitely send runtime statistics on the websocket connection.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sendStats</span><span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">defaultSendPeriod</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">tick</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

	<span class="kd">var</span> <span class="nx">stats</span> <span class="nx">stats</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
			<span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stats</span><span class="p">.</span><span class="nx">Mem</span><span class="p">)</span>
			<span class="nx">stats</span><span class="p">.</span><span class="nx">NumGoroutine</span> <span class="p">=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">WriteJSON</span><span class="p">(</span><span class="nx">stats</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>对客户端代码感兴趣的请自行阅读源码。</p>
<h2 id="总结">总结</h2>
<p>如果你需要实时图表的方式查看系统运行时的一些数据，可以尝试下它。用类似这样几行代码一步将它集成进你的系统：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go Playground 还能这么玩？</title>
			<link>https://polarisxu.studygolang.com/posts/go/project/usingg-gpgsync/</link>
			<pubDate>Fri, 09 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/project/usingg-gpgsync/</guid>
			<description>大家好，我是 polarisxu。 之前我为大家推荐过 Playground，对比了三款 Go Playground 。今天发现了另外一款 Playground，它最核心的特点是，可以多人协同编辑。 协同编辑，目前是很流行的一种多人协作模式。GitHub 的编辑器 Atom 就有这方面的支持。 简介 先简单看看这款 Playground：gpgsync。这是 syumai 开发的一款多人协同编辑的 Go Playground，他是</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>之前我为大家推荐过 Playground，<a href="https://mp.weixin.qq.com/s/SYngjiM8M2T6KS0OQNonCQ" target="_blank" rel="noopener">对比了三款 Go Playground</a>
。今天发现了另外一款 Playground，它最核心的特点是，可以多人协同编辑。</p>
<p>协同编辑，目前是很流行的一种多人协作模式。GitHub 的编辑器 Atom 就有这方面的支持。</p>
<h2 id="简介">简介</h2>
<p>先简单看看这款 Playground：gpgsync。这是 <a href="https://github.com/syumai" target="_blank" rel="noopener">syumai</a>
 开发的一款多人协同编辑的 Go Playground，他是一个 TypeScript 和 Go 爱好者。</p>
<p>项目地址：<a href="https://github.com/syumai/gpgsync" target="_blank" rel="noopener">https://github.com/syumai/gpgsync</a>
，这是一个 Node 项目，你可以本地搭建，也可以直接试用作者提供的 Demo：<a href="https://gpgsync.herokuapp.com/" target="_blank" rel="noopener">https://gpgsync.herokuapp.com/</a>
。</p>
<h2 id="如何使用">如何使用</h2>
<p>打开 <a href="https://gpgsync.herokuapp.com/" target="_blank" rel="noopener">https://gpgsync.herokuapp.com/</a>
，会让你提供一个 Room ID，可以使用随机生成的，也可以自定义。</p>
<p><p class="md__image">
  <img src="../imgs/gpgsync01.png"
    alt=""  />
</p>
</p>
<p>点击 Join 后，进入编辑界面。</p>
<p><p class="md__image">
  <img src="../imgs/gpgsync02.png"
    alt=""  />
</p>
</p>
<p>这个界面和官方的 Playground 基本类似，但多了一个 Options。这个功能来自作者的另一个项目：<a href="https://github.com/syumai/go-playground-custom" target="_blank" rel="noopener">https://github.com/syumai/go-playground-custom</a>
，好吧，又一个 Playground。这个项目的目标是为 Playground 提供一些额外的特性，包括：</p>
<ul>
<li>基于 CodeMirror 的丰富编辑器；
<ul>
<li>语法高亮（官方 Playground 是不支持语法高亮的）；</li>
<li>Vim 模式（我太喜欢这点了）；</li>
</ul>
</li>
<li>go2go 支持。这是对 Go 泛型的支持；</li>
</ul>
<p>点击 Options 后，在底部有相关配置：</p>
<p><p class="md__image">
  <img src="../imgs/gpgsync03.png"
    alt=""  />
</p>
</p>
<p>回到主题。</p>
<p>当你进入后，你可以将你的 Room ID 告诉你的协作者，或者直接复制链接发给 TA，你们就可以协同了。你或 TA 的改动，另一方能实时看到。</p>
<p>我的 Room：<a href="https://gpgsync.herokuapp.com/rooms/polarisxu" target="_blank" rel="noopener">https://gpgsync.herokuapp.com/rooms/polarisxu</a>
，大家可以试试，看看一堆人是啥效果，会不会崩溃~</p>
<p>你自己想单独试验，可以开两个浏览器看看效果。</p>
<p><strong>特别说明</strong>：最终的运行是交给 play.golang.org 的，因此要实际运行，请自备梯子。</p>
<h2 id="有啥用">有啥用</h2>
<p>我想到的有两点：</p>
<ul>
<li>请教大牛问题，实时看 TA 怎么写代码的；</li>
<li>面试，特别远程面试时，可以让对方通过这个写代码，你实时看到对方的整个 coding 过程；</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>终于找到了一款我喜欢的安装和管理 Go 版本的工具</title>
			<link>https://polarisxu.studygolang.com/posts/go/project/go-version-manager/</link>
			<pubDate>Fri, 09 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/project/go-version-manager/</guid>
			<description>一直以来，我都习惯通过源码安装 Go。我是这么做的： 1）Git clone Go 源码 $ git clone https://github.com/golang/go 2）需要安装什么版本就切换到对应的分支，比如安装 1.15.x $ git checkout -b release-branch.go1.15 origin/release-branch.go1.15 如果本地之前已经存在该分支，直接 git checkout release-branch.go1.15 即可。 3）将 go 整个目录复制到 /usr/local/go1.15，编译安装 4）创建软链： ln -s go1.15 go 之后加上环境变量等。 如果想要切换版本，只需要做类似上面的步骤，最后将 go 这个软链指向要切换的</description>
			<content type="html"><![CDATA[<p>一直以来，我都习惯通过源码安装 Go。我是这么做的：</p>
<p>1）Git clone Go 源码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git clone https://github.com/golang/go
</code></pre></div><p>2）需要安装什么版本就切换到对应的分支，比如安装 1.15.x</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git checkout -b release-branch.go1.15 origin/release-branch.go1.15
</code></pre></div><p>如果本地之前已经存在该分支，直接 git checkout release-branch.go1.15 即可。</p>
<p>3）将 go 整个目录复制到 /usr/local/go1.15，编译安装</p>
<p>4）创建软链：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">ln -s go1.15 go
</code></pre></div><p>之后加上环境变量等。</p>
<p>如果想要切换版本，只需要做类似上面的步骤，最后将 go 这个软链指向要切换的版本。</p>
<p>我这种方式存在两个问题：</p>
<ul>
<li>因为 Go1.5 实现了自举，对于没有安装 Go 的系统，需要先安装 Go1.4；</li>
<li>每次都编译，还是没那么方便，而且如果是 Windows 系统，可能会有一些问题（现在的 Windows 也可能没问题了？好久没使用 Windows 了，使用 Windows 的朋友可以留言告知下）；</li>
</ul>
<p>之后看到 <a href="https://github.com/moovweb/gvm" target="_blank" rel="noopener">gvm</a>
 这个工具，我试用了，可能是国内网络的原因，根本没法安装 Go，基本卡着不动。此外还有一些其他的解决方案，比如 <a href="https://github.com/syndbg/goenv" target="_blank" rel="noopener">goenv</a>
，这是仿照 pyenv 和 rbenv 实现的，安装配置感觉略微有点复杂，直接没尝试。</p>
<p>今天发现另外一个工具，和我手动管理多版本的思路类似，所以爱上了！</p>
<h2 id="1开发-goup-的初衷">1、开发 goup 的初衷</h2>
<p>发音：Go Up。作者介绍，他开发了这个工具的原因：</p>
<p>1）操作系统发行版的包管理工具一般不会那么及时的升级 Go 到最新版本，特别是 Linux 发行版；</p>
<p>2）虽然安装和管理 Go 版本的工具不少，但作者认为要么存在一些问题，要么体验不好或缺失一些功能；（哈哈哈，很有道理是不是？造一个轮子，总是觉得别人的不够圆，自己的又大又圆，有木有？）</p>
<p>作者想要一个这样的工具：</p>
<ul>
<li>不需要先安装了 Go 的某个版本；（我上面的管理方案就是需要先安装某个版本）</li>
<li>这个工具本身安装足够简单，最好一行命令搞定；</li>
<li>跨平台，在所有操作系统运行良好，至少在类 Unix 系统运行良好；</li>
<li>能方便的安装最新的 Go 版本；</li>
<li>能方便的安装 Go 的任意版本，包括 tip；</li>
<li>不会污染你的 Shell；</li>
<li>使用 Go 语言实现；</li>
</ul>
<h2 id="2安装-goup">2、安装 goup</h2>
<p>因为 goup 本身是 Go 语言实现的，因此他通过一个脚本下载对应系统的预编译 goup 程序。当前最新版本 0.0.7 （这个工具是 9 月底开发的），当然你也可以自己手动下载这些编译好 goup 程序。（如果你本地安装了 Go 版本，直接 go get -u -v github.com/owenthereal/goup/&hellip; 安装也是可以的）</p>
<p><p class="md__image">
  <img src="../imgs/goup01.png"
    alt=""  />
</p>
</p>
<p>一行代码安装 goup（推荐的方式）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ curl -sSf https://raw.githubusercontent.com/owenthereal/goup/master/install.sh <span class="p">|</span> sh
</code></pre></div><h2 id="3使用介绍">3、使用介绍</h2>
<p>看看 goup 的帮助文档：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ goup <span class="nb">help</span>
The Go installer

Usage:
  goup <span class="o">[</span>command<span class="o">]</span>

Available Commands:
  <span class="nb">help</span>        Help about any <span class="nb">command</span>
  init        Initialize the goup environment file.
  install     Install Go by providing a version <span class="o">(</span>e.g. <span class="s2">&#34;1.15.2&#34;</span>, or <span class="s2">&#34;tip&#34;</span><span class="o">)</span>. If empty, use the latest version.
  show        Show the current version of installed Go
  version     Show goup version

Flags:
  -h, --help   <span class="nb">help</span> <span class="k">for</span> goup

Use <span class="s2">&#34;goup [command] --help&#34;</span> <span class="k">for</span> more information about a command.
</code></pre></div><ul>
<li>install：安装对应的 Go 版本，也可以是 tip。如果不提供版本，则安装当前最新版本；</li>
<li>show：显示当前生效的 Go 版本；</li>
<li>init：会在 <code>$HOME/.go</code> 目录下生成一个 env 文件，内容是设置 PATH 环境变量，即将 <code>$HOME/.go/bin</code> 和 <code>$HOME/.go/current/bin</code> 加入 PATH 中；同时会往一些系统配置文件中加上 <code>source &quot;$HOME/.go/env&quot;</code>；</li>
</ul>
<p>比如我想试试还不支持 Module 的版本：1.10.8</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ goup install 1.10.8
Downloaded   0.0% <span class="o">(</span>    <span class="m">3320</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded   3.7% <span class="o">(</span> <span class="m">3260416</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  11.7% <span class="o">(</span><span class="m">10338304</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  21.1% <span class="o">(</span><span class="m">18563072</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  27.9% <span class="o">(</span><span class="m">24592384</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  34.8% <span class="o">(</span><span class="m">30588928</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  41.6% <span class="o">(</span><span class="m">36618240</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  48.4% <span class="o">(</span><span class="m">42549248</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  55.2% <span class="o">(</span><span class="m">48611328</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  62.1% <span class="o">(</span><span class="m">54640640</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  68.9% <span class="o">(</span><span class="m">60669952</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  75.8% <span class="o">(</span><span class="m">66666496</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  82.6% <span class="o">(</span><span class="m">72695808</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  88.8% <span class="o">(</span><span class="m">78135296</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  93.3% <span class="o">(</span><span class="m">82100224</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  94.4% <span class="o">(</span><span class="m">83083264</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  98.7% <span class="o">(</span><span class="m">86851584</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded 100.0% <span class="o">(</span><span class="m">87999054</span> / <span class="m">87999054</span> bytes<span class="o">)</span>
INFO<span class="o">[</span>0016<span class="o">]</span> Unpacking /Users/xuxinhua/.go/go1.10.8/go1.10.8.darwin-amd64.tar.gz ...
INFO<span class="o">[</span>0020<span class="o">]</span> Success: go1.10.8 downloaded in /Users/xuxinhua/.go/go1.10.8
INFO<span class="o">[</span>0020<span class="o">]</span> Default Go is <span class="nb">set</span> to <span class="s1">&#39;go1.10.8&#39;</span>
</code></pre></div><p>你当前系统的 Go 版本就是 1.10.8 了。如果之前安装过，上面的下载过程就没有了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ goup install 1.10.8
INFO<span class="o">[</span>0000<span class="o">]</span> go1.10.8: already downloaded in /Users/xuxinhua/.go/go1.10.8
INFO<span class="o">[</span>0000<span class="o">]</span> Default Go is <span class="nb">set</span> to <span class="s1">&#39;go1.10.8&#39;</span>

$ goup show
go1.10.8
</code></pre></div><p>尽情地享受吧！</p>
<h2 id="4工作原理">4、工作原理</h2>
<p>这个工具的灵感来自 Rust 的工具：<a href="https://rustup.rs/" target="_blank" rel="noopener">rustup</a>
。</p>
<p>它的工作原理很简单，在 <code>$HOME/.go</code> 目录下创建对应的版本目录，然后在这个目录创建一个软链 current 来控制当前使用哪个 Go 版本。这个思路和我一直源码安装的思路类似。唯一区别是，它是从 dl.google.com 上下载对应编译好的版本。但 tip 版本，则需要 clone Go 源码，进行编译安装，因此要求有 Go 环境。</p>
<p>我本地 <code>$HOME/.go</code> 下的文件信息：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">lrwxr-xr-x   <span class="m">1</span> xuxinhua  staff   <span class="m">28</span> <span class="m">10</span>  <span class="m">9</span> 17:16 current -&gt; /Users/xuxinhua/.go/go1.10.8
-rw-r--r--   <span class="m">1</span> xuxinhua  staff   <span class="m">57</span> <span class="m">10</span>  <span class="m">9</span> 16:46 env
drwxr-xr-x  <span class="m">21</span> xuxinhua  staff  <span class="m">672</span> <span class="m">10</span>  <span class="m">9</span> 17:14 go1.10.8
drwxr-xr-x  <span class="m">22</span> xuxinhua  staff  <span class="m">704</span> <span class="m">10</span>  <span class="m">9</span> 10:03 go1.14.9
drwxr-xr-x  <span class="m">22</span> xuxinhua  staff  <span class="m">704</span> <span class="m">10</span>  <span class="m">9</span> 10:02 go1.15.2
drwxr-xr-x   <span class="m">2</span> xuxinhua  staff   <span class="m">64</span> <span class="m">10</span>  <span class="m">9</span> 17:10 gotip
</code></pre></div><h2 id="5存在的一些问题">5、存在的一些问题</h2>
<p>这个工具才出来十几天，试用下来，还存在一些问题：</p>
<ul>
<li>安装最新版本，需要知道当前最新版本是哪个？这是从 <a href="https://golang.org/VERSION?m=text" target="_blank" rel="noopener">https://golang.org/VERSION?m=text</a>
 获取的，但这个网址咱们无法访问；同样的道理，安装 tip 版本，源码是从 <a href="https://go.googlesource.com/go" target="_blank" rel="noopener">https://go.googlesource.com/go</a>
 获取的。因此目前大陆还无法使用；不过我已经给作者提了 issue，应该很快就会支持；</li>
<li>缺失一些功能。比如我想安装某个版本，比如 1.12.x，但我希望安装的是 1.12 系列的最新版本，这时候你只能去找 1.12 的最新版本是哪个。</li>
<li>。。。</li>
</ul>
<p>我参照 gvm 提供的功能，给 goup 作者提了 issue，希望增加如下功能：</p>
<ul>
<li>goup list 和 goup listall</li>
<li>goup uninstall</li>
</ul>
<h2 id="6小结">6、小结</h2>
<p>整体上，目前 goup 的使用还是比较顺畅的。欢迎大家试用，可以顺便给个 star。对了，项目地址：<a href="https://github.com/owenthereal/goup" target="_blank" rel="noopener">https://github.com/owenthereal/goup</a>
。</p>
<p>对了，至于为什么会需要管理多版本，我想很多人还会有这样的需求吧？！你为什么需要呢？欢迎留言。</p>
<h2 id="7更新">7、更新</h2>
<p>上面提到的点，目前差不多解决了。</p>
<ul>
<li>提供了 goup ls-ver 命令列出 Go 版本</li>
<li>提供 goup remove 命令删除某个已安装的 Go 版本</li>
<li>还提供了 goup upgrade 来升级自己</li>
</ul>
<p>此外当执行 goup install 时，默认会安装当前最新发布版本，大陆会有问题，可以通过如下方式解决：</p>
<blockquote>
<p>GOUP_GO_HOST=golang.google.cn goup install</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>题解：竟然半数以上的人做错了，基础真的很重要</title>
			<link>https://polarisxu.studygolang.com/posts/basic/complement/</link>
			<pubDate>Sat, 03 Oct 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/basic/complement/</guid>
			<description>双节发布了两道题： 题一： package main func main() { var a int8 = -1 var b int8 = -128 / a println(b) } 题二： package main func main() { const a int8 = -1 var b int8 = -128 / a println(b) } 答对的人真不多（半数以上答错了），特别是题一，一半以上竟然是 128，难道不知道 int8 能表示的范围吗？[-128, 127]。不过为什么答案是：题一 -128，题二编译错误？ 其实这是一道计算机基础题。 先看看网友 Jayce 的解释：第一题是 -128（untyped const）</description>
			<content type="html"><![CDATA[<p>双节发布了两道题：</p>
<p>题一：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="kt">int8</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="kt">int8</span> <span class="p">=</span> <span class="o">-</span><span class="mi">128</span> <span class="o">/</span> <span class="nx">a</span>

	<span class="nb">println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>题二：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">a</span> <span class="kt">int8</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="kt">int8</span> <span class="p">=</span> <span class="o">-</span><span class="mi">128</span> <span class="o">/</span> <span class="nx">a</span>

	<span class="nb">println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>答对的人真不多（半数以上答错了），特别是题一，一半以上竟然是 128，难道不知道 int8 能表示的范围吗？[-128, 127]。不过为什么答案是：题一 -128，题二编译错误？</p>
<p>其实这是一道计算机基础题。</p>
<p>先看看网友 Jayce 的解释：第一题是 -128（untyped const）/ -1 (int8 var)，untyped 隐式转换为 int8，刚好在范围内，结果是 128 ，溢出 int8 的范围。因为结果不是常量，允许溢出，最高位为符号位，变成了补码，刚好又是 -128。 第二题 -128 和 -1 都是 const，直接在编译时求值，untyped 的 -128 隐式转 int8，结果为 128，仍然是一个 const。const 转换时不允许溢出，编译错误。 其实差别就是表达式的值，题一不是常量题二是，常量类型转换不允许溢出后 truncate。</p>
<h2 id="关于补码">关于补码</h2>
<p>如果你忘了补码（<code>Two's Complement</code>，2 的补码，一般直接称为补码），这里简单做个说明。</p>
<p>先问一个问题：在计算机内部 -1 二进制表示是什么（假如为 int8）？</p>
<p>我们很容易这么想：1 的二进制是 00000001，而最高位是符号位，因此 -1 是 10000001。因为 1 + (-1) = 0，但 00000001 + 10000001 = 10000010，很显然，这个结果不是 0。这是原码表示。</p>
<p><p class="md__image">
  <img src="../imgs/complement01.png"
    alt="原码形式"  />
</p>
</p>
<p>所以，计算机内部采用补码（Two&rsquo;s Complement）表示负数。补码怎么得到呢？一般分两步：</p>
<p><p class="md__image">
  <img src="../imgs/complement02.png"
    alt="-1的补码表示"  />
</p>
</p>
<ul>
<li>
<p>第一步，每一个二进制位都取相反值，0 变成 1，1 变成 0。比如，00000001 的相反值就是 11111110。</p>
</li>
<li>
<p>第二步，将上一步得到的值加 1。11111110 就变成 11111111。</p>
</li>
</ul>
<p><p class="md__image">
  <img src="../imgs/complement03.png"
    alt="补码形式的加法"  />
</p>
</p>
<p>关于原码、反码和补码，可以看这篇文章：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html</a>
，很详细。</p>
<h2 id="题解">题解</h2>
<h3 id="先看题一">先看题一</h3>
<p>因为 <code>var b int8 = -128 / a</code> 不是常量表达式，因此 untyped 常量 -128 隐式转换为 int8 类型（即和 a 的类型一致），所以 <code>-128 / a</code> 的结果是 int8 类型，值是 128，超出了 int8 的范围。因为结果不是常量，允许溢出，128 的二进制表示是 10000000，正好是 -128 的补码。所以，第一题的结果是 -128。</p>
<blockquote>
<p>关于整数溢出的 Go 语言规范说明：<a href="https://hao.studygolang.com/golang_spec.html#id158" target="_blank" rel="noopener">https://hao.studygolang.com/golang_spec.html#id158</a>
。</p>
</blockquote>
<p>在 Go 语言规范中关于整数运算有这样的说明：<a href="https://hao.studygolang.com/golang_spec.html#id327" target="_blank" rel="noopener">https://hao.studygolang.com/golang_spec.html#id327</a>
</p>
<blockquote>
<p>对于两个整数值 x 和 y ，其整数商 q = x / y 和余数 r = x % y 满足如下关系：</p>
<p>x = q*y + r 且 |r| &lt; |y|</p>
<p>这个规则有一个例外，如果对于 x 的整数类型来说，被除数 x 是该类型中最负的那个值，那么，因为 补码 的 整数溢出 ，商 q = x / -1 等于 x （并且 r = 0 ）。</p>
</blockquote>
<p>所以例外情况有：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>x, q 的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>int8</td>
<td>-128</td>
</tr>
<tr>
<td>int16</td>
<td>-32768</td>
</tr>
<tr>
<td>int32</td>
<td>-2147483648</td>
</tr>
<tr>
<td>int64</td>
<td>-9223372036854775808</td>
</tr>
</tbody>
</table>
<h3 id="再看题二">再看题二</h3>
<p>对于 <code>var b int8 = -128 / a</code>，因为 a 是 int8 类型常量，所以 <code>-128 / a</code> 是常量表达式，在编译器计算，结果必然也是常量。因为 a 的类型是 int8，因此 -128 也会隐式转为 int8 类型，128 这个结果超过了 int8 的范围，但常量不允许溢出，因此编译报错。</p>
<h2 id="总结">总结</h2>
<p>这题并非 Go 独有，而是计算机的基础。比如相应的 C 语言程序，结果和 Go 对应程序是一样的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 对应题一
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span> <span class="o">/</span> <span class="n">a</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>结果 -128。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 对应题二
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span> <span class="o">/</span> <span class="n">a</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>编译报错。</p>
]]></content>
		</item>
		
		<item>
			<title>何时使用 Rust 和何时使用 Golang</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/when-to-use-rust-and-when-to-use-golang/</link>
			<pubDate>Wed, 30 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/when-to-use-rust-and-when-to-use-golang/</guid>
			<description>Golang 和 Rust 之间有明显的区别。Golang 更加注重构建可以无限扩展的 Web API 和小型服务，尤其是在 goroutine 的强大支持下。Rust 也可以用于小型服务，但是从开发人员的经验来看，事情要困难得多。 Rust 非常适合处理大量数据和其他 CPU 密集型操作，例如执行算法。这是 Rust 超过 Golang 的最大优势。要求高性能的项目通常更适合 Rust。 在本教程中，我们将就 Golang 和 Rust 进行比较和对比，评估这两种编程语言的性能，并发</description>
			<content type="html"><![CDATA[<p><p class="md__image">
  <img src="../imgs/use-rust-go01.png"
    alt="何时使用Rust和何时使用Golang"  />
</p>
</p>
<p>Golang 和 Rust 之间有明显的区别。Golang 更加注重构建可以无限扩展的 Web API 和小型服务，尤其是在 goroutine 的强大支持下。Rust 也可以用于小型服务，但是从开发人员的经验来看，事情要困难得多。</p>
<p>Rust 非常适合处理大量数据和其他 CPU 密集型操作，例如执行算法。这是 Rust 超过 Golang 的最大优势。要求高性能的项目通常更适合 Rust。</p>
<p>在本教程中，我们将就 Golang 和 Rust 进行比较和对比，评估这两种编程语言的性能，并发性，内存管理和整体开发人员体验。我们还将概述这些元素，以帮助您一目了然地为项目选择正确的语言。</p>
<p>如果您刚开始使用 Rust，那么在继续阅读之前，最好先阅读一下<a href="https://blog.logrocket.com/getting-up-to-speed-with-rust/" target="_blank" rel="noopener">初学者指南</a>
。</p>
<p>如果您全都都准备好了，那就让我们开始吧！</p>
<h2 id="性能">性能</h2>
<p>Golang 最初是由 Google 的工程师设计的，于 2009 年向公众推出。它的创建是为 C++提供替代方案，该替代方案易于学习和编码，并且经过优化可在多核 CPU 上运行。</p>
<p>从那时起，Golang 对于希望利用该语言提供的并发性的开发人员来说非常有用。该语言提供了 goroutine，使您可以将函数作为 goroutine 运行。</p>
<p>Golang 的一大优势是您可以轻松使用 goroutines。只需将<code>go</code>添加到函数前即可使其作为 goroutine 运行。Golang 的并发模型允许您跨多个 CPU 内核部署工作负载，从而使其成为一种非常有效的语言。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">f</span><span class="p">(</span><span class="nx">from</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="nf">f</span><span class="p">(</span><span class="s">&#34;direct&#34;</span><span class="p">)</span>

    <span class="k">go</span> <span class="nf">f</span><span class="p">(</span><span class="s">&#34;goroutine&#34;</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>尽管有多核 CPU 支持，Rust 仍然跑赢 Golang。Rust 在执行算法和资源密集型操作方面效率更高。该<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html" target="_blank" rel="noopener">基准测试游戏</a>
比较了 rust 和 golang 的不同算法，如二叉树。对于所有经过测试的算法，Rust 至少快 30％；在二叉树计算的情况下，最高可达 1,000％。<a href="https://bitbucket.org/blog/why-rust" target="_blank" rel="noopener">Bitbucket 的</a>
一项研究表明，Rust 与 C++的性能相似。</p>
<p><p class="md__image">
  <img src="../imgs/use-rust-go02.png"
    alt="根据Bitbucket的性能"  />
</p>
</p>
<p><em>（来源：<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html" target="_blank" rel="noopener">基准测试游戏</a>
）</em></p>
<h2 id="并发">并发</h2>
<p>如上所述，Golang 支持并发。例如，假设您正在运行一个处理 API 请求的 Web 服务器。您可以使用 Golang 的 goroutine 程序将每个请求作为 goroutine 运行，通过将任务分发到所有可用的 CPU 内核来最大程度地提高效率。</p>
<p>Goroutines 是 Golang 内置功能的一部分，而 Rust 仅支持本地 async/await 语法来支持并发。因此，在并发方面，Golang 的开发人员有经验优势。但是，Rust 在保证内存安全方面要好得多。</p>
<p>这是 Rust 的简化线程的示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">time</span>::<span class="n">Duration</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">   </span><span class="c1">// 1. create a new thread
</span><span class="c1"></span><span class="w">   </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">         </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;thread: number {}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">         </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span><span class="w">
</span><span class="w">      </span><span class="p">}</span><span class="w">
</span><span class="w">   </span><span class="p">});</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;hi from the main thread!&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>并发一直是开发人员的棘手问题。在不影响开发人员体验的情况下保证内存安全的并发性并不是一项容易的任务。但是，这种极端的安全重点导致创建了<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" target="_blank" rel="noopener">可证明正确的并发</a>
。Rust 尝试使用所有权概念来防止未经请求的资源访问，以防止出现内存安全错误。</p>
<p>Rust 提供了四种不同的并发范例，以帮助您避免常见的内存安全陷阱。我们将仔细研究两个常见的范例：channel 和锁。</p>
<h3 id="channel">Channel</h3>
<p><a href="https://doc.rust-lang.org/stable/rust-by-example/std_misc/channels.html" target="_blank" rel="noopener">channel</a>
 有助于从一个线程传送消息到另一个。虽然 Golang 也存在此概念，但 Rust 允许您将<a href="https://doc.rust-lang.org/std/primitive.pointer.html" target="_blank" rel="noopener">指针</a>
从一个线程转移到另一个线程，以避免争用资源。通过传递指针，Rust 可以对 channel 强制执行线程隔离。同样，Rust 在并发模型方面表现出对内存安全的痴迷。</p>
<h3 id="锁">锁</h3>
<p>仅当持有<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html" target="_blank" rel="noopener">锁</a>
时才能访问数据。Rust 依赖于锁定数据而不是 cod 的原理，而 cod 经常在诸如 Java 之类的编程语言中找到。</p>
<p>有关所有权和所有并发范例的更多详细信息，请查看“<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" target="_blank" rel="noopener">使用 Rust 进行无所畏惧的并发</a>
”。</p>
<h2 id="内存安全">内存安全</h2>
<p>较早的所有权概念是 Rust 的主要卖点之一。Rust 将<a href="https://en.wikipedia.org/wiki/Type_safety" target="_blank" rel="noopener">类型安全</a>
提升到了新的水平，这对于实现内存安全的并发性也很重要。</p>
<p>根据<a href="https://bitbucket.org/blog/why-rust" target="_blank" rel="noopener">Bitbucket 博客</a>
，“ Rust 非常严格和繁琐的编译器会检查您使用的每个变量以及您引用的每个内存地址。它避免了可能发生的数据争用情况，并通知您未定义的行为。”</p>
<p>这意味着由于 Rust 对内存安全性的极度痴迷，您最终不会出现缓冲区溢出或争用情况。但是，这也有其缺点。例如，您在编写代码时必须非常了解内存分配原则。始终保持您的内存安全防护并不容易。</p>
<h2 id="开发人员体验">开发人员体验</h2>
<p>首先，让我们看一下每种语言的学习曲线。Golang 在设计时考虑了简单性。开发人员经常将其称为“无聊”语言，也就是说，其有限的内置功能集使 Golang 易于学习、使用。</p>
<p>此外，Golang 提供了比 C++更简单的替代方案，隐藏了诸如内存安全性和内存分配等方面的内容。Rust 采用了另一种方法，迫使您考虑诸如内存安全性的概念。所有权的概念和传递指针的能力使 Rust 失去了学习的吸引力。当您不断考虑内存安全性时，您的工作效率就会降低，并且您的代码注定会变得更加复杂。</p>
<p>与 Golang 相比，Rust 的学习曲线非常陡峭。值得一提的是，与 Python 和 JavaScript 等动态语言相比，Golang 的学习曲线较为陡峭。</p>
<h2 id="何时使用-golang">何时使用 Golang</h2>
<p>Go 在各种用例中都能很好地工作，使其成为创建 Web API 的 Node.js 的绝佳替代品。正如<a href="https://kristoff.it/blog/why-go-and-not-rust/" target="_blank" rel="noopener">Loris Cro</a>
指出的那样，“ Go 的并发模型非常适合必须处理多个独立请求的服务器端应用程序”。这正是 Golang 提供 goroutines 的原因。</p>
<p>此外，Golang 内置了对 HTTP Web 协议的支持。您可以使用内置的 HTTP 支持快速设计一个小型 API，并将其作为微服务运行。因此，Golang 非常适合微服务架构并满足 API 开发人员的需求。</p>
<p>简而言之，如果您重视开发速度并且更喜欢语法简单而不是性能，那么 Golang 是一个很好的选择。最重要的是，Golang 提供了更好的代码可读性，这对于大型开发团队而言是一个重要标准。</p>
<p>在以下情况下选择 Golang：</p>
<ul>
<li>您关心简单性和可读性</li>
<li>您需要一种简单的语法来快速编写代码</li>
<li>您想使用支持 Web 开发的更灵活的语言</li>
</ul>
<h2 id="何时使用-rust">何时使用 Rust</h2>
<p>当性能很重要时，例如在处理大量数据时，Rust 是一个不错的选择。此外，Rust 为您提供了对线程行为以及线程之间资源共享方式的细粒度控制。</p>
<p>另一方面，Rust 具有陡峭的学习曲线，并且由于内存安全性的额外复杂性而减慢了开发速度。这并不一定是不利的。Rust 还保证当编译器检查每个数据指针时，您不会遇到内存安全性错误。对于复杂的系统，此保证会派上用场。</p>
<p>在以下情况下选择 Rust：</p>
<ul>
<li>您关心性能</li>
<li>您想要对线程进行细粒度的控制</li>
<li>您重视内存安全而不是简单性</li>
</ul>
<h2 id="go-vs-rust我的大实话">Go vs. Rust：我的大实话</h2>
<p>让我们从突出相似之处开始。Go 和 Rust 都是开源的，旨在支持微服务架构和并行计算环境。两者都通过并发优化了可用 CPU 内核的利用率。</p>
<p>但归根结底，哪种语言是最好的？</p>
<p>有很多方法可以解决这个问题。我建议考虑要构建哪种类型的应用程序。Golang 可很好地用于创建 Web 应用程序和 API，这些应用程序和 API 利用其内置的并发功能，同时支持微服务体系结构。</p>
<p>您还可以使用 Rust 来开发 Web API，但并不是在设计时考虑到此用例。Rust 对内存安全性的关注增加了复杂性和开发时间，尤其是对于相当简单的 Web API。但是，对代码的大量控制使您可以编写更优化，内存效率更高且性能更高的代码。</p>
<p>简而言之，Golang 与 Rust 的争论实际上是一个简单与安全的问题。</p>
<p>有关更多观点，请查看“<a href="https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/" target="_blank" rel="noopener">在 Go 和 Rust 之间选择</a>
”。</p>
<h2 id="logrocket全面了解线上-rust-应用程序">LogRocket：全面了解线上 Rust 应用程序</h2>
<p>调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能，自动显示错误以及跟踪缓慢的网络请求和加载时间感兴趣，请<a href="https://logrocket.com/signup" target="_blank" rel="noopener">尝试 LogRocket</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/use-rust-go03.png"
    alt="LogRocket仪表板免费试用横幅"  />
</p>
</p>
<p><a href="https://logrocket.com/signup" target="_blank" rel="noopener">LogRocket</a>
就像 Web 应用程序的 DVR，实际上记录了 Rust 应用程序中发生的所有事情。您可以汇总并报告问题发生时应用程序所处的状态，而不用猜测为什么会发生问题。LogRocket 还监视您的应用程序的性能，报告诸如客户端 CPU 负载，客户端内存使用情况等指标。</p>
<blockquote>
<p>原文链接：https://blog.logrocket.com/when-to-use-rust-and-when-to-use-golang/</p>
<p>原文作者：Michiel Mulders</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>15 张图带你深入理解浮点数</title>
			<link>https://polarisxu.studygolang.com/posts/basic/diagram-float-point/</link>
			<pubDate>Tue, 29 Sep 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/basic/diagram-float-point/</guid>
			<description>大家好，我是站长 polarisxu。 团队一直保持着分享的习惯，而我却分享的较少。忘了当时同事分享什么主题，涉及到浮点数相关知识。于是我决定分享一期关于浮点数的，而且 Go 之父 Rob Pike 说不懂浮点数不配当码农。。。So？！ 本着「要学习就系统透彻的学」这个原则，本文通过图的方式尽可能详细的讲解浮点数，让大家能够对浮点数有一个更深层次的认识。 本文目录： 0、几个问题 开始之前请</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>团队一直保持着分享的习惯，而我却分享的较少。忘了当时同事分享什么主题，涉及到浮点数相关知识。于是我决定分享一期关于浮点数的，而且 Go 之父 Rob Pike 说不懂浮点数不配当码农。。。So？！</p>
<p><p class="md__image">
  <img src="../imgs/float-point01.png"
    alt=""  />
</p>
</p>
<p>本着「要学习就系统透彻的学」这个原则，本文通过图的方式尽可能详细的讲解浮点数，让大家能够对浮点数有一个更深层次的认识。</p>
<p>本文目录：</p>
<p><p class="md__image">
  <img src="../imgs/float-point-content.png"
    alt=""  />
</p>
</p>
<h2 id="0几个问题">0、几个问题</h2>
<p>开始之前请思考如下问题：</p>
<ul>
<li>二进制 0.1，用十进制表示的话是多少？十进制的 0.1，用二进制表示又是多少？</li>
<li>为什么 0.1 + 0.2 = 0.30000000000000004？</li>
<li>单精度和双精度浮点数的有效小数位分别是多少？</li>
<li>单精度浮点数能表示的范围是什么？</li>
<li>浮点数为什么会存在 -0？infinity 和 NaN 又是怎么表示的？</li>
</ul>
<p>如果现在不会，那这篇文章正好可以为你解惑。</p>
<h2 id="1什么是浮点数">1、什么是浮点数</h2>
<p>我们知道，数学中并没有浮点数的概念，虽然小数看起来像浮点数，但从不这么叫。那为什么计算机中不叫小数而叫浮点数呢？</p>
<p>因为资源的限制，数学中的小数无法直接在计算机中准确表示。为了更好地表示它，计算机科学家们发明了浮点数，这是对小数的近似表示。维基百科中关于<a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" target="_blank" rel="noopener">浮点数</a>
的概念说明如下：</p>
<blockquote>
<p>The term floating point refers to the fact that a number&rsquo;s radix point (decimal point, or, more commonly in computers, binary point) can float; that is, it can be placed anywhere relative to the significant digits of the number.</p>
</blockquote>
<p>也就是说浮点数是相对于定点数而言的，表示小数点位置是浮动的。比如 7.5 × 10、0.75 × 10² 等表示法，值一样，但小数点位置不一样。</p>
<p>具体来说，浮点数是指用符号、尾数、基数和指数这四部分来表示的小数。</p>
<p><p class="md__image">
  <img src="../imgs/float-point02.png"
    alt=""  />
</p>
</p>
<h2 id="2ieee754-又是什么">2、IEEE754 又是什么</h2>
<p>知道了浮点数的概念，但需要确定一套具体的表示、运算标准。其中最有名的就是 <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE754 标准</a>
。William Kahan 正是因为浮点数标准化的工作获得了图灵奖。</p>
<blockquote>
<p>The <strong>IEEE Standard for Floating-Point Arithmetic</strong> (<strong>IEEE 754</strong>) is a <a href="https://en.wikipedia.org/wiki/Technical_standard" target="_blank" rel="noopener">technical standard</a>
 for <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" target="_blank" rel="noopener">floating-point arithmetic</a>
 established in 1985 by the <a href="https://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers" target="_blank" rel="noopener">Institute of Electrical and Electronics Engineers</a>
 (IEEE). The standard <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#IEEE_754_design_rationale" target="_blank" rel="noopener">addressed many problems</a>
 found in the diverse floating-point implementations that made them difficult to use reliably and <a href="https://en.wikipedia.org/wiki/Software_portability" target="_blank" rel="noopener">portably</a>
. Many hardware <a href="https://en.wikipedia.org/wiki/Floating-point_unit" target="_blank" rel="noopener">floating-point units</a>
 use the IEEE 754 standard.</p>
</blockquote>
<p>本文的讨论都基于 IEEE754 标准，这也是目前各大编程语言和硬件使用的标准。</p>
<p>根据上面浮点数的组成，因为是在计算机中表示浮点数，基数自然是 2，因此 IEEE754 浮点数只关注符号、尾数和指数三部分。</p>
<h2 id="3小数的二进制和十进制转换">3、小数的二进制和十进制转换</h2>
<p>为了方便后面的内容顺利进行，复习下二进制和十进制的转换，其中主要涉及到小数的转换。</p>
<h3 id="二进制转十进制">二进制转十进制</h3>
<p>和整数转换一样，采用各位数值和位权相乘。比如：</p>
<p>(0.101)₂ = 1×2⁻¹ + 0×2⁻² + 0×2⁻³ = (0.625)₁₀</p>
<p>记住小数点后第一位是从 -1 开始即可。</p>
<h3 id="十进制转二进制">十进制转二进制</h3>
<p>十进制整数转二进制采用“除 2 取余，逆序排列”法。例如十进制数 11 转为二进制：</p>
<pre tabindex="0"><code>11/2=5 … 余1
5/2=2  … 余1
2/2=1  … 余0
1/2=0  … 余1
</code></pre><p>所以 (11)₁₀ 的二进制是 (1011)₂。</p>
<p>但如果十进制是小数，转为二进制小数如何做？采用“乘 2 取整，顺序排列”。例如十进制小数 0.625 转为二进制小数：</p>
<pre tabindex="0"><code>0.625*2=1.25 … 取整数部分1
0.25*2=0.5 	 … 取整数部分0
0.5*2=1			 … 取整数部分1
</code></pre><p>顺序排列，所以 (0.625)₁₀ = (0.101)₂。</p>
<p>为了方便大家快速的做转换，网上有很多这样的工具。推荐一个我觉得最棒的：<a href="https://baseconvert.com/" target="_blank" rel="noopener">https://baseconvert.com/</a>
，支持各进制的转换，还支持浮点数。</p>
<h2 id="4经典问题01--02--030000000000000004">4、经典问题：0.1 + 0.2 = 0.30000000000000004</h2>
<p>这个问题网上相关的讨论很多，甚至有专门的一个网站：<a href="https://0.30000000000000004.com/" target="_blank" rel="noopener">https://0.30000000000000004.com/</a>
，这个网站上有各门语言的 0.1 + 0.2 的结果。比如 C 语言：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%.17f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mf">.1</span> <span class="o">+</span> <span class="mf">.2</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Go 语言：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果都是 0.30000000000000004。</p>
<p>为什么会这样？这要回到 IEEE754 标准关于浮点数的规定。</p>
<h2 id="5浮点数的-ieee754-表示">5、浮点数的 IEEE754 表示</h2>
<p>上文提到，浮点数由四个部分构成，那 IEEE754 标准是如何规定它们的存储方式的呢？</p>
<p>一般地，IEEE754 浮点数有两种类型：单精度浮点数（float）和双精度浮点数（double），还有其他的，不常用。单精度浮点数使用 4 字节表示；双精度浮点数使用 8 字节表示。在 Go 语言中用 float32 和 float64 表示这两种类型。</p>
<p><p class="md__image">
  <img src="../imgs/float-point03.png"
    alt=""  />
</p>
</p>
<p>符号位不用说，0 表示正数，1 表示负数。着重看指数部分和尾数部分。（基数前文说了，固定是 2，因此不存）</p>
<h3 id="尾数部分">尾数部分</h3>
<p>前面提到过，浮点数名称的由来在于小数点是浮动的。但具体存储时，需要固定一种形式，这叫做尾数的标准化。IEEE754 规定，在二进制数中，通过移位，将小数点前面的值固定为 1。IEEE754 称这种形式的浮点数为规范化浮点数（normal number）。</p>
<p>比如十进制数 0.15625，转为二进制是 0.00101。为了让第 1 位为 1，执行逻辑右移 3 位，尾数部分成为 1.01，因为右移了 3 位，所以指数部分是 -3。因为规定第 1 位永远为 1，因此可以省略不存，这样尾数部分多了 1 位，只需存 0100（要记住，这是的数字是小数点后的数字，因此实际是 0.01，转为十进制是 0.25 — 没算未存的小数点前面的 1）。</p>
<p>因此对于规范化浮点数，尾数其实比实际的多 1 位，也就是说单精度的是 24 位，双精度是 53 位。为了作区分，IEEE754 称这种尾数为 significand。</p>
<blockquote>
<p>有规范化浮点数，自然会有<strong>非规范化浮点数</strong>（denormal number），这会在后文讲解。</p>
</blockquote>
<p>请牢记，尾数决定了精度，对于单精度浮点数，因为只有 23 位，而 <code>1&lt;&lt;23</code> 对应十进制是 8388608，因此不能完整表示全部的 7 个十进制位，所以说，单精度浮点数<strong>有效小数位</strong>最多 7 位；双精度的<strong>有效小数位</strong>是 15 位；切记切记，有精度问题！！</p>
<h3 id="指数部分">指数部分</h3>
<p>因为指数有正、有负，为了避免使用符号位，同时方便比较、排序，指数部分采用了 <strong>The Biased exponent</strong>（有偏指数）。IEEE754 规定，2ᵉ⁻¹-1 的值是 0，其中 e 表示指数部分的位数，小于这个值表示负数，大于这个值表示正数。因此，对于单精度浮点数而言， 2⁸⁻¹-1 = 127 是 0；双精度浮点数，2¹¹⁻¹-1 = 1023 是 0。</p>
<p>没看懂？举个栗子。</p>
<p>还是用十进制 0.15625 举例。上文知道，因为右移了 3 位，所以指数是 -3。根据 IEEE754 的定义，单精度浮点数情况下，-3 的实际值是 127 - 3 = 124。明白了吗？127 表示 0，124 就表示 -3 了。而十进制的 124 转为二进制就是 1111100。</p>
<p>如果你还不理解，想想这个问题。</p>
<blockquote>
<p>如果让你用扑克牌（A ~ K，也就是 1 ~ 13）来表示支持负数的。怎么办？我们会选择一个中间的数，比如 7 当做 0，因此 10 就是 +3，4 就是 -3。现在理解了吧！</p>
</blockquote>
<h3 id="小结">小结</h3>
<p>结合尾数和指数的规定，IEEE754 单精度浮点数，十进制 0.15625 对应的二进制内存表示是：0 01111100 01000000000000000000000。</p>
<h2 id="6程序确认下-ieee754-的如上规定">6、程序确认下 IEEE754 的如上规定</h2>
<p>读到这里，希望你能坚持下去。为了进一步加深理解，我画一张图和一个确认程序。</p>
<h3 id="一张图">一张图</h3>
<p><p class="md__image">
  <img src="../imgs/float-point04.png"
    alt=""  />
</p>
</p>
<p>这张图是单精度浮点数 0.15625 的内存存储表示。根据三部分的二进制表示，可以反推出计算该数的十进制表示。作为练习，十进制的 2.75，用上图表示的话，各个位置分别都是什么值呢？</p>
<h3 id="程序确认单精度浮点数的内存表示">程序确认单精度浮点数的内存表示</h3>
<p>使用 Go 语言编写一个程序，能够得到一个单精度浮点数的二进制内存表示。比如提供单精度浮点数 0.15625，该程序能够输出：0-01111100-01000000000000000000000。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">f</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">0.15625</span>
	<span class="nf">outputFEEE754</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">outputFEEE754</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float32</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 将该浮点数内存布局当做 uint32 看待（因为都占用 4 字节）
</span><span class="c1"></span>	<span class="c1">// 这里实际上是做强制转换，内部实现是：return *(*uint32)(unsafe.Pointer(&amp;f))
</span><span class="c1"></span>	<span class="nx">buf</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Float32bits</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

	<span class="c1">// 加上两处 -，结果一共 34 byte
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[</span><span class="mi">34</span><span class="p">]</span><span class="kt">byte</span>

	<span class="c1">// 从低字节开始
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">33</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">{</span>
			<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;-&#39;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">buf</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;1&#39;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;0&#39;</span>
			<span class="p">}</span>
			<span class="nx">buf</span> <span class="o">/=</span> <span class="mi">2</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// output: 0-01111100-01000000000000000000000
</span></code></pre></div><p>你可以使用上述程序，验证下 2.75，看看你做对没有！提供了一个在线可运行版本：<a href="https://play.studygolang.com/p/pg0QNQtBHYx" target="_blank" rel="noopener">https://play.studygolang.com/p/pg0QNQtBHYx</a>
。</p>
<p>其实上面推荐的那个工具就能够得到十进制浮点数的二进制内存表示，地址：<a href="https://baseconvert.com/ieee-754-floating-point" target="_blank" rel="noopener">https://baseconvert.com/ieee-754-floating-point</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/float-point05.png"
    alt=""  />
</p>
</p>
<p>另外，在 Java 语言中也有类似的方法：Float.floatToIntBits()，你可以使用 Java 实现上面类似的功能。</p>
<h2 id="6再看-0102--030000000000000004">6、再看 0.1+0.2 = 0.30000000000000004</h2>
<p>有了上面的知识，我们回过头看看这个经典的问题。（讨论单精度的情况，因此实际是 0.1+0.2 = 0.300000004）</p>
<h3 id="出错的原因">出错的原因</h3>
<p>出现这种情况的根本原因是，有些十进制小数无法转换为二进制数。如下图：</p>
<p><p class="md__image">
  <img src="../imgs/float-point06.png"
    alt=""  />
</p>
</p>
<p>在小数点后 4 位时，连续的二进制数，对应的十进制数却是不连续的，因此只能增加位数来尽可能近似的表示。</p>
<h3 id="01-和-02-是如何表示的">0.1 和 0.2 是如何表示的？</h3>
<p>根据前面的讲解，十进制 0.1 转为二进制小数，得到的是 0.0001100… （重复1100）这样一个循环二进制小数，使用 IEEE754 表示如下图：</p>
<p><p class="md__image">
  <img src="../imgs/float-point07.png"
    alt=""  />
</p>
</p>
<p>同样的方法，0.2 用单精度浮点数表示是：0.20000000298023223876953125。所以，0.1 + 0.2 的结果是：0.300000004470348358154296875。</p>
<p><p class="md__image">
  <img src="../imgs/float-point08.png"
    alt=""  />
</p>
</p>
<h2 id="7特殊值">7、特殊值</h2>
<p>耐心的读者看到这里，你真的很棒！但还没完哦，继续加油！</p>
<h3 id="单精度浮点数的最大值">单精度浮点数的最大值</h3>
<p>讲解下一个知识点之前，请思考本文开始的一个问题：<strong>单精度浮点数的最大值是多少？</strong></p>
<p>根据前面学到的知识，我们很容易想到它的最大值的内存应该表示是这样的。</p>
<p><p class="md__image">
  <img src="../imgs/float-point09.png"
    alt=""  />
</p>
</p>
<p>即：01111111111111111111111111111111。然而我们把这个值填入 <a href="https://baseconvert.com/ieee-754-floating-point" target="_blank" rel="noopener">https://baseconvert.com/ieee-754-floating-point</a>
 中，发现结果是这样的：</p>
<p><p class="md__image">
  <img src="../imgs/float-point10.png"
    alt=""  />
</p>
</p>
<p>什么？NaN 是个什么鬼？！我就是按照你上面讲过的思考的。。。</p>
<p>别急，因为凡是都有特殊。现在就讲讲浮点数中的特殊值。</p>
<h3 id="特殊值-infinity无穷">特殊值 infinity（无穷）</h3>
<p>当指数位全是 1，尾数位全是 0 时，这样的浮点数表示无穷。根据符号位，有正无穷和负无穷（+infinity 和 -infinity）。为什么需要无穷？因为计算机资源的限制，没法表示所有的数，当一个数超过了浮点数的表示范围时，就可以用 infinity 来表示。而数学中也有无穷的概念。</p>
<p>在 Go 语言中，通过 math 包的 func Inf(sign int) float64 函数可以获取到正负无穷。</p>
<p>在 Java 语言中，通过 Float 或 Double 类中的常量可以获得：Float.POSITIVE_INFINITY、Float.NEGATIVE_INFINITY。</p>
<p>具体表示可以定义一个常量，比如：</p>
<blockquote>
<p>正无穷：0x7FF0000000000000，负无穷：0xFFF0000000000000</p>
</blockquote>
<p>和上面浮点数内存位模型强转 int 类似，这个执行相反操作（类似 Float64frombits 这样的函数），就得到了这个特殊的浮点值。可以看 Go 语言 math 标准库相应函数的实现。</p>
<h3 id="特殊值-nan">特殊值 NaN</h3>
<p>NaN 是 not-a-number 的缩写，即不是一个数。为什么需要它？例如，当对 -1 进行开根号时，浮点数不知道如何进行计算，就会使用 NaN，表示不是一个数。</p>
<p>NaN 的具体内存表示是：指数位全是 1，尾数位不全是 0。</p>
<p>和 infinity 类似，Go 和 Java 都定义了相应的函数或常量。</p>
<h3 id="小结-1">小结</h3>
<p>现在清楚上面单精度浮点数最大值是不对的了吧，它是一个 NaN。画一张图，方便你更清晰的记住这些特殊值。</p>
<p><p class="md__image">
  <img src="../imgs/float-point11.png"
    alt=""  />
</p>
</p>
<p>所以单精度浮点数的最大值应该能确认了，即：0 11111110 11111111111111111111111。</p>
<p><p class="md__image">
  <img src="../imgs/float-point12.png"
    alt=""  />
</p>
</p>
<h2 id="8非规范化浮点数">8、非规范化浮点数</h2>
<p>接着用问题的方式继续：单精度浮点数的最小值是多少（正数）？</p>
<p>根据前面的知识，我们会得到这样的最小值：0 00000000 00000000000000000000001。根据前面规范化浮点数的规定，我们知晓该值是：2⁻¹²⁷×(1+2⁻²³)。</p>
<p>然而，最小值的内存表示没错，但算出来的结果是错的。（额头冒汗没？怎么又错了~）</p>
<p>为了避免两个小浮点数相减结果是 0（也就是规范化浮点数无法表示）这样情况出现，同时根据规范化浮点数的定义，因为尾数部分有一个省略的前导 1，因此无法表示 0。所以，IEEE754 规定了另外一种浮点数：</p>
<blockquote>
<p>当指数位全是 0，尾数部分不全为 0，尾数部分没有省略的前导 1，同时指数部分的偏移值比规范形式的偏移值小 1，即单精度是 -126，双精度是 -2046。这种形式的浮点数叫非规范化浮点数（denormal number）。</p>
</blockquote>
<p>因此单精度浮点数的最小值（正数）如下图：</p>
<p><p class="md__image">
  <img src="../imgs/float-point13.png"
    alt=""  />
</p>
</p>
<p>有了非规范化浮点数，IEEE754 就可以表示 0 了，但会存在 +0 和 -0：即所有位全是 0 时是 +0；符号位是 1，其他位是 0 时是 -0。</p>
<h2 id="9ieee754-浮点数分类小结">9、IEEE754 浮点数分类小结</h2>
<p>至此，浮点数相关的知识就介绍差不多了。为了让大家对整体再有一个更好的掌握，对浮点数的分类进行一些总结。</p>
<p>从上面的讲解，IEEE754 浮点数，指数是关键，根据指数，将其分为：特殊值、非规范化浮点数和规范化浮点数。</p>
<p><p class="md__image">
  <img src="../imgs/float-point14.png"
    alt=""  />
</p>
</p>
<p>从上图规范化和非规范化浮点数的表示范围可以看出，两种类型的表示是具有连续性的。这也就是为什么非规范化浮点数指数规定为比规范形式的偏移值小 1（即单精度为 -126，双精度为 -2046）。</p>
<p>在数轴上，浮点数的分布：</p>
<p><p class="md__image">
  <img src="../imgs/float-point15.png"
    alt=""  />
</p>
</p>
<h2 id="10总结">10、总结</h2>
<p>《深入理解计算机系统》这本书在讲解浮点数时说：许多程序员认为浮点数没意思，往坏了说，深奥难懂。经过本文的四千多字图文并茂的方式讲解，如果你认真看完了，我相信你一定掌握了浮点数。</p>
<p>此外，还有其他一些知识点，比如浮点数的运算、不满足结合律、四舍但五不一定入等，有兴趣的可以查阅相关资料。</p>
<p>现在是时候回过头来看看开始的题目了，你都会了吗？</p>
<p>最后，建议你结合你熟悉的语言更进一步补充相关知识。比如 Go 语言的 math 标准库；Java 的 java.lang.Float/Double 等包。</p>
<h2 id="参考资料或相关链接">参考资料或相关链接</h2>
<ul>
<li><a href="https://floating-point-gui.de/" target="_blank" rel="noopener">https://floating-point-gui.de/</a>
</li>
<li><a href="https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/</a>
</li>
<li><a href="https://baseconvert.com/" target="_blank" rel="noopener">https://baseconvert.com/</a>
</li>
<li>这个交互式工具，很不错：http://evanw.github.io/float-toy/</li>
<li><a href="https://bartaz.github.io/ieee754-visualization/" target="_blank" rel="noopener">https://bartaz.github.io/ieee754-visualization/</a>
</li>
<li>柴大：https://mp.weixin.qq.com/s/0lCte3UD5qYcaBnebwnYrQ</li>
<li>左神：https://mp.weixin.qq.com/s/QsEe34pcimNdqCb99h44cQ</li>
<li>图书《程序是怎样跑起来的》</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>这么一道“简单”的题，为什么结果出乎我的意料</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/</link>
			<pubDate>Sun, 27 Sep 2020 14:52:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/</guid>
			<description>今天在《Go语言爱好者周刊：第62期》 中贴了一道 Go101 的题，原题如下： package main const s = &amp;#34;Go101.org&amp;#34; // len(s) == 9 // 1 &amp;lt;&amp;lt; 9 == 512 // 512 / 128 == 4 var a byte = 1 &amp;lt;&amp;lt; len(s) / 128 var b byte = 1 &amp;lt;&amp;lt; len(s[:]) / 128 func main() { println(a, b) } 答案是 4 0。 不少人对这个结果应该很吃惊，因为从答题结果看，不到一半的人答对了。而且，如果只给 var b byte = 1 &amp;lt;&amp;lt; len(s[:]) / 128，没有 a 对比，我想答对的人会更少。因为有对比，很多人虽然直觉是 4 4，但想到一定有陷阱，所</description>
			<content type="html"><![CDATA[<p>今天在<a href="https://mp.weixin.qq.com/s/xvlAcDBqb77HUzTo7gjuCw" target="_blank" rel="noopener">《Go语言爱好者周刊：第62期》</a>
中贴了一道 Go101 的题，原题如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">const</span> <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;Go101.org&#34;</span>
<span class="c1">// len(s) == 9
</span><span class="c1">// 1 &lt;&lt; 9 == 512
</span><span class="c1">// 512 / 128 == 4
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>答案是 4 0。</p>
<p>不少人对这个结果应该很吃惊，因为从答题结果看，不到一半的人答对了。而且，如果只给 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，没有 a 对比，我想答对的人会更少。因为有对比，很多人虽然直觉是 4 4，但想到一定有陷阱，所以会重新思考。</p>
<p>好几个群都问，为什么结果会是 4 0，希望我解释下。因此有了此文。</p>
<p>这个小题涉及到几个知识点。</p>
<h2 id="len-函数的结果">len 函数的结果</h2>
<p>要注意，len 是一个内置函数。在官方标准库文档<a href="https://docs.studygolang.com/pkg/builtin/#len" target="_blank" rel="noopener">关于 len 函数</a>
有这么一句：</p>
<blockquote>
<p>For some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification&rsquo;s &ldquo;Length and capacity&rdquo; section for details.</p>
</blockquote>
<p>明确支持，当参数是字符串字面量和简单 array 表达式，len 函数返回值是常量，这很重要。</p>
<p>上题中，如果 <code>const s = &quot;Go101.org”</code> 改为 <code>var s = &quot;Go101.org&quot;</code> 结果又会是什么呢？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;Go101.org&#34;</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果是 0 0。</p>
<p>但改为这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;G&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="sc">&#39;g&#39;</span><span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果又是 4 0。</p>
<p>接着看文档那句话的后半句，查看 Go 语言规范中<a href="https://hao.studygolang.com/golang_spec.html#id221" target="_blank" rel="noopener">关于长度和容量的说明</a>
。</p>
<blockquote>
<p>内置函数 len 和 cap 获取各种类型的实参并返回一个 int 类型结果。实现会保证结果总是一个 int 值。</p>
<p>如果 s 是一个字符串常量，那么 len(s) 是一个常量 。如果 s 类型是一个数组或到数组的指针且表达式 s 不包含 信道接收 或（非常量的） 函数调用的话， 那么表达式 len(s) 和 cap(s) 是常量；这种情况下， s 是不求值的。否则的话， len 和 cap 的调用结果不是常量且 s 会被求值。</p>
</blockquote>
<p>可见题目中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>
</code></pre></div><p>第一句的 len(s) 是常量（因为 s 是字符串常量）；而第二句的 len(s[:]) 不是常量。这是这两条语句的唯一区别：两个 len 的返回结果数值并无差异，都是 9，但一个是常量一个不是。</p>
<h2 id="关于位移操作">关于位移操作</h2>
<p>根据上面的分析，现在问题的关键在于位移运算这里。Go 语言规范中有<a href="https://docs.studygolang.com/ref/spec#Operators" target="_blank" rel="noopener">这么一句</a>
：</p>
<blockquote>
<p>The right operand in a shift expression must have integer type or be an untyped constant representable by a value of type uint. If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.</p>
</blockquote>
<p>大意是：在位移表达式的右侧的操作数必须为整数类型，或者可以被 uint 类型的值所表示的无类型的常量。如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型。</p>
<p>这里的关键在于常量位移表达式。根据上文的分析，<code>1 &lt;&lt; len(s)</code> 是常量位移表达式，而 <code>1 &lt;&lt; len(s[:])</code> 不是。</p>
<p>规范上关于常量表达式中，还有<a href="https://docs.studygolang.com/ref/spec#Constant_expressions" target="_blank" rel="noopener">这么一句</a>
：</p>
<blockquote>
<p>If the left operand of a constant shift expression is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of integer type.</p>
</blockquote>
<p>大意是：如果常量 位移表达式 的左侧操作数是一个无类型常量，那么其结果是一个整数常量；否则就是和左侧操作数同一类型的常量（必须是 整数类型 ）</p>
<p>因此对于 <code>var a byte = 1 &lt;&lt; len(s) / 128</code>，因为 <code>1 &lt;&lt; len(s)</code> 是一个常量位移表达式，因此它的结果也是一个整数常量，所以是 512，最后除以 128，最终结果就是 4。</p>
<p>而对于 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，因为 <code>1 &lt;&lt; len(s[:])</code> 不是一个常量位移表达式，而做操作数是 1，一个无类型常量，根据规范定义它是 byte 类型（根据：如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型）。</p>
<p>为什么是 byte 类型，大家可能还是有点晕。这要回到关于常量的说明上。</p>
<h3 id="常量">常量</h3>
<p>常量是在编译的时候进行计算的。在 Go 语言中，常量分两种：无类型和有类型。Go 规范上说，字面值常量， true , false , iota 以及一些仅包含无类型的恒定操作数的 常量表达式 是无类型的。</p>
<p>那有类型常量是怎么来的呢？一般有两种：显示声明或隐式得到。比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">a</span> <span class="kt">int32</span> <span class="p">=</span> <span class="mi">23</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">0.1</span>
</code></pre></div><p>无类型常量都有一个默认类型（无类型常量的默认类型分别是 bool , rune , int , float64 , complex128 或 string）。当在上下文中需要请求该常量为一个带类型的值时，这个 默认类型 便指向该常量隐式转换后的类型。</p>
<p>所以 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code> 中，根据规范定义，1 会隐式转换为 byte 类型，因此 <code>1 &lt;&lt; len(s[:])</code> 的结果也是 byte 类型，而 byte 类型最大只能表示 255，很显然 512 溢出了，结果为 0，因此最后 b 的结果也是 0。</p>
<h2 id="小结">小结</h2>
<p>一道很具迷惑性的题目引出这么多小知识点。可能有人要喷：讨论这些有什么用？这也太细节了。我想说的是，Go 语言规范，细节点很多，能多掌握一些没坏处，说不定将来实际工作就遇到了类似的问题呢？！以上的知识点，很细节，但我认为也是挺有价值的。</p>
<p>当然了，你怎么说都行，你都是对的，你开心就好！</p>
]]></content>
		</item>
		
		<item>
			<title>如何在调试过程中查找 Goroutine</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/how-to-find-goroutines-during-debugging/</link>
			<pubDate>Fri, 18 Sep 2020 18:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/how-to-find-goroutines-during-debugging/</guid>
			<description>Goroutines 是大多数用 Go 编写的程序的重要组成部分。但是，使用大量 goroutines 会使程序难以调试。那怎么办？在此博文中，我们将介绍如何使用自定义数据为 goroutine 加上标签，这是 GoLand 2020.1（现已包含在 EAP 中）的最新功能之一。 目录 在 IDE 下使用 在命令行下使用 性能影响 使用自定义库启用调试标签 让我们以向 Web 服务器发出请求的应用程序为例： package main import ( &amp;#34;io&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;time&amp;#34; ) func fakeTraffic() { // Wait for the server to start time.Sleep(1 * time.Second) pages := []string{&amp;#34;/&amp;#34;, &amp;#34;/login&amp;#34;, &amp;#34;/logout&amp;#34;, &amp;#34;/products&amp;#34;, &amp;#34;/product/{productID}&amp;#34;, &amp;#34;/basket&amp;#34;, &amp;#34;/about&amp;#34;}</description>
			<content type="html"><![CDATA[<p>Goroutines 是大多数用 Go 编写的程序的重要组成部分。但是，使用大量 goroutines 会使程序难以调试。那怎么办？在此博文中，我们将介绍如何使用自定义数据为 goroutine 加上标签，这是 GoLand 2020.1（现已包含在 <a href="https://blog.jetbrains.com/go/tag/2020-1/" target="_blank" rel="noopener">EAP</a>
 中）的最新功能之一。</p>
<h2 id="目录">目录</h2>
<ul>
<li>在 IDE 下使用</li>
<li>在命令行下使用</li>
<li>性能影响</li>
<li>使用自定义库启用调试标签</li>
</ul>
<p>让我们以向 Web 服务器发出请求的应用程序为例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
 
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;io&#34;</span>
    <span class="s">&#34;io/ioutil&#34;</span>
    <span class="s">&#34;math/rand&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
    <span class="s">&#34;strconv&#34;</span>
    <span class="s">&#34;strings&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>
 
<span class="kd">func</span> <span class="nf">fakeTraffic</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Wait for the server to start
</span><span class="c1"></span>    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
 
    <span class="nx">pages</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="s">&#34;/login&#34;</span><span class="p">,</span> <span class="s">&#34;/logout&#34;</span><span class="p">,</span> <span class="s">&#34;/products&#34;</span><span class="p">,</span> <span class="s">&#34;/product/{productID}&#34;</span><span class="p">,</span> <span class="s">&#34;/basket&#34;</span><span class="p">,</span> <span class="s">&#34;/about&#34;</span><span class="p">}</span>
 
    <span class="nx">activeConns</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">10</span><span class="p">)</span>
 
    <span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{</span>
        <span class="nx">Timeout</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
    <span class="p">}</span>
 
    <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
 
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">activeConns</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
        <span class="nx">i</span><span class="o">++</span>
 
        <span class="nx">page</span> <span class="o">:=</span> <span class="nx">pages</span><span class="p">[</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">pages</span><span class="p">))]</span>
 
        <span class="c1">// We need to launch this using a closure function to
</span><span class="c1"></span>        <span class="c1">// ensure that we capture the correct value for the
</span><span class="c1"></span>        <span class="c1">// two parameters we need: page and i
</span><span class="c1"></span>        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rid</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">makeRequest</span><span class="p">(</span><span class="nx">activeConns</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">rid</span><span class="p">)</span>
        <span class="p">}(</span><span class="nx">page</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">makeRequest</span><span class="p">(</span><span class="nx">done</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">page</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Unblock the next request from the queue
</span><span class="c1"></span>        <span class="o">&lt;-</span><span class="nx">done</span>
    <span class="p">}()</span>
 
    <span class="nx">page</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="nx">page</span><span class="p">,</span> <span class="s">&#34;{productID}&#34;</span><span class="p">,</span> <span class="s">&#34;abc-&#34;</span><span class="o">+</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="p">)),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span> <span class="s">&#34;http://localhost:8080&#34;</span><span class="o">+</span><span class="nx">page</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
 
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
 
    <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
 
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span> <span class="o">+</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="在-ide-下使用">在 IDE 下使用</h2>
<p>如果我们在调试器（debugger）中分析此代码，我们如何知道 makeRequest goroutines 在做什么？当我们看这样的清单时，这些 goroutine 的执行上下文什么？</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/03/debugger-classic-without-labels-optimized.png"
    alt="debugger without labels"  />
</p>
</p>
<p>这就是 GoLand 新版本支持读取 goroutines 标签的缘由。</p>
<p>我们调整下上面的代码：（polaris 注：pprof 是标准库的 runtime/pprof ）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rid</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">labels</span> <span class="o">:=</span> <span class="nx">pprof</span><span class="p">.</span><span class="nf">Labels</span><span class="p">(</span><span class="s">&#34;request&#34;</span><span class="p">,</span> <span class="s">&#34;automated&#34;</span><span class="p">,</span> <span class="s">&#34;page&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="s">&#34;rid&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">rid</span><span class="p">)))</span>
    <span class="nx">pprof</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">labels</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">makeRequest</span><span class="p">(</span><span class="nx">activeConns</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">rid</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}(</span><span class="nx">page</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</code></pre></div><p>现在，当在调试器中运行相同的代码时，我们将看到以下视图：</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/03/debugger-classic-with-labels-optimized.png"
    alt="debugger with labels"  />
</p>
</p>
<p>看起来好多了。现在，我们可以看到在标签中设置的所有信息。而且，最重要的是，我们还可以看到通过函数调用在后台启动的其他 goroutine，它们都会自动携带标签。</p>
<p>由于 HTTP HandleFunc 这种形式的处理程序非常受欢迎，并且可以与其他处理程序类型进行比较，因此让我们看一下如何调整下面的代码以设置标签。</p>
<p>我们的原始代码将 m 用作 <code>*http.ServeMux</code>（或 <code>*github.com/gorilla/mux.Router</code>），看起来像这样：<code>m.HandleFunc(&quot;/&quot;, homeHandler)</code>。</p>
<p>应用标签代码后，它将变为如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">labels</span> <span class="o">:=</span> <span class="nx">pprof</span><span class="p">.</span><span class="nf">Labels</span><span class="p">(</span><span class="s">&#34;path&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">,</span> <span class="s">&#34;request&#34;</span><span class="p">,</span> <span class="s">&#34;real&#34;</span><span class="p">)</span>
    <span class="nx">pprof</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">labels</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">homeHandler</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">})</span>
</code></pre></div><p>这将标记处理每个 HTTP 请求的 goroutine，如下所示。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/03/debugger-http-with-labels-optimized.png"
    alt="debugging http middleware with labels"  />
</p>
</p>
<p>由于可以访问请求对象，因此可以使用比示例代码中更复杂的数据填充标签。</p>
<h2 id="在命令行下使用">在命令行下使用</h2>
<p>如果直接在命令行中使用 Delve，则需要使用 <a href="https://github.com/go-delve/delve/commit/186786235fc9c2bd9b16c26bb4b0aef60ffb731c" target="_blank" rel="noopener">1867862</a>
 或更高版本的 Delve。这些更改将包含在下一个版本中，而当前v1.4.0 版本中未包含。</p>
<p>要查看标签，请在调试会话期间调用 <code>goroutines -l</code> 命令，以查看到与 IDE 中相同的数据。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/03/debugger-dlv-with-labels-optimized.png"
    alt="debugger dlv from command line with labels"  />
</p>
</p>
<h2 id="性能影响">性能影响</h2>
<p>随之而来的自然问题是：使用上述代码对性能会有影响吗？</p>
<p>答案是肯定的，设置这些标签确实会降低性能。通常，它的影响很小，但是仍然会存在，因此最好使用一些基准测试代码在自己的硬件上进行测试。</p>
<p>考虑到这种影响，就会出现下一个问题：如果涉及性能，则意味着每次需要进行调试时，我都需要应用和撤消代码。这会影响我的开发速度，这能做得更好吗？</p>
<h2 id="使用自定义库启用调试标签">使用自定义库启用调试标签</h2>
<p>要回答上述问题并允许我们的调试代码在不影响性能的情况下进行编译，请使用 <a href="https://github.com/dlsniper/debugger" target="_blank" rel="noopener">github.com/dlsniper/debugger</a>
 库并更改我们的 makeRequest 代码以包括以下函数调用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makeRequest</span><span class="p">(</span><span class="nx">done</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">page</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Unblock the next request from the queue
</span><span class="c1"></span>        <span class="o">&lt;-</span><span class="nx">done</span>
    <span class="p">}()</span>
 
    <span class="nx">debugger</span><span class="p">.</span><span class="nf">SetLabels</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
            <span class="s">&#34;request&#34;</span><span class="p">,</span> <span class="s">&#34;automated&#34;</span><span class="p">,</span>
            <span class="s">&#34;page&#34;</span><span class="p">,</span> <span class="nx">page</span><span class="p">,</span>
            <span class="s">&#34;rid&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">})</span>
	<span class="c1">// ..
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>在调试器中运行此代码之前，我们需要进行其他更改。我们需要在运行配置的 Go 工具参数字段中添加 <code>-tags debugger</code>。否则，该库将加载生产代码，标签将不起作用。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/03/debugger-run-configuration-optimized.png"
    alt="debugger - run configuration"  />
</p>
</p>
<p>此处显示的库支持标准的 http.HandlerFunc 签名，以方便在现有应用程序中使用。</p>
<p>回到我们的代码，如下所示：<code>m.HandleFunc(&quot;/&quot;, homeHandler)</code>。</p>
<p>要将标签添加到这些处理程序，我们可以将代码更改为如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">debugger</span><span class="p">.</span><span class="nf">Middleware</span><span class="p">(</span><span class="nx">homeHandler</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
        <span class="s">&#34;request&#34;</span><span class="p">,</span> <span class="s">&#34;real&#34;</span><span class="p">,</span>
        <span class="s">&#34;path&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}))</span>
</code></pre></div><p><strong>专业提示：</strong></p>
<p>在单个函数或方法中对 <a href="https://pkg.go.dev/github.com/dlsniper/debugger?tab=doc#SetLabels" target="_blank" rel="noopener">debugger.SetLabels</a>
 函数进行多次调用，可以更轻松地跟踪执行进度并过滤掉不需要的数据。</p>
<p><strong>专业提示：</strong></p>
<p>可以复制运行配置，从而可以在有和没有调试器构建标记（build tag）的情况下使用代码。</p>
<p><strong>注意：</strong></p>
<p>如上所示，设置标签会导致性能下降。因此，仅在对性能要求不高的环境中使用 <code>-tags=debugger</code> 构建的二进制文件，或确保通过改善调试体验来抵消性能损失。</p>
<p>今天就这样。我们学习了如何使用 GoLand 调试复杂的 Go 应用程序并在 goroutine 中添加标签，从而使生活变得更轻松。</p>
<p>这篇文章中的所有代码都可以在 <a href="https://github.com/dlsniper/debugger" target="_blank" rel="noopener">github.com/dlsniper/debugger</a>
 上找到。用于测试该库的示例代码可在  <a href="https://github.com/dlsniper/serverdemo" target="_blank" rel="noopener">github.com/dlsniper/serverdemo</a>
 上找到。</p>
<blockquote>
<p>作者：<a href="https://blog.jetbrains.com/go/author/florin-patanjetbrains-com/" target="_blank" rel="noopener">Florin Pățan</a>
</p>
<p>原文链接：https://blog.jetbrains.com/go/2020/03/03/how-to-find-goroutines-during-debugging/</p>
<p>翻译：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>在 iOS 和 Android 上运行 Go 代码</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/running-go-code-on-ios-and-android/</link>
			<pubDate>Mon, 14 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/running-go-code-on-ios-and-android/</guid>
			<description>在本教程中，我们将构建一个简单的 Go 包，您可以从 iOS 应用程序（Swift）和 Android 应用程序（Kotlin）运行该软件包。 本教程不会使用go mobile 框架。相反，它使用 Cgo 构建可导入到您的移动项目中的原始静态（iOS）和共享（Android） C 库（Go Mobile 框架在后台进行此操作）。 构建 在本教程中，我们将创建具有以下结构的简单 monorepo： . ├── android/ ├── go/ │ ├── cmd/ │ │ └── libfoo/</description>
			<content type="html"><![CDATA[<p>在本教程中，我们将构建一个简单的 Go 包，您可以从 iOS 应用程序（Swift）和 Android 应用程序（Kotlin）运行该软件包。</p>
<p>本教程不会使用<a href="https://github.com/golang/mobile" target="_blank" rel="noopener">go mobile</a>
 框架。相反，它使用 Cgo 构建可导入到您的移动项目中的原始静态（iOS）和共享（Android） C 库（Go Mobile 框架在后台进行此操作）。</p>
<h2 id="构建">构建</h2>
<p>在本教程中，我们将创建具有以下结构的简单 monorepo：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">.
├── android/
├── go/
│   ├── cmd/
│   │   └── libfoo/
│   │       └── main.go
│   ├── foo/
│   │   └── foo.go
│   ├── go.mod
│   └── go.sum
└── ios/
$ mkdir -p android ios go/cmd/libfoo go/foo
</code></pre></div><p>我们将从 Go 代码开始，稍后再返回创建 iOS 和 Android 项目。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-zsh" data-lang="zsh">$ <span class="nb">cd</span> go
$ go mod init rogchap.com/libfoo
</code></pre></div><h2 id="foo-包">Foo 包</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// go/foo/foo.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">foo</span>

<span class="c1">// Reverse reverses the given string by each utf8 character
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Reverse</span><span class="p">(</span><span class="nx">in</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="kt">rune</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">))</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
        <span class="kt">rune</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">r</span>
        <span class="nx">n</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="kt">rune</span> <span class="p">=</span> <span class="kt">rune</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">n</span><span class="p">]</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="kt">rune</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="kt">rune</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kt">rune</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">],</span> <span class="kt">rune</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="kt">rune</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们的<code>foo</code>程序包有一个函数<code>Reverse</code>，该函数具有单个字符串参数<code>in</code>和单个字符串输出。</p>
<h2 id="导出为-c">导出为 C</h2>
<p>为了使我们的 C 库调用我们的<code>foo</code>包，我们需要导出所有要公开给 C 的函数，并带有特殊<code>export</code>注释。该包装器必须位于<code>main</code>包装中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// go/cmd/libfoo/main.go
</span><span class="c1"></span><span class="nx">pacakge</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;C&#34;</span>

<span class="c1">// other imports should be seperate from the special Cgo import
</span><span class="c1"></span><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;rogchap.com/libfoo/foo&#34;</span>
<span class="p">)</span>

<span class="c1">//export reverse
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">in</span> <span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)</span> <span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">C</span><span class="p">.</span><span class="nf">CString</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nf">Reverse</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nf">GoString</span><span class="p">(</span><span class="nx">in</span><span class="p">)))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div><p>我们正在使用特殊的 <code>C.GoString()</code>和<code>C.CString()</code>函数在 Go 字符串和 C 字符串之间进行转换。</p>
<p>*注意：*我们要导出的函数不必是导出的 Go 函数（即以大写字母开头）。还要注意是空<code>main</code>函数；这对于 Go 代码进行编译是必需的，否则会出现 <code>function main is undeclared in the main package</code>错误。</p>
<p>让我们通过使用 <code>-buildmode</code> 标志创建一个静态 C 库来测试我们的构建：</p>
<pre tabindex="0"><code>go build -buildmode=c-archive -o foo.a ./cmd/libfoo
</code></pre><p>这应该已经输出了 C 库：<code>foo.a</code>和头文件：<code>foo.h</code>。您应该在头文件的底部看到导出的函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">extern</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">reverse</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">in</span><span class="p">);</span>
</code></pre></div><h2 id="为-ios-构建">为 iOS 构建</h2>
<p>我们的目标是创建一个可以在 iOS 设备和 iOS 模拟器上使用的 <a href="https://en.wikipedia.org/wiki/Fat_binary" target="_blank" rel="noopener">Fat 二进制文件</a>
。</p>
<p>Go 标准库包含用于构建 iOS 的脚本： <a href="https://golang.org/misc/ios/clangwrap.sh" target="_blank" rel="noopener"><code>$GOROOT/misc/ios/clangwrap.sh</code></a>
，但是该脚本仅针对生成<code>arm64</code>，而<code>x86_64</code>iOS Simulator 也需要该脚本 。因此，我们将创建自己的<code>clangwrap.sh</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/sh
</span><span class="cp"></span>
<span class="c1"># go/clangwrap.sh</span>

<span class="nv">SDK_PATH</span><span class="o">=</span><span class="sb">`</span>xcrun --sdk <span class="nv">$SDK</span> --show-sdk-path<span class="sb">`</span>
<span class="nv">CLANG</span><span class="o">=</span><span class="sb">`</span>xcrun --sdk <span class="nv">$SDK</span> --find clang<span class="sb">`</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$GOARCH</span><span class="s2">&#34;</span> <span class="o">==</span> <span class="s2">&#34;amd64&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">CARCH</span><span class="o">=</span><span class="s2">&#34;x86_64&#34;</span>
<span class="k">elif</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$GOARCH</span><span class="s2">&#34;</span> <span class="o">==</span> <span class="s2">&#34;arm64&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">CARCH</span><span class="o">=</span><span class="s2">&#34;arm64&#34;</span>
<span class="k">fi</span>

<span class="nb">exec</span> <span class="nv">$CLANG</span> -arch <span class="nv">$CARCH</span> -isysroot <span class="nv">$SDK_PATH</span> -mios-version-min<span class="o">=</span>10.0 <span class="s2">&#34;</span><span class="nv">$@</span><span class="s2">&#34;</span>
</code></pre></div><p>不要忘记让它可执行：</p>
<pre tabindex="0"><code>chmod +x clangwrap.sh
</code></pre><p>现在，我们可以为每种体系结构构建库，并使用该<code>lipo</code>工具（通过 Makefile）合并为 Fat 二进制文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="c"># go/Makefile
</span><span class="c"></span>
<span class="nf">ios-arm64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>darwin <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>arm64 <span class="se">\
</span><span class="se"></span>	<span class="nv">SDK</span><span class="o">=</span>iphoneos <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>PWD<span class="k">)</span>/clangwrap.sh <span class="se">\
</span><span class="se"></span>	<span class="nv">CGO_CFLAGS</span><span class="o">=</span><span class="s2">&#34;-fembed-bitcode&#34;</span> <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-archive -tags ios -o <span class="k">$(</span>IOS_OUT<span class="k">)</span>/arm64.a ./cmd/libfoo

<span class="nf">ios-x86_64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>darwin <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>amd64 <span class="se">\
</span><span class="se"></span>	<span class="nv">SDK</span><span class="o">=</span>iphonesimulator <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>PWD<span class="k">)</span>/clangwrap.sh <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-archive -tags ios -o <span class="k">$(</span>IOS_OUT<span class="k">)</span>/x86_64.a ./cmd/libfoo

<span class="nf">ios</span><span class="o">:</span> <span class="n">ios</span>-<span class="n">arm</span>64 <span class="n">ios</span>-<span class="n">x</span>86<span class="n">_</span>64
	lipo <span class="k">$(</span>IOS_OUT<span class="k">)</span>/x86_64.a <span class="k">$(</span>IOS_OUT<span class="k">)</span>/arm64.a -create -output <span class="k">$(</span>IOS_OUT<span class="k">)</span>/foo.a
	cp <span class="k">$(</span>IOS_OUT<span class="k">)</span>/arm64.h <span class="k">$(</span>IOS_OUT<span class="k">)</span>/foo.h
</code></pre></div><h2 id="创建我们的-ios-应用程序">创建我们的 iOS 应用程序</h2>
<p>使用 XCode，我们可以创建一个简单的单页应用程序。我将使用 Swift UI，但这与 UIKit 一样容易：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// ios/foobar/ContentView.swift</span>

<span class="kd">struct</span> <span class="nc">ContentView</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>

    <span class="p">@</span><span class="n">State</span> <span class="kd">private</span> <span class="kd">var</span> <span class="nv">txt</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>

    <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
        <span class="n">VStack</span><span class="p">{</span>
            <span class="n">TextField</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="err">$</span><span class="n">txt</span><span class="p">)</span>
            <span class="p">.</span><span class="n">textFieldStyle</span><span class="p">(</span><span class="n">RoundedBorderTextFieldStyle</span><span class="p">())</span>
            <span class="n">Button</span><span class="p">(</span><span class="s">&#34;Reverse&#34;</span><span class="p">){</span>
                <span class="c1">// Reverse text here</span>
            <span class="p">}</span>
            <span class="n">Spacer</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="p">.</span><span class="n">padding</span><span class="p">(.</span><span class="n">all</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在 Xcode 中，将新生成的<code>foo.a</code> 和 <code>foo.h</code> 拖进我们的项目。为了使我们的 Swift 代码与我们的库互操作，我们需要创建一个桥接头文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// ios/foobar/foobar-Bridging-Header.h
</span><span class="c1"></span>
<span class="cp">#import &#34;foo.h&#34;
</span></code></pre></div><p>在 Xcode <code>Build Settings</code> 中，<code>Swift Compiler - General</code> 下，设置 <code>Objective-C Bridging Header</code> 为我们刚刚创建的文件：<code>foobar/foobar-Bridging-Header.h</code>。</p>
<p>我们还需要设置 <code>Library Search Paths</code> 为包括我们生成的头文件 <code>foo.h</code> 的目录。（当您将文件拖放到项目中时，Xcode 可能已经为您完成了此操作）。</p>
<p>现在我们可以从 Swift 调用函数，然后构建并运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// ios/foobar/ContentView.swift</span>

<span class="n">Button</span><span class="p">(</span><span class="s">&#34;Reverse&#34;</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nv">str</span> <span class="p">=</span> <span class="bp">reverse</span><span class="p">(</span><span class="nb">UnsafeMutablePointer</span><span class="p">&lt;</span><span class="nb">Int8</span><span class="p">&gt;(</span><span class="kr">mutating</span><span class="p">:</span> <span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">txt</span> <span class="k">as</span> <span class="n">NSString</span><span class="p">).</span><span class="n">utf8String</span><span class="p">))</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">txt</span> <span class="p">=</span> <span class="nb">String</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">cString</span><span class="p">:</span> <span class="n">str</span><span class="p">!,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span>
    <span class="c1">// don&#39;t forget to release the memory to the C String</span>
    <span class="n">str</span><span class="p">?.</span><span class="n">deallocate</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p><p class="md__image">
  <img src="https://rogchap.com/posts/img/libfoo_ios.gif"
    alt="libfoo ios应用程序"  />
</p>
</p>
<h2 id="创建-android-应用程序">创建 Android 应用程序</h2>
<p>使用 Android Studio，我们将创建一个新的 Android 项目。从 Project Templates 中选择 <code>Native C++</code>，这将创建一个带有 Empty Activity 的项目，该项目被配置为使用 Java Native Interface（JNI）。我们仍将选择 <code>Kotlin</code> 作为该项目的语言。</p>
<p>创建一个简单的 Activity 后，加上 <code>EditText</code> 和，<code>Button</code> 两个控件，为应用创建基本功能：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="c1">// android/app/src/main/java/com/rogchap/foobar/MainActivity.kt
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">MainActivity</span> <span class="p">:</span> <span class="n">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
        <span class="n">setContentView</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">layout</span><span class="p">.</span><span class="n">activity_main</span><span class="p">)</span>

        <span class="n">btn</span><span class="p">.</span><span class="n">setOnClickListener</span> <span class="p">{</span>
            <span class="n">txt</span><span class="p">.</span><span class="n">setText</span><span class="p">(</span><span class="n">reverse</span><span class="p">(</span><span class="n">txt</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">toString</span><span class="p">()))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
</span><span class="cm">     * A native method that is implemented by the &#39;native-lib&#39; native library,
</span><span class="cm">     * which is packaged with this application.
</span><span class="cm">     */</span>
    <span class="k">private</span> <span class="k">external</span> <span class="k">fun</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">str</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">String</span>

    <span class="k">companion</span> <span class="k">object</span> <span class="p">{</span>
        <span class="c1">// Used to load the &#39;native-lib&#39; library on application startup.
</span><span class="c1"></span>        <span class="k">init</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="n">loadLibrary</span><span class="p">(</span><span class="s2">&#34;native-lib&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>我们创建了（并调用）一个外部函数 <code>reverse</code>，我们需要在 JNI （C++）实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// android/app/src/main/cpp/native-lib.cpp
</span><span class="c1"></span>
<span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="p">{</span>
    <span class="n">jstring</span>
    <span class="nf">Java_com_rogchap_foobar_MainActivity_reverse</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Reverse text here
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>JNI 代码必须遵循约定才能在本机 C++ 和 Kotlin（JVM）之间互操作。</p>
<h2 id="为-android-构建">为 Android 构建</h2>
<p>在许多版本的 Android 和 NDK 中，JNI 与外部库的工作方式已发生变化。当前（也是最简单的方法）是将输出的库放置到一个特殊的 <code>jniLibs</code> 文件夹中，该文件夹将复制到我们的最终 APK 文件中。</p>
<p>与创建 Fat 二进制文件（就像我们在 iOS 中所做的那样）不同，我将每个体系结构放置在正确的文件夹中。同样，对于 JNI，约定很重要。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">//</span> <span class="err">go/Makefile</span>

<span class="nv">ANDROID_OUT</span><span class="o">=</span>../android/app/src/main/jniLibs
<span class="nv">ANDROID_SDK</span><span class="o">=</span><span class="k">$(</span>HOME<span class="k">)</span>/Library/Android/sdk
<span class="nv">NDK_BIN</span><span class="o">=</span><span class="k">$(</span>ANDROID_SDK<span class="k">)</span>/ndk/21.0.6113669/toolchains/llvm/prebuilt/darwin-x86_64/bin

<span class="nf">android-armv7a</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>arm <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARM</span><span class="o">=</span><span class="m">7</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/armv7a-linux-androideabi21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/armeabi-v7a/libfoo.so ./cmd/libfoo

<span class="nf">android-arm64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>arm64 <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/aarch64-linux-android21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/arm64-v8a/libfoo.so ./cmd/libfoo

<span class="nf">android-x86</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span><span class="m">386</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/i686-linux-android21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/x86/libfoo.so ./cmd/libfoo

<span class="nf">android-x86_64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>amd64 <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/x86_64-linux-android21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/x86_64/libfoo.so ./cmd/libfoo

<span class="nf">android</span><span class="o">:</span> <span class="n">android</span>-<span class="n">armv</span>7<span class="n">a</span> <span class="n">android</span>-<span class="n">arm</span>64 <span class="n">android</span>-<span class="n">x</span>86 <span class="n">android</span>-<span class="n">x</span>86<span class="n">_</span>64
</code></pre></div><p><strong>注意</strong>确保为您的 Android SDK 和已下载的 NDK 版本设置正确的位置。</p>
<p><code>make android</code> 将我们需要的所有共享库构建到正确的文件夹中。现在，我们需要将库添加到 CMake：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="err">//</span> <span class="err">android/app/src/main/cpp/CMakeLists.txt
</span><span class="err">
</span><span class="err">//</span> <span class="err">...
</span><span class="err">
</span><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">lib_foo</span> <span class="s">SHARED</span> <span class="s">IMPORTED</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set_property</span><span class="p">(</span><span class="s">TARGET</span> <span class="s">lib_foo</span> <span class="s">PROPERTY</span> <span class="s">IMPORTED_NO_SONAME</span> <span class="s">1</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">lib_foo</span> <span class="s">PROPERTIES</span> <span class="s">IMPORTED_LOCATION</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/../jniLibs/</span><span class="o">${</span><span class="nv">CMAKE_ANDROID_ARCH_ABI</span><span class="o">}</span><span class="s">/libfoo.so</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/../jniLibs/</span><span class="o">${</span><span class="nv">CMAKE_ANDROID_ARCH_ABI</span><span class="o">}</span><span class="s">/</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err">//</span> <span class="err">...
</span><span class="err">
</span><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">native-lib</span> <span class="s">lib_foo</span> <span class="o">${</span><span class="nv">log-lib</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></code></pre></div><p>我花了一段时间才弄清楚这些设置，再次命名很重要，因此使用库命名 <code>lib_xxxx</code> 并设置属性很重要，同时设置 <code>IMPORTED_NO_SONAME 1</code>，否则您的 apk 会在错误的位置查找你的库。</p>
<p>现在，我们可以将 JN I 代码连接到 Go 库中，然后运行我们的应用程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// android/app/src/main/cpp/native-lib.cpp
</span><span class="c1"></span>
<span class="cp">#include</span> <span class="cpf">&#34;libfoo.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="p">{</span>
    <span class="n">jstring</span>
    <span class="nf">Java_com_rogchap_foobar_MainActivity_reverse</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cstr</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetStringUTFChars</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">cout</span> <span class="o">=</span> <span class="n">reverse</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">cstr</span><span class="p">));</span>
        <span class="n">jstring</span> <span class="n">out</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
        <span class="n">env</span><span class="o">-&gt;</span><span class="n">ReleaseStringUTFChars</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">cstr</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><p class="md__image">
  <img src="https://rogchap.com/posts/img/libfoo_android.gif"
    alt="libfoo android应用"  />
</p>
</p>
<h2 id="结论">结论</h2>
<p>Go 的优势之一就是它是跨平台的，这不仅意味着 Window，Mac 和 Linux，Go 还可以针对许多其他体系结构，包括 iOS 和 Android。现在，您可以在工具栏中找到另一个选项，以创建在服务器、移动应用程序甚至 Web（通过 Web 程序集）上运行的共享库。</p>
<p>本教程的所有代码均可在 GitHub 上获得：<a href="https://github.com/rogchap/libfoo" target="_blank" rel="noopener">https://github.com/rogchap/libfoo</a>
</p>
<p>期待听到您使用 Go 构建的新杀手级应用程序。</p>
<blockquote>
<p>原文链接：https://rogchap.com/2020/09/14/running-go-code-on-ios-and-android/</p>
<p>作者：Roger Chapman</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>观点：Go 尚未准备好用于企业系统，原因在这里</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/golang-is-not-ready-for-enterprise-systems-yet-and-heres-why/</link>
			<pubDate>Sat, 12 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/golang-is-not-ready-for-enterprise-systems-yet-and-heres-why/</guid>
			<description>译注：发表这篇文章，不代表我认同作者的观点。大家都知道，在国内，Go 已经被很多大厂使用，早就可以用于企业系统。 对一门语言的爱，可以接受任何不同的观点，真理总是越辩越明，相信有不同的声音，Go 也会越来越好。欢迎大家留言发表你的看法。 介绍 企业应用程序是一个寿命长、可靠的系统，具有多年的持久数据。如今，Golang 的世界并没有提供以企业系统构建方式构建系统的可能性</description>
			<content type="html"><![CDATA[<blockquote>
<p>译注：发表这篇文章，不代表我认同作者的观点。大家都知道，在国内，Go 已经被很多大厂使用，早就可以用于企业系统。</p>
<p>对一门语言的爱，可以接受任何不同的观点，真理总是越辩越明，相信有不同的声音，Go 也会越来越好。欢迎大家留言发表你的看法。</p>
</blockquote>
<h2 id="介绍">介绍</h2>
<p>企业应用程序是一个寿命长、可靠的系统，具有多年的持久数据。如今，Golang 的世界并没有提供以企业系统构建方式构建系统的可能性。</p>
<p><p class="md__image">
  <img src="../imgs/not-ready-enterprice01.png"
    alt="Martin Fowler 的“企业应用程序”"  />
</p>
</p>
<h2 id="golang-的发展文化">Golang 的发展文化</h2>
<p>让我们考虑几个问题，如错误处理不当、 手动组合的 SQL 查询和面向轮子开发。</p>
<h3 id="错误处理不当">错误处理不当</h3>
<p>Golang 在错误处理方面提供了更多的自由。由于开发人员方面缺乏责任，这通常会导致应用程序中的错误处理不当。</p>
<p>最常见的情况与 sql 查询的执行有关：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">defer</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span> <span class="c1">// omitted errors from sql driver
</span></code></pre></div><p>没有明确的方法来处理此返回的错误。实际上，该语言提供了捕获错误的特定方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">()</span>
</code></pre></div><p>该错误是一个典型的返回值，可以通过各种方式忽略：</p>
<pre tabindex="0"><code>defer rows.Close() // omitted errors from sql driver
defer body.Close() // omitted IO errors
result, _ := foo() // omitted errors from foo function
</code></pre><p><p class="md__image">
  <img src="../imgs/not-ready-enterprice02.png"
    alt="sketch: Now you come to Me and you say “Don Gopher, handle Me.” But you don’t ask with respect. you don’t offer friendship."  />
</p>
</p>
<p>此外，它会导致应用程序在 panic 函数调用后立即崩溃的风险增加，并且通常会降低可靠性。</p>
<blockquote>
<p>根据 M.Nygard 的 “Release it!”，可靠的系统必须处理每个不重要的错误而不会崩溃。没有权衡。</p>
</blockquote>
<p>作为解决方案，我们可以使用其他语言的 try/catch/finally 结构添加可靠的机制。此外，还需要消除 panic 函数。当然，这将是一种较慢的方法，但更可靠。</p>
<hr>
<h3 id="手动编写-sql-查询语句">手动编写 SQL 查询语句</h3>
<p>Golang 中处理数据库查询的典型方法是手动编写查询。如果 <strong>SQL 查询被手工编写的</strong>，那么数据库集成将是一个<strong>瓶颈</strong>。并非所有开发人员都擅长 SQL 和使用数据库。诸如 Hibernate（Java）和 Entity Framework（.NET）之类的功能齐全的 ORM 生成的典型查询已开放，用于数据库和缓存数据优化。<strong>这是根据 ‘Release it’ 来编写可靠的应用程序的最有效方法之一。</strong></p>
<p>有些库将来可能是功能齐全的ORM（例如 GORM 和 XORM）。我相信，与手工编写的 SQL  查询相比，它们将来会更受欢迎。</p>
<h3 id="重新发明轮子">重新发明轮子</h3>
<p>通常，Golang 开发人员都在选择重新发明轮子。轮子无处不在：task scheduler，迁移工具，logger，worker pool，十进制数字的库，授权库和其他工具。</p>
<blockquote>
<p>它们没有经过良好的测试，没有良好的文档，在生产中使用不足。风险太高，不能在企业应用程序中使用它们。</p>
</blockquote>
<p>为了减少使用风险代码的可能性，检查是否有可用的解决方案。例如可以查看 <a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">awesome-go</a>
。</p>
<hr>
<h2 id="生态系统">生态系统</h2>
<p>Go 世界的生态系统包括 Consul, Kubernetes, Zipkin 和 Træfik 等。它是一个非常年轻且发展迅速的技术栈，没有公认的使用标准。</p>
<blockquote>
<p>Golang 生态系统中没有任何工具可以帮助建立可靠的企业系统。</p>
</blockquote>
<p>考虑到以上所有情况，我们需要非常谨慎地将第三方中间件集成到基础架构中，公司必须有足够的专业知识支持该过程。否则，它将成为具有不同技术的生产环境中的雷区。好消息是，市场有很多管理解决方案，以最大限度地降低风险。不幸的是，它很贵。</p>
<hr>
<p>Golang 生态系统太年轻，缺乏工具、编程文化，但我相信它将来会成为一个伟大的生态系统，并拥有伟大的程序员。语言社区正朝着正确的方向努力：性能和简化。但是，我们不能忘记可靠性也很重要。我们越早了解可靠性的价值，我们就会越快地用 Golang 编码更多、更好的企业系统。</p>
<h2 id="ps">P.S.</h2>
<p>我很惊讶，这篇文章有这么多的解释。可惜很多人错过了文章的重点。</p>
<p>这篇文章：</p>
<p><em>1）不是关于我</em></p>
<p><em>2）不是关于我的技能</em></p>
<p><em>3）不是关于我的狗</em></p>
<p>*4）*不是关于“为什么我的狗在其企业狗系统中不需要使用 Golang”</p>
<p><em>5）不是关于 Golang 的最佳编码实践</em></p>
<p><em>6）不是关于与处理 go 错误有关的最佳实践</em></p>
<p><em>7）不是关于如何以正确的方式选择正确的工具</em></p>
<p><em>8）不是关于 Golang 的一般设计</em></p>
<p><em>9）不是关于“没有人可以将 Go 用于企业系统”</em></p>
<p><em>10）不是关于“没有人需要将 Go 用于企业系统”</em></p>
<p>正如我所观察到的，这涉及将 Golang 用于企业的风险（在“ Golang”下，我的意思更多在于文化和生态系统，而不是语言设计）。这是我的看法。</p>
<p>当然，很多大公司，如谷歌和 Netflix 在企业中使用 Golang，在我看来，他们一样有风险（记住，谷歌使用 Golang 时，这种语言还没有包带版本的管理器 ）。其他开发人员可以有其他观点和其他经验并观察。</p>
<p>本文的主要目的是进行讨论，看看有多少人有相同的看法。</p>
<h2 id="参考">参考</h2>
<p>图书：《Release It! Design and Deploy Production-Ready Software》</p>
<p>图书：《Patterns of Enterprise Application Architecture》by Martin Fowler</p>
<blockquote>
<p>原文链接：https://medium.com/@afondmitro/golang-is-not-ready-for-enterprise-systems-yet-and-heres-why-c0ee72069963</p>
<p>作者：Dmitry Afonkin</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Google 的核心数据解决方案团队是如何使用 Go 的？</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/google-go-coredata/</link>
			<pubDate>Tue, 08 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/google-go-coredata/</guid>
			<description>关于 Google 的核心数据： Google 是一家技术公司，其使命是组织全世界的信息，并使其普遍可访问和有用。 在这个案例研究中，Google 的核心数据解决方案团队分享了他们的 Go 旅程，包括他们决定在 Go 中重写 web 索引服务，利用 Go 的内置并发性，并观察 Go 如何帮助改进开发过程。 Google 的使命是“组织世界各地的信息，并使其普遍可访问和有用。” Google 的核心数据解决方案团队是负责组织该信息的团队之一。除此之外</description>
			<content type="html"><![CDATA[<p>关于 Google 的核心数据：</p>
<blockquote>
<p>Google 是一家技术公司，其使命是组织全世界的信息，并使其普遍可访问和有用。</p>
<p>在这个案例研究中，Google 的核心数据解决方案团队分享了他们的 Go 旅程，包括他们决定在 Go 中重写 web 索引服务，利用 Go 的内置并发性，并观察 Go 如何帮助改进开发过程。</p>
</blockquote>
<p><p class="md__image">
  <img src="../imgs/go_core_data_case_study.png"
    alt="核心数据"  />
</p>
</p>
<p>Google 的使命是“组织世界各地的信息，并使其普遍可访问和有用。” Google 的核心数据解决方案团队是负责组织该信息的团队之一。除此之外，该团队维护服务以索引全球的网页。这些网络索引服务通过保持搜索结果的更新和全面来帮助支持诸如 Google 搜索之类的产品，这些产品都是用 Go 语言编写的。</p>
<p>2015 年，为了跟上 Google 的规模，我们的团队需要我们将索引堆栈从用 C++ 编写的单个整体二进制代码重写为微服务架构中的多个组件。我们决定使用 Go 重写许多索引服务，现在我们将其用于支持大多数架构。</p>
<p>“ 因为鼓励团队中的工程师使用并发和并行算法，所以 Go 的内置并发是很自然的选择。” —Minjae Hwang， 软件工程师</p>
<p>选择语言时，我们的团队发现 Go 的多种特性特别适合。例如，因为鼓励团队中的工程师使用并发和并行算法，所以 Go 的内置并发是很自然的选择。工程师还发现，“ Go 代码更为自然”，使他们可以将时间花在业务逻辑和分析上，而不是在管理内存和优化性能上。</p>
<p>使用 Go 时，编写的代码要简单的多，因为它有助于减轻开发过程中的认知负担。例如，当使用 C++ 时，复杂的 IDE 可能“显示出源代码没有编译错误实际上确实有错误”，而“在 Go 中，当 IDE 指出代码没有错误时，代码总是会编译。” Core Data Solutions 团队的软件工程师 MinJae Hwang 说。减少开发过程中的小摩擦点，例如缩短修复编译错误的周期，有助于我们的团队在原始重写期间更快地发布，并有助于保持较低的维护成本。</p>
<p>“当我使用 C++ 并想使用更多软件包时，必须写一些 header 文件。当我用 Go 语言时，<strong>内置工具使我可以更轻松地使用软件包。我的开发速度要快得多</strong>。</p>
<p>通过简单的语言语法和 Go 工具的支持，我们团队中的一些成员发现用 Go 编写代码要容易的多。我们还发现 Go 在静态类型检查方面做得非常好，并且某些 Go 基础知识（例如 godoc 命令）已帮助团队围绕编写文档建立了更规范的规则。</p>
<p>“…在一年内重新设计了 Google 的网络索引。更令人印象深刻的是，团队中的大多数开发人员在学习 Go 的同时也用 Go 进行了重写。”— Prasanna Meda，软件工程师</p>
<p>研发在全球范围内被广泛使用的产品绝非易事，而我们团队使用 Go 的决定并不是一件容易的事，但是这样做有助于我们更快地行动。结果，在一年内重新设计了 Google 的网络索引。更令人印象深刻的是，该团队中的大多数开发人员在学习 Go 的同时就用 Go 完成重写。</p>
<p>除了核心数据解决方案团队外，Google 的工程团队在开发过程中也采用了Go。了解 <a href="https://go.dev/solutions/google/chrome/" target="_blank" rel="noopener">Chrome</a>
 和 <a href="https://go.dev/solutions/google/firebase/" target="_blank" rel="noopener">Firebase 托管</a>
团队如何使用 Go 来大规模构建快速，可靠和高效的软件。关于他们的下次分享。</p>
<blockquote>
<p>原文链接：https://go.dev/solutions/google/coredata/</p>
<p>作者：Prasanna Meda, Software Engineer, Core Data Solutions</p>
<p>翻译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>关于 Go 语言泛型设计的最新进展和一些问题的说明</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/about-go-generic-progress/</link>
			<pubDate>Sun, 23 Aug 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/about-go-generic-progress/</guid>
			<description>前段时间 Go 官方发布了新的泛型草案，一时间在社区引起了很大的反响，各种关于泛型的文章、讨论涌现出来。8 月 21日 Ian Lance Taylor 在 golang-nuts 讨论组总结了泛型设计的最新进展和一些问题的说明。 Go Team 在经过多次讨论并阅读了许多评论后，计划对泛型设计进行一些更改并澄清草案的一些问题。 1 泛型语法极有可能使用方括号 []（不用 &amp;lt;&amp;gt; 是因为和比较运算符大于、小于冲突，为了保持 Go1 兼容性，所以选择了 []）</description>
			<content type="html"><![CDATA[<p>前段时间 Go 官方发布了新的泛型草案，一时间在社区引起了很大的反响，各种关于泛型的文章、讨论涌现出来。8 月 21日 Ian Lance Taylor 在 <a href="https://groups.google.com/g/golang-nuts/c/iAD0NBz3DYw/m/VcXSK55XAwAJ" target="_blank" rel="noopener">golang-nuts</a>
 讨论组总结了泛型设计的最新进展和一些问题的说明。</p>
<p>Go Team 在经过多次讨论并阅读了许多评论后，计划对泛型设计进行一些更改并澄清草案的一些问题。</p>
<h2 id="1">1</h2>
<p>泛型语法极有可能使用方括号 <code>[]</code>（不用 &lt;&gt; 是因为和比较运算符大于、小于冲突，为了保持 Go1 兼容性，所以选择了 []）但考虑删除类型参数中的 <code>type</code> 关键字，因为使用方括号足以区分类型参数和普通参数。为了避免与数组声明混淆，将要求所有类型参数都提供一个约束（constraint）。这样做的好处是可以给类型参数列表与普通参数列表使用完全相同的语法（除了括号的区别之外）。为简化类型参数的常见情况，该参数可以无限制，将引入一个新的预先声明的标识符 <code>any</code> 作为 <code>interface{}</code> 的别名。</p>
<p>所以支持泛型的声明类似这样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Vector</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span> 
<span class="kd">func</span> <span class="nx">Print</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span> 
<span class="kd">func</span> <span class="nx">Index</span><span class="p">[</span><span class="nx">T</span> <span class="nx">comparable</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">e</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span> 
</code></pre></div><p>Go Team 认为预定义新标识符 <code>any</code> 的成本较低：因为每个常规参数始终都有一个类型，每个类型参数始终具有一个约束（其元类型）。</p>
<p>将 <code>[type T]</code> 更改为 <code>[T any]</code> 似乎同样易读，并且节省了一个字符。我们将能够简化许多现有的标准库和其他地方的代码，只需替换 <code>interface {}</code> 为 <code>any</code> 即可。</p>
<h2 id="2">2</h2>
<p>将简化类型列表满足的规则。如果类型参数或者类型参数的底层（underlying ）类型和类型列表中的任意类型相同，则类型参数满足约定。调整后的规则意味着，类型列表可以决定是否接受除预先声明的类型外的确切定义的类型，或者是否接受具有匹配底层类型的任何类型。</p>
<p>这是一个微小的变化，预计不会影响任何现有的实验代码。</p>
<h2 id="3">3</h2>
<p>需要澄清的是，在考虑允许的操作时，对于类型参数中某个类型的值，将忽略在类型列表中的任何类型方法。一般规则是，泛型函数可以使用类型中每种类型允许的任何操作清单。但是，这仅适用于自定义函数和预声明的函数（例如 <code>len</code> 和 <code>cap</code>）。它不适用于方法，因为类型列表包含所有定义了方法的类型列表。任何方法都必须在 interface 中单独列出，而不是从类型列表中继承。即泛型函数只能使用类型约束所定义的那些操作。</p>
<p>该规则通常看起来很清晰，并且避免了一些复杂的推理涉及类型列表，其中包括带有嵌入式类型的结构参数。</p>
<h2 id="4">4</h2>
<p>允许对具有类型列表的类型参数执行类型开关（type switch）操作。用 (.type) 的语法来阐明类似 <code>switch v := x.(type)</code> 的代码。在类型参数上的类型开关不能使用 <code>:=</code> 语法，因此 <code>.(type)</code> 是不必要的。在具有类型列表的类型参数上执行类型开关操作时，列出的每一个 case 都必须是出现在类型列表中的（当然也允许使用 <code>default</code>）。如果和类型参数匹配，则该 case 被选中。如上面讨论的那样，可能该 case 不是完全匹配的类型参数而是类型参数的底层类型，该 case 也会被选中。</p>
<p>为了使该规则更明确。没有类型列表的类型参数不允许使用类型开关。但这种情况是允许的：对于一个没有类型列表的类型参数值 <code>x</code>，可以写这样的代码，<code>switch (interface{})(x).(type)</code>，根据上面的说明，以后应该写成这样 <code>switch any(x).(type)</code>。这个结构不是最简单的，但它仅使用了语言已有的特性。</p>
<h2 id="接下来">接下来</h2>
<p>这些更改将很快在以下实验设计中实现：dev.generics 分支，并在 go2go Playground 可用。以上有些已经可以完成了。同时 Go Team 会相应地更新设计草案。</p>
]]></content>
		</item>
		
		<item>
			<title>对比三款 Go Playground：你喜欢哪款？</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/compare-three-playground/</link>
			<pubDate>Wed, 19 Aug 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/compare-three-playground/</guid>
			<description>曾几何时，语言的在线运行（Playground）似乎成了标配。确实，Playground 能够让我们可以快速试验一些想法。Go 语言在发布之初就提供了一个，这就是 https://play.golang.org 。然而，由于众所周知的原因，我们访问不了。为了方便国内广大 gopher，我搞了一个国内镜像：https://play.studygolang.com ，尽情使用、分享吧。 官方的 Playground 不得不说，Go 官方的 Playground 真</description>
			<content type="html"><![CDATA[<p>曾几何时，语言的在线运行（Playground）似乎成了标配。确实，Playground 能够让我们可以快速试验一些想法。Go 语言在发布之初就提供了一个，这就是 <a href="https://play.golang.org" target="_blank" rel="noopener">https://play.golang.org</a>
。然而，由于众所周知的原因，我们访问不了。为了方便国内广大 gopher，我搞了一个国内镜像：<a href="https://play.studygolang.com" target="_blank" rel="noopener">https://play.studygolang.com</a>
，尽情使用、分享吧。</p>
<h2 id="官方的-playground">官方的 Playground</h2>
<p>不得不说，Go 官方的 Playground 真的比较原始。</p>
<p><p class="md__image">
  <img src="../imgs/playgolangorg.png"
    alt=""  />
</p>
</p>
<p>提供的功能比较少，主要有：</p>
<ul>
<li>格式化，但需要手动点击。在点击格式化时，如果勾选了 Imports，会自动对使用的标准库做导入；</li>
<li>分享。能够将你的代码分享给其他人，方便对方查看、运行；</li>
<li>代码片段。顶部下拉列表中提供了一些代码片段，点击可以直接切换编辑框内容；</li>
</ul>
<p>总结下：官方的 Playground 主要提供了在线编辑、运行、分享 Go 代码的功能，其中分享对全球的 gopher 来说，可以更方便的进行代码交流，排查问题等，分享也是使用最多的。</p>
<p>然而官方的 Playground 缺点也很明显：</p>
<ul>
<li>界面简单，略显丑陋；</li>
<li>不支持代码高亮；</li>
<li>不支持代码提示；</li>
<li>语法错误无法实时提示；</li>
<li>。。。</li>
</ul>
<p>于是有了第三方的 Playground。</p>
<h2 id="goplayspace">goplay.space</h2>
<p>第一个出场的是 <a href="https://goplay.space" target="_blank" rel="noopener">https://goplay.space</a>
。这是 iafan 在 2017 年开发的，</p>
<blockquote>
<p>Go Play Space is an experimental alternative <a href="https://play.golang.org/" target="_blank" rel="noopener">Go Playground</a>
 frontend that is built in Go itself (using <a href="https://github.com/gopherjs/gopherjs" target="_blank" rel="noopener">GopherJS</a>
), a Go→JavaScript transpiler, and <a href="https://github.com/gopherjs/vecty" target="_blank" rel="noopener">Vecty</a>
, a React-like frontend library for GopherJS).</p>
</blockquote>
<p><p class="md__image">
  <img src="../imgs/goplayspace.gif"
    alt=""  />
</p>
</p>
<p>可见，goplay.space 的代码运行依然使用官方的，只是替换了前端部分。看看它提供了哪些功能：</p>
<ul>
<li>语法高亮显示，大括号和引号自动关闭，正确的撤消/重做，自动缩进；</li>
<li>智能文档查找：例如双击源代码中的包名或 Println 等函数名称，在右边将看到相关的文档；这个功能真的很实用；</li>
<li>实时的语法错误检查；</li>
<li>错误行高亮显示（语法错误和编译器返回的错误）；</li>
<li>能够突出显示代码行和代码块（类似在 Github 上，但更好！）—只需单击行号即可。使用 Shift 和 Ctrl 修改选择；</li>
<li>键盘快捷键（请参阅顶部按钮标题处）；</li>
<li>支持多个 UI 主题；</li>
<li>支持 <a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">Fira Code</a>
 字体（系统中已安装的字体或 Webfont）；</li>
<li>go import 始终在运行代码之前运行，因此您通常不必担心导入问题；</li>
</ul>
<p>代码执行是官方的 Go Playground 的代理，因此它保证了程序将有相同的结果。同时共享的代码段也存储在 golang.org 服务器上。所以，分享的代码，可以直接在 goplay.space 展示。比如这个代码：<a href="https://play.golang.org/p/aouL6zP4O35" target="_blank" rel="noopener">https://play.golang.org/p/aouL6zP4O35</a>
，对应的 goplay.space 就是：<a href="https://goplay.space/#aouL6zP4O35" target="_blank" rel="noopener">https://goplay.space/#aouL6zP4O35</a>
。</p>
<p>个人认为 goplay.space 最大的特色是智能文档查找，可以在写代码时及时查看文档。要是加上自动完成功能就好了。</p>
<h2 id="goplaytools">goplay.tools</h2>
<p><a href="https://twitter.com/x1unix" target="_blank" rel="noopener">x1unix</a>
 觉得以上两个 Playground 都不够好。就在前些天（2020-08-12），发布了一个 “Better Go Playground”，这就是 <a href="https://goplay.tools/" target="_blank" rel="noopener">https://goplay.tools/</a>
。</p>
<p>几个月前，x1unix 决定尝试创建一个更好的 Go Play 版本，该版本将具有一些有价值的小功能，使原型制作足够舒适，例如基本代码自动完成（仅支持 stdlib），语法检查，代码段和示例。另外，随着 Go in WebAssembly 趋势开始增长，添加了 WebAssembly 支持。</p>
<p>此外，用户可以选择编辑器字体以及一些其他选项的小选项来自定义编辑器。</p>
<p>这个项目基于 React 和 Monaco editor 创建。</p>
<p><p class="md__image">
  <img src="../imgs/goplaytools.gif"
    alt=""  />
</p>
</p>
<p>目前该 Playground 有如下特性：</p>
<ul>
<li>代码完成：标准库</li>
<li>加载和保存文件</li>
<li>代码片段和教程，基于 <a href="https://gobyexample.com/" target="_blank" rel="noopener">gobyexample.com</a>
</li>
<li>WebAssembly 支持</li>
<li>暗黑模式</li>
<li>更多定制选项</li>
</ul>
<p>和 goplay.space 一样，它也是官方 Playground 的代理，因此官方分享的，在这里也可以直接查看，方便国内用户。上面例子对应该 Playground 是：<a href="https://goplay.tools/snippet/aouL6zP4O35" target="_blank" rel="noopener">https://goplay.tools/snippet/aouL6zP4O35</a>
。</p>
<p>仔细研究会发现它还支持鼠标右键菜单，有类似 VSCode 的 Command Palette 功能，调出该面板的快捷键是 F1。</p>
<p><p class="md__image">
  <img src="../imgs/goplaytools.png"
    alt=""  />
</p>
</p>
<p>代码完成功能可以显示对应的文档（针对标准库），如下：</p>
<p><p class="md__image">
  <img src="../imgs/goplaytools-doc.png"
    alt=""  />
</p>
</p>
<p>可见这真的是一个更好的 Playground，一定程度上有点在线编辑器的感觉。该项目在 GitHub 的地址：<a href="https://github.com/x1unix/go-playground" target="_blank" rel="noopener">https://github.com/x1unix/go-playground</a>
。</p>
<h2 id="后记">后记</h2>
<p>除了以上三款，其实还有一些其他的，比较小众，因此不做对比。最后，推荐大家以后可以使用 <a href="https://goplay.tools/" target="_blank" rel="noopener">https://goplay.tools/</a>
，有兴趣的也可以为它贡献代码。</p>
]]></content>
		</item>
		
		<item>
			<title>GoUI：一个非常简单的 GUI 框架</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/goui-a-very-simple-ui-framework/</link>
			<pubDate>Mon, 17 Aug 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/goui-a-very-simple-ui-framework/</guid>
			<description>最近，我一直想开发一些桌面（主要是 Windows，但也可以考虑 MacOS 或 Linux）应用程序。虽然 Go 不是开发 UI 应用程序时首选语言，但是该语言的简单性和健壮性仍然使它成为我的首选语言。是的，这是我的锤子（hammer）&amp;hellip; 但这是一个该死的漂亮锤子。 以前，我曾将 Ebiten 图形库用于 Go，以便与孩子们一起编写一些游戏。但是，对于一般的“应用程序”开发（即需要“小部件</description>
			<content type="html"><![CDATA[<p>最近，我一直想开发一些桌面（主要是 Windows，但也可以考虑 MacOS 或 Linux）应用程序。虽然 Go 不是开发 UI 应用程序时首选语言，但是该语言的简单性和健壮性仍然使它成为我的首选语言。是的，这是我的锤子（hammer）&hellip; 但这是一个该死的漂亮锤子。</p>
<p>以前，我曾将 Ebiten 图形库用于 Go，以便与孩子们一起编写一些游戏。但是，对于一般的“应用程序”开发（即需要“小部件 widgets”，例如按钮，菜单等），Ebiten 并非真的适合。因此，我一直在寻找可以使用的 Go UI 库。然而大多数都使用 cgo，但我真的希望我的应用程序是纯 Go。这纯粹是个人喜好，我不知道使用 cgo 而不是纯 Go 会有什么影响。如果我要使用 cgo，我认为首选的 UI 库肯定是 <a href="https://fyne.io/" target="_blank" rel="noopener">Fyne</a>
。Fyne 看起来是一个非常全面的框架，如果您不介意 cgo，我绝对会建议你看看看 Fyne。</p>
<p>还有其他一些库，但没有吸引我。他们说你永远不应该编写自己的安全性代码，并且我也相信你不应该编写自己的 UI 库。但是我忽略了这个建议&hellip;</p>
<p>因此，我写了一个 <a href="https://github.com/kpfaulkner/goui" target="_blank" rel="noopener">GoUI</a>
 !!</p>
<p>这纯粹是那些“抓痒”的项目之一。虽然现在还很早，但 UI 库的基本知识（由 Ebiten 进行实际渲染）正在慢慢融合。在详细介绍下面细节之前，我想先说明一下，我认为程序在 CLI 达到了顶峰。其次，我不是 UI 编程人员……写这些是我个人的兴趣。</p>
<p>GoUI 的基本思想是两种类型的图形元素。一个是可以包含其他面板或小部件的面板（Panel）。另一个是小部件，它是基本的 UI 元素（按钮，文本输入等）。我们目前使用的面板类型有 HPanel（水平添加）和 VPanel（我让你猜）。从技术上讲，我们确实有其他面板，例如工具栏，但这实际上只是 HPanel，需要一点点定制工作。总体而言，如果我可以结合其他现有面板/小工具来构造一些“新”东西，那么我会做的。如果我需要优化或与已有产品脱节，那么我将做一些全新的事情。</p>
<p>我们目前拥有的小部件是：</p>
<ul>
<li>
<p>ImageButton：（由应用程序提供的单击/未单击的图像）。</p>
</li>
<li>
<p>TextButton：基本的彩色矩形，其中包含您想要的任何文本。</p>
</li>
<li>
<p>Checkbox：与 TextButton 相同，但是旁边有一个小方框，可以打对勾。</p>
</li>
<li>
<p>EmptySpace：完全由我控制。用于强制其他小部件之间的空间。一旦添加适当的填充，该填充可能会消失。</p>
</li>
<li>
<p>Label：文本标签，不能输入。</p>
</li>
<li>
<p>Text Input：文本输入框。</p>
</li>
<li>
<p>RadioButtonGroup：这是一个面板，其中包含 vpanel 或 hpanel（取决于标志），然后其中包含许多复选框。复选框将图像（带有刻度）替换为常规的单选按钮。这是重新使用现有窗口小部件的好例子。如果事实证明我需要对复选框进行足够的修改以使其不适合用作单选按钮，那么我将不得不放入一个真正的单选按钮。但是目前，它运行良好。</p>
</li>
</ul>
<p>我还没有完成菜单，模态窗口等，但是正如我所说的……这还是早期。</p>
<p>现在，让我们尝试一个超级简单的 Demo。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
 
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/hajimehoshi/ebiten&#34;</span>
    <span class="s">&#34;github.com/kpfaulkner/goui/pkg&#34;</span>
    <span class="s">&#34;github.com/kpfaulkner/goui/pkg/widgets&#34;</span>
    <span class="nx">log</span> <span class="s">&#34;github.com/sirupsen/logrus&#34;</span>
    <span class="s">&#34;image/color&#34;</span>
<span class="p">)</span>
 
<span class="kd">type</span> <span class="nx">MyApp</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">window</span> <span class="nx">pkg</span><span class="p">.</span><span class="nx">Window</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">NewMyApp</span><span class="p">()</span> <span class="o">*</span><span class="nx">MyApp</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="nx">MyApp</span><span class="p">{}</span>
    <span class="nx">a</span><span class="p">.</span><span class="nx">window</span> <span class="p">=</span> <span class="nx">pkg</span><span class="p">.</span><span class="nf">NewWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="s">&#34;test app&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">a</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">SetupUI</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">vPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewVPanel</span><span class="p">(</span><span class="s">&#34;main vpanel&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">})</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">AddPanel</span><span class="p">(</span><span class="nx">vPanel</span><span class="p">)</span>
    <span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">button1</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nf">SetupUI</span><span class="p">()</span>
    <span class="nx">ebiten</span><span class="p">.</span><span class="nf">SetRunnableInBackground</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
    <span class="nx">ebiten</span><span class="p">.</span><span class="nf">SetWindowResizable</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">MainLoop</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">DebugLevel</span><span class="p">)</span>
    <span class="nx">app</span> <span class="o">:=</span> <span class="nf">NewMyApp</span><span class="p">()</span>
    <span class="nx">app</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>让我们解释一下以上代码。</p>
<p>首先，该程序的核心仍然是直接调用 Ebiten。这些尚未封装。因此，你将在 main 和 Run 函数中看到，我们基本上已经制作了 MyApp 结构的实例，然后调用 SetupUI，设置一些 Ebiten 标志，然后调用 MainLoop。</p>
<p>NewMyApp 函数调用 pkg.NewWindow 函数。这是应用程序的主窗口。一旦添加了模态/其他窗口，这可能会更改，但是就目前而言，这将创建给定大小的主 UI 窗口。</p>
<p>SetupUI 是你需要注意的地方。我们要做的第一件事是创建一个 VPanel。请记住，VPanel 把小部件垂直堆叠放置。我们将 vPanel 添加到主窗口。实际上（当前），我们应该只在主窗口中添加 1 个面板，其他所有内容都应放入该面板中。因此，在这种情况下，我们创建 button1（新的 TextButton）并将其添加到 vPanel。</p>
<p><p class="md__image">
  <img src="../imgs/goui-01.png"
    alt=""  />
</p>
</p>
<p>花点时间来学习理解一下上面的 UI 技能。</p>
<p>下面，让我们做一些更有趣的事情。假设我们要在按下按钮时做出响应。创建 TextButton 的行是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</code></pre></div><p>所有细节就不描述了，但是最后一个参数是带有 <strong>func (event IEvent) error</strong> 签名的事件处理程序。因此，如果我们创建一个带有该签名的方法，并将其作为最后一个参数传递给 NewTextButton。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">ButtonAction1</span><span class="p">(</span><span class="nx">event</span> <span class="nx">events</span><span class="p">.</span><span class="nx">IEvent</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;My button1 action 1!!!&#34;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>然后我们将按钮创建修改为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ButtonAction1</span><span class="p">)</span>
</code></pre></div><p>现在，当单击按钮时，将调用 ButtonAction1 函数，我们可以触发所需的任何功能。</p>
<p>是不是很简单。</p>
<p>现在，如果我想要在按钮旁边放点东西该怎么办？我们在这里要做的是创建一个 HPanel，并将其首先放入 VPanel。然后，将按钮添加到 HPanel。如果这样做，我们最终将得到如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">SetupUI</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
 
    <span class="nx">vPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewVPanel</span><span class="p">(</span><span class="s">&#34;main vpanel&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">})</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">AddPanel</span><span class="p">(</span><span class="nx">vPanel</span><span class="p">)</span>
 
    <span class="nx">hPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewHPanel</span><span class="p">(</span><span class="s">&#34;hpanel1&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">})</span>
    <span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">hPanel</span><span class="p">)</span>
 
    <span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ButtonAction1</span><span class="p">)</span>
    <span class="nx">hPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">button1</span><span class="p">)</span>
 
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>从视觉上看，什么都不会改变。我们仍然只显示 1 个小部件。</p>
<p>现在，如果我们在同一 HPanel 中添加一个复选框怎么办？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">SetupUI</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
 
    <span class="nx">vPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewVPanel</span><span class="p">(</span><span class="s">&#34;main vpanel&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">})</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">AddPanel</span><span class="p">(</span><span class="nx">vPanel</span><span class="p">)</span>
 
    <span class="nx">hPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewHPanel</span><span class="p">(</span><span class="s">&#34;hpanel1&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">})</span>
    <span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ButtonAction1</span><span class="p">)</span>
    <span class="nx">hPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">button1</span><span class="p">)</span>
 
    <span class="nx">cb1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewCheckBox</span><span class="p">(</span><span class="s">&#34;my checkbox1&#34;</span><span class="p">,</span> <span class="s">&#34;check me please&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="nx">hPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">cb1</span><span class="p">)</span>
 
    <span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">hPanel</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>因此，与之前完全相同，但只有这额外的两条：创建复选框，然后添加到 hPanel。</p>
<p>现在 UI 看起来是这样：</p>
<p><p class="md__image">
  <img src="../imgs/goui-02.png"
    alt=""  />
</p>
</p>
<p>现在不担心这里的间距了。</p>
<p>现在让我们在 TextButton 下面添加一个 ImageButton。这意味着我们将向 vPanel 添加第二项（第一项是 hPanel）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">imageButton</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewImageButton</span><span class="p">(</span><span class="s">&#34;ib1&#34;</span><span class="p">,</span> <span class="s">&#34;images/pressedbutton.png&#34;</span><span class="p">,</span> <span class="s">&#34;images/nonpressedbutton.png&#34;</span><span class="p">,</span><span class="kc">nil</span> <span class="p">)</span>
<span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">imageButton</span><span class="p">)</span>
</code></pre></div><p>这是效果如下：</p>
<p><p class="md__image">
  <img src="../imgs/goui-03.png"
    alt=""  />
</p>
</p>
<p>这时，我们有了 2 张图片（屏幕截图中只显示了一张）。按下按钮时一个，不按下时一个（只更改了阴影）。懂了吧。</p>
<p>好了，介绍就这么多。虽然该 UI 库还不完善，但 GUI 的基本功能已经可以实现了。再次放上该库的地址：<a href="https://github.com/kpfaulkner/goui" target="_blank" rel="noopener">https://github.com/kpfaulkner/goui</a>
。</p>
<blockquote>
<p>作者：<a href="https://kpfaulkner.wordpress.com/author/kpfaulkner/" target="_blank" rel="noopener">kpfaulkner</a>
</p>
<p>日期：2020 年 8 月 17 日</p>
<p>原文链接：<a href="https://kpfaulkner.wordpress.com/2020/08/17/goui-a-very-simple-ui-framework/" target="_blank" rel="noopener">https://kpfaulkner.wordpress.com/2020/08/17/goui-a-very-simple-ui-framework/</a>
</p>
<p>译者：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Go 源代码中的复活节彩蛋</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/easter-eggs-in-go-source-code-2l02/</link>
			<pubDate>Fri, 17 Jul 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/easter-eggs-in-go-source-code-2l02/</guid>
			<description>前言 前段时间，我在某个 Slack 工作区与朋友聊天： 朋友：“有人知道为什么time.minWall 的默认值是 1885 吗？” 我：“不知道，也许是从《回到未来 3》那一年开始的？” 我那么说基本是在开玩笑，因为我也不知道为什么将其设置为 1885 年。尽管其背后的事实与我在 Go 中的日常编码没有任何关系，但我还是情不自禁地询问了幕后花絮。我在团队聊天中问了我的同伴 Gophers，但似乎没人能找到</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>前段时间，我在某个 Slack 工作区与朋友聊天：</p>
<blockquote>
<p>朋友：“有人知道为什么<code>time.minWall</code> 的默认值是 1885 吗？”
我：“不知道，也许是从《<em>回到未来 3</em>》那一年开始的？”</p>
</blockquote>
<p>我那么说基本是在开玩笑，因为我也不知道为什么将其设置为 1885 年。尽管其背后的事实与我在 Go 中的日常编码没有任何关系，但我还是情不自禁地询问了幕后花絮。我在团队聊天中问了我的同伴 Gophers，但似乎没人能找到相关的线索。</p>
<p>最后，我直接向 Russ Cox（<a href="https://twitter.com/_rsc" target="_blank" rel="noopener">@_rsc</a>
）发送了一封电子邮件，以了解背景。</p>
<h2 id="timeminwall">time.minWall</h2>
<p>一个 const 值<code>time.minWall</code>设置为 1885，在如下代码中：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/release-branch.go1.15/src/time/time.go#L153" target="_blank" rel="noopener">src/time/time.go</a>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">hasMonotonic</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span>
    <span class="nx">maxWall</span>      <span class="p">=</span> <span class="nx">wallToInternal</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">33</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// year 2157
</span><span class="c1"></span>    <span class="nx">minWall</span>      <span class="p">=</span> <span class="nx">wallToInternal</span>               <span class="c1">// year 1885
</span><span class="c1"></span>    <span class="nx">nsecMask</span>     <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nx">nsecShift</span>    <span class="p">=</span> <span class="mi">30</span>
<span class="p">)</span>
</code></pre></div><p>这是个常数值，它定义了时间包中值的时代。这是一个常量值，它定义了 time 包的时间纪元。我们经常使用 UNIX 纪元（即 1970 年 1 月 1 日 UTC 的 00:00:00），但这只是几个用于表示日期时间值的标准或实现中的一个纪元，当然 Go 是一种多平台语言，因此 Go 中的纪元需要涵盖所有这些平台。</p>
<p>Russ Cox 在以下地方公开评论了 Go 的纪元。第一个是在 <a href="https://github.com/golang/go/issues/12914#issuecomment-277335863" target="_blank" rel="noopener">GitHub issue 上</a>
：</p>
<blockquote>
<p>已合入 Go 1.9。我将内部纪元移到 1885 年（最大年份为 2157 年），以避免 NTP 纪元派生的时间出现任何可能的问题。我还调整了设计文档，以调整此更改和一些较小的编码更改。</p>
</blockquote>
<p>但是这个评论只提到了为什么以及何时将内部纪元移到 1885 年，而没有提及为什么他们没有移至其他年份，例如 1900 年。</p>
<p>第二个是内部纪元移动的提案文档。</p>
<ul>
<li><a href="https://github.com/golang/proposal/blob/master/design/12914-monotonic.md" target="_blank" rel="noopener">提案：Go 中的单调时间测量</a>
</li>
</ul>
<blockquote>
<p>基于 Unix 的系统通常使用 1970，而基于 Windows 的系统通常使用 1980。我们不知道任何使用更早默认壁钟时间（Wall Time）的系统，但是由于 NTP 协议纪元使用 1900，因此选择 1900 之前的年份似乎更具前瞻性。</p>
</blockquote>
<p>可见，理论依据也只是支持 1900 年之前的任何年份，而不是特指 1885 年。我几乎可以肯定，这一年来自“<em>回到未来 3”</em>，但我想 100％ 确定这一年，所以我联系了肯定知道这一点的人，即向 Russ Cox 发送了一封电子邮件，询问原因。他在一天之内做出了回应（考虑到 EDT 和 JST 之间的时区差异，这是非常快的）：</p>
<blockquote>
<p>是的，人们说服我移到 1900 年之前，而 1885 年是显而易见的选择，因为它对加利福尼亚的希尔山谷（Hill Valley）具有历史意义。:-)</p>
</blockquote>
<p>这就是我知道的！！同样，我很高兴能够从谁做出决定中得到真正的答案。</p>
<h2 id="httpalongtimeago">http.aLongTimeAgo</h2>
<p>尽管我很欣赏 Russ 的回答，但这还不是故事的结局。Russ 的回信中还有另外一行。</p>
<blockquote>
<p>另请参见 http.aLongTimeAgo，现在将其设置为 time.Unix(1, 0)，但以前是 time.Unix(233431200, 0)。</p>
</blockquote>
<p>正如他所说，在 Go1.15 中，它设置为<code>time.Unix(1, 0)</code>。</p>
<ul>
<li><a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.15/src/net/http/http.go#L30" target="_blank" rel="noopener">Go 1.15: src/net/http/http.go</a>
</li>
</ul>
<pre tabindex="0"><code>// aLongTimeAgo is a non-zero time, far in the past, used for
// immediate cancellation of network operations.
var aLongTimeAgo = time.Unix(1, 0)
</code></pre><p>因此，我们在源码中确认其原始值。你可以在 Go 1.8 中找到它。</p>
<ul>
<li><a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.8/src/net/http/http.go#L23" target="_blank" rel="noopener">Go 1.8: src/net/http/http.go</a>
</li>
</ul>
<pre tabindex="0"><code>// aLongTimeAgo is a non-zero time, far in the past, used for
// immediate cancelation of network operations.
var aLongTimeAgo = time.Unix(233431200, 0)
</code></pre><p>我们将 UNIX 时间转换为人类可读的格式。当然，Go 提供了超级简单的方法。</p>
<ul>
<li><a href="https://play.golang.org/p/c4u1lF5Q6xQ" target="_blank" rel="noopener">示例代码：以人类可读的格式读取 UNIX 时间</a>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">pdt</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">LoadLocation</span><span class="p">(</span><span class="s">&#34;America/Los_Angeles&#34;</span><span class="p">)</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Unix</span><span class="p">(</span><span class="mi">233431200</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="nf">In</span><span class="p">(</span><span class="nx">pdt</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果是：</p>
<pre tabindex="0"><code>1977-05-25 11:00:00 -0700 PDT
</code></pre><p>我们得到 2 条提示：“A Long Time Ago”和 “1977-05-25”。这两个是：</p>
<p><p class="md__image">
  <img src="../imgs/eggs01.jpeg"
    alt=""  />
</p>
</p>
<p>当然，除了*《星球大战：第四集》外*，别无其他。它于1977年5月25日发布的（<a href="https://en.wikipedia.org/wiki/Star_Wars_%28film%29" target="_blank" rel="noopener">Wikipedia</a>
）</p>
<p>Go 包中如何使用此值呢？这是通过指定过去时间的截止日期来强制取消现有连接，例如：</p>
<pre tabindex="0"><code>cr.conn.rwc.SetReadDeadline(aLongTimeAgo)
</code></pre><p>当该值被改为 <code>time.Unix(1, 0)</code> 时，有人注意到了，因此对此作了一些评论（比如 1977-05-25 是谁的生日吗？）。我喜欢看到这些评论。这些有趣的聊天有时会在更改列表中进行。</p>
<ul>
<li><a href="https://github.com/golang/go/commit/6983b9a57955fa12ecd81ab8394ee09e64ef21b9" target="_blank" rel="noopener">net, net/http: 调整过去的时间到更早的时间</a>
</li>
</ul>
<h2 id="致谢">致谢</h2>
<ul>
<li>Russ Cox：感谢您回答我的问题和其他信息。另外，感谢您允许公开分享此内容。引用他的评论：</li>
</ul>
<blockquote>
<p>放心吧。这里没有秘密。</p>
</blockquote>
<ul>
<li><a href="https://twitter.com/broady" target="_blank" rel="noopener">Chris Broadfoot</a>
 和 <a href="https://twitter.com/val_deleplace" target="_blank" rel="noopener">Valentin Deleplace</a>
：感谢你们在群聊中一起找到线索。</li>
<li><a href="https://twitter.com/mattn_jp" target="_blank" rel="noopener">mattn</a>
：感谢您让我知道人们对此价值<a href="https://twitter.com/mattn_jp" target="_blank" rel="noopener">有何</a>
反应的 GitHub 评论线。</li>
</ul>
<h2 id="注意">注意</h2>
<p>该文最初于 2020-07-17 发布于我的日语博客中。</p>
<ul>
<li><a href="https://ymotongpoo.hatenablog.com/entry/2020/07/17/093000" target="_blank" rel="noopener">https://ymotongpoo.hatenablog.com/entry/2020/07/17/093000</a>
</li>
</ul>
<blockquote>
<p>原文链接：https://dev.to/ymotongpoo/easter-eggs-in-go-source-code-2l02</p>
<p>作者：Yoshi Yamaguchi</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>GoLand 2020.2 Beta 版发布：go.mod 升级以及对泛型的实验性支持</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/2020.2.beta/</link>
			<pubDate>Thu, 16 Jul 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/2020.2.beta/</guid>
			<description>GoLand 2020.2 达到 Beta。这意味着我们将结束一连串的新功能开发，将重点转移到完善我们已经完成的工作上，并开始计算发布日之前的日子！
与我们的“抢先体验计划”版本相比，该测试版非常稳定，但请记住，可能仍然在某处存在 Bug。
同样请注意，此 Beta 版本是 EAP 周期中的最后一个版本，不需要订阅即可使用（如果您只是想尝试 GoLand，请尝试）。测试版通常会在发布候选版本之后出现，一旦我们发现该版本足够好并且可以在您的计算机上安装了。
在此发布周期中，我们为即将推出的 GoLand 2020.2 打包了 Go 模块的新功能，更好地呈现了代码中可能存在的问题和薄弱环节，提供了新的代码检查功能以及新的代码编辑功能，例如期待已久的 “Add Caret Per Selected Line”，改进了后台流程，使其更透明，更快，更多！
让我们来看看即将发布的版本中的新功能。选择您感兴趣的主题，或浏览整个博客文章以了解每个新功能。
 Go Modules Generics a.k.a. Type Parameters Code Editing Code Inspections Take Variadic Arguments Under Сontrol References from Comments Save Projects as Templates Under the Hood Processes Version Control  Go Modules 支持 GOMODCACHE 环境变量 从 Go 1.15 开始，可以使用新的 GOMODCACHE 环境变量将 Go Modules 缓存的默认位置从 $GOPATH/pkg/mod 更改为另一个文件夹。
为此，只需在 “Preferences/Settings | Go Modules | Environment” 设置 GOMODCACHE 即可。
IDE 将识别自定义位置，并将其用于具有依赖关系的所有后续操作。同步依赖项快速修复程序（可通过 Alt + Enter 实现）会将依赖项下载到 GOMODCACHE，外部库也将在新的自定义位置显示依赖项。
升级 go.mod 文件 行注释（在 Windows/Linux 上为 Ctrl + /，在 macOS 上为 ⌘ + /）可用于 go.mod 文件。
现在，当您键入 replace，exclude 和 require 语句的左括号时，GoLang 立即自动为你添加右括号。
泛型（又称类型参数） 6月16日，Go Team 宣布了泛型（也称为类型参数）设计草案。请访问 Golang 文档以获取有关该概念的完整详细信息 。
这是一个重大的发展，因此我们立即着手增加对它的支持。GoLand 2020.2 Beta 提供了对泛型的实验性支持，您可以通过在 Settings/Preferences | Go 启用对泛型的实验性支持。
此初始支持提供语法高亮显示和基本参考解析，并且仅在 go2 文件中有效。
请注意，有关泛型的工作仍在进行中，我们目前尚无法提供全面的支持。
尽管如此，请分享您的体验和您可能有的任何建议。它确实可以帮助我们完善到目前为止已完成的工作，因此我们可以使其可靠并使用更高级的功能进行填充。
代码编辑 想要将快速修复的结果应用于代码之前预览其结果，请使用 Alt + Enter 快捷方式调用显示上下文操作，选择所需的快速修复，然后在 macOS 上按 Alt + Space 或在 Windows 和 Linux 上为 Ctrl + Shift + I。
新的“按选定的行添加插入（多行操作）”操作会在每个选定行的末尾插入，并取消选择这些行。在 Windows/Linux 上使用快捷键 Alt + Shift + G 或在 macOS 上使用 ⌥ + ⇧ + G 调用它。
在 Preferences/Settings | Editor | Code Style | Go | Wrapping and Braces 中为调用参数，函数参数和复合文字元素配置换行。或者，您可以使用 Alt + Enter 键，调出 Put arguments on separate lines 和 *Put arguments on one line，*以手动拆分和合并元素。</description>
			<content type="html"><![CDATA[<p>GoLand 2020.2 达到 Beta。这意味着我们将结束一连串的新功能开发，将重点转移到完善我们已经完成的工作上，并开始计算发布日之前的日子！</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-1.png"
    alt=""  />
</p>
</p>
<p>与我们的“抢先体验计划”版本相比，该测试版非常稳定，但请记住，可能仍然在某处存在 Bug。</p>
<p>同样请注意，此 Beta 版本是 EAP 周期中的最后一个版本，不需要订阅即可使用（如果您只是想尝试 GoLand，请尝试）。测试版通常会在发布候选版本之后出现，一旦我们发现该版本足够好并且可以在您的计算机上安装了。</p>
<p>在此发布周期中，我们为即将推出的 GoLand 2020.2 打包了 Go 模块的新功能，更好地呈现了代码中可能存在的问题和薄弱环节，提供了新的代码检查功能以及新的代码编辑功能，例如期待已久的 “Add Caret Per Selected Line”，改进了后台流程，使其更透明，更快，更多！</p>
<p>让我们来看看即将发布的版本中的新功能。选择您感兴趣的主题，或浏览整个博客文章以了解每个新功能。</p>
<ul>
<li>Go Modules</li>
<li>Generics a.k.a. Type Parameters</li>
<li>Code Editing</li>
<li>Code Inspections</li>
<li>Take Variadic Arguments Under Сontrol</li>
<li>References from Comments</li>
<li>Save Projects as Templates</li>
<li>Under the Hood Processes</li>
<li>Version Control</li>
</ul>
<h2 id="go-modules">Go Modules</h2>
<h3 id="支持-gomodcache-环境变量">支持 GOMODCACHE 环境变量</h3>
<p>从 Go 1.15 开始，可以使用新的 GOMODCACHE 环境变量将 Go Modules 缓存的默认位置从 $GOPATH/pkg/mod 更改为另一个文件夹。</p>
<p>为此，只需在 “<em>Preferences/Settings | Go Modules | Environment</em>” 设置 GOMODCACHE 即可。</p>
<p>IDE 将识别自定义位置，并将其用于具有依赖关系的所有后续操作。同步依赖项快速修复程序（可通过 Alt + Enter 实现）会将依赖项下载到 GOMODCACHE，外部库也将在新的自定义位置显示依赖项。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-2.png"
    alt=""  />
</p>
</p>
<h2 id="升级-gomod-文件">升级 go.mod 文件</h2>
<p>行注释（在 Windows/Linux 上为 Ctrl + /，在 macOS 上为 ⌘ + /）可用于 go.mod 文件。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-3.gif"
    alt=""  />
</p>
</p>
<p>现在，当您键入 replace，exclude 和 require 语句的左括号时，GoLang 立即自动为你添加右括号。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-4.gif"
    alt=""  />
</p>
</p>
<h2 id="泛型又称类型参数">泛型（又称类型参数）</h2>
<p>6月16日，Go Team 宣布了泛型（也称为类型参数）设计草案。请访问 Golang 文档以获取有关该概念的<a href="https://go.googlesource.com/proposal/&#43;/refs/heads/master/design/go2draft-type-parameters.md" target="_blank" rel="noopener">完整详细信息</a>
。</p>
<p>这是一个重大的发展，因此我们立即着手增加对它的支持。GoLand 2020.2 Beta 提供了对泛型的实验性支持，您可以通过在 <em>Settings/Preferences | Go</em> 启用对泛型的实验性支持。</p>
<p>此初始支持提供语法高亮显示和基本参考解析，并且仅在 go2 文件中有效。</p>
<p>请注意，有关泛型的工作仍在进行中，我们目前尚无法提供全面的支持。</p>
<p>尽管如此，请分享您的体验和您可能有的任何建议。它确实可以帮助我们完善到目前为止已完成的工作，因此我们可以使其可靠并使用更高级的功能进行填充。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-5.png"
    alt=""  />
</p>
</p>
<h2 id="代码编辑">代码编辑</h2>
<p>想要将快速修复的结果应用于代码之前预览其结果，请使用 Alt + Enter 快捷方式调用显示上下文操作，选择所需的快速修复，然后在 macOS 上按 Alt + Space 或在 Windows 和 Linux 上为 Ctrl + Shift + I。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-6.gif"
    alt=""  />
</p>
</p>
<p>新的“按选定的行添加插入（多行操作）”操作会在每个选定行的末尾插入，并取消选择这些行。在 Windows/Linux 上使用快捷键 Alt + Shift + G 或在 macOS 上使用 ⌥ + ⇧ + G 调用它。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-7.gif"
    alt=""  />
</p>
</p>
<p>在 <em>Preferences/Settings | Editor | Code Style | Go | Wrapping and Braces</em> 中为调用参数，函数参数和复合文字元素配置换行。或者，您可以使用 Alt + Enter 键，调出 <em>Put arguments on separate lines</em> 和 *Put arguments on one line，*以手动拆分和合并元素。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-8.gif"
    alt=""  />
</p>
</p>
<h2 id="代码检查">代码检查</h2>
<p>GoLand 2020.2 有了一个新的检查部件（<em>Inspections Widget</em>）！它位于代码编辑器的右上角，显示当前文件中的警告，错误和错别字数量。您可以使用箭头图标或“下一个错误”操作（F2）遍历它们。</p>
<p>该小部件可让您配置突出显示级别（从无、仅错误或所有问题中选择），更改检查的严重性级别以及切换紧凑视图。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-9.gif"
    alt=""  />
</p>
</p>
<p>我们还添加了一个“问题视图”工具窗口，该窗口显示当前文件中的警告和错误列表，为您提供这些问题的描述，并让您立即使用 Alt + Enter 进行修复。在“问题视图”工具窗口中右键单击问题，以直接移至发生错误的代码行。要打开“问题视图”，请单击“检查”小部件或转到 <em>View | Tool Window | Problems</em>。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-10.gif"
    alt=""  />
</p>
</p>
<p>GoLand 2020.2 现在在所有情况下都在项目视图中标记包含错误的文件，以使您更容易发现它们。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-11.png"
    alt=""  />
</p>
</p>
<p>现在，新的代码检查可以处理 string(int) 转换可能出现的问题，这些转换返回 Unicode代码点 x 的 UTF-8 表示形式，而不是预期的 x 十进制字符串表示形式。GoLand 将通知您有关此类潜在错误的信息，并提供专用的快速修复程序。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-12.gif"
    alt=""  />
</p>
</p>
<p>GoLand 会通知您有关测试和示例的常见错误用法，因此您不再需要为此而明确地使用 go vet。在简单情况下，IDE 还提供了快速修复程序。例如，它建议将 Testme 重命名为 TestMe。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-13.png"
    alt=""  />
</p>
</p>
<p>格式错误的 struct tags 代码检查将检查 struct tags 是否符合 Go 约定，并通知您潜在的问题。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-14.png"
    alt=""  />
</p>
</p>
<p>不可能的接口类型断言代码检查将检查类型断言 v.(T) 和相应的 type-switch case，其中 v 的静态类型 V 是无法实现目标接口 T 的接口。这发生在当 V 和 T 包含相同名称但签名不同的方法时。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-15.png"
    alt=""  />
</p>
</p>
<h2 id="在控制下接受可变参数的论证">在控制下接受可变参数的论证</h2>
<p>引入变量重构（在 Windows 和 Linux 上为 Ctrl + Alt + V，在 macOS 上为 ⌘ + ⌥ + V）可以将一些可变参数打包到新的 slice 变量中；相反的，内联变量（在 MacOS 上为 ⌥ + ⌘ + N 和在 Linux 上为 Ctrl + Alt + N），则将切片分解为可变参数。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-16.gif"
    alt=""  />
</p>
</p>
<p>此外，您现在可以通过 Unpack slice 快速修复来处理解包的可变参数的问题。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-17.gif"
    alt=""  />
</p>
</p>
<h2 id="注释中的引用">注释中的引用</h2>
<p>IDE 显示注释中对相关程序包级别声明的引用，并允许您通过“导航到声明或使用”操作（在 macOS 上为 ⌘ + B，在Windows / Linux上为 Ctrl + B）来跳转。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-18.gif"
    alt=""  />
</p>
</p>
<h2 id="将项目另存为模板">将项目另存为模板</h2>
<p>现在，您可以通过将项目或文件另存为自定义项目模板来重复使用它们：选择 <em>Tools</em> | <em>Save Project as Template</em>。IDE 将使用文件、文件夹和构建配置重新创建项目树。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-19.png"
    alt=""  />
</p>
</p>
<h2 id="后台进程">后台进程</h2>
<h3 id="更好地解决带有-vendor-文件夹的项目">更好地解决带有 Vendor 文件夹的项目</h3>
<p>启用 vendoring 模式后，仅使用项目中 Vendor 文件夹中存储的依赖项包来构建应用程序。</p>
<p>现在，如果项目有一个 vendor 文件夹，并且您已经选中了 <em>Settings/Preferences | Go | Go Modules</em> 中的 <em>Enable vendoring mode**automatically</em>，这时只会使用 vendor 文件夹，而不会查询模块缓存。一个重要的优点是您可以更快地发现未解决的依赖项。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-20.gif"
    alt=""  />
</p>
</p>
<h2 id="go-list-命令">Go list 命令</h2>
<p>GoLand 依序运行 go list 命令，并提供一个进度条，其中包含有关队列中 go list 命令的实际数量的信息。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-21.png"
    alt=""  />
</p>
</p>
<h2 id="版本控制">版本控制</h2>
<h3 id="wsl2-在-windows-上对-git-的支持">WSL2 在 Windows 上对 Git 的支持</h3>
<p>GoLand 2020.2 将允许您使用 WSL2 中的 Git，该版本在 Windows 10（2004 年 5 月更新）的本地版本中可用。如果 Windows 中未安装 Git，GoLand 将在 WSL 中自动查找 Git 并使用它。对于从 WSL 打开的项目，它还将自动从 WSL 切换到 Git（通过 \wsl$ 路径）。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-22.gif"
    alt=""  />
</p>
</p>
<h3 id="改进的-git-操作对话框">改进的 Git 操作对话框</h3>
<p>我们针对 <em>Merge</em>, <em>Pull</em> 和 <em>Rebase</em> 之类的操作重新设计了 Git 对话框，以使它们更加一致和好用。我们还使您更容易理解将执行哪个 Git 命令，并在 “Pull” 对话框中添加了 &ndash;rebase 选项，在“Merge”对话框中添加了&ndash;no-verify 选项。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-23.png"
    alt=""  />
</p>
</p>
<h3 id="全面支持-github-pull-request">全面支持 GitHub Pull Request</h3>
<p>GitHub Pull Requests 配备齐全！在不离开 GoLand 的情况下浏览，分配，管理，甚至合并拉取请求，查看时间线和内联注释，提交注释和评论以及接受更改。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-24.png"
    alt=""  />
</p>
</p>
<h3 id="从日志中压缩squash本地提交">从日志中压缩（Squash）本地提交</h3>
<p>现在，您可以在 Git 工具窗口的“日志”选项卡中选择多个本地提交，并将其压缩为一个。可以从右键单击上下文菜单中执行此操作。</p>
<h3 id="改进了比较分支结果的表示方式">改进了“比较分支”结果的表示方式</h3>
<p>现在，当您在 GoLand 中比较 2 个分支时，可以在一个视图中查看比较后的分支的提交。IDE 现在将在编辑器中而不是在 VCS 工具窗口中打开要比较的两个分支的日志，在该窗口中没有足够的空间来显示所有信息。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-25.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/2020/07/16/goland-2020-2-reaches-beta/</p>
<p>作者：<a href="https://blog.jetbrains.com/author/ekaterina-zharovajetbrains-com" target="_blank" rel="noopener">Ekaterina Zharova</a>
</p>
<p>日期：2020-07-16</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>对 gRPC 的 Rust 和 Go 版本进行基准测试</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/benchmarking-grpc-in-rust-go/</link>
			<pubDate>Thu, 16 Jul 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/benchmarking-grpc-in-rust-go/</guid>
			<description>背景 如果你计划构建可靠，内存安全 ，高性能的应用程序，那么 Rust＆Go 无疑会是你的选择。 如果您希望从内部应用程序中获得更高的性能，则可能还需要考虑使用 gRPC 而不是普通的 REST API。所有这些都是减少您的计算开销的解决方案。 我尝试比较各种库以了解它们的性能，并希望对你有所帮助。 关注的库 tower-grpc (Rust) 高性能 rust 库，尽管已被 tonic 替代 grpc-go (Golang) grpc 的官方 Go 模块 grpc-rust (Rust) 仍在开发中，另一个 rust grpc 库。看起来</description>
			<content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>如果你计划构建可靠，<a href="https://blog.gds-gov.tech/appreciating-rust-memory-safety-438301fee097" target="_blank" rel="noopener">内存安全</a>
，高性能的应用程序，那么 Rust＆Go 无疑会是你的选择。</p>
<p>如果您希望从内部应用程序中获得更高的性能，则可能还需要考虑使用 <a href="https://grpc.io/docs/what-is-grpc/introduction/" target="_blank" rel="noopener">gRPC</a>
 而不是普通的 <a href="https://restfulapi.net/" target="_blank" rel="noopener">REST</a>
 API。所有这些都是减少您的计算开销的解决方案。</p>
<p>我尝试比较各种库以了解它们的性能，并希望对你有所帮助。</p>
<h2 id="关注的库">关注的库</h2>
<ul>
<li>
<p><a href="https://github.com/tower-rs/tower-grpc" target="_blank" rel="noopener">tower-grpc</a>
 (Rust)</p>
<p>高性能 rust 库，尽管已被 tonic 替代</p>
</li>
<li>
<p><a href="https://github.com/grpc/grpc-go" target="_blank" rel="noopener">grpc-go</a>
 (Golang)</p>
<p>grpc 的官方 Go 模块</p>
</li>
<li>
<p><a href="https://github.com/stepancheg/grpc-rust" target="_blank" rel="noopener">grpc-rust</a>
 (Rust)</p>
<p>仍在开发中，另一个 rust grpc 库。看起来很不错</p>
</li>
<li>
<p><a href="https://github.com/hyperium/tonic" target="_blank" rel="noopener">tonic</a>
 (Rust)</p>
<p>tower-grpc 库的改进更新，支持新的 await 语法</p>
</li>
<li>
<p><a href="https://github.com/grpc/grpc-node" target="_blank" rel="noopener">grpc-node</a>
 (NodeJs)</p>
<p>包含有基准基准点</p>
</li>
<li>
<p><a href="https://github.com/tikv/grpc-rs" target="_blank" rel="noopener">grpc-rs</a>
 (Rust — C bindings)</p>
<p>使用 <a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">grpc</a>
 的 rust 库</p>
</li>
</ul>
<h2 id="基准测试工具">基准测试工具</h2>
<p>对于基准测试，我将在 gRPC 中使用与 <a href="https://github.com/rakyll/hey" target="_blank" rel="noopener">Hey</a>
 等效的 <a href="https://github.com/bojand/ghz" target="_blank" rel="noopener">ghz</a>
。</p>
<p>该测试将重点关注如果使用上述每个库将 10,000 个并发请求的相同负载发送到服务器，将有多少开销。我将为每个使用相同的 <a href="https://github.com/grpc/grpc-go/blob/master/examples/helloworld/helloworld/helloworld.proto" target="_blank" rel="noopener">helloworld</a>
 greeter。不会为任何测试启用 TLS，因此我们可以大致了解每种测试的原始性能。</p>
<h3 id="grpc-go">grpc-go</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 229.40 ms
  Slowest: 6.26 ms
  Fastest: 0.11 ms
  Average: 1.04 ms
  Requests/sec: 43591.54Response <span class="nb">time</span> histogram:
  0.114 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  0.728 <span class="o">[</span>3355<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.343 <span class="o">[</span>4580<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.957 <span class="o">[</span>1519<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎
  2.572 <span class="o">[</span>294<span class="o">]</span>  <span class="p">|</span>∎∎∎
  3.187 <span class="o">[</span>36<span class="o">]</span>   <span class="p">|</span>
  3.801 <span class="o">[</span>11<span class="o">]</span>   <span class="p">|</span>
  4.416 <span class="o">[</span>74<span class="o">]</span>   <span class="p">|</span>∎
  5.030 <span class="o">[</span>52<span class="o">]</span>   <span class="p">|</span>
  5.645 <span class="o">[</span>45<span class="o">]</span>   <span class="p">|</span>
  6.259 <span class="o">[</span>33<span class="o">]</span>   <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 0.46 ms
  <span class="m">25</span> % in 0.64 ms
  <span class="m">50</span> % in 0.88 ms
  <span class="m">75</span> % in 1.24 ms
  <span class="m">90</span> % in 1.68 ms
  <span class="m">95</span> % in 2.00 ms
  <span class="m">99</span> % in 4.77 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="tonic">tonic</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 581.81 ms
  Slowest: 6.39 ms
  Fastest: 0.17 ms
  Average: 2.84 ms
  Requests/sec: 17187.66Response <span class="nb">time</span> histogram:
  0.174 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  0.796 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>
  1.418 <span class="o">[</span>6<span class="o">]</span>    <span class="p">|</span>
  2.040 <span class="o">[</span>167<span class="o">]</span>  <span class="p">|</span>∎
  2.662 <span class="o">[</span>3427<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.284 <span class="o">[</span>5074<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.906 <span class="o">[</span>1048<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎
  4.528 <span class="o">[</span>217<span class="o">]</span>  <span class="p">|</span>∎∎
  5.150 <span class="o">[</span>29<span class="o">]</span>   <span class="p">|</span>
  5.773 <span class="o">[</span>21<span class="o">]</span>   <span class="p">|</span>
  6.395 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 2.35 ms
  <span class="m">25</span> % in 2.55 ms
  <span class="m">50</span> % in 2.79 ms
  <span class="m">75</span> % in 3.07 ms
  <span class="m">90</span> % in 3.39 ms
  <span class="m">95</span> % in 3.66 ms
  <span class="m">99</span> % in 4.22 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="grpc-node">grpc-node</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 589.25 ms
  Slowest: 12.56 ms
  Fastest: 1.21 ms
  Average: 2.88 ms
  Requests/sec: 16970.81Response <span class="nb">time</span> histogram:
  1.206 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  2.341 <span class="o">[</span>2592<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.476 <span class="o">[</span>5516<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  4.612 <span class="o">[</span>1588<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎
  5.747 <span class="o">[</span>180<span class="o">]</span>  <span class="p">|</span>∎
  6.882 <span class="o">[</span>42<span class="o">]</span>   <span class="p">|</span>
  8.017 <span class="o">[</span>32<span class="o">]</span>   <span class="p">|</span>
  9.152 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>
  10.288 <span class="o">[</span>20<span class="o">]</span>  <span class="p">|</span>
  11.423 <span class="o">[</span>6<span class="o">]</span>   <span class="p">|</span>
  12.558 <span class="o">[</span>18<span class="o">]</span>  <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 2.14 ms
  <span class="m">25</span> % in 2.33 ms
  <span class="m">50</span> % in 2.62 ms
  <span class="m">75</span> % in 3.24 ms
  <span class="m">90</span> % in 3.85 ms
  <span class="m">95</span> % in 4.26 ms
  <span class="m">99</span> % in 6.41 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="tower-grpc">tower-grpc</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 571.88 ms
  Slowest: 10.59 ms
  Fastest: 0.25 ms
  Average: 2.76 ms
  Requests/sec: 17486.12Response <span class="nb">time</span> histogram:
  0.246 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  1.280 <span class="o">[</span>139<span class="o">]</span>  <span class="p">|</span>∎
  2.314 <span class="o">[</span>2927<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.348 <span class="o">[</span>5198<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  4.382 <span class="o">[</span>1390<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎
  5.416 <span class="o">[</span>114<span class="o">]</span>  <span class="p">|</span>∎
  6.450 <span class="o">[</span>61<span class="o">]</span>   <span class="p">|</span>
  7.484 <span class="o">[</span>80<span class="o">]</span>   <span class="p">|</span>∎
  8.518 <span class="o">[</span>47<span class="o">]</span>   <span class="p">|</span>
  9.552 <span class="o">[</span>31<span class="o">]</span>   <span class="p">|</span>
  10.586 <span class="o">[</span>12<span class="o">]</span>  <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 1.80 ms
  <span class="m">25</span> % in 2.20 ms
  <span class="m">50</span> % in 2.65 ms
  <span class="m">75</span> % in 3.13 ms
  <span class="m">90</span> % in 3.64 ms
  <span class="m">95</span> % in 4.05 ms
  <span class="m">99</span> % in 7.18 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="grpc-rust">grpc-rust</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 479.30 ms
  Slowest: 8.15 ms
  Fastest: 0.90 ms
  Average: 2.34 ms
  Requests/sec: 20863.64Response <span class="nb">time</span> histogram:
  0.901 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  1.626 <span class="o">[</span>193<span class="o">]</span>  <span class="p">|</span>∎
  2.351 <span class="o">[</span>5587<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.076 <span class="o">[</span>3562<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.801 <span class="o">[</span>506<span class="o">]</span>  <span class="p">|</span>∎∎∎∎
  4.526 <span class="o">[</span>119<span class="o">]</span>  <span class="p">|</span>∎
  5.251 <span class="o">[</span>16<span class="o">]</span>   <span class="p">|</span>
  5.976 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>
  6.701 <span class="o">[</span>2<span class="o">]</span>    <span class="p">|</span>
  7.426 <span class="o">[</span>2<span class="o">]</span>    <span class="p">|</span>
  8.151 <span class="o">[</span>7<span class="o">]</span>    <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 1.87 ms
  <span class="m">25</span> % in 2.03 ms
  <span class="m">50</span> % in 2.25 ms
  <span class="m">75</span> % in 2.57 ms
  <span class="m">90</span> % in 2.90 ms
  <span class="m">95</span> % in 3.23 ms
  <span class="m">99</span> % in 4.11 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="grpc-rs">Grpc-rs</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 289.82 ms
  Slowest: 4.22 ms
  Fastest: 0.22 ms
  Average: 1.36 ms
  Requests/sec: 34504.74Response <span class="nb">time</span> histogram:
  0.222 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  0.621 <span class="o">[</span>195<span class="o">]</span>  <span class="p">|</span>∎∎
  1.021 <span class="o">[</span>1829<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.420 <span class="o">[</span>4059<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.820 <span class="o">[</span>2625<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  2.219 <span class="o">[</span>972<span class="o">]</span>  <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎
  2.618 <span class="o">[</span>239<span class="o">]</span>  <span class="p">|</span>∎∎
  3.018 <span class="o">[</span>45<span class="o">]</span>   <span class="p">|</span>
  3.417 <span class="o">[</span>18<span class="o">]</span>   <span class="p">|</span>
  3.817 <span class="o">[</span>6<span class="o">]</span>    <span class="p">|</span>
  4.216 <span class="o">[</span>11<span class="o">]</span>   <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 0.87 ms
  <span class="m">25</span> % in 1.07 ms
  <span class="m">50</span> % in 1.30 ms
  <span class="m">75</span> % in 1.62 ms
  <span class="m">90</span> % in 1.90 ms
  <span class="m">95</span> % in 2.07 ms
  <span class="m">99</span> % in 2.56 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h2 id="汇总概要">汇总概要</h2>
<p><p class="md__image">
  <img src="../imgs/rust-go-bench-01.png"
    alt="总响应时间（以毫秒为单位）。越低越好。"  />
</p>
</p>
<p>总响应时间（以毫秒为单位）。越低越好。</p>
<p><p class="md__image">
  <img src="../imgs/rust-go-bench-02.png"
    alt="吞吐量（请求/秒）。越高越好。"  />
</p>
</p>
<p>吞吐量（请求/秒）。越高越好。</p>
<h2 id="总结">总结</h2>
<p>结果表明，在性能方面，rust 与 node 相当，这是一个令人震惊的结果。</p>
<p>Go 库在并发性和最小开销方面均表现出色。</p>
<p>如果有人对 Go 库表现优异有些疑惑，请给留言给出你的看法！</p>
<blockquote>
<p>原文链接：<a href="https://medium.com/@Rustling_gopher/benchmarking-grpc-in-rust-go-184545e7688a" target="_blank" rel="noopener">https://medium.com/@Rustling_gopher/benchmarking-grpc-in-rust-go-184545e7688a</a>
</p>
<p>作者：Rustler</p>
<p>编译：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>从签名售书说起</title>
			<link>https://polarisxu.studygolang.com/posts/talk/sell-my-book/</link>
			<pubDate>Thu, 09 Jul 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/sell-my-book/</guid>
			<description>上周通过公众号对外公布新手开卖后，有人想要签名版。由于双作者，涉及到双签，知道可能会很麻烦，但第一次，也有可能是最后一次，和煎鱼沟通后决定搞搞。 大概谈谈我们的操作过程。 1、编辑帮我们买书，104 本；也是想办法弄到了当时最便宜的价格； 2、寄到我家里。周六、日分批到的，去封皮签名，大部分还写了一些 Go 箴言，但还有 26 本周末没到； 3、弄好后寄到深圳。用什么快递也是有讲</description>
			<content type="html"><![CDATA[<p>上周通过公众号对外公布新手开卖后，有人想要签名版。由于双作者，涉及到双签，知道可能会很麻烦，但第一次，也有可能是最后一次，和煎鱼沟通后决定搞搞。</p>
<p>大概谈谈我们的操作过程。</p>
<p>1、编辑帮我们买书，104 本；也是想办法弄到了当时最便宜的价格；</p>
<p>2、寄到我家里。周六、日分批到的，去封皮签名，大部分还写了一些 Go 箴言，但还有 26 本周末没到；</p>
<p><p class="md__image">
  <img src="../imgs/go-tour-01.png"
    alt=""  />
</p>
</p>
<p>3、弄好后寄到深圳。用什么快递也是有讲究的。目标是尽可能费用低。对比 了多家，最后找了德邦物流。超重物品运输走物流比较合适。称了一下，一本书 0.8kg，104 本至少 83kg。</p>
<p>4、到深圳后煎鱼签完字一个个寄出去。</p>
<p>这里最麻烦的就是统计需要签名的读者信息和收款。</p>
<p>开始想的比较简单，把意向者拉入群，避免隐私问题，通过问卷的形式收集收货地址。在确认了运费后，通过支付宝收款。主要考虑支付宝可以看到实名，能够和收货地址上的对应上。但支付宝只显示姓名最后一个字。这还好，勉强能搞定。最麻烦的是让大家提交信息或付款。n 多次通过群公告通知所有人，还设置了群待办，依然有人或者没填信息或者填了信息不付款。一个个加好友，有些没法加，有些加了没反应等，各种情况都有。</p>
<p>说了上面这些，我到底想说什么？本文重点来了。</p>
<p><strong>重点 1</strong></p>
<p>不要低估任何看似简单的事情。这在我们的日常工作中很常见。大家脑海中应该浮现了类似的场景吧。</p>
<blockquote>
<p>场景一：</p>
<p>产品经理：这个很简单吧，不就是加一个按钮吗？</p>
<p>程序员：。。。</p>
</blockquote>
<blockquote>
<p>场景二：</p>
<p>老板：什么？这么简单的功能要开发这么久？</p>
<p>程序员：。。。</p>
</blockquote>
<p>有一项研究表明，人们总是会低估他人工作的难度，根源在于自己没有做过或对他人工作不了解。因此，一个重视效率，珍惜时间的人，在做自己从来没有做过的事情时，应该进行一些思考，分析评估事情的难点，可能存在的问题。如果是专业性的，可能需要咨询专业人士，避免浪费时间。</p>
<p>针对签名售书这件事，煎鱼问了曹大当初签名的情况，给的回馈是很麻烦，也给了一些建议或可能的坑。当然我们还是重视不够，没有深究，也许坑自己走一遍印象能够更深刻。</p>
<blockquote>
<p>温馨建议：在工作或生活中，不要麻木指责别人的工作，除非你自己做过或掌握了足够的信息；对于自己来说，准备做没做过的事情，如果比较耗时或重要，应该认真评估，避免浪费不必要的时间，同时效果可能还不好。</p>
</blockquote>
<p><strong>重点 2</strong></p>
<p>靠自觉遵守很多时候是不可行的，总是会出现不遵守的情况，特别是人数或次数多的时候。我们以为进群了就是要签名书的；我们以为 @ 所有人了，大家会看到消息并进行处理；我们以为填了信息的人会进行支付。。。好吧，我们太年轻~</p>
<p>对于程序员，你所在的公司会有这样那样的规范，不说遵守，有时候都不一定能记住。比如代码规范。如果只是简单的约定，靠程序员自觉的遵守，往往是不可行的。程序员号称都很懒，因此能自动化的一定要自动化，能用工具做的绝不人工。</p>
<p>那 Go 语言有哪些规范？如何借助工具辅助进行约束呢？</p>
<p>规范推荐阅读官方的文档：<a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">Go Code Review Comments</a>
，这是每个 Gopher 都应该至少阅读一遍的官方代码规范指南。另外 Uber 公开了其内部的 Go 语言代码规范，供参考：<a href="https://mp.weixin.qq.com/s/nA26g46tM_hu-khaGYniAQ" target="_blank" rel="noopener">Uber Go语言编码规范</a>
。</p>
<p>针对规范，我们有什么工具可以使用呢？</p>
<p>Go 语言提供的工具链是我喜欢 Go 的原因之一，官方提供了一系列工具，其中有一些用于辅助代码规范，使用最多的有：gofmt、goimports、golint 等，此外还有第三方的工具，像 <a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">golangci-lint</a>
 等。这些工具都可以配合你的编辑器使用。好的工具是效率提升的必要条件，因此建议大家花时间折腾下你使用的编辑器或熟悉你使用的编辑器（或 IDE）的一些功能。</p>
<p>以上闲扯，希望对大家之后工作或做事有一定帮助。</p>
<p><strong>福利</strong></p>
<p>上次朋友支持我们的新书，搞了一个抽奖，我看到了就参与一下，结果我竟然中奖了。大家调侃有黑幕，调侃应该双倍重抽。所以，我今天送两本《Go语言编程之旅》，感谢大家的支持！</p>
<p><strong>参与抽奖的请关注下我的公众号，你不会后悔，如果未关注，中奖了无效哦！</strong></p>
]]></content>
		</item>
		
		<item>
			<title>重磅！史上第一本带你做项目的 Go 图书开卖</title>
			<link>https://polarisxu.studygolang.com/posts/talk/my-first-action-book/</link>
			<pubDate>Thu, 02 Jul 2020 20:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/my-first-action-book/</guid>
			<description>2020 年过去了一半，这半年对所有人来说都不寻常。但也是这场疫情，让我完成了一件大事：出了一本 Go 语言图书，书名是：《Go 语言编程之旅：一起用 Go 做项目》。 海报 先上海报： 全书共分为 6 章，分别是命令行应用、HTTP 应用、RPC 应用、WebSocket 应用、进程内缓存和 Go 语言中的大杀器，其中前 5 章是 Go 语言开发中最常见的项目类型。本书对项目开发、细节分析、运行时分析等核心内</description>
			<content type="html"><![CDATA[<p>2020 年过去了一半，这半年对所有人来说都不寻常。但也是这场疫情，让我完成了一件大事：出了一本 Go 语言图书，书名是：《Go 语言编程之旅：一起用 Go 做项目》。</p>
<h2 id="海报">海报</h2>
<p>先上海报：</p>
<p><p class="md__image">
  <img src="https://img30.360buyimg.com/vc/jfs/t1/143768/33/1853/1056513/5efd2c6aEa179705e/48099b6c7b9e9c05.jpg"
    alt=""  />
</p>
</p>
<p>全书共分为 6 章，分别是命令行应用、HTTP 应用、RPC 应用、WebSocket 应用、进程内缓存和 Go 语言中的大杀器，其中前 5 章是 Go 语言开发中最常见的项目类型。本书对项目开发、细节分析、运行时分析等核心内容进行了较为深入的剖析，提供了相对完整的项目实践经验。在项目迭代过程中，难免会遇到问题，因此本书针对 Go 语言的大杀器（分析工具）及常见问题进行了全面讲解，帮助读者对各类问题进行排查。本书适合有一定 Go 语言基础的读者以及相关开发人员阅读。</p>
<h2 id="写书那些事">写书那些事</h2>
<p>2019 年 8 月份，博文视点的安娜加我微信，想我出一本 Go 语言的图书。因为时间关系，我并没有打算出。安娜直接约我见面聊，到我公司找我，还送我一本书。之后在微信上多次问我有无意向。有点心动，但担心烂尾。</p>
<p>之前跟 《Go 语言高级编程》的作者柴大交流，他写书时，因为怕烂尾，邀请了曹大一起，两个人相互鼓励、交流、讨论能更好的的完成。正好 2019 年年初认识了煎鱼，之后交流也比较多，他产出很高，写的文章质量不错，于是我和他沟通一起出书的事情。</p>
<p><p class="md__image">
  <img src="../imgs/book-01.png"
    alt=""  />
</p>
</p>
<p>事实证明我没看错人，煎鱼很靠谱，很自律，产出高、质量高，由于我比较忙，因此他主动承担了更多内容，不是找了他，这本书现在肯定不会面世。因此，他理所当然成为了第一作者。由衷感谢，合作愉快。2019 年 12 月中旬我还去了一趟深圳，和煎鱼一起吃了顿饭，交流了很多。年轻人很有想法，前途无量！</p>
<p>所以，看了很多煎鱼文章的，欢迎购买支持；如果你在学习 Go 语言的过程中，Go 语言中文网对你有点帮助，我运营的社区对你有帮助，欢迎购买支持；如果苦于学了 Go 没法实践，这本书也许可以帮助你，那就下单购买吧。</p>
<p>目前京东 7.5 折。</p>
<h2 id="感谢">感谢</h2>
<p>最后感谢我的伙伴煎鱼，感谢博文编辑美丽的安娜，感谢曹大、无闻、杨文大佬推荐，感谢傲飞、大彬、晓东花费宝贵的时间进行 Review。同时要感谢我的老婆，春节期间对我无微不至的照顾，让我全身心投入该书的写作中。</p>
]]></content>
		</item>
		
		<item>
			<title>从这些角度看 Go 是一门很棒的语言</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-is-awesome/</link>
			<pubDate>Mon, 22 Jun 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-is-awesome/</guid>
			<description>Go 当前引起了很多关注。让我们看一下 Go 好的部分。 我最近用 Go 写了一个 SSH 服务器 ，在其中启动容器。该项目已经发展到很大规模，并且我还向 Go 发起了 PR ，以修复我发现的错误。在积累了比 “Hello world！” 更多的经验之后，现在我有信心写出我真正喜欢的 Go 语言部分。 跨平台 Go 引起我注意的原因之一是其构建系统。Java 的最初承诺是它是跨平台的，但是它需要安装运行时的事实显然是一</description>
			<content type="html"><![CDATA[<p>Go 当前引起了很多关注。让我们看一下 Go 好的部分。</p>
<p><p class="md__image">
  <img src="../imgs/go-is-awesome.jpg"
    alt=""  />
</p>
</p>
<p>我最近用 Go 写了一个 <a href="https://github.com/janoszen/containerssh" target="_blank" rel="noopener">SSH 服务器</a>
，在其中启动容器。该项目已经发展到很大规模，并且我还向 Go <a href="https://go-review.googlesource.com/c/crypto/&#43;/236517" target="_blank" rel="noopener">发起了 PR</a>
，以修复我发现的错误。在积累了比 “Hello world！” 更多的经验之后，现在我有信心写出我真正喜欢的 Go 语言部分。</p>
<h2 id="跨平台">跨平台</h2>
<p>Go 引起我注意的原因之一是其构建系统。Java 的最初承诺是它是跨平台的，但是它需要安装运行时的事实显然是一个失败。而 Go 编译为本地二进制文件。在 Windows 上，您将获得一个 .exe 文件，在 Linux 上，您将获得一个 ELF 二进制文件，依此类推。而且，除非您使用 cgo，否则 Go 程序可以在几乎没有外部依赖的情况下运行。无需安装任何 .dll 或 .so 文件，Go 程序即可<a href="https://www.youtube.com/watch?v=YPN0qhSyWy8" target="_blank" rel="noopener">直接使用</a>
。</p>
<p>大部分时候，除了某些函数需要 libc 外，Go 程序可以在完全没有外部依赖的情况下运行。</p>
<p>Go 可以用来构建真正的跨平台二进制文件而无需安装笨拙的运行时（例如使用 Java 或 Python），这一事实是 Go 的主要吸引点。</p>
<h2 id="goroutines-和-channels">Goroutines 和 Channels</h2>
<p>当我开始使用 Go 语言时，我意识到它对并发的处理是多么的酷。传统上，您将使用线程或单独的进程来同时运行多个任务（例如 Java，C，C ++）。另外，您也可以依靠协作式多任务处理（例如 Javascript）来达到相同的效果。</p>
<p>对于线程和进程，操作系统必须执行的每个切换都会造成资源损耗。这称为上下文切换。换句话说，一个使用大量线程的粗心程序员将带来性能问题。</p>
<p>另一方面，协作多任务将在单个线程上运行。每当一项任务必须等待某件事时，另一项任务就会运行。如果一个任务占用了 CPU，其他任务将被饿死。</p>
<p>Go 以巧妙的方式将两者结合在一起。让我们以以下示例为例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nf">someOtherFunction</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>注意 go 关键字。通过使用此关键字，someOtherFunction() 可在 goroutine 中运行。想象一下 Go 作为线程池处理并发的方式。每当您运行 goroutine 时，它将在这些线程之一中运行。这样 Go 可以优化线程的使用以提高性能。</p>
<p>为了促进 goroutine 之间的数据传输，Go 引入了通道（channel），通道是应用程序中的消息队列，用于发送数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">chan</span> <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kt">bool</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kc">true</span>
    <span class="p">}()</span>

    <span class="c1">//This will wait until the goroutine finishes
</span><span class="c1"></span>    <span class="o">&lt;-</span> <span class="nx">done</span>
<span class="p">}</span>
</code></pre></div><p>从上面的代码中可以看到，<code>&lt;- channelname</code> 将堵塞当前 goroutine 的执行，直到有可用数据为止，这使得并发编程非常容易。</p>
<p>如果您对更多细节感兴趣，请查看 <a href="https://gobyexample.com/channels" target="_blank" rel="noopener">channel</a>
，<a href="https://gobyexample.com/context" target="_blank" rel="noopener">上下文</a>
和<a href="https://gobyexample.com/mutexes" target="_blank" rel="noopener">互斥锁</a>
。</p>
<h2 id="指针defer-和垃圾收集">指针，Defer 和垃圾收集</h2>
<p>当提到指针时，首先想到的是 C 或 C++。通常，这种记忆并不愉快。</p>
<p>在 Go 中，指针更像是引用。指针并非总是将数据复制到变量中，而是指向原始的内存。不管传递包含指针的变量多少次，任何修改都将始终更改原始值。</p>
<p>让我们看一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">someVar</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">someStruct</span><span class="p">{}</span>
</code></pre></div><p>现在，变量包含指向该结构的指针。传递时，无论您复制指针多少次，它始终指代相同的内存空间。</p>
<p>但是，与 C 指针不同，Go 指针在不再需要时会自动进行垃圾回收。您无需担心使用后释放或缓冲区溢出漏洞，这些在 Go 中都不是问题。太棒了！</p>
<p>此外，您还可以使用 defer 语句来帮助您进行函数清除。考虑以下函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">close</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Do somehing to clean up stuff
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// Do something else
</span><span class="c1"></span>    <span class="nb">close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>如您所见，我们在此函数中调用了 close() 两次。如果 foo 函数有多个出口（返回），则需要为每个出口重复 close() 调用。</p>
<p>defer 语句完全可以解决此问题：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">close</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Do somehing to clean up stuff
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">defer</span> <span class="nb">close</span><span class="p">()</span>

    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// Do something else
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>defer 语句保证 close 总是会被调用。</p>
<h2 id="多返回值">多返回值</h2>
<p>这看似没什么，但是在编程语言中却很少见。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">sshConn</span><span class="p">,</span> <span class="nx">chans</span><span class="p">,</span> <span class="nx">reqs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ssh</span><span class="p">.</span><span class="nf">NewServerConn</span><span class="p">(</span><span class="nx">tcpConn</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span>
</code></pre></div><p>有什么理由不喜欢？</p>
<h2 id="oop好的部分">OOP（好的部分）</h2>
<p>尽管 Go 没有类的概念，但仍然可以编写面向对象的代码。</p>
<p>假设有以下 Java 代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">TreeNode</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addChild</span><span class="o">(</span><span class="n">child</span> <span class="n">TreeNode</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">child</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在 Go 中，类似的代码如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TreeNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">children</span> <span class="p">[]</span><span class="nx">treeNode</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">()</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">treeNode</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="nf">AddChild</span><span class="p">(</span><span class="nx">child</span> <span class="o">*</span> <span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Go 将（<code>treeNode *TreeNode</code>）部分称为接收器。Go 中的 Receiver 可以使用与其他语言中的 this 关键字非常相似的任何数据类型和功能。</p>
<h2 id="slices">Slices</h2>
<p>和许多其他低级语言一样，Go 将数组实现为固定大小的元素列表。创建后无法更改其大小。</p>
<p>另一方面，切片（Slice）是使它们动态化的技巧。当切片已满时，Go 会创建一个更大的切片新副本。Go 以尽可能少的复制的方式优化过程。</p>
<p>此外，Go slice 还具有创建不占用额外内存的子切片的简洁功能。这些切片引用原始的数组。如果更改切片中的数据，则原始数据也将更改。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">,</span> <span class="s">&#34;d&#34;</span><span class="p">}</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
	<span class="c1">// Will print [c]
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
	<span class="nx">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;f&#34;</span>
	<span class="c1">//Will print [a b f d]
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>如果您想深入了解，请继续阅读 <a href="https://gobyexample.com/slices" target="_blank" rel="noopener">Go by Example</a>
。</p>
<h2 id="库">库</h2>
<p>选择 Go 的原因之一是库数量众多。SSH 客户端和服务器库？<a href="https://godoc.org/golang.org/x/crypto/ssh" target="_blank" rel="noopener">有</a>
。适用于 AWS 的 SDK？<a href="https://aws.amazon.com/sdk-for-go/" target="_blank" rel="noopener">同样有</a>
。GitHub 操作库？<a href="https://github.com/google/go-github" target="_blank" rel="noopener">当然有</a>
。让我们尝试一些非常少用的东西……FastCGI 协议实现如何？<a href="https://golang.org/pkg/net/http/fcgi/" target="_blank" rel="noopener">当然也有</a>
。</p>
<p>我可以继续，但是没多大必要了。Go 的普及无疑对生态系统有所帮助。</p>
<h2 id="工具">工具</h2>
<p>构建 Go 拥有大量可用的工具。您拥有从<a href="https://blog.golang.org/gofmt" target="_blank" rel="noopener">自动代码格式化</a>
，测试到<a href="https://goreleaser.com/" target="_blank" rel="noopener">完整发布工具</a>
的全套工具。几乎所有的都有很多工具。</p>
<h2 id="结论">结论</h2>
<p>在代码组织方面，Go 当然有其缺点。但是，它特别适合用于各种任务的高性能软件开发。</p>
<p>那 Go 具体有哪些缺点呢？下次我们“喷一喷” Go 的缺点。</p>
<blockquote>
<p>原文链接：https://pasztor.at/blog/go-is-awesome
编译：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>从这些角度看 Go 是一门糟糕的语言</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-is-terrible/</link>
			<pubDate>Mon, 22 Jun 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-is-terrible/</guid>
			<description>上篇文章作者讲到了 Go 的优点，这篇文章提到一些缺点。然而，不少内容我是不认可的。欢迎留言说说你的观点。 Go 当前引起了很多关注。让我们看一下 Go 不好的部分。 作为开发人员，如今很难忽视 Go。因为诸如 Docker 和 Kubernetes 之类的软件，它已迅速崛起。但是，如果仅看一下该语言的流行度图表，Go 就与最流行或增长最快的编程语言相去甚远。 为何每个人似乎都在谈论和招聘 Go？从系统级工程到建立网上商</description>
			<content type="html"><![CDATA[<blockquote>
<p>上篇文章作者讲到了 Go 的优点，这篇文章提到一些缺点。然而，不少内容我是不认可的。欢迎留言说说你的观点。</p>
</blockquote>
<p>Go 当前引起了很多关注。让我们看一下 Go 不好的部分。</p>
<p><p class="md__image">
  <img src="../imgs/go-is-terrible.jpg"
    alt=""  />
</p>
</p>
<p>作为开发人员，如今很难忽视 Go。因为诸如 Docker 和 Kubernetes 之类的软件，它已迅速崛起。但是，如果仅看一下该语言的流行度图表，Go 就与最流行或增长最快的编程语言相去甚远。</p>
<p>为何每个人似乎都在谈论和招聘 Go？从系统级工程到建立网上商店，似乎每个人都想使用 Go？这仅仅是炒作曲线吗，Go 适用于它正在执行的任务吗？</p>
<p>我最近用 Go 写了一个 <a href="https://github.com/janoszen/containerssh" target="_blank" rel="noopener">SSH 服务器</a>
，在其中启动容器。该项目已经发展到很大规模，并且我还向 Go <a href="https://go-review.googlesource.com/c/crypto/&#43;/236517" target="_blank" rel="noopener">发起了 PR</a>
，以修复我发现的错误。</p>
<p>在本文中，我将介绍一些不好的部分：语言设计的缺陷，Go 需要进一步成熟的部分，甚至是令人讨厌的地方。</p>
<p>但是，这并非完全不好：Go 具有一些很棒的功能，使其成为许多应用程序的宝贵工具。如果您对此感兴趣，请“继续”阅读上篇文章。</p>
<p>让我们看一下令人讨厌的部分。请记住，本文是基于 Go 1.14 撰写的。时间推移，这些可能会改进。</p>
<h2 id="错误处理">错误处理</h2>
<p>Go 没有异常。在我看来，尽管对异常有非常有效的批评，但 Go 选择用于处理错误的方法却更加糟糕。</p>
<p>你会看到，在 Go 中可以声明如下的函数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;this is an error&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>调用此函数时，可以选择处理此错误：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">doSomethingElse</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">//More things to do
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这里有很多东西要解释。首先，没有什么可以强制您处理此潜在错误。当然，像 Goland 这样的 IDE 会警告您，但是编译器不会强制您处理此错误。（这个问题也可以通过 linter 来部分缓解，因为 linter 会检查您的源代码是否有类似的意外遗漏。）</p>
<p>更进一步，在 99.9％ 的情况下，错误基本上是字符串。是的，错误是您可以根据需要实现的任何接口，但是我见过的大多数 Go 代码都没有利用此接口来提供类型错误。提供类型错误的标准方法似乎如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">MyError</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;this is an error&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">MyError</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">doSomethingElse</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">MyError</span> <span class="p">{</span>
            <span class="c1">// Handle MyError specifically
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Handle other errors
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//More things to do
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这是样板代码，用于简单的错误处理。但是，更大的问题是函数无法声明它们返回的错误类型。当我使用第三方库的函数进行此操作时，有两个选择：</p>
<ol>
<li>我使用 IDE 跳入第三方库，对它引发的错误类型进行反向工程，然后对其进行处理。在我的职业生涯中，我已经用大约十二种编程语言编写了生产级代码，但是我从来没有像 Go 那样做过这么多的逆向工程。</li>
<li>将错误视为一串未知内容。</li>
</ol>
<p>我研究过的几乎所有 Go 代码都使用选项 2。难怪，这是更简单的代码选项。这导致以下两种模式之一：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;an error happened (%v)&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>第一种选择基本上等同于异常。除了会导致大量的样板代码。第二个选项使程序崩溃，并显示无用的错误消息。</p>
<p>我有强迫开发人员显式处理错误的想法，但是我见过的大多数 Go 代码都只是使用这两种无意识模式之一。</p>
<p>为什么我们不仅仅拥有捕获类型错误的异常？这样会更简单，并且会导致更少的样板代码。哎，现在可能为时已晚。</p>
<h2 id="nullability可空性">Nullability（可空性）</h2>
<p>Go 中的 nil 值可用于任何<a href="https://tour.golang.org/moretypes/1" target="_blank" rel="noopener">指针类型</a>
。指针保存一块内存的地址。在 Go 中，您无法直接分配内存，但是其他编程语言（例如 C）可以实现这一点。指针地址 0 是不指向任何地方的同义词。当然，内存地址为 0 并不一定意味着内存位置无效，但是现代的编译器可以理解这一点，并将空指针转换为要编译的 CPU 体系结构的相应无值类型。</p>
<p>现在，在 Go 中，nil 值实际上是一个问题，因为没有用语言的方式来指示值是否可以为 null。</p>
<pre tabindex="0"><code class="language-ggo" data-lang="ggo">something := getSomething()
something.process()
</code></pre><p>如果 something 是 nil，此代码可能会导致崩溃。是的，全面崩溃。当然，您可以重写代码以包括错误处理，但是，如果 Go 从其他语言的错误中学到什么了，那就更好了。</p>
<h2 id="范围界定和代码结构">范围界定和代码结构</h2>
<p>到目前为止，我发现最大的 Bug 是范围界定。Go 没有公开，私有或受保护的限定词。编译器将所有 .go 文件放在同一包中并合并。如果变量名，接口等以小写开头字母书写，则将其视为“私有”，并且仅在程序包中可见。如果以大写首字母书写，则为“公开”。</p>
<p>换句话说，小写字母只能在同一包中访问，大写字母是全局可见的。不幸的是，没有办法限制同一程序包中的可见性。</p>
<blockquote>
<p>注意：使用 Go 模块（这是首选方法）时，一个软件包表示一个目录。其他构建系统（如 Bazel）允许每个目录包含多个软件包。这在某种程度上减轻了范围界定的不足。</p>
</blockquote>
<p>假设您有一个数据结构，以及一组实现非常特定的业务逻辑的函数。某些不熟悉业务逻辑的人可能不会考虑太多，而是在同一包中实现了一种功能，该功能以一种从业务角度来看并不理想的方式更改数据。</p>
<p>在其他编程语言中，通常可以通过更精细的作用域来防止这种情况。例如，您可以使用类并创建私有成员变量来封装数据。</p>
<p>您有两种选择来解决此问题：</p>
<ol>
<li>相信没有人会违反任何存储数据的完整性。</li>
<li>以这样的方式组织您的代码，即每个软件包仅包含最少数量的代码。</li>
</ol>
<p>当然，您可以选择选项 1，但我从未见过这样的选择。总是有一个同事匆忙地执行某些事情而没有思考。范围界定可以使不好的事情变得困难，而让好事情变得容易。这称为防御性编程。</p>
<p>在 Go 防御性编程中，您必须创建许多目录。我认为太多了。可能你会认为 Java 的文件和目录太多了……</p>
<h2 id="缺乏不变性">缺乏不变性</h2>
<p>防御性编程中的另一个有用工具是不变性。不变的数据结构可防止在创建数据结构后对其进行修改，因此只能对其进行复制。尽管就性能而言这不是很有效，但也需要防止意外的副作用。</p>
<p>想象一下一个 HTTP 请求结构体：应用程序的第一层创建它，然后将其向下传递给几个模块。如果将请求结构作为指针向下传递，则修改请求的任何层都将对其进行全局修改，从而在顶层产生潜在的副作用。</p>
<p>即使您不使用指针而按值切片传递结构，仍然是可变的数据结构。</p>
<p>Go 似乎在很大程度上优先考虑性能，而不是避免潜在的错误。除了<a href="https://github.com/jinzhu/copier" target="_blank" rel="noopener">第三方深层复制库</a>
之外，没有语言可以在模块边界创建安全的数据传输。</p>
<p>换句话说，除非使用深层复制库，否则开发人员必须知道整个应用程序中的数据会发生什么，以确保没有意外的副作用。</p>
<h2 id="缺乏泛型">缺乏泛型</h2>
<p>泛型是创建可重用代码的便捷方法。假设我们要建造一棵树。在 Java 中，它可能如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">()</span>
<span class="n">tree</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span>
    <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="s">&#34;Hello world!&#34;</span><span class="o">)</span>
<span class="o">)</span>
<span class="c1">//...
</span><span class="c1"></span><span class="n">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">getChild</span><span class="o">(</span><span class="n">0</span><span class="o">).</span><span class="na">getData</span><span class="o">()</span>
</code></pre></div><p>如果我们这样编写代码，则数据变量将具有 Object 类型，而没有特定信息。实际上，它是一个字符串，因此我们将没有代码自动提示。我们将需要进行类型转换：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">tree</span><span class="o">.</span><span class="na">getChild</span><span class="o">(</span><span class="n">0</span><span class="o">).</span><span class="na">getData</span><span class="o">()</span>
</code></pre></div><p>如果包含的数据不是字符串，则将导致错误。要变通解决此问题，我们可以使用泛型为包含的数据指定类型：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span>
<span class="n">tree</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span>
    <span class="k">new</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span><span class="s">&#34;Hello world!&#34;</span><span class="o">)</span>
<span class="o">)</span>
<span class="c1">//...
</span><span class="c1"></span><span class="n">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">getChild</span><span class="o">(</span><span class="n">0</span><span class="o">).</span><span class="na">getData</span><span class="o">()</span>
</code></pre></div><p>在这种情况下，数据将是字符串，并且我们可以确保树中只有字符串。</p>
<p>现在 Go 缺乏此特性。因为我们总是需要强制转换为我们相信或希望将返回的数据类型。</p>
<h2 id="oop不好的部分">OOP（不好的部分）</h2>
<p>既然我们讨论了树结构，让我们看一下如何在 Go 中实现树节点。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">tree</span>

<span class="kd">type</span> <span class="nx">TreeNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">children</span> <span class="p">[]</span><span class="nx">treeNode</span>
    <span class="nx">data</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nf">TreeNode</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">treeNode</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="nf">AddChild</span><span class="p">(</span><span class="nx">child</span> <span class="o">*</span> <span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">treeNode</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="nf">GetChild</span><span class="p">(</span><span class="nx">childIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">childIndex</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p>是的，它没有错误处理，但你知晓了。我们本身没有一个类，但是我们有一个叫做接收器的怪异结构，它是这部分的：<code>（treeNode *TreeNode）</code>。接收者基本上就是其他 OOP 语言中的 this 或 self 关键字。</p>
<p>在 Go 中，您将像这样使用 TreeNode：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tree</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">(</span><span class="nx">data</span> <span class="nx">here</span><span class="p">)</span>
<span class="nx">tree</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="nf">New</span><span class="p">(</span><span class="nx">data</span> <span class="nx">here</span><span class="p">))</span>
</code></pre></div><p>您甚至可以实现接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TreeNodeInterface</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">AddChild</span><span class="p">(</span><span class="nx">child</span> <span class="nx">TreeNode</span><span class="p">)</span>
    <span class="nf">GetChild</span><span class="p">(</span><span class="nx">childIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">TreeNode</span>
<span class="p">}</span>
</code></pre></div><p>非常简单，上面的接口已经实现了此接口。不需要特殊的关键字，当深入研究新代码时，这并不是完全有帮助。像 Goland 这样的 IDE 可以帮助您进行代码导航，但是很难知道哪种实现在哪里。此外，如果因为没有实现某个接口的一个方法，则代码导航将不再起作用。</p>
<p>此外值得一提的是，缺少继承和泛型，使编写可重用代码非常困难。</p>
<h2 id="没有枚举">没有枚举</h2>
<p>有一个古怪的问题，可能是由于语言的构建方式引起的。现在我们彻头彻尾的傻了。在实现 <a href="https://github.com/janoszen/containerssh" target="_blank" rel="noopener">SSH 服务器</a>
时，我遇到了一段代码，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">newChannel</span><span class="p">.</span><span class="nf">Reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
</code></pre></div><p>参数 reason 是一个 channel.RejectionReason 类型。你认为该类型是什么？让我们使用 IDE 的功能来解决它。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// RejectionReason is an enumeration used when rejecting channel creation
</span><span class="c1">// requests. See RFC 4254, section 5.1.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RejectionReason</span> <span class="kt">uint32</span>
</code></pre></div><p>酷！这是一个 32 位无符号整数。它可以有什么值？不清楚。可以检查我是否发送了无效的值吗？不能。Go 中没有枚举。可能的值分别定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Prohibited</span> <span class="nx">RejectionReason</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">ConnectionFailed</span>
	<span class="nx">UnknownChannelType</span>
	<span class="nx">ResourceShortage</span>
<span class="p">)</span>
</code></pre></div><p>这些值与上面的类型定义无关。世界上没有任何 IDE 可以为您提供代码完成功能，因此您必须深入研究用于解决此问题的库。</p>
<h2 id="包管理">包管理</h2>
<p>长期以来，Go 中的软件包管理绝对是糟糕的。值得庆幸的是，从 1.11 Go 起引入了模块，但是依赖管理距离其他语言还有很长的路要走。</p>
<p>一个主要问题是，它们使用 git 作为软件包管理工具。程序包通常不包含有关其作者，许可证，版本号等的任何元信息。发布版本后，不会冻结任何代码，这完全打破了以后不会更改版本的假设。没有简洁的方法来遵守 Apache 许可要求，以任何合理的方式在您的最终版本中包括 NOTICE 文件。是的，我知道，大多数人不会瞎弄，但实际上你能保证吗？</p>
<h2 id="炒作">炒作</h2>
<p>最后，最愚蠢的是：炒作。如果您想构建系统级的东西，甚至微小优化都可以带来明显的好处，那么 Go 是一种很棒的语言。很明显，它是在考虑执行速度的基础上构建的，以及代码的可维护性。</p>
<p>我遇到的每个较大的 Go 项目都存在一个可怕的混乱局面，它比普通的 Javascript 框架具有更多的依赖项。您必须专注于微小的实现细节，而不是宏观的概念。</p>
<p>Go 不太适合具有大量业务逻辑的应用程序。或网上商店。或您作为普通开发人员遇到的 99％ 的项目 。您不是 Google，并且没有类似 Google 的性能问题。</p>
<h2 id="结论">结论</h2>
<p>Go 当然是系统级开发的绝佳工具，但付出的代价是认知负担。我绝对不想编写带有沉重业务逻辑的内容，但我一直在努力寻找一种更好的工具来编写高性能的系统工具或实用程序。</p>
<blockquote>
<p>原文链接：<a href="https://pasztor.at/blog/go-is-terrible" target="_blank" rel="noopener">https://pasztor.at/blog/go-is-terrible</a>
</p>
<p>编译：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——实战篇0：使用 Echo 开发一个博客系统</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/action00-intro/</link>
			<pubDate>Sat, 16 May 2020 15:08:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/action00-intro/</guid>
			<description>实战是掌握一门技术很好的方式：纸上得来终觉浅，绝知此事要躬行！ 在初步了解了 Echo 框架的特性、功能后，我们通过具体的一个项目来掌握 Echo 框架，这个项目就是写一个博客系统。 实战篇目标 掌握 go/echo 开发项目的方法； 通过项目更深入掌握 echo； 完善完善，甚至可以作为自己的一个博客系统使用； 因此，在项目实战过程中可能引申讲解 Echo 的特性，毕竟基础篇对 Echo 的特性没有深入讲解。 依赖技术 该实战项</description>
			<content type="html"><![CDATA[<p>实战是掌握一门技术很好的方式：纸上得来终觉浅，绝知此事要躬行！</p>
<p>在初步了解了 Echo 框架的特性、功能后，我们通过具体的一个项目来掌握 Echo 框架，这个项目就是写一个博客系统。</p>
<h2 id="实战篇目标">实战篇目标</h2>
<ul>
<li>掌握 go/echo 开发项目的方法；</li>
<li>通过项目更深入掌握 echo；</li>
<li>完善完善，甚至可以作为自己的一个博客系统使用；</li>
</ul>
<p>因此，在项目实战过程中可能引申讲解 Echo 的特性，毕竟基础篇对 Echo 的特性没有深入讲解。</p>
<h2 id="依赖技术">依赖技术</h2>
<p>该实战项目计划采用前后端分离的方式进行。前端采用 Vue + ElementUI。前端不是强项，目标就是争取能做出来，还凑合，如果你是 Vue 老手，欢迎帮忙处理这块。</p>
<h2 id="主要功能">主要功能</h2>
<p>我们会实现博客系统常用的一些功能，包括：</p>
<ul>
<li>列表页</li>
<li>详情页</li>
<li>归档</li>
<li>标签</li>
<li>浏览数</li>
<li>简单的管理后台</li>
</ul>
<p>该项目代码放在 GitHub 上：<a href="https://github.com/polaris1119/go-echo-example" target="_blank" rel="noopener">https://github.com/polaris1119/go-echo-example</a>
 ，欢迎 star 。</p>
]]></content>
		</item>
		
		<item>
			<title>当 GoLand 遇到 Kubernetes：如何调试和运行 Go 程序</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/using-kubernetes-from-goland/</link>
			<pubDate>Mon, 11 May 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/using-kubernetes-from-goland/</guid>
			<description>这是我们使用 Docker，Docker Compose 或 Kubernetes 运行 Go 服务的系列文章的最后一部分。在这一部分中，我们将专注于使用 Kubernetes 集群时的运行和调试。
虽然我们不会介绍如何安装和配置 Kubernetes 集群，但是可以使用各种工具（例如 kubeadm ，minikube 和 microk8s ）来实现这一目标。如果您使用的是 Windows，则 Docker Desktop for Windows 附带内置的 Kubernetes 支持 。如果您打算使用基于 ARM 芯片的平台（例如 Raspberry Pi 4 ），则可以使用 k3s 之类的东西来入门。
在开始之前，还应该安装 Kubernetes 插件，因为它没有与 IDE 捆绑在一起。您可以通过打开 Settings/Preferences | Plugins | Marketplace并搜索 Kubernetes 找到并安装插件。
在 IDE 中使用 Kubernetes 运行服务 如果您到目前为止一直在关注本系列，那么您会知道所有代码都可以在此 下载和使用，使用 Kubernetes 也是这种情况。我们可以从 kubernetes 分支 开始。
在这里我们可以找到两个不同的文件：db.yaml 和 web.yaml。这些文件包含了我们开始使用 Kubernetes 集群中的应用程序所需的所有定义。为了方便起见，他们还假定 Kubernetes 与 IDE 在同一台计算机上运行。
打开 db.yaml：
apiVersion:v1kind:ConfigMapmetadata:name:db-configlabels:dockerdev:dbdata:POSTGRES_DB:golandPOSTGRES_USER:golandPOSTGRES_PASSWORD:goland---apiVersion:apps/v1kind:StatefulSetmetadata:labels:dockerdev:dbname:dbspec:serviceName:dockerdev-dbselector:matchLabels:dockerdev:dbtemplate:metadata:labels:dockerdev:dbspec:containers:- name:dbimage:postgres:12.2-alpineimagePullPolicy:IfNotPresentenvFrom:- configMapRef:name:db-configports:- containerPort:5432volumeMounts:- name:db-initmountPath:/docker-entrypoint-initdb.d/init.sqlsubPath:init.sqlvolumes:- name:db-inithostPath:path:/d/GoLandProjects/dockerdev---apiVersion:v1kind:Servicemetadata:labels:dockerdev:dbname:dockerdev-db-exportedspec:type:NodePortports:- name:5432-tcpport:5432targetPort:5432nodePort:30432selector:dockerdev:db注意：在启动此示例之前，我们需要确保更改了 init.sql 文件在主机上的位置。您可以通过将路径：/d/ GoLandProjects / dockerdev 替换为先前克隆该项目的位置的路径来实现。
完成此操作后，我们可以使用文件顶部编辑器装订线上的绿色箭头在 Kubernetes 中部署数据库。
部署数据库将创建一个 StatefulSet 并在 pod 中运行数据库。将出现 “Services Tool” 窗口，并显示用于创建资源的命令以及该命令的输出。
Kubernetes 集群概述 在 Kubernetes 集群中，我们将看到工作负载信息，例如正在运行的 Pods, Deployments, Stateful Sets, Daemon Sets, Jobs, Cron Jobs, Replica Sets, 和 Replication Controllers。
我们还可以查看有关集群中服务和入口点的网络信息。
“Configuration” 部分包含当前名称空间或群集的所有配置信息，例如有关运行名称空间，节点，群集角色，角色，配置 map 和秘钥的信息。
最后，“Storage” 部分将向我们显示当前配置中的“持久卷”，“持久卷声明”和“存储类”。
在 IDE 中使用 Kubernetes 集群运行 Go 应用程序 让我们在同一个 Kubernetes 集群中运行 Go 应用程序，看看它是如何工作的。
不过，在运行该应用程序之前，我们首先需要构建该应用程序所在的 Docker 容器。示例代码库中包含一个名为 build Dockerfile 的运行配置，需要运行该配置才能在集群中使用我们的容器。
正如您可能已经猜到的那样，此后，我们终于可以使用先前与 db.yaml 文件一起使用的绿色箭头在 Kubernetes 中运行 Go 应用程序，只有这次我们才在 web.yaml 文件中使用它。
apiVersion:apps/v1kind:Deploymentmetadata:labels:dockerdev:webname:webspec:selector:matchLabels:dockerdev:webtemplate:metadata:labels:dockerdev:webspec:containers:- name:dockerdev-webimage:dockerdev-web:latestimagePullPolicy:Neverenv:- name:DD_DB_HOSTvalue:&amp;#34;dockerdev-db-exported&amp;#34;ports:- containerPort:8000---apiVersion:v1kind:Servicemetadata:labels:dockerdev:webname:dockerdev-web-exportedspec:type:NodePortports:- name:8000-tcpport:8000targetPort:8000nodePort:30800selector:dockerdev:webPro tip：我们可以使用 HTTP 请求文件的方式从 IDE 运行请求，以检查服务是否已启动并正在运行。
从 Kubernetes 调试服务 在使用 GoLand 调试 Kubernetes 服务之前，我们需要对 web.yaml 文件进行一些更改。这些变化可以在我们代码库的 kubernetes-debug 分支中看到。
我们需要进行一些与调试常规 Docker 容器非常相似的更改。
首先，我们需要调整 Dockerfile，然后我们必须使用 Run | Run … | ‘build Dockerfile’ 来配置。</description>
			<content type="html"><![CDATA[<p>这是我们使用 Docker，Docker Compose 或 Kubernetes 运行 Go 服务的系列文章的最后一部分。在这一部分中，我们将专注于使用 Kubernetes 集群时的运行和调试。</p>
<p>虽然我们不会介绍如何安装和配置 Kubernetes 集群，但是可以使用各种工具（例如 <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">kubeadm</a>
，<a href="https://kubernetes.io/docs/setup/learning-environment/minikube/" target="_blank" rel="noopener">minikube</a>
 和 <a href="https://microk8s.io/" target="_blank" rel="noopener">microk8s</a>
）来实现这一目标。如果您使用的是 Windows，则 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker Desktop for Windows</a>
 附带<a href="https://docs.docker.com/docker-for-windows/kubernetes/" target="_blank" rel="noopener">内置的 Kubernetes 支持</a>
。如果您打算使用基于 ARM 芯片的平台（例如 <a href="https://blog.jetbrains.com/go/2020/02/18/running-goland-on-a-raspberry-pi-4/" target="_blank" rel="noopener">Raspberry Pi 4</a>
），则可以使用 <a href="https://k3s.io/" target="_blank" rel="noopener">k3s</a>
 之类的东西来入门。</p>
<p>在开始之前，还应该安装 Kubernetes 插件，因为它没有与 IDE 捆绑在一起。您可以通过打开 <code>Settings/Preferences | Plugins | Marketplace</code>并搜索 Kubernetes 找到并安装插件。</p>
<h2 id="在-ide-中使用-kubernetes-运行服务">在 IDE 中使用 Kubernetes 运行服务</h2>
<p>如果您到目前为止一直在关注本系列，那么您会知道所有代码都可以<a href="https://github.com/dlsniper/dockerdev" target="_blank" rel="noopener">在此</a>
下载和使用，使用 Kubernetes 也是这种情况。我们可以从 <a href="https://github.com/dlsniper/dockerdev/tree/kubernetes" target="_blank" rel="noopener">kubernetes 分支</a>
开始。</p>
<p>在这里我们可以找到两个不同的文件：db.yaml 和 web.yaml。这些文件包含了我们开始使用 Kubernetes 集群中的应用程序所需的所有定义。为了方便起见，他们还假定 Kubernetes 与 IDE 在同一台计算机上运行。</p>
<p>打开 db.yaml：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ConfigMap</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-config</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w"></span><span class="nt">data</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">POSTGRES_DB</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">  </span><span class="nt">POSTGRES_USER</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">  </span><span class="nt">POSTGRES_PASSWORD</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">StatefulSet</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">serviceName</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">          </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">postgres:12.2-alpine</span><span class="w">
</span><span class="w">          </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">IfNotPresent</span><span class="w">
</span><span class="w">          </span><span class="nt">envFrom</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">configMapRef</span><span class="p">:</span><span class="w">
</span><span class="w">                </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-config</span><span class="w">
</span><span class="w">          </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span><span class="w">
</span><span class="w">          </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-init</span><span class="w">
</span><span class="w">              </span><span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/docker-entrypoint-initdb.d/init.sql</span><span class="w">
</span><span class="w">              </span><span class="nt">subPath</span><span class="p">:</span><span class="w"> </span><span class="l">init.sql</span><span class="w">
</span><span class="w">      </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-init</span><span class="w">
</span><span class="w">           </span><span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span><span class="w">             </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/d/GoLandProjects/dockerdev</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db-exported</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">NodePort</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span>-<span class="l">tcp</span><span class="w">
</span><span class="w">      </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span><span class="w">
</span><span class="w">      </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span><span class="w">
</span><span class="w">      </span><span class="nt">nodePort</span><span class="p">:</span><span class="w"> </span><span class="m">30432</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span></code></pre></div><p><strong>注意</strong>：在启动此示例之前，我们需要确保更改了 init.sql 文件在主机上的位置。您可以通过将路径：/d/ GoLandProjects / dockerdev 替换为先前克隆该项目的位置的路径来实现。</p>
<p>完成此操作后，我们可以使用文件顶部编辑器装订线上的绿色箭头在 Kubernetes 中部署数据库。</p>
<p>部署数据库将创建一个 StatefulSet 并在 pod 中运行数据库。将出现 “Services Tool” 窗口，并显示用于创建资源的命令以及该命令的输出。</p>
<h2 id="kubernetes-集群概述">Kubernetes 集群概述</h2>
<p>在 Kubernetes 集群中，我们将看到工作负载信息，例如正在运行的 Pods, Deployments, Stateful Sets, Daemon Sets, Jobs, Cron Jobs, Replica Sets, 和 Replication Controllers。</p>
<p><p class="md__image">
  <img src="../imgs/14-Launching-a-Kubernetes-ReplicaSet-from-GoLand.gif"
    alt=""  />
</p>
</p>
<p>我们还可以查看有关集群中服务和入口点的网络信息。</p>
<p><p class="md__image">
  <img src="../imgs/15-Kubernetes-Services-and-Ingress-points.gif"
    alt=""  />
</p>
</p>
<p>“Configuration” 部分包含当前名称空间或群集的所有配置信息，例如有关运行名称空间，节点，群集角色，角色，配置 map 和秘钥的信息。</p>
<p><p class="md__image">
  <img src="../imgs/16-Kubernetes-Configuration-options.gif"
    alt=""  />
</p>
</p>
<p>最后，“Storage” 部分将向我们显示当前配置中的“持久卷”，“持久卷声明”和“存储类”。</p>
<p><p class="md__image">
  <img src="../imgs/17-Kubernetes-Storage-options.gif"
    alt=""  />
</p>
</p>
<h2 id="在-ide-中使用-kubernetes-集群运行-go-应用程序">在 IDE 中使用 Kubernetes 集群运行 Go 应用程序</h2>
<p>让我们在同一个 Kubernetes 集群中运行 Go 应用程序，看看它是如何工作的。</p>
<p>不过，在运行该应用程序之前，我们首先需要构建该应用程序所在的 Docker 容器。示例代码库中包含一个名为 build Dockerfile 的运行配置，需要运行该配置才能在集群中使用我们的容器。</p>
<p>正如您可能已经猜到的那样，此后，我们终于可以使用先前与 db.yaml 文件一起使用的绿色箭头在 Kubernetes 中运行 Go 应用程序，只有这次我们才在 web.yaml 文件中使用它。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-web</span><span class="w">
</span><span class="w">          </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-web:latest</span><span class="w">
</span><span class="w">          </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Never</span><span class="w">
</span><span class="w">          </span><span class="nt">env</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">DD_DB_HOST</span><span class="w">
</span><span class="w">              </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;dockerdev-db-exported&#34;</span><span class="w">
</span><span class="w">          </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-web-exported</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">NodePort</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span>-<span class="l">tcp</span><span class="w">
</span><span class="w">      </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span><span class="w">
</span><span class="w">      </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span><span class="w">
</span><span class="w">      </span><span class="nt">nodePort</span><span class="p">:</span><span class="w"> </span><span class="m">30800</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span></code></pre></div><p><p class="md__image">
  <img src="../imgs/18-Run-a-Go-service-in-Kubernetes-with-GoLand.gif"
    alt=""  />
</p>
</p>
<p><strong>Pro tip</strong>：我们可以使用 HTTP 请求文件的方式从 IDE 运行请求，以检查服务是否已启动并正在运行。</p>
<p><p class="md__image">
  <img src="../imgs/19-Run-HTTP-Request-from-IDE.gif"
    alt=""  />
</p>
</p>
<h2 id="从-kubernetes-调试服务">从 Kubernetes 调试服务</h2>
<p>在使用 GoLand 调试 Kubernetes 服务之前，我们需要对 web.yaml 文件进行一些更改。这些变化可以在我们代码库的 kubernetes-debug 分支中看到。</p>
<p>我们需要进行一些与调试常规 Docker 容器非常相似的更改。</p>
<p>首先，我们需要调整 Dockerfile，然后我们必须使用 <code>Run | Run … | ‘build Dockerfile’ </code>来配置。</p>
<p>接着我们可以使用 <code>Run | Debug … | Kubernetes Service</code>，它将启动 Go Remote 调试配置。</p>
<p><p class="md__image">
  <img src="../imgs/20-Debugging-Go-Service-running-in-Kubernetes.gif"
    alt=""  />
</p>
</p>
<p>调试器将跟之前我们习惯的调试形式一样工作。</p>
<p>这个系列文章是我们使用 Docker，Docker Compose 和 Kubernetes 运行和调试 Go 微服务的总结。</p>
<p>在本文中，我们讨论了如何使用 Kubernetes 插件来编辑 Deployment 文件，以便它将正常启动，从而可以对其进行调试。</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/go/2020/05/11/using-kubernetes-from-goland/</p>
<p>作者：Florin Pățan</p>
<p>翻译：Go语言中文网 polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>在 GoLang 中使用 Docker Compose 运行 Go 应用程序</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/running-go-applications-using-docker-compose-in-goland/</link>
			<pubDate>Fri, 08 May 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/running-go-applications-using-docker-compose-in-goland/</guid>
			<description>今天，我们将继续有关如何使用 Docker 运行 和调试 Go 应用程序 的系列文章。
在本文中，我们将使用 Docker Compose 运行和调试我们的应用程序。对于本文，我们将使用此处的源代码 ，在开始之前切换到 compose 分支 。
使用 Docker Compose 运行 Go 应用程序 让我们从使用 Docker Compose 运行应用程序开始。
查看我们已经创建的项目，可以在代码仓库中找到 docker-compose.yaml 文件：
version:&amp;#34;3.5&amp;#34;services:web:container_name:dockerdevbuild:./ports:- &amp;#34;8000:8000&amp;#34;environment:DD_DB_HOST:dbcommand:/serverdepends_on:- dbdb:container_name:dockerdev-dbimage:postgres:12.2-alpineports:- &amp;#34;5432:5432&amp;#34;environment:POSTGRES_USER:golandPOSTGRES_PASSWORD:golandPOSTGRES_DB:golandvolumes:- ./init.sql:/docker-entrypoint-initdb.d/init.sql在数据库部分，我们需要创建一个名为 init.sql 的新文件。该文件的内容用于设置服务运行所需的数据库。
最后，让我们在 main.go 文件中运行 Sync packages of &amp;lt;project&amp;gt; 来 quick-fix，以下载 pgx 库并运行该应用程序。注意：如果你的模块缓存中还没有 pgx 的 4.5.0 版本，则需要执行此步骤。
运行基于 Docker Compose 的应用程序类似于其他 Run Configurations。单击 docker-compose.yaml 中 services 指令旁边的双绿色箭头按钮。要仅运行一项服务，请点击要运行的服务类型旁边的绿色箭头，例如上面的示例配置中的 web 或 db。
配置运行后，在 Docker 节点下的 Services Tool 窗口中会有一个名为 Compose 的新节点。这里会显示正在运行的每个 Docker Compose 服务套件。
可以浏览每个服务定义，并为每个服务显示所有正在运行的实例。Docker Compose 服务中可用于容器的信息与常规 Docker 容器可使用的信息相同。
注意：如果你要启动较重的服务（例如数据库服务器），或者这些服务需要一些初始化时间，则我们的 Go 程序服务需要考虑这些服务的启动时间。
在我们的示例代码中，这是使用 getDBConnection 函数处理的，该函数尝试在放弃之前尝试几次以指数退避的方式连接到数据库。
重启动 Docker Compose 服务 更改我们的代码后，我们需要重新启动服务以重新加载这些更改。目前，使用 IDE 重新启动它有点复杂，因为这样做需要你执行以下步骤：
 执行 Run | Edit Configurations 并复制一份现有的 Docker Compose 配置； 编辑新创建的配置以添加重新启动的服务的名称，并启用 –build 选项以强制在运行镜像之前对其进行重建；  完成这些步骤之后，你可以停止现有服务，删除现有容器，然后启动新创建的配置。
Pro tip：你可以使用 “Delete” 功能同时停止和删除服务。
使用 Docker Compose 调试 Go 应用程序 要使用 Docker Compose 调试应用程序，我们需要同时更改 Dockerfile 和 docker-compose.yaml 文件。我们可以切换到代码库的 compose-debug 分支 ，这样更容易理解。
现在，docker-compose.yaml 文件如下所示：
version:&amp;#34;3.5&amp;#34;services:web:container_name:dockerdevbuild:./ports:- &amp;#34;8000:8000&amp;#34;- &amp;#34;40000:40000&amp;#34;environment:DD_DB_HOST:dbsecurity_opt:- &amp;#34;seccomp:unconfined&amp;#34;cap_add:- SYS_PTRACEcommand:/dlv --headless --listen=:40000 --api-version=2 exec /serverdepends_on:- dbdb:container_name:dockerdev-dbimage:postgres:12.2-alpineports:- &amp;#34;5432:5432&amp;#34;environment:POSTGRES_USER:golandPOSTGRES_PASSWORD:golandPOSTGRES_DB:golandvolumes:- ./init.sql:/docker-entrypoint-initdb.d/init.sql注意：这里的重要部分是 security_opt 和 cap_add 属性，因为它们允许调试器在 Docker 环境中运行。
运行此操作类似于运行常规 Docker Compose 配置。我们可以使用 Go Remote 配置连接到容器，调试器会话将像调试常规配置一样开始。
今天我们的文章到此结束。我们已经讨论了如何使用 Docker Compose，以及如何从 GoLand 运行和调试我们的应用程序。
在下一篇文章中，我们将介绍如何在 IDE 中使用 Kubernetes，以及如何使用它运行和调试我们的应用程序。
 原文链接：https://blog.jetbrains.com/go/2020/05/08/running-go-applications-using-docker-compose-in-goland/
作者：Florin Pățan
翻译：Go语言中文网 polaris
 </description>
			<content type="html"><![CDATA[<p>今天，我们将继续有关<a href="https://mp.weixin.qq.com/s/2tajxPBhGwgwlT4TzAgmVw" target="_blank" rel="noopener">如何使用 Docker 运行</a>
和<a href="https://mp.weixin.qq.com/s/4-fkIWcr_3LdLFALVk4ZTA" target="_blank" rel="noopener">调试 Go 应用程序</a>
的系列文章。</p>
<p>在本文中，我们将使用 Docker Compose 运行和调试我们的应用程序。对于本文，我们将使用<a href="https://github.com/dlsniper/dockerdev/tree/compose" target="_blank" rel="noopener">此处的源代码</a>
，在开始之前切换到 <a href="https://github.com/dlsniper/dockerdev/tree/compose" target="_blank" rel="noopener">compose 分支</a>
。</p>
<h2 id="使用-docker-compose-运行-go-应用程序">使用 Docker Compose 运行 Go 应用程序</h2>
<p>让我们从使用 Docker Compose 运行应用程序开始。</p>
<p>查看我们已经创建的项目，可以在代码仓库中找到 docker-compose.yaml 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3.5&#34;</span><span class="w">
</span><span class="w"> 
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">web</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev</span><span class="w">
</span><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;8000:8000&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">DD_DB_HOST</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">/server</span><span class="w">
</span><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">db</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">postgres:12.2-alpine</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;5432:5432&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_USER</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_PASSWORD</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_DB</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">./init.sql:/docker-entrypoint-initdb.d/init.sql</span><span class="w">
</span></code></pre></div><p>在数据库部分，我们需要创建一个名为 init.sql 的新文件。该文件的内容用于设置服务运行所需的数据库。</p>
<p>最后，让我们在 main.go 文件中运行 <code>Sync packages of &lt;project&gt;</code> 来 quick-fix，以下载 <a href="https://github.com/jackc/pgx/" target="_blank" rel="noopener">pgx</a>
 库并运行该应用程序。注意：如果你的模块缓存中还没有 pgx 的 4.5.0 版本，则需要执行此步骤。</p>
<p>运行基于 Docker Compose 的应用程序类似于其他 <code>Run Configurations</code>。单击 docker-compose.yaml 中 services 指令旁边的双绿色箭头按钮。要仅运行一项服务，请点击要运行的服务类型旁边的绿色箭头，例如上面的示例配置中的 web 或 db。</p>
<p><p class="md__image">
  <img src="../imgs/11-Running-Docker-Compose-from-the-IDE.gif"
    alt=""  />
</p>
</p>
<p>配置运行后，在 Docker 节点下的 <code>Services Tool</code> 窗口中会有一个名为 Compose 的新节点。这里会显示正在运行的每个 Docker Compose 服务套件。</p>
<p>可以浏览每个服务定义，并为每个服务显示所有正在运行的实例。Docker Compose 服务中可用于容器的信息与常规 Docker 容器可使用的信息相同。</p>
<p><strong>注意</strong>：如果你要启动较重的服务（例如数据库服务器），或者这些服务需要一些初始化时间，则我们的 Go 程序服务需要考虑这些服务的启动时间。</p>
<p>在我们的示例代码中，这是使用 getDBConnection 函数处理的，该函数尝试在放弃之前尝试几次以指数退避的方式连接到数据库。</p>
<h2 id="重启动-docker-compose-服务">重启动 Docker Compose 服务</h2>
<p>更改我们的代码后，我们需要重新启动服务以重新加载这些更改。目前，使用 IDE 重新启动它有点复杂，因为这样做需要你执行以下步骤：</p>
<ul>
<li>执行 <code>Run | Edit Configurations</code> 并复制一份现有的 Docker Compose 配置；</li>
<li>编辑新创建的配置以添加重新启动的服务的名称，并启用 <code>–build</code> 选项以强制在运行镜像之前对其进行重建；</li>
</ul>
<p>完成这些步骤之后，你可以停止现有服务，删除现有容器，然后启动新创建的配置。</p>
<p><p class="md__image">
  <img src="../imgs/12-Restart-Docker-Compose-service.gif"
    alt=""  />
</p>
</p>
<p><strong>Pro tip</strong>：你可以使用 “Delete” 功能同时停止和删除服务。</p>
<h2 id="使用-docker-compose-调试-go-应用程序">使用 Docker Compose 调试 Go 应用程序</h2>
<p>要使用 Docker Compose 调试应用程序，我们需要同时更改 Dockerfile 和 docker-compose.yaml 文件。我们可以切换到代码库的 <a href="https://github.com/dlsniper/dockerdev/tree/compose-debug" target="_blank" rel="noopener">compose-debug 分支</a>
，这样更容易理解。</p>
<p>现在，docker-compose.yaml 文件如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3.5&#34;</span><span class="w">
</span><span class="w"> 
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">web</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev</span><span class="w">
</span><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;8000:8000&#34;</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;40000:40000&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">DD_DB_HOST</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">    </span><span class="nt">security_opt</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;seccomp:unconfined&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">cap_add</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">SYS_PTRACE</span><span class="w">
</span><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">/dlv --headless --listen=:40000 --api-version=2 exec /server</span><span class="w">
</span><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">db</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">postgres:12.2-alpine</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;5432:5432&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_USER</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_PASSWORD</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_DB</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">./init.sql:/docker-entrypoint-initdb.d/init.sql</span><span class="w">
</span></code></pre></div><p><strong>注意</strong>：这里的重要部分是 security_opt 和 cap_add 属性，因为它们允许调试器在 Docker 环境中运行。</p>
<p>运行此操作类似于运行常规 Docker Compose 配置。我们可以使用 Go Remote 配置连接到容器，调试器会话将像调试常规配置一样开始。</p>
<p><p class="md__image">
  <img src="../imgs/13-Debugging-Go-Service-in-Docker-Compose.gif"
    alt=""  />
</p>
</p>
<p>今天我们的文章到此结束。我们已经讨论了如何使用 Docker Compose，以及如何从 GoLand 运行和调试我们的应用程序。</p>
<p>在下一篇文章中，我们将介绍如何在 IDE 中使用 Kubernetes，以及如何使用它运行和调试我们的应用程序。</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/go/2020/05/08/running-go-applications-using-docker-compose-in-goland/</p>
<p>作者：Florin Pățan</p>
<p>翻译：Go语言中文网 polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>基于 GoLand 使用 Docker 容器进行 Go 开发</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/debugging-a-go-application-inside-a-docker-container/</link>
			<pubDate>Mon, 04 May 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/debugging-a-go-application-inside-a-docker-container/</guid>
			<description>今天，我们开始撰写一系列有关 GoLand 内部对 Docker，Docker Compose 和 Kubernetes 的支持以及它如何帮助我们在 Go 中编写（微）服务的文章。
我们将研究如何在 IDE 中配置项目，如何使用 Docker 或 Kubernetes 运行或调试我们的项目，以及如何将项目连接到我们选择的数据库 PostgreSQL。
让我们从介绍普通的 Docker 工作流程开始，然后我们将构建容器并运行它。
在继续之前，我们需要 GoLand 2020.1.1 或更高版本，该版本带有最新的 Docker 插件。我们还需要一个相当现代的 Docker 版本，例如 17.06 或更高版本。注意：虽然旧版本的 IDE 在一定程度上可以使用，但是本文使用了新功能，并且 IDE 的外观可能有所不同。
项目设置 让我们开始设置我们的项目。
我们可以创建一个新的 Go Modules 项目，也可以使用现有的项目。
项目结构应类似于此仓库中的结构：https://github.com/dlsniper/dockerdev 。
本教程不会介绍如何为你的系统安装和配置 Docker。
相反，我们将从配置 Docker 服务器开始，以便我们可以运行我们的应用程序。将 Docker 安装到系统中后，转到 Settings/Preferences | Build, Execution, Deployment | Docker，然后单击 + 按钮添加新的 Docker 服务器连接。
默认情况下，该插件将创建与本地计算机 Docker 服务器的连接，对于我们的教程而言已经足够了。单击确定按钮以创建服务器配置。
使用 Dockerfile 首先，让我们在项目的根目录中打开 Dockerfile。
# Compile stage FROM golang:1.13.8 AS build-env ADD . /dockerdev WORKDIR /dockerdev RUN go build -o /server # Final stage FROM debian:buster EXPOSE 8000 WORKDIR / COPY --from=build-env /server / CMD [&amp;quot;/server&amp;quot;] 该 Dockerfile 使用多阶段构建，该方式使我们能够生成最小的 Docker 映像，因为构建应用程序二进制文件的编译阶段与构建容器的最终阶段是分开的。
将上面的代码粘贴到 Dockerfile 中后，第一个 FROM […] 指令旁边会出现一个绿色箭头。这是运行容器的最快方法。
但是，我们需要进行一些编辑才能运行它，因为我们需要为容器公开正确的端口以接收连接。
为容器创建一个新的运行配置 我们可以创建一个新的运行配置，也可以编辑仓库中存在的配置。为了简单起见，直接使用现有的，因为它已经预先填写了我们需要的所有值。要对其进行编辑，请单击选项列表底部的 Edit ‘Docker – Web – Standalone’  选项。
在这里，我们可以设置运行 Docker 容器所需的所有选项。我们的运行配置已经填上了重要内容，例如配置名称：“ Docker – Web Dev – Standalone”。容器名称设置为 docker-web-dev-standalone。最后，在“绑定端口”字段中，我们将“主机”端口和“容器”端口都设置为 8000，以便可以访问应用程序。
现在，我们可以单击对话框底部的 “Run” 按钮，来启动我们的容器。
了解服务工具窗口 Docker 完成构建过程后，我们可以查看 “Services Tool Window” 窗口，并在 “Containers” 部分中看到新创建的容器。我们还将在 “Images” 部分中看到使用的镜像。
对于每个容器，有以下可用选项卡：
 Build Log：它显示用于构建容器的日志； Log：显示容器的输出； Attached console：如果可以的话，这允许我们与容器的应用程序/shell 交互； Properties：将显示有关容器的更多信息，例如 镜像 ID 或容器 ID； Environment variables：显示容器使用的环境变量； Port bindings：显示容器暴露给主机的所有端口； Volume bindings：显示为容器安装的卷； Files：如果它支持运行 ls 命令，则允许我们浏览容器中的文件。对于像我们这样的基于 Alpine 的容器，我们可以添加 RUN apk add &amp;ndash;no-cache coreutils 指令来启用此功能；  在左侧，我们可以看到各种按钮。首先，有一个 “Redeploy” 按钮，它使我们可以再次运行容器的构建配置。</description>
			<content type="html"><![CDATA[<p>今天，我们开始撰写一系列有关 GoLand 内部对 Docker，Docker Compose 和 Kubernetes 的支持以及它如何帮助我们在 Go 中编写（微）服务的文章。</p>
<p>我们将研究如何在 IDE 中配置项目，如何使用 Docker 或 Kubernetes 运行或调试我们的项目，以及如何将项目连接到我们选择的数据库 PostgreSQL。</p>
<p>让我们从介绍普通的 Docker 工作流程开始，然后我们将构建容器并运行它。</p>
<p>在继续之前，我们需要 GoLand 2020.1.1 或更高版本，该版本带有最新的 Docker 插件。我们还需要一个相当现代的 Docker 版本，例如 17.06 或更高版本。注意：虽然旧版本的 IDE 在一定程度上可以使用，但是本文使用了新功能，并且 IDE 的外观可能有所不同。</p>
<h2 id="项目设置">项目设置</h2>
<p>让我们开始设置我们的项目。</p>
<p>我们可以创建一个新的 Go Modules 项目，也可以使用现有的项目。</p>
<p>项目结构应类似于此仓库中的结构：<a href="https://github.com/dlsniper/dockerdev" target="_blank" rel="noopener">https://github.com/dlsniper/dockerdev</a>
。</p>
<p>本教程不会介绍如何为你的系统安装和配置 Docker。</p>
<p>相反，我们将从配置 Docker 服务器开始，以便我们可以运行我们的应用程序。将 Docker 安装到系统中后，转到 <code>Settings/Preferences | Build, Execution, Deployment | Docker</code>，然后单击 + 按钮添加新的 Docker 服务器连接。</p>
<p>默认情况下，该插件将创建与本地计算机 Docker 服务器的连接，对于我们的教程而言已经足够了。单击确定按钮以创建服务器配置。</p>
<p><p class="md__image">
  <img src="../imgs/01-Configure-Docker-Server.gif"
    alt=""  />
</p>
</p>
<h2 id="使用-dockerfile">使用 Dockerfile</h2>
<p>首先，让我们在项目的根目录中打开 Dockerfile。</p>
<pre tabindex="0"><code class="language-dockefile" data-lang="dockefile"># Compile stage
FROM golang:1.13.8 AS build-env
 
ADD . /dockerdev
WORKDIR /dockerdev
 
RUN go build -o /server
 
# Final stage
FROM debian:buster
 
EXPOSE 8000
 
WORKDIR /
COPY --from=build-env /server /
 
CMD [&quot;/server&quot;]
</code></pre><p>该 Dockerfile 使用多阶段构建，该方式使我们能够生成最小的 Docker 映像，因为构建应用程序二进制文件的编译阶段与构建容器的最终阶段是分开的。</p>
<p>将上面的代码粘贴到 Dockerfile 中后，第一个 <code>FROM […]</code> 指令旁边会出现一个绿色箭头。这是运行容器的最快方法。</p>
<p>但是，我们需要进行一些编辑才能运行它，因为我们需要为容器公开正确的端口以接收连接。</p>
<p><p class="md__image">
  <img src="../imgs/02-Dockerfile.png"
    alt="02 - Dockerfile"  />
</p>
</p>
<h2 id="为容器创建一个新的运行配置">为容器创建一个新的运行配置</h2>
<p>我们可以创建一个新的运行配置，也可以编辑仓库中存在的配置。为了简单起见，直接使用现有的，因为它已经预先填写了我们需要的所有值。要对其进行编辑，请单击选项列表底部的 <code>Edit ‘Docker – Web – Standalone’ </code> 选项。</p>
<p>在这里，我们可以设置运行 Docker 容器所需的所有选项。我们的运行配置已经填上了重要内容，例如配置名称：“ Docker – Web Dev – Standalone”。容器名称设置为 docker-web-dev-standalone。最后，在“绑定端口”字段中，我们将“主机”端口和“容器”端口都设置为 8000，以便可以访问应用程序。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/05/03-Edit-Dockerfile-Run-Configuration.png"
    alt="03 - Edit Dockerfile Run Configuration"  />
</p>
</p>
<p>现在，我们可以单击对话框底部的 “Run” 按钮，来启动我们的容器。</p>
<h2 id="了解服务工具窗口">了解服务工具窗口</h2>
<p>Docker 完成构建过程后，我们可以查看 “Services Tool Window” 窗口，并在 “Containers” 部分中看到新创建的容器。我们还将在 “Images” 部分中看到使用的镜像。</p>
<p>对于每个容器，有以下可用选项卡：</p>
<ul>
<li>Build Log：它显示用于构建容器的日志；</li>
<li>Log：显示容器的输出；</li>
<li>Attached console：如果可以的话，这允许我们与容器的应用程序/shell 交互；</li>
<li>Properties：将显示有关容器的更多信息，例如 镜像 ID 或容器 ID；</li>
<li>Environment variables：显示容器使用的环境变量；</li>
<li>Port bindings：显示容器暴露给主机的所有端口；</li>
<li>Volume bindings：显示为容器安装的卷；</li>
<li>Files：如果它支持运行 ls 命令，则允许我们浏览容器中的文件。对于像我们这样的基于 Alpine 的容器，我们可以添加 RUN apk add &ndash;no-cache coreutils 指令来启用此功能；</li>
</ul>
<p><p class="md__image">
  <img src="../imgs/04-Running-a-Docker-Container.gif"
    alt=""  />
</p>
</p>
<p>在左侧，我们可以看到各种按钮。首先，有一个 “Redeploy” 按钮，它使我们可以再次运行容器的构建配置。</p>
<p>还有 “Edit Configuration” 按钮，可用于对容器的 “Run Configuration” 进行任何调整。</p>
<p>最后， “Start/Stop” 按钮，用于启动或停止容器，以及 “Delete” 按钮，用于删除容器。</p>
<p><p class="md__image">
  <img src="../imgs/05-Docker-Tool-Window-Service-Overview.gif"
    alt=""  />
</p>
</p>
<p>容器上的右键单击操作可以访问一些其他有用的功能。我们可以使用 List Processes 看到正在运行的进程的列表，也可以使用 Exec 在正在运行的容器中执行命令。最后，Inspect 将提供有关容器及其当前配置的更多信息。</p>
<p><p class="md__image">
  <img src="../imgs/06-Docker-Container-menu-options.gif"
    alt=""  />
</p>
</p>
<p><strong>Pro tip</strong>：如果将鼠标悬停在容器名称上，则可以看到容器的正常运行时间。</p>
<p><strong>Pro tip</strong>：要加快容器的构建速度，请使用 Go vendoring mode。在 IDE 终端中运行 go mod vendor 命令可确保 IDE 自动选择 vendor 文件夹。为此，您还需要在容器的环境变量列表中添加 <code>GOFLAGS =&quot;-mod = vendor&quot;</code>。</p>
<h2 id="总结">总结</h2>
<p>我们讨论了如何创建和运行 Docker 配置。在下一篇文章中，我们将介绍如何调试 Docker 中的应用程序。</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/go/2020/05/04/go-development-with-docker-containers/</p>
<p>作者：Florin Pățan</p>
<p>翻译：Go语言中文网 polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>还在用 2019.3 就 Out 了：GoLand 2020.1 版本正式发布</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/goland-2020-1-release/</link>
			<pubDate>Fri, 10 Apr 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/goland-2020-1-release/</guid>
			<description>北京时间 2020 年 4 月 10 日凌晨，Jetbrains 宣布正式发布 GoLand 2020.1 版本。
该版本主要的变化有：
引入了对 Go 模块支持的各种升级以及代码编辑功能，这些功能几乎不需要用户交互，也不需要扩展的代码补全系列。
除此之外，还添加了新的代码检查、快速修复和其他改进，例如新的 LightEdit 模式（可让您在文本编辑器中打开文件，而无需创建或加载项目）、智能拼写和语法检查以及用于 Web 开发和数据库处理的新功能。
Go 语言中文网在 2020.1 还未正式发布之前，就发过关于该版本特性的文章，现在 2020.1 正式发布了，相关功能特性稳定了，我们再次介绍下相关新特性。
Go 模块改进 2020.1 现已支持 Go 1.13 的环境变量 GOPROXY、GOPRIVATE、GOSUMDB、GONOPROXY 和 GONOSUMB。
使用 Go Modules 项目模板配置其默认值。只需点击 Environment 字段中的 Browse 图标即可打开新的 Environment Variables 对话框。
go.mod 文件支持 go、module、require、replace 和 exclude 关键字代码补全、依赖项名称以及本地路径替换。
此外，也可以使用 Rename 和 Move 重构。 重命名或移动由 replace 语句引用的目录时，GoLand 将相应地更改 go.mod 文件中的路径。
现在，您还可以通过 Project 视图调用 Find Usages，以探索 go.mod 文件中特定目录路径的使用位置。
在 GoLand 2020.1 中，您可以通过 Alt-Enter 获取缺失的依赖项并移除未使用的依赖项。
最后但同样重要的是，如果存在本地路径替换，则新版本将在您提交之前显示一条通知，这样您就不会意外提交它们。
您无需学习如何使用的代码补全功能 GoLand 2020.1 将建议 if err != nil { &amp;hellip; } 来补全错误处理模式。 只需在表达式内输入 if。
只需输入 type 关键字或 struct 和 interface，即可更快地定义结构和接口类型。
Fill Fields 操作在格式化规则要求时会在冒号后面添加空格。 它还会在组合文字声明中语句的末尾添加逗号。
现在，使用 map 时，代码补全会在您补全键类型后将光标移到右中括号后面。
对于函数的返回类型，补全功能将为局部变量和零值提供适合相应返回值类型的建议。
智能代码补全（⌥⇧Space 或 Ctrl+Shift+Space） 智能代码补全会建议一个指向结构初始值设定项的指针。
它还会建议在断言和类型 switch 用例中首先使用兼容类型。
在类型断言中，它提供已赋值变量的类型。
最后，它提供了表达式中可能指针的建议列表。
基本代码补全（⌃空格或 Ctrl+空格） 为注释添加了基本代码补全，这将使编写文档更加轻松！ 它可为当前包声明建议名称，并为函数和方法建议参数名称。除此之外，基本代码补全还可以建议文字和转换。
代码编辑 编写多值返回函数的签名时，GoLand 2020.1 会在逗号后面的返回类型周围添加括号。当您在字符串文字中粘贴一些文本时，IDE 会转义双引号。
Go 1.14 支持 1）支持重叠接口
Go 1.14 添加了对嵌入重叠接口的支持，我们也添加了此功能！ 当您使用重叠接口描述类型的不同方面时，GoLand 不会将这些方面的重复方法报告为错误。
2）自动 vendoring 模式
如果模块根包含 vendor 目录，则会在 Go 1.14 中自动启用 vendoring 模式。 对于 GoLand 2020.1，我们决定为 Go 1.13 及更早版本实现类似的行为。 IDE 会自动将导入解析到 vendor/ 文件夹（如果模块中存在）。
调试器更新 1）分析器标签支持
为了帮助您在调试或核心转储分析过程中更轻松地区分 goroutine，我们为其添加了分析器标签。更多详情请参考：如何在调试过程中查找 Goroutine 。
2）宏支持
现在，可以将宏用作运行或调试应用程序的参数。 在 Run/Debug Configurations 对话框中，点击 Go Tool 中的 + 或 Program arguments 字段即可打开新的 Macros 对话框，其中会列出要使用的可用宏。
此外，您现在还可以将配置文件存储在项目中。 在 Run/Debug Configurations 对话框的顶部，选择 Store 作为项目文件选项。</description>
			<content type="html"><![CDATA[<p>北京时间 2020 年 4 月 10 日凌晨，Jetbrains 宣布正式发布 GoLand 2020.1 版本。</p>
<p>该版本主要的变化有：</p>
<p>引入了对 Go 模块支持的各种升级以及代码编辑功能，这些功能几乎不需要用户交互，也不需要扩展的代码补全系列。</p>
<p>除此之外，还添加了新的代码检查、快速修复和其他改进，例如新的 LightEdit 模式（可让您在文本编辑器中打开文件，而无需创建或加载项目）、智能拼写和语法检查以及用于 Web 开发和数据库处理的新功能。</p>
<p>Go 语言中文网在 2020.1 还未正式发布之前，就发过关于该版本特性的文章，现在 2020.1 正式发布了，相关功能特性稳定了，我们再次介绍下相关新特性。</p>
<h2 id="go-模块改进">Go 模块改进</h2>
<p>2020.1 现已支持 Go 1.13 的环境变量 GOPROXY、GOPRIVATE、GOSUMDB、GONOPROXY 和 GONOSUMB。</p>
<p>使用 Go Modules 项目模板配置其默认值。只需点击 Environment 字段中的 Browse 图标即可打开新的 Environment Variables 对话框。</p>
<p>go.mod 文件支持 go、module、require、replace 和 exclude 关键字代码补全、依赖项名称以及本地路径替换。</p>
<p>此外，也可以使用 Rename 和 Move 重构。 重命名或移动由 replace 语句引用的目录时，GoLand 将相应地更改 go.mod 文件中的路径。</p>
<p>现在，您还可以通过 Project 视图调用 Find Usages，以探索 go.mod 文件中特定目录路径的使用位置。</p>
<p>在 GoLand 2020.1 中，您可以通过 Alt-Enter 获取缺失的依赖项并移除未使用的依赖项。</p>
<p>最后但同样重要的是，如果存在本地路径替换，则新版本将在您提交之前显示一条通知，这样您就不会意外提交它们。</p>
<h2 id="您无需学习如何使用的代码补全功能">您无需学习如何使用的代码补全功能</h2>
<p>GoLand 2020.1 将建议 if err != nil { &hellip; } 来补全错误处理模式。 只需在表达式内输入 if。</p>
<p>只需输入 type 关键字或 struct 和 interface，即可更快地定义结构和接口类型。</p>
<p>Fill Fields 操作在格式化规则要求时会在冒号后面添加空格。 它还会在组合文字声明中语句的末尾添加逗号。</p>
<p>现在，使用 map 时，代码补全会在您补全键类型后将光标移到右中括号后面。</p>
<p>对于函数的返回类型，补全功能将为局部变量和零值提供适合相应返回值类型的建议。</p>
<h2 id="智能代码补全space-或-ctrlshiftspace">智能代码补全（⌥⇧Space 或 Ctrl+Shift+Space）</h2>
<p>智能代码补全会建议一个指向结构初始值设定项的指针。</p>
<p>它还会建议在断言和类型 switch 用例中首先使用兼容类型。</p>
<p>在类型断言中，它提供已赋值变量的类型。</p>
<p>最后，它提供了表达式中可能指针的建议列表。</p>
<h2 id="基本代码补全空格或-ctrl空格">基本代码补全（⌃空格或 Ctrl+空格）</h2>
<p>为注释添加了基本代码补全，这将使编写文档更加轻松！ 它可为当前包声明建议名称，并为函数和方法建议参数名称。除此之外，基本代码补全还可以建议文字和转换。</p>
<h2 id="代码编辑">代码编辑</h2>
<p>编写多值返回函数的签名时，GoLand 2020.1 会在逗号后面的返回类型周围添加括号。当您在字符串文字中粘贴一些文本时，IDE 会转义双引号。</p>
<h2 id="go-114-支持">Go 1.14 支持</h2>
<p>1）支持重叠接口</p>
<p>Go 1.14 添加了对嵌入重叠接口的支持，我们也添加了此功能！ 当您使用重叠接口描述类型的不同方面时，GoLand 不会将这些方面的重复方法报告为错误。</p>
<p>2）自动 vendoring 模式</p>
<p>如果模块根包含 vendor 目录，则会在 Go 1.14 中自动启用 vendoring 模式。 对于 GoLand 2020.1，我们决定为 Go 1.13 及更早版本实现类似的行为。 IDE 会自动将导入解析到 vendor/ 文件夹（如果模块中存在）。</p>
<h2 id="调试器更新">调试器更新</h2>
<p>1）分析器标签支持</p>
<p>为了帮助您在调试或核心转储分析过程中更轻松地区分 goroutine，我们为其添加了分析器标签。更多详情请参考：<a href="https://mp.weixin.qq.com/s/ANNUlYvWshNikNwCw6qSHw" target="_blank" rel="noopener">如何在调试过程中查找 Goroutine</a>
。</p>
<p>2）宏支持</p>
<p>现在，可以将宏用作运行或调试应用程序的参数。 在 Run/Debug Configurations 对话框中，点击 Go Tool 中的 + 或 Program arguments 字段即可打开新的 Macros 对话框，其中会列出要使用的可用宏。</p>
<p>此外，您现在还可以将配置文件存储在项目中。 在 Run/Debug Configurations 对话框的顶部，选择 Store 作为项目文件选项。</p>
<h2 id="后缀补全">后缀补全</h2>
<p><code>.else</code> <em>Postfix Completion</em> 模板可以快速添加 <code>if</code> 语句来检查表达式是否为假。</p>
<h2 id="快速修复">快速修复</h2>
<p>按下 Alt+Enter，可立即将非格式化调用更改为格式化调用。现在，Create variable 快速修复会显示预期的类型提示，以便您更轻松地输入正确的值。</p>
<h2 id="代码检查">代码检查</h2>
<p>新代码检查可以警告您注意非指针接收器上指针方法的无效调用，并提供了快速修复。</p>
<p>如果错误使用 uintptr 和 unsafe.Pointer 将整数转换为指针，Invalid conversions of uintptr to unsafe.Pointer 代码检查会发出警告。</p>
<p>Unmarshal is called with incorrect argument 检查可以分析对 json.Unmarshal 以及 encoding/json、encoding/xml 和 encoding/gob 包的类似函数的调用。</p>
<p>Locks mistakenly passed by value 代码检查可帮助您避免意外复制包含锁定的值。</p>
<h2 id="实时模板">实时模板</h2>
<p>添加了新模板来帮助您快速创建声明组。 其中包括 consts、vars、types 和 imports。 当您使用这些模板之一时，GoLand 将在声明名称周围添加大括号。</p>
<p>fori 模板可为经典的 for 循环插入样板代码。</p>
<h2 id="重构">重构</h2>
<p>Extract Method 重构会保留父函数和方法参数的原始顺序。Rename 重构现在会自动检测声明的重命名。 这意味着当您手动重命名声明时，IDE 将显示一个间距图标，此图标会建议重命名其所有用法。</p>
<h2 id="导航">导航</h2>
<p>Navigate to implementations（macOS 上为 ⌥⌘B，Windows/Linux 上为 Ctrl+Alt+B）和 Navigate to Declaration 或 Usages（macOS 上为 ⌘B，Windows/Linux 上为 Ctrl+B）现在会首先显示当前项目中的结果。</p>
<p>此外，默认情况下，Find Usages（Windows/Linux 上为 Alt+F7，macOS 上为 ⌥F7）操作现在会始终查找接口方法的用法。 要像以前一样查找当前方法的用法，请在 Windows/Linux 上使用 Alt+Shift+Ctrl+F7 或在 macOS 上使用 ⌥⇧⌘F7。</p>
<h2 id="改进-vcs">改进 VCS</h2>
<p>1）新 Commit 工具窗口</p>
<p>现在，新的 Commit 工具窗口包含 <em>Local Changes</em> 和 <em>Shelf</em> 选项卡。 此工具窗口涵盖了与提交有关的所有任务，例如检查差异，选择要提交的文件和块，以及输入提交消息。 Commit 是位于屏幕左侧的垂直工具窗口，这样就为整个编辑器留出了显示差异的空间。</p>
<p>2）改进了 Branches 弹出窗口</p>
<p><em>Branches</em> 弹出窗口在多个方面进行了重新设计：</p>
<ul>
<li>我们添加了一个显式搜索字段，您可以借助此字段查找现有的远程和本地分支。</li>
<li>现在，您可以使用 <em>Refresh</em> 按钮更新现有的远程分支。</li>
<li>传入（蓝色）和传出（绿色）提交指示器已添加到状态栏。</li>
</ul>
<p>3）Interactively Rebase from Here 对话框</p>
<p>大幅重新设计了 Interactively Rebase from Here。 您可以利用此对话框编辑、组合及移除之前的提交，从而让您的提交历史记录更加清晰易懂。</p>
<p>要调用此对话框，请转到 Git 工具窗口的 Log 选项卡，在要编辑的一系列提交中选择最旧的提交，点击右键，然后选择 Interactively Rebase from Here。</p>
<h2 id="数据库更新">数据库更新</h2>
<ul>
<li>使用 <em>Run configurations</em> 运行脚本文件和代码段。 这样，您可以在启动前一次运行多个文件，对它们进行重新排序，添加新文件以及运行其他程序或配置。</li>
<li>现在，您可以在代码编辑器中查看结果。 默认情况下，此选项处于禁用状态。 要启用此功能，请转到 <em>Settings/Preferences | Database | General | Show output results in the editor</em>。</li>
<li>创建 SSH 隧道的配置，并在许多数据源或项目中使用。</li>
<li>我们添加了以 Excel 格式导出数据的功能。</li>
<li>另外，您也可以在提取程序下拉列表中选择首选数据格式。</li>
</ul>
<h2 id="web开发">Web开发</h2>
<p>1）用于 JavaScript 和 TypeScript 的新智能意图和检查</p>
<p>使用新的智能意图和检查 (Alt+Enter) 可在编码时节省时间！ 例如，您现在可以快速地将现有代码转换为可选链和/或空值合并，该语法已在最新版本的 JavaScript 和 TypeScript 中引入。</p>
<p>2）更有帮助的快速文档</p>
<p>对于 JavaScript 和 TypeScript，<em>Documentation</em> 弹出窗口现在会显示更多有用的信息，包括符号类型和可视性的详细信息以及定义符号的位置。</p>
<h2 id="其他变更">其他变更</h2>
<ul>
<li>JetBrains 的新字体 <em>JetBrains Mono</em> 默认可用。 要详细了解该字体，请访问<a href="https://www.jetbrains.com/lp/mono/" target="_blank" rel="noopener">此页面</a>
。</li>
<li>默认捆绑了 <em>Grazie</em>，此插件可为您在 IDE 中编写的文本提供智能的拼写和语法检查。</li>
<li>新的 <em>LightEdit 模式</em>允许您在文本编辑器中打开文件，而无需创建或加载项目。 要试用此这一功能，您首先需要从 <em>Tools | Create Command-line Launcher</em> 创建命令行启动器，如<a href="https://www.jetbrains.com/help/idea/working-with-the-ide-features-from-command-line.html" target="_blank" rel="noopener">此处</a>
所述（如果您使用的是 Toolbox App，步骤<a href="https://www.jetbrains.com/help/idea/working-with-the-ide-features-from-command-line.html#toolbox" target="_blank" rel="noopener">略有不同</a>
）。 有关如何打开文件、比较/合并文件甚至运行代码检查的详细说明，请参阅<a href="https://www.jetbrains.com/help/idea/opening-files-from-command-line.html" target="_blank" rel="noopener">此 Web 帮助部分</a>
。</li>
<li>我们添加了新的 <em>Zen 模式</em>，它消除了可能的干扰，可帮助您完全专注于代码。 本质上，此模式结合了<em>免打扰模式</em>和<em>全屏模式</em>。 要启用此模式，请转到 <em>View | Appearance | Enter Zen Mod</em>，或者从 <em>Quick Switch Scheme</em> 弹出窗口中选择 (<em>Ctrl+` | View mode | Enter Zen Mode</em>)。</li>
<li><em>外部文档</em>现在指向 <a href="https://pkg.go.dev/" target="_blank" rel="noopener">https://pkg.go.dev</a>
 而不是 <a href="https://godoc.org/" target="_blank" rel="noopener">https://godoc.org</a>
。</li>
<li>我们恢复了<em>默认</em>配色方案，但采用新名称 <em>Classic Light</em>。</li>
</ul>
<h2 id="结语">结语</h2>
<p>新版本可以免费试用 30 天。新版本下载地址：<a href="https://www.jetbrains.com/zh-cn/go/download/" target="_blank" rel="noopener">https://www.jetbrains.com/zh-cn/go/download/</a>
。该下载页面支持通过微信和支付宝支付。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇4：自定义 Renderer，增强或替换模板引擎</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom04-renderer/</link>
			<pubDate>Mon, 16 Mar 2020 10:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom04-renderer/</guid>
			<description>Render，顾名思义，要进行页面渲染。Go 语言不但自带有强大的 http 库，还自带了 HTML 模板引擎。Echo 框架对模板引擎进行了一些额外处理，并提供了给用户自定义页面渲染的接口。本文就相关问题进行探讨。 模板渲染 Echo 框架的 Context 接口提供了下面的方法进行页面渲染： // echo 包中 Context 接口的方法 Render(code int, name string, data interface{}) error 其中，code 是 HTTP Status，name 是定义的模板名，data 是模板可能需要的数</description>
			<content type="html"><![CDATA[<p>Render，顾名思义，要进行页面渲染。Go 语言不但自带有强大的 http 库，还自带了 HTML 模板引擎。Echo 框架对模板引擎进行了一些额外处理，并提供了给用户自定义页面渲染的接口。本文就相关问题进行探讨。</p>
<h2 id="模板渲染">模板渲染</h2>
<p>Echo 框架的 Context 接口提供了下面的方法进行页面渲染：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// echo 包中 Context 接口的方法
</span><span class="c1"></span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></div><p>其中，code 是 HTTP Status，name 是定义的模板名，data 是模板可能需要的数据。执行这个方法后，通过数据渲染模板，并发送带有 HTTP 状态的 text/html 响应。可以通过 Echo.Renderer 来注册模板，从而允许我们使用任何模板引擎。</p>
<p>Renderer 接口定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Renderer is the interface that wraps the Render function.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Renderer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">Render</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>这里可能会有点迷糊，怎么有两个 Render 方法，而且它们的签名还不一样。这里的逻辑是这样的：</p>
<ul>
<li>echo.Echo 类型有一个 Renderer 接口类型的字段，用来注册模板引擎；</li>
<li>echo.Context 接口类型有一个 Render 方法，在 Handle 中我们通过调用 Context 的 Render 方法进行模板渲染；</li>
<li>在 Context 的 Render 方法内部（当然是 echo 中 Context 接口的默认实现），会调用 echo.Echo 的字段 Renderer 的 Render 方法，进行具体的模板渲染；</li>
</ul>
<p>这里是具体的渲染源码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">context</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">echo</span><span class="p">.</span><span class="nx">Renderer</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ErrRendererNotRegistered</span>
	<span class="p">}</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">echo</span><span class="p">.</span><span class="nx">Renderer</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">HTMLBlob</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><p>可见，如果调用了 Context#Render 进行模板渲染，但并没有注册模板引擎则会报错（ErrRendererNotRegistered）。</p>
<h3 id="集成标准库模板引擎">集成标准库模板引擎</h3>
<p>1、我们先定义一个类型：Template，然后实现 Echo.Renderer 接口，即提供 Render 方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Template</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">templates</span> <span class="o">*</span><span class="nx">template</span><span class="p">.</span><span class="nx">Template</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">templates</span><span class="p">.</span><span class="nf">ExecuteTemplate</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>2、接着预编译一个模板。定义一个模板文件：template/index.html，内容如下：</p>
<pre tabindex="0"><code>{{define &quot;index&quot;}}Hello, {{.}}!{{end}}
</code></pre><p>然后预编译得到 Template 的实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">tpl</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Template</span><span class="p">{</span>
    <span class="nx">templates</span><span class="p">:</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">ParseGlob</span><span class="p">(</span><span class="s">&#34;template/*.html&#34;</span><span class="p">)),</span>
<span class="p">}</span>
</code></pre></div><p>3、注册模板引擎：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

<span class="nx">e</span><span class="p">.</span><span class="nx">Renderer</span> <span class="p">=</span> <span class="nx">tpl</span>
</code></pre></div><p>4、在 Handler 中渲染模板：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;index&#34;</span><span class="p">,</span> <span class="s">&#34;studygolang&#34;</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div><p>注意这里的 index 是模板文件中 <code>define &quot;index&quot;</code> ，而不是文件名。</p>
<p>编译后运行，浏览器正常显示：Hello，studygolang!</p>
<p><p class="md__image">
  <img src="https://s2.ax1x.com/2020/03/08/3v2XQ0.png"
    alt=""  />
</p>
</p>
<h2 id="通用化定制">通用化定制</h2>
<p>一般的，页面会有一些通用的部分，比如头部、尾部等。所以业界通常的做法是有一个 layout，而且还可能不止一个 layout，因为普通用户看到的和后台看到的头部、尾部一般会不一样。那这样的通用化定制需求该如何集成到 Echo 的 Render 中呢？</p>
<p>先考虑只有一种 layout 的情况。定义一个类型 layoutTemplate，实现 Echo.Renderer 接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">layoutTemplate</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">var</span> <span class="nx">LayoutTemplate</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">layoutTemplate</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">layoutTemplate</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">contentTpl</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">layout</span> <span class="o">:=</span> <span class="s">&#34;layout.html&#34;</span>
	<span class="nx">tpl</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">layout</span><span class="p">).</span><span class="nf">ParseFiles</span><span class="p">(</span><span class="s">&#34;template/common/&#34;</span><span class="o">+</span><span class="nx">layout</span><span class="p">,</span> <span class="s">&#34;template/&#34;</span><span class="o">+</span><span class="nx">contentTpl</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">tpl</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>然后注册该 Renderer，并在 Handler 中渲染，注意 ctx.Render 的第二个参数，跟上面说的不一样，我们传递的是子模板的文件名：index.html。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

<span class="nx">e</span><span class="p">.</span><span class="nx">Renderer</span> <span class="p">=</span> <span class="nx">render</span><span class="p">.</span><span class="nx">LayoutTemplate</span>

<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;index.html&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div><p>这里用到了两个模板文件：layout.html 和  index.html，来源 Hugo 的 <a href="https://themes.gohugo.io/theme/soho/" target="_blank" rel="noopener">soho 这个模板</a>
。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">xmlns</span><span class="o">=</span><span class="s">&#34;http://www.w3.org/1999/xhtml&#34;</span> <span class="na">xml:lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;content-type&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;text/html; charset=utf-8&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Echo博客系统<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;author&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;Go语言中文网站长polaris&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;keywords&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;&#34;</span> <span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;description&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;&#34;</span> <span class="p">/&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/static/css/print.css&#34;</span> <span class="na">media</span><span class="o">=</span><span class="s">&#34;print&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/static/css/poole.css&#34;</span><span class="p">&gt;</span> 
  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/static/css/hyde.css&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span>
        <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&amp;display=swap&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span>
        <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css&#34;</span>
        <span class="na">integrity</span><span class="o">=</span><span class="s">&#34;sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=&#34;</span>
        <span class="na">crossorigin</span><span class="o">=</span><span class="s">&#34;anonymous&#34;</span> <span class="p">/&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;apple-touch-icon-precomposed&#34;</span>
        <span class="na">sizes</span><span class="o">=</span><span class="s">&#34;144x144&#34;</span>
        <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://themes.gohugo.io//theme/soho/apple-touch-icon-144-precomposed.png&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;shortcut icon&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://themes.gohugo.io//theme/soho/favicon.png&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">aside</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;sidebar&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;container&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;sidebar-about&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;author-image&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">img</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://themes.gohugo.io/theme/soho/images/profile.png&#34;</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;img-circle img-headshot center&#34;</span> <span class="na">alt</span><span class="o">=</span><span class="s">&#34;Profile Picture&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Echo-Gopher<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">nav</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">ul</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;sidebar-nav&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/&#34;</span><span class="p">&gt;</span>Home<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span> <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/about/&#34;</span><span class="p">&gt;</span> About <span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span> <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">nav</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">section</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;social-icons&#34;</span><span class="p">&gt;</span>

            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://github.com/polaris1119&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;me&#34;</span> <span class="na">title</span><span class="o">=</span><span class="s">&#34;GitHub&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">i</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;fab fa-github&#34;</span> <span class="na">aria-hidden</span><span class="o">=</span><span class="s">&#34;true&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">i</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
            
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://weibo.com/studygolang&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;me&#34;</span> <span class="na">title</span><span class="o">=</span><span class="s">&#34;Weibo&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">i</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;fab fa-weibo&#34;</span> <span class="na">aria-hidden</span><span class="o">=</span><span class="s">&#34;true&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">i</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
            
        <span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">aside</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">main</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;content container&#34;</span><span class="p">&gt;</span>
    {{template &#34;content&#34; .}}
  <span class="p">&lt;/</span><span class="nt">main</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">footer</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;copyright&#34;</span><span class="p">&gt;</span>
      <span class="ni">&amp;copy;</span> polaris 2020 · <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://creativecommons.org/licenses/by-sa/4.0&#34;</span><span class="p">&gt;</span>CC BY-SA 4.0<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">footer</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js&#34;</span>
  <span class="na">integrity</span><span class="o">=</span><span class="s">&#34;sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=&#34;</span>
  <span class="na">crossorigin</span><span class="o">=</span><span class="s">&#34;anonymous&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
  
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><p>这是 layout.html 的内容，核心在于 <code>{{template &quot;content&quot; .}}</code>，表示具体内容模板需要定义 content，所以看看 index.html 文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html">{{define &#34;content&#34;}}
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;posts&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">article</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h2</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-title&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/&#34;</span><span class="p">&gt;</span>Echo 系列教程 — 定制篇3：自定义 Logger，用你喜欢的日志库<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-date&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">time</span> <span class="na">datetime</span><span class="o">=</span><span class="s">&#34;2020-03-06T00:00:00Z&#34;</span><span class="p">&gt;</span>Mar 06, 2020<span class="p">&lt;/</span><span class="nt">time</span><span class="p">&gt;</span> · 3 min read
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
        在知识星球简书项目中，我们分析对比了目前的一些日志库。虽然 Go 标准库有一个 log，但功能有限，所以才出现了很多第三方的日志库。
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;read-more-link&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;http://blog.studygolang.com/2020/03/echo-custom-logger/&#34;</span><span class="p">&gt;</span>阅读全文<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>

    <span class="p">&lt;</span><span class="nt">article</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h2</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-title&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/&#34;</span><span class="p">&gt;</span>Echo 系列教程 — 定制篇2：自定义 Validator，进行输入校验<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-date&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">time</span> <span class="na">datetime</span><span class="o">=</span><span class="s">&#34;2020-02-28T00:00:00Z&#34;</span><span class="p">&gt;</span>Feb 28, 2020<span class="p">&lt;/</span><span class="nt">time</span><span class="p">&gt;</span> · 4 min read
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
        上一篇讲 Binder 时提到，参数自动绑定和校验是 Web 框架很重要的两个功能，可以极大的提升开发速度，并更好的保证数据的可靠性（服务端数据校验很重要）。
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;read-more-link&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;http://blog.studygolang.com/2020/02/echo-custom-validator/&#34;</span><span class="p">&gt;</span>阅读全文<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
{{end}}
</code></pre></div><p>运行后打开浏览器访问 http://localhost:2020 ：</p>
<p><p class="md__image">
  <img src="https://s1.ax1x.com/2020/03/13/8uzXAf.png"
    alt=""  />
</p>
</p>
<p>接下来看看如何处理多个 layout 的情况。</p>
<p>因为 Render 的签名是固定的，不同的 layout 通过什么方式告知 Render 呢？观察 Render 方法的参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nf">Render</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span>
</code></pre></div><p>可以在 data 和 ctx 上下功夫：</p>
<ol>
<li>
<p>将 data 指定为 map[string]interface{}，layout 通过 data 传递；</p>
</li>
<li>
<p>通过 ctx 的 Set 方法设置 layout，方法内通过 ctx.Get 获取 layout；</p>
</li>
</ol>
<p>先看第 1 种方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NoNavRender 没有导航的 layout html 输出
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NoNavRender</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">contentTpl</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">data</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">data</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
	<span class="p">}</span>
	<span class="nx">data</span><span class="p">[</span><span class="s">&#34;layout&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;nonav_layout.html&#34;</span>

	<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">contentTpl</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在 render 包中增加了一个 NoVaRender 函数，该函数要求 data 必须是 map[string]interface{}，这样就可以做到将 layout 传递给 Render 方法，不过因为 Render 方法的 data 参数是 interface{} 类型，因此得做类型断言。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">layout</span> <span class="o">:=</span> <span class="s">&#34;layout.html&#34;</span>

<span class="k">if</span> <span class="nx">data</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">dataMap</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">.(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{});</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">layoutInter</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">dataMap</span><span class="p">[</span><span class="s">&#34;layout&#34;</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
      <span class="nx">layout</span> <span class="p">=</span> <span class="nx">layoutInter</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>看看第 2 种方式如何实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NoNavRender 没有导航的 layout html 输出
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NoNavRender</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">contentTpl</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ctx</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;layout&#34;</span><span class="p">,</span> <span class="s">&#34;nonav_layout.html&#34;</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">contentTpl</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在 Render 中获取 layout 的值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">layout</span> <span class="o">:=</span> <span class="s">&#34;layout.html&#34;</span>

<span class="nx">layoutInter</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;layout&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">layoutInter</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">layout</span> <span class="p">=</span> <span class="nx">layoutInter</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>两种方式个人觉得第 2 种更优雅。不过需要注意的是，两种方式要注意 layout 不能冲突，也就是不能他用。</p>
<p>另外，我个人建议，data 参数永远要么传递 nil，要么传递 map[string]interface{} 。个人感觉 Echo 的 Render 方法 data 参数的类型不应该用 interface{} 而是用 map[string]interface{}，这样可以更方便地往 data 中加入更多全局的数据。在简书项目中，我们会通过其他方式弥补这个问题。</p>
<h2 id="小结">小结</h2>
<p>通过本节，你应该掌握了 Render 的使用、集成和大项目 layout 的处理。</p>
<p>额外提一句，因为 Context.Render 方法最终是调用的 Context.HTML 方法进行渲染，因此我们也完全可以抛弃 Render 方法，而是使用自己的 Render。目前简书的代码（后续会改掉）和 studygolang 的源码采用的就是完全抛弃 Context.Render 的方式，主要考虑还是有一些 Render 不能很好满足的地方，比如上面说的多 layout、data 类型等，不过也是可以解决的。因此还是建议采用 Echo 框架的 Render。</p>
<p>本节<a href="https://github.com/polaris1119/go-echo-example/tree/0cd46e8b1f38317439e95d55e3fe29a173a2e3c1" target="_blank" rel="noopener">完整代码点这里</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇5：自定义 HTTP Error Handler，让 HTTP 错误处理更友好</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom05-error-handler/</link>
			<pubDate>Mon, 16 Mar 2020 10:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom05-error-handler/</guid>
			<description>Echo 倡导通过从中间件和 Handler 返回错误来进行集中式 HTTP 错误处理。集中式错误处理程序使我们能够从统一位置将错误记录到外部服务，并向客户端发送自定义的 HTTP 响应。本节一起学习如何定制化，进行集中式错误处理。 默认的错误处理 在定制篇 4 中，我们讲到了 Render。如果在 Handler 中调用了 Render，但是并没有给 Echo.Renderer 赋值或其他原因，导致出错，页面看到的信息如下： { &amp;#34;message&amp;#34;: &amp;#34;Internal Server Error&amp;#34; } 这是 Echo 默认的 HTTP Error H</description>
			<content type="html"><![CDATA[<p>Echo 倡导通过从中间件和 Handler 返回错误来进行集中式 HTTP 错误处理。集中式错误处理程序使我们能够从统一位置将错误记录到外部服务，并向客户端发送自定义的 HTTP 响应。本节一起学习如何定制化，进行集中式错误处理。</p>
<h2 id="默认的错误处理">默认的错误处理</h2>
<p>在定制篇 4 中，我们讲到了 Render。如果在 Handler 中调用了 Render，但是并没有给 Echo.Renderer 赋值或其他原因，导致出错，页面看到的信息如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
	<span class="nt">&#34;message&#34;</span><span class="p">:</span> <span class="s2">&#34;Internal Server Error&#34;</span>
<span class="p">}</span>
</code></pre></div><p>这是 Echo 默认的 HTTP Error Handler，表示发生了 500 - Internal Server Error 错误。看看该默认 Error Handler 的代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// DefaultHTTPErrorHandler is the default HTTP error handler. It sends a JSON response
</span><span class="c1">// with status code.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">DefaultHTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">he</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">HTTPError</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Internal</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">herr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Internal</span><span class="p">.(</span><span class="o">*</span><span class="nx">HTTPError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">he</span> <span class="p">=</span> <span class="nx">herr</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">he</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">HTTPError</span><span class="p">{</span>
			<span class="nx">Code</span><span class="p">:</span>    <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">,</span>
			<span class="nx">Message</span><span class="p">:</span> <span class="nx">http</span><span class="p">.</span><span class="nf">StatusText</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">),</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Issue #1426
</span><span class="c1"></span>	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Code</span>
	<span class="nx">message</span> <span class="o">:=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Message</span>
	<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Debug</span> <span class="p">{</span>
		<span class="nx">message</span> <span class="p">=</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.(</span><span class="kt">string</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">message</span> <span class="p">=</span> <span class="nx">Map</span><span class="p">{</span><span class="s">&#34;message&#34;</span><span class="p">:</span> <span class="nx">m</span><span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Send response
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">Response</span><span class="p">().</span><span class="nx">Committed</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Request</span><span class="p">().</span><span class="nx">Method</span> <span class="o">==</span> <span class="nx">http</span><span class="p">.</span><span class="nx">MethodHead</span> <span class="p">{</span> <span class="c1">// Issue #608
</span><span class="c1"></span>			<span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">NoContent</span><span class="p">(</span><span class="nx">he</span><span class="p">.</span><span class="nx">Code</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>如果是非 HTTPError，会包装成 HTTPError，并设置为 500 - Internal Server Error；</li>
<li>如果开启了 Debug 模式，则会输出具体的错误信息；</li>
</ul>
<p>因此，开启 Debug 模式（e.Debug = true）后，输出是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="s2">&#34;renderer not registered&#34;</span>
</code></pre></div><p>这对于调试很方便。</p>
<h2 id="集中化自定义错误处理">集中化自定义错误处理</h2>
<p>在有些时候，默认错误 HTTP 处理程序可能足够了；但是，如果你想捕获其他类型的错误并采取相应的处理，比如，发送通知电子邮件或将错误记录到外部日志系统中，这时集中化自定义错误处理就很有用了。除此之外，你可能还希望错误页面更好看，或发送个性化的 JSON 响应。</p>
<p>通过给 Echo#HTTPErrorHandler 设置一个 HTTPErrorHandler 来设置自定义的错误处理程序，HTTPErrorHandler 的定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// HTTPErrorHandler is a centralized HTTP error handler.
</span><span class="c1"></span><span class="kd">type</span>	<span class="nx">HTTPErrorHandler</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">,</span> <span class="nx">Context</span><span class="p">)</span>
</code></pre></div><h3 id="自定义错误页面">自定义错误页面</h3>
<p>一般来说，通过 Go 语言渲染页面的话，在发生错误时，渲染对应的错误页面，比如：404.html、500.html 等。</p>
<p>以下自定义 HTTP 错误处理程序根据不同类型的错误显示对应的错误页面并记录错误。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 放在 http 包下的 error.go 中
</span><span class="c1">// CustomHTTPErrorHandler 自定义 HTTP 错误处理
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">CustomHTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span>
	<span class="k">if</span> <span class="nx">he</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HTTPError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">code</span> <span class="p">=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Code</span>
	<span class="p">}</span>
	<span class="nx">errorPage</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d.html&#34;</span><span class="p">,</span> <span class="nx">code</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">File</span><span class="p">(</span><span class="s">&#34;template/&#34;</span> <span class="o">+</span> <span class="nx">errorPage</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在项目的 template 目录下加上相应的 html 文件，比如：404.html、500.html。之后设置上自定义的 CustomHTTPErrorHandler：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nx">HTTPErrorHandler</span> <span class="p">=</span> <span class="nx">myhttp</span><span class="p">.</span><span class="nx">CustomHTTPErrorHandler</span>
</code></pre></div><p>页面简单的包含一些内容，如 404.html 页面内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>404<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>这是404错误页面<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><p>编译启动程序后，随意访问一个不存在的路径：http://localhost:2020/notfound ，结果如下：</p>
<p><p class="md__image">
  <img src="../imgs/404.png"
    alt=""  />
</p>
</p>
<p>这里的错误，我们简单的记录下来。实际业务中，根据你的情况，可以发送到你需要记录的第三方系统中。</p>
<p>另外，这里给客户端的响应，不一定是 HTML 页面，还有可能是 JSON，根据实际的情况进行相应的处理。而且，实际中，HTML 页面也不会是这么简单的一个页面，可能涉及到一些通用数据，比如通用的头尾等。比如让这个错误页面更符合我们网站的风格，可以这么做：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// CustomHTTPErrorHandler 自定义 HTTP 错误处理
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">CustomHTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span>
	<span class="k">if</span> <span class="nx">he</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HTTPError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">code</span> <span class="p">=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Code</span>
	<span class="p">}</span>
	<span class="nx">errorPage</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d.html&#34;</span><span class="p">,</span> <span class="nx">code</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">errorPage</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>404.html 页面内容变为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html">{{define &#34;content&#34;}}
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;posts&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">article</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h2</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-title&#34;</span><span class="p">&gt;</span>你想要的页面走丢了！<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">hr</span><span class="p">&gt;</span>
        404
    <span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
{{end}}
</code></pre></div><p>这时 404 页面看起来像这样：</p>
<p><p class="md__image">
  <img src="../imgs/404-pretty.png"
    alt=""  />
</p>
</p>
<h3 id="怎么做到的">怎么做到的？</h3>
<p>为什么这么一句：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nx">HTTPErrorHandler</span> <span class="p">=</span> <span class="nx">myhttp</span><span class="p">.</span><span class="nx">CustomHTTPErrorHandler</span>
</code></pre></div><p>就可以接管错误处理？在 Echo 框架源码中搜索 <code>Echo#HTTPErrorHandler</code> 在哪里调用的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ServeHTTP implements `http.Handler` interface, which serves HTTP requests.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Acquire context
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="o">*</span><span class="nx">context</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span>

	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">NotFoundHandler</span>

	<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">premiddleware</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">e</span><span class="p">.</span><span class="nf">findRouter</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Host</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nf">getPath</span><span class="p">(</span><span class="nx">r</span><span class="p">),</span> <span class="nx">c</span><span class="p">)</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Handler</span><span class="p">()</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nf">applyMiddleware</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">middleware</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="nx">e</span><span class="p">.</span><span class="nf">findRouter</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Host</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nf">getPath</span><span class="p">(</span><span class="nx">r</span><span class="p">),</span> <span class="nx">c</span><span class="p">)</span>
			<span class="nx">h</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Handler</span><span class="p">()</span>
			<span class="nx">h</span> <span class="p">=</span> <span class="nf">applyMiddleware</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">middleware</span><span class="o">...</span><span class="p">)</span>
			<span class="k">return</span> <span class="nf">h</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nf">applyMiddleware</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">premiddleware</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Execute chain
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">h</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">e</span><span class="p">.</span><span class="nf">HTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Release context
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>以上代码的逻辑大体是：</p>
<ul>
<li>从池中获取一个 Context；</li>
<li>解析路由和中间件；</li>
<li>执行中间件链，发生错误时，调用 <code>e.HTTPErrorHandler</code>；</li>
<li>将 Context 放回池中；</li>
</ul>
<p>如果中间件（包括 Handler）执行没有出错，HTTPErrorHandler 自然执行不到。因此，我们可以不用上文提到的方式进行集中错误处理。**你知道是什么方式吗？**当然我们应该使用 HTTPErrorHandler 的方式，这是使用该框架的正确姿势。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇6：自定义 Server 相关，替换或扩展默认的 Server</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom06-ext-server/</link>
			<pubDate>Mon, 16 Mar 2020 10:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom06-ext-server/</guid>
			<description>这是定制篇的最后一节，讲解 Server 的自定义。 默认 Server 通常情况下，Echo 通过如下方式启动一个 HTTP Server： e := echo.New() e.GET(&amp;#34;/&amp;#34;, func(c echo.Context) error { return c.String(http.StatusOK, &amp;#34;Hello, World!&amp;#34;) }) e.Logger.Fatal(e.Start(&amp;#34;:2020&amp;#34;)) 我们打开源码一探究竟： // Start starts an HTTP server. func (e *Echo) Start(address string) error { e.Server.Addr = address return e.StartServer(e.Server) } 原来调用的是 StartServer，参数是默认的 Server 实例，它是一个 http.Server 的指针类型。 自定义 Server 知道了 Echo#Start 最终调用的是 Echo#StartServer，而且它的参数是一个 *http.Server 类型，所以自</description>
			<content type="html"><![CDATA[<p>这是定制篇的最后一节，讲解 Server 的自定义。</p>
<h2 id="默认-server">默认 Server</h2>
<p>通常情况下，Echo 通过如下方式启动一个 HTTP Server：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
</code></pre></div><p>我们打开源码一探究竟：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Start starts an HTTP server.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">Start</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Server</span><span class="p">.</span><span class="nx">Addr</span> <span class="p">=</span> <span class="nx">address</span>
	<span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nf">StartServer</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Server</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>原来调用的是 StartServer，参数是默认的 Server 实例，它是一个 http.Server 的指针类型。</p>
<h2 id="自定义-server">自定义 Server</h2>
<p>知道了 Echo#Start 最终调用的是 Echo#StartServer，而且它的参数是一个 <code>*http.Server</code> 类型，所以自定义一个 Server 很容易。我们先看看 http.Server 这个结构。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Server</span> <span class="kd">struct</span> <span class="p">{</span>
  	<span class="c1">// 指定 TCP 的监听地址，形式：&#34;host:port&#34;。如果空，则使用 &#34;:http&#34;，即 80 端口
</span><span class="c1"></span>    <span class="nx">Addr</span> <span class="kt">string</span>
	
		<span class="c1">// 当前服务器的 Handler，如果未设置，使用 http.DefaultServeMux
</span><span class="c1"></span>    <span class="nx">Handler</span> <span class="nx">Handler</span>

  	<span class="c1">// TLS 配置
</span><span class="c1"></span>    <span class="nx">TLSConfig</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>

  	<span class="c1">// 读取整个 request（包括 body）的最大允许时间（超时时间）
</span><span class="c1"></span>    <span class="nx">ReadTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

  	<span class="c1">// 从 Go1.8 开始增加。只是读取请求头的最大允许时间（超时时间）
</span><span class="c1"></span>    <span class="nx">ReadHeaderTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// Go 1.8
</span><span class="c1"></span>
  	<span class="c1">// 和 ReadTimeout 对应，这是写 response 的最大允许时间（超时时间）
</span><span class="c1"></span>    <span class="nx">WriteTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

  	<span class="c1">// 从 Go1.8 开始增加。下个请求到来前允许的最大空闲时间（keep-alive 启用时）。
</span><span class="c1"></span>  	<span class="c1">// 如果是 0，使用 ReadTimeout，都为 0 ，不会超时。
</span><span class="c1"></span>    <span class="nx">IdleTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// Go 1.8
</span><span class="c1"></span>
  	<span class="c1">// 允许的最大请求头（单位字节），默认值 DefaultMaxHeaderBytes
</span><span class="c1"></span>    <span class="nx">MaxHeaderBytes</span> <span class="kt">int</span>
		
  	<span class="c1">// 其他字段忽略。。。
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>默认情况下启动的 Server，超时时间是 0，也就是不会超时。我们自定义一个 Server，设置超时时间：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
  <span class="nx">Addr</span><span class="p">:</span>         <span class="s">&#34;:2020&#34;</span><span class="p">,</span>
  <span class="nx">ReadTimeout</span><span class="p">:</span>  <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
  <span class="nx">WriteTimeout</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">StartServer</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</code></pre></div><p>为了方便验证，我们将超时时间设置的较短：10s，实际项目这个肯定太短了。</p>
<h3 id="验证读超时是否生效">验证读超时是否生效</h3>
<p>往下看之前，你想想用什么办法可以验证？</p>
<p>因为 HTTP 是基于 TCP 的，我们可以简单的通过建立 TCP 连接，然后等待一段时间后，再发送 HTTP 报文，具体代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:2020&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">11</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="s">&#34;GET / HTTP/1.0\r\n\r\n&#34;</span><span class="p">)</span>
	<span class="nx">status</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">conn</span><span class="p">).</span><span class="nf">ReadString</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">status</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>通过修改 Sleep 的时间来控制等待时间，可以看看 10s 以内是否成功（刚好 10s 可能也会失败），10s 以上又是什么情况。</p>
<blockquote>
<p>注意，这里的 HTTP/1.0 不能改为 1.1 等，否则得提供 Host 头部</p>
</blockquote>
<p>Sleep 设置为 11s ，运行客户端后，如果返回 EOF，则表明超时设置生效了。</p>
<h2 id="自定义-listener">自定义 Listener</h2>
<p>Echo 框架支持自定义 Listener，即通过 <code>Echo#Listener</code> 进行设置。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:1323&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Listener</span> <span class="p">=</span> <span class="nx">l</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))</span>
</code></pre></div><p>什么场景下会需要自定义？或者说为什么 Echo 要让用户可以自定义 Listener？我认为有两种考虑：</p>
<ol>
<li>
<p>Listener 支持配置，具体就是 net.ListenConfig 类型。实际上，net 包中，net.Listen() 函数就是用了这个类型获取 Listener 实例；</p>
</li>
<li>
<p>除了使用 net.Listen 获取一个 Listener 接口的实例外，还有其他的方式可以获取 Listener 接口的实例；</p>
</li>
</ol>
<h3 id="unixlistener">UnixListener</h3>
<p>我们着重看看第 2 种情况。</p>
<p>net.Listener 是一个接口。在 net 库中，有 TCPListener 和 UnixListener，除此之外，其他的 Listener 都是基于这两种。比如 net.FileListener() 函数，最终是 TCPListener。</p>
<p>一般我们使用的就是 TCPListener，如果想在 echo 中使用 UnixListener，如何实现？（这个例子没有太多现实意义）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">unixAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ResolveUnixAddr</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="s">&#34;/tmp/echo.sock&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">unixListener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ListenUnix</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="nx">unixAddr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello Unix！&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Listener</span> <span class="p">=</span> <span class="nx">unixListener</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>因为基于 Unix Domain Socket，所以，没法直接浏览器访问。写一个测试程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">unixAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ResolveUnixAddr</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="s">&#34;/tmp/echo.sock&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">DialUnix</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">unixAddr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="s">&#34;GET / HTTP/1.0\r\n\r\n&#34;</span><span class="p">)</span>
	<span class="nx">body</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">body</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>客户端能够输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">HTTP/1.0 <span class="m">200</span> OK
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Wed, <span class="m">25</span> Mar <span class="m">2020</span> 06:35:12 GMT
Content-Length: <span class="m">13</span>

Hello Unix！
</code></pre></div><p>表示成功！</p>
<p>再提醒下，一般不会定义 Listener，你知晓能定义即可。</p>
<h2 id="tls-相关">TLS 相关</h2>
<p>这里顺便介绍下 Echo 对 TLS 的支持。一般来说是用不到的，因为实际中，我们会使用 Web Server 进行反向代理，由 Web Server 来处理 TLS。但了解相关内容还是有利的。</p>
<h3 id="https-server">HTTPS Server</h3>
<p>看下相应的方法签名：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">StartTLS</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">certFile</span><span class="p">,</span> <span class="nx">keyFile</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>相比 Echo#Start 方法，StartTLS 多了两个参数：certFile 和 keyFile。这两个参数是什么意思？这里简单介绍下，知晓什么意思即可。</p>
<ul>
<li>certFile：证书</li>
<li>keyFile：私钥</li>
</ul>
<p>net/http 包，这两个参数是字符串，代表两个文件的路径。Echo 对此进行了扩展，除了可以代表文件的路径，还可以是字节数组，表示证书和私钥的具体内容。</p>
<p>CA 证书可以购买，也可以申请免费的（阿里云、七牛云都有），也可以使用 let’s encrypt 免费证书。这里我们先自己生成证书，本地验证。（注意，自己生成的证书，浏览器是不认的）</p>
<h4 id="证书生成">证书生成</h4>
<p>证书的生成可以用 Linux/Mac 的 OpenSSL 工具链。对于一个网站，首先必须有自己的私钥，私钥的生成方式为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> go-cache-example <span class="c1"># 切换到我们的项目根目录</span>
$ openssl genrsa -out server.key <span class="m">2048</span>
</code></pre></div><p>会在当前目录下生成一个 server.key 文件，这就是私钥。</p>
<p>利用私钥就可以生成证书了。OpenSSL 使用 x509 命令生成证书。这里需要区分两个概念：证书（certificate）和证书请求（certificate sign request）</p>
<ul>
<li>证书是自签名或 CA 签名过的凭据，用来进行身份认证</li>
<li>证书请求是对签名的请求，需要使用私钥进行签名</li>
</ul>
<p>x509 命令可以将证书和证书请求相互转换。</p>
<p>从私钥可以生成自签名证书：（跳过了证书请求，一步到位）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">openssl req -new -x509 -key server.key -out server.crt -days <span class="m">365</span>
</code></pre></div><p>req 命令会通过命令行要求用户输入国家、地区、组织等信息，这些信息会附加在证书中展示给连接方。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class="s1">&#39;.&#39;</span>, the field will be left blank.
-----
Country Name <span class="o">(</span><span class="m">2</span> letter code<span class="o">)</span> <span class="o">[]</span>:CN
State or Province Name <span class="o">(</span>full name<span class="o">)</span> <span class="o">[]</span>:Beijing
Locality Name <span class="o">(</span>eg, city<span class="o">)</span> <span class="o">[]</span>:Beijing
Organization Name <span class="o">(</span>eg, company<span class="o">)</span> <span class="o">[]</span>:studygolang
Organizational Unit Name <span class="o">(</span>eg, section<span class="o">)</span> <span class="o">[]</span>:
Common Name <span class="o">(</span>eg, fully qualified host name<span class="o">)</span> <span class="o">[]</span>:localhost
Email Address <span class="o">[]</span>:polaris@studygolang.com
</code></pre></div><p>以上命令会在当前目录生成 server.crt 文件。</p>
<p>这样我们有了上面需要的 cert 和 key。</p>
<h3 id="验证本地的-https-server">验证本地的 HTTPS Server</h3>
<p>在 go-cache-example 项目中的 cmd/custom/main.go 包含如下代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello TLS！&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">StartTLS</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">,</span> <span class="s">&#34;server.crt&#34;</span><span class="p">,</span> <span class="s">&#34;server.key&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>启动服务：go run cmd/custom/main.go</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">   ____    __
  / __/___/ /  ___
 / _// __/ _ <span class="se">\/</span> _ <span class="se">\
</span><span class="se"></span>/___/<span class="se">\_</span>_/_//_/<span class="se">\_</span>__/ v4.1.15
High performance, minimalist Go web framework
https://echo.labstack.com
____________________________________O/_______
                                    O<span class="se">\
</span><span class="se"></span>⇨ https server started on <span class="o">[</span>::<span class="o">]</span>:2020
</code></pre></div><p>打开 Chrome 浏览器，请求：https://localhost:2020 （注意是 HTTPS），出现如下错误：</p>
<p><p class="md__image">
  <img src="../imgs/custom-https.png"
    alt=""  />
</p>
</p>
<p>在浏览器输出：<code>chrome://flags/#allow-insecure-localhost</code> ，高亮的置为 Enabled，Reload Chrome。</p>
<p><p class="md__image">
  <img src="../imgs/chrome-insecure-localhost.png"
    alt=""  />
</p>
</p>
<p>再次请求 https://localhost:2020 ，能正常输出：Hello TLS！表明成功了。</p>
<p>通过 FireFox 浏览器，可以方便看到，我们这个服务支持 HTTP/2：</p>
<p><p class="md__image">
  <img src="../imgs/firefox-http2.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>Echo 还支持自动 TLS，即：Echo#StartAutoTLS 方法，它从 <a href="https://letsencrypt.org" target="_blank" rel="noopener">https://letsencrypt.org</a>
 获取证书。这涉及到正式域名等，在此不演示！</p>
</blockquote>
<h2 id="自定义-http2-cleartext-server">自定义 HTTP/2 Cleartext Server</h2>
<p>默认情况下，HTTP/2 是基于 TLS 的。上面也看到，当是 HTTPS Server 时，浏览器支持 HTTP/2，默认使用了它。如果我们想使用 HTTP/2，但是又不想使用 TLS，可以吗？这就是 H2C，即：HTTP/2 Cleartext Server。</p>
<p>从 Echo4.1.15 开始支持启动 H2C 服务器：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">StartH2CServer</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">h2s</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">Server</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>Go 从 1.6 开始，标准库 net/http 支持 HTTP/2，Go1.8 支持 HTTP/2 的 Push。Go 对 HTTP/2 的支持，最初通过 golang.org/x/net/http2 包实现。Echo 中，上面方法的参数 http2.Server 就是 golang.org/x/net/http2 包中的。</p>
<p>实现一个支持 H2C 的 HTTP Server：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">().</span><span class="nx">Proto</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello HTTP/2！&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">server</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http2</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
		<span class="nx">MaxConcurrentStreams</span><span class="p">:</span> <span class="mi">250</span><span class="p">,</span>
		<span class="nx">MaxReadFrameSize</span><span class="p">:</span>     <span class="mi">1048576</span><span class="p">,</span>
		<span class="nx">IdleTimeout</span><span class="p">:</span>          <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">StartH2CServer</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">,</span> <span class="nx">server</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>然而，因为现代的浏览器都不支持  H2C，所以测试我们通过 curl 来进行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ curl -v --http2 -k http://localhost:2020

*   Trying ::1...
* TCP_NODELAY <span class="nb">set</span>
* Connected to localhost <span class="o">(</span>::1<span class="o">)</span> port <span class="m">2020</span> <span class="o">(</span><span class="c1">#0)</span>
&gt; GET / HTTP/1.1
&gt; Host: localhost:2020
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt; Connection: Upgrade, HTTP2-Settings
&gt; Upgrade: h2c
&gt; HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
&gt;
&lt; HTTP/1.1 <span class="m">101</span> Switching Protocols
&lt; Connection: Upgrade
&lt; Upgrade: h2c
* Received <span class="m">101</span>
* Using HTTP2, server supports multi-use
* Connection state changed <span class="o">(</span>HTTP/2 confirmed<span class="o">)</span>
* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: <span class="nv">len</span><span class="o">=</span><span class="m">0</span>
* Connection state changed <span class="o">(</span><span class="nv">MAX_CONCURRENT_STREAMS</span> <span class="o">==</span> 250<span class="o">)</span>!
&lt; HTTP/2 <span class="m">200</span>
&lt; content-type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
&lt; content-length: <span class="m">15</span>
&lt; date: Thu, <span class="m">26</span> Mar <span class="m">2020</span> 08:20:58 GMT
&lt;
* Connection <span class="c1">#0 to host localhost left intact</span>
Hello HTTP/2！* Closing connection <span class="m">0</span>
</code></pre></div><p>而且服务端的输出也确实证明是 HTTP/2。</p>
<p>另外可以通过 Echo#DisableHTTP2 禁用 HTTP/2。</p>
<p>至此，关于 Server 的定制就介绍完了。Echo 的定制也全部讲解完。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇3：自定义 Logger，用你喜欢的日志库</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom03-logger/</link>
			<pubDate>Fri, 06 Mar 2020 11:50:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom03-logger/</guid>
			<description>在知识星球简书项目中，我们分析对比了目前的一些日志库。虽然 Go 标准库有一个 log，但功能有限，所以才出现了很多第三方的日志库。在 用 Go 实现一个简书 8：日志记录和优秀库的学习 中，我们得出结论，推荐大家使用 zerolog 。现在我们就将 zerolog 集成进 Echo 框架中。 Echo 默认的 Logger Echo 日志记录的默认格式是 JSON，可以通过修改标头来更改，即 Echo#Logger.SetHeader(io.Write</description>
			<content type="html"><![CDATA[<p>在知识星球简书项目中，我们分析对比了目前的一些日志库。虽然 Go 标准库有一个 log，但功能有限，所以才出现了很多第三方的日志库。在 <a href="https://studygolang.com/topics/10625" target="_blank" rel="noopener">用 Go 实现一个简书 8：日志记录和优秀库的学习</a>
 中，我们得出结论，推荐大家使用 <a href="https://github.com/rs/zerolog" target="_blank" rel="noopener">zerolog</a>
。现在我们就将 zerolog 集成进 Echo 框架中。</p>
<h2 id="echo-默认的-logger">Echo 默认的 Logger</h2>
<p>Echo 日志记录的默认格式是 JSON，可以通过修改标头来更改，即 <code>Echo#Logger.SetHeader(io.Writer)</code>。</p>
<h3 id="log-header">Log Header</h3>
<p>标头默认值为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span><span class="nt">&#34;time&#34;</span><span class="p">:</span><span class="s2">&#34;${time_rfc3339_nano}&#34;</span><span class="p">,</span><span class="nt">&#34;level&#34;</span><span class="p">:</span><span class="s2">&#34;${level}&#34;</span><span class="p">,</span><span class="nt">&#34;prefix&#34;</span><span class="p">:</span><span class="s2">&#34;${prefix}&#34;</span><span class="p">,</span><span class="nt">&#34;file&#34;</span><span class="p">:</span><span class="s2">&#34;${short_file}&#34;</span><span class="p">,</span><span class="nt">&#34;line&#34;</span><span class="p">:</span><span class="s2">&#34;${line}&#34;</span><span class="p">}</span>
</code></pre></div><p>因为 Echo 默认使用的 Logger 是作者开发的 <code>github.com/labstack/gommon/log</code> 库，我们看看怎么自定义默认标头。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;github.com/labstack/gommon/log&#34;</span>

<span class="cm">/* ... */</span>

<span class="k">if</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.(</span><span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
  <span class="nx">l</span><span class="p">.</span><span class="nf">SetHeader</span><span class="p">(</span><span class="s">&#34;${time_rfc3339} ${level}&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这样输出的标头成为：<code>2018-05-08T20:30:06-07:00 INFO info</code>。</p>
<p>目前，预定义的 tag 有：</p>
<ul>
<li><code>time_rfc3339</code>：时间格式</li>
<li><code>time_rfc3339_nano</code>：带纳秒的时间格式</li>
<li><code>level</code>：级别</li>
<li><code>prefix</code>：前缀</li>
<li><code>long_file</code>：长文件名（带路径）</li>
<li><code>short_file</code>：短文件名（不带路径）</li>
<li><code>line</code>：文件行号</li>
</ul>
<h3 id="log-输出">Log 输出</h3>
<p><code>Echo#Logger.SetOutput(io.Writer)</code> 可以设置日志输出的目的地。默认输出到标准输出。如果想禁用日志，有两种方式：</p>
<ul>
<li>Echo#Logger.SetOutput(ioutil.Discard)</li>
<li>Echo#Logger.SetLevel(log.OFF)</li>
</ul>
<h3 id="log-级别">Log 级别</h3>
<p>默认情况下，日志的级别是 ERROR。可以通过 <code>Echo#Logger.SetLevel(log.Lvl)</code> 修改。一共有如下一些级别：</p>
<ul>
<li><code>DEBUG</code></li>
<li><code>INFO</code></li>
<li><code>WARN</code></li>
<li><code>ERROR</code></li>
<li><code>OFF</code></li>
</ul>
<p>以上就是 Echo 框架提供的可以定制 Log 的相关接口。</p>
<h2 id="自定义-logger">自定义 Logger</h2>
<p>Echo 支持通过<code>Echo#Logger</code> 注册自定义的 Logger，前提是这个 Logger 必须实现 Echo 提供的接口：echo.Logger：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Output</span><span class="p">()</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
    <span class="nf">SetOutput</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>
    <span class="nf">Prefix</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nf">SetPrefix</span><span class="p">(</span><span class="nx">p</span> <span class="kt">string</span><span class="p">)</span>
    <span class="nf">Level</span><span class="p">()</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Lvl</span>
    <span class="nf">SetLevel</span><span class="p">(</span><span class="nx">v</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Lvl</span><span class="p">)</span>
    <span class="nf">SetHeader</span><span class="p">(</span><span class="nx">h</span> <span class="kt">string</span><span class="p">)</span>
    <span class="nf">Print</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Printj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Debug</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Debugf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Debugj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Info</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Infof</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Infoj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Warn</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Warnf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Warnj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Error</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Errorf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Errorj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Fatal</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Fatalj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Fatalf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Panic</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Panicj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Panicf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="p">}</span>
</code></pre></div><p>这个接口看着很吓人，基本上是几个日志级别对应的方法。因此，如果我们要将 zerolog 集成进 Echo，让 zerolog 实现该接口（zerolog 本身肯定没有实现该接口）。</p>
<p>因为 zerolog 库的设计和 API 与 echo.Logger 接口差异极大，想要直接为 zerolog 实现一个 Adapter 以便实现 echo.Logger 接口不太现实。于是我们做如下处理来进行适配：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span>
	<span class="nx">ZeroLog</span> <span class="nx">zerolog</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>
</code></pre></div><p>我们定义一个自己的 Logger 结构体，内嵌一个 github.com/labstack/gommon/log 库的 Logger 指针，这样默认就实现了 echo.Logger 接口，然后再是 zerolog.Logger。看看构造函数如何实现？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">writer</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="o">*</span><span class="nx">Logger</span> <span class="p">{</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Logger</span><span class="p">{</span>
		<span class="nx">Logger</span><span class="p">:</span>  <span class="nx">log</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;-&#34;</span><span class="p">),</span>
		<span class="nx">ZeroLog</span><span class="p">:</span> <span class="nx">zerolog</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">writer</span><span class="p">).</span><span class="nf">With</span><span class="p">().</span><span class="nf">Caller</span><span class="p">().</span><span class="nf">Timestamp</span><span class="p">().</span><span class="nf">Logger</span><span class="p">(),</span>
	<span class="p">}</span>
  
	<span class="c1">// log 默认是 ERROR，将 Level 默认都改为 INFO
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">INFO</span><span class="p">)</span>

	<span class="nx">l</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetOutput</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">l</span>
<span class="p">}</span>
</code></pre></div><p>这么做有什么用？还不如干脆 echo 框架自己的日志由它处理，我们的日志使用 zerolog 处理。这样当然是可以的。但集成在一起有如下好处：</p>
<ul>
<li>形式上变成了一个日志类，也就是我们自定义的 Logger；</li>
<li>方便统一控制，比如输出目标、日志级别；</li>
<li>通过一个日志库，既可以做到单独控制 echo 的行为，也可以单独控制 zerolog 的行为；</li>
</ul>
<p>那统一控制行为如何实现呢？这里实现了两个，控制输出目的地和日志级别。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">SetOutput</span><span class="p">(</span><span class="nx">writer</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetOutput</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span><span class="p">.</span><span class="nf">Output</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">SetLevel</span><span class="p">(</span><span class="nx">level</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Lvl</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">level</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">level</span> <span class="o">==</span> <span class="nx">log</span><span class="p">.</span><span class="nx">OFF</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span><span class="p">.</span><span class="nf">Level</span><span class="p">(</span><span class="nx">zerolog</span><span class="p">.</span><span class="nx">Disabled</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">zeroLevel</span> <span class="o">:=</span> <span class="nb">int8</span><span class="p">(</span><span class="nx">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span><span class="p">.</span><span class="nf">Level</span><span class="p">(</span><span class="nx">zerolog</span><span class="p">.</span><span class="nf">Level</span><span class="p">(</span><span class="nx">zeroLevel</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>当然这种方式也有麻烦的地方，那就是通过 echo 的 Context 获得 zerolog 日志实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">zerolog</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().(</span><span class="o">*</span><span class="nx">logger</span><span class="p">.</span><span class="nx">Logger</span><span class="p">).</span><span class="nx">ZeroLog</span>
</code></pre></div><p>这样自定义日志库就完成了。该库完整代码见：<a href="https://github.com/polaris1119/go-echo-example/blob/master/pkg/logger/logger.go" target="_blank" rel="noopener">https://github.com/polaris1119/go-echo-example/blob/master/pkg/logger/logger.go</a>
。</p>
<h2 id="在-echo-项目中使用自定义日志库">在 Echo 项目中使用自定义日志库</h2>
<p>在 go-echo-example 项目的 cmd 下创建一个目录 gopher，将来我们的实战篇就用它作为入口。之后创建一个 main.go 文件，核心代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span> <span class="p">=</span> <span class="nx">logger</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span>
  <span class="c1">// e.Logger.SetLevel(log.DEBUG)
</span><span class="c1"></span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Recover</span><span class="p">())</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;This is echo logger debug msg!&#34;</span><span class="p">)</span>

		<span class="nx">zerolog</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().(</span><span class="o">*</span><span class="nx">logger</span><span class="p">.</span><span class="nx">Logger</span><span class="p">).</span><span class="nx">ZeroLog</span>
		<span class="nx">zerolog</span><span class="p">.</span><span class="nf">Debug</span><span class="p">().</span><span class="nf">Str</span><span class="p">(</span><span class="s">&#34;path&#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Path</span><span class="p">()).</span><span class="nf">Msg</span><span class="p">(</span><span class="s">&#34;This is Debug msg!&#34;</span><span class="p">)</span>

		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">HTML</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>我们得到 echo 的实例后，将其日志设置为我们自定义的 logger：<code>e.Logger = logger.New(os.Stdout)</code>。注意注释掉的代码。运行程序：go run main.go，打开浏览器访问 http://localhost:2020 ，看看日志是否有两条 Debug 记录。接着将注释去掉再次测试，看日志是否有输出。</p>
<p>不出意外，一切都符合预期。恭喜你大功告成！</p>
<p><a href="https://github.com/polaris1119/go-echo-example/tree/091967f4bea4a3f9ee7c20411f15287d2c950e02" target="_blank" rel="noopener">完整代码点这里</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇2：自定义 Validator，进行输入校验</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom02-validator/</link>
			<pubDate>Fri, 28 Feb 2020 18:53:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom02-validator/</guid>
			<description>上一篇讲 Binder 时提到，参数自动绑定和校验是 Web 框架很重要的两个功能，可以极大的提升开发速度，并更好的保证数据的可靠性（服务端数据校验很重要）。本节，我们就一起看看如何自定义 Echo 的表单校验功能。 不同于 Binder，Echo 并没有内置数据校验的能力，也就是没有默认的 Validator 实现。然而，你可以很方便的集成第三方的数据校验库。跟 Binder 类似，Echo 提供了一个 Validator 接口，方便将第三方数据校</description>
			<content type="html"><![CDATA[<p>上一篇讲 Binder 时提到，参数自动绑定和校验是 Web 框架很重要的两个功能，可以极大的提升开发速度，并更好的保证数据的可靠性（服务端数据校验很重要）。本节，我们就一起看看如何自定义 Echo 的表单校验功能。</p>
<p>不同于 Binder，Echo 并没有内置数据校验的能力，也就是没有默认的 Validator 实现。然而，你可以很方便的集成第三方的数据校验库。跟 Binder 类似，Echo 提供了一个 Validator 接口，方便将第三方数据校验库集成进来。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">Validator</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">Validate</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>通过这个实现这个接口，可以很方便的将任何第三方数据校验库集成到 Echo 中。在 Awesome-Go 上可以找到第三方数据校验库：<a href="https://github.com/avelino/awesome-go#validation" target="_blank" rel="noopener">https://github.com/avelino/awesome-go#validation</a>
。本文我们使用最流行的 <a href="https://github.com/go-playground/validator" target="_blank" rel="noopener">https://github.com/go-playground/validator</a>
 库来讲解。</p>
<h2 id="go-playgroundvalidator">go-playground/validator</h2>
<p>这是一个 Go 结构体及字段校验器，包括：跨字段和跨结构体校验，Map，切片和数组，是目前校验器相关库中 Star 数最高的一个，对国际化支持也很好，建议大家使用它。</p>
<p>它具有以下独特功能：</p>
<ul>
<li>通过使用验证标签（tag）或自定义验证程序进行跨字段和跨结构体验证；</li>
<li>切片，数组和 map，可以验证任何的多维字段或多层级；</li>
<li>能够深入（多维）了解 map 键和值以进行验证；</li>
<li>通过在验证之前确定其基础类型来处理接口类型；</li>
<li>处理自定义字段类型，例如 sql driver Valuer；</li>
<li>别名验证标签，允许将多个验证映射到单个标签，以便更轻松地定义结构上的验证；</li>
<li>提取自定义定义的字段名称，例如可以指定在验证时提取 JSON 名称，并将其用于结果 FieldError 中；</li>
<li>可自定义的 i18n 错误消息；</li>
<li>gin Web 框架的默认验证器；</li>
</ul>
<h3 id="一个简单的例子">一个简单的例子</h3>
<p>通过一个简单例子来看看如何使用该库。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;flag&#34;</span>

	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`validate:&#34;required&#34;`</span>
	<span class="nx">Age</span>   <span class="kt">uint</span>   <span class="s">`validate:&#34;gte=1,lte=130&#34;`</span>
	<span class="nx">Email</span> <span class="kt">string</span> <span class="s">`validate:&#34;required,email&#34;`</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">name</span>  <span class="kt">string</span>
	<span class="nx">age</span>   <span class="kt">uint</span>
	<span class="nx">email</span> <span class="kt">string</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;输入名字&#34;</span><span class="p">)</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">UintVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">age</span><span class="p">,</span> <span class="s">&#34;age&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;输入年龄&#34;</span><span class="p">)</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">email</span><span class="p">,</span> <span class="s">&#34;email&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;输入邮箱&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>

	<span class="nx">user</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="nx">name</span><span class="p">,</span>
		<span class="nx">Age</span><span class="p">:</span>   <span class="nx">age</span><span class="p">,</span>
		<span class="nx">Email</span><span class="p">:</span> <span class="nx">email</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">validate</span> <span class="o">:=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>执行如下命令，运行代码：</p>
<pre tabindex="0"><code>go run main.go -name studygolang -age 7 -email polaris@studygolang.com
</code></pre><p>什么都没有输出，表示一切正常。如果我们提供一个非法的邮箱地址：</p>
<pre tabindex="0"><code>go run main.go -name studygolang -age 7 -email polaris@studygolang
</code></pre><p>输出如下错误：</p>
<pre tabindex="0"><code>Key: 'User.Email' Error:Field validation for 'Email' failed on the 'email' tag
</code></pre><p>错误显示不友好。怎么能够更友好，并进行国际化呢？</p>
<h3 id="国际化i18n">国际化（i18n）</h3>
<p>在介绍校验库错误消息国际化之前，有一个概念需要了解下，那就是 CLDR。</p>
<h4 id="什么是-cldr">什么是 CLDR？</h4>
<p>它是 i18n 的一套核心规范（ Common Locale Data Respository），即通用的本地化数据存储库，什么意思呢？比如我们的手机，电脑都可以选择语言模式为 英语、汉语、日语、法语等等，这套操作背后的规范，就是 CLDR；CLDR 是以 Unicode 的编码标准作为前提，将多国的语言文字进行编码的。</p>
<p>看看官方对于 CLDR 的说明，官方网址：<a href="http://cldr.unicode.org/" target="_blank" rel="noopener">http://cldr.unicode.org/</a>
</p>
<blockquote>
<p>Unicode CLDR 提供了支持世界语言的软件的关键构建块，并且具有最大和最广泛的本地设置数据标准存储库。大量的公司使用此数据进行软件的国际化和本地化，使它们的软件适应此类通用软件任务的不同语言的约定。</p>
</blockquote>
<p>需要进行国际化和本地化的主要包括：</p>
<ul>
<li>用于格式化和解析的特定于语言环境的模式：日期，时间，时区，数字和货币值，度量单位，…</li>
<li>名称的翻译：语言，脚本，国家和地区，货币，时代，月份，工作日，白天，时区，城市和时间单位，表情符号字符和序列（和搜索关键字），…</li>
<li>语言和文字信息：使用的字符；复数情况；性别；大写；分类和搜索规则；写作方向；音译规则；拼写数字的规则；将文本分割成字符，单词和句子的规则；键盘布局…</li>
<li>国家/地区信息：语言使用情况，货币信息，日历首选项，星期惯例等…</li>
<li>有效性：Unicode 语言环境，语言，脚本，区域和扩展名的定义，别名和有效性信息，…</li>
</ul>
<h4 id="cldr-的-go-语言实现">CLDR 的 Go 语言实现</h4>
<p>本文讲解的校验库是 go-playground 这个组织创建的，它们还提供了其他的一些有用库，其中就包括了 CLDR 的 Go 语言实现，这就是 <a href="https://github.com/go-playground/locales" target="_blank" rel="noopener">locales</a>
。</p>
<blockquote>
<p>该库是从 CLDR 项目生成的一组语言环境，可以单独使用或在 i18n 软件包中使用；这些是专为 <a href="https://github.com/go-playground/universal-translator" target="_blank" rel="noopener">https://github.com/go-playground/universal-translator</a>
 构建的，但也可以单独他用。</p>
</blockquote>
<p>这引出了该组织的另外一个库：<a href="https://github.com/go-playground/universal-translator" target="_blank" rel="noopener">universal-translator</a>
。</p>
<p><a href="https://github.com/go-playground/universal-translator" target="_blank" rel="noopener">universal-translator</a>
：一个使用 CLDR 数据+复数规则（比如英语很多复数规则是加 s）的 Go i18n 转换器（翻译器）。该库是  <a href="https://github.com/go-playground/locales" target="_blank" rel="noopener">locales</a>
 的薄包装，以便存储和翻译文本，供你在应用程序中使用。</p>
<h4 id="universal-translator-简明教程">universal-translator 简明教程</h4>
<p>这个通用的翻译器包主要包含了两个核心数据结构：Translator 接口和 UniversalTranslator 结构体，其他的是错误类型。我们先看 Translator 接口。（注意，该包的包名是 ut）</p>
<p><strong>Translator 接口</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Translator</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">locales</span><span class="p">.</span><span class="nx">Translator</span>

    <span class="c1">// adds a normal translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {#} is the only replacement type accepted and are ad infinitum
</span><span class="c1"></span>    <span class="c1">// eg. one: &#39;{0} day left&#39; other: &#39;{0} days left&#39;
</span><span class="c1"></span>    <span class="nf">Add</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// adds a cardinal plural translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {0} is the only replacement type accepted and only one variable is accepted as
</span><span class="c1"></span>    <span class="c1">// multiple cannot be used for a plural rule determination, unless it is a range;
</span><span class="c1"></span>    <span class="c1">// see AddRange below.
</span><span class="c1"></span>    <span class="c1">// eg. in locale &#39;en&#39; one: &#39;{0} day left&#39; other: &#39;{0} days left&#39;
</span><span class="c1"></span>    <span class="nf">AddCardinal</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rule</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRule</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// adds an ordinal plural translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {0} is the only replacement type accepted and only one variable is accepted as
</span><span class="c1"></span>    <span class="c1">// multiple cannot be used for a plural rule determination, unless it is a range;
</span><span class="c1"></span>    <span class="c1">// see AddRange below.
</span><span class="c1"></span>    <span class="c1">// eg. in locale &#39;en&#39; one: &#39;{0}st day of spring&#39; other: &#39;{0}nd day of spring&#39;
</span><span class="c1"></span>    <span class="c1">// - 1st, 2nd, 3rd...
</span><span class="c1"></span>    <span class="nf">AddOrdinal</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rule</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRule</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// adds a range plural translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {0} and {1} are the only replacement types accepted and only these are accepted.
</span><span class="c1"></span>    <span class="c1">// eg. in locale &#39;nl&#39; one: &#39;{0}-{1} day left&#39; other: &#39;{0}-{1} days left&#39;
</span><span class="c1"></span>    <span class="nf">AddRange</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rule</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRule</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// creates the translation for the locale given the &#39;key&#39; and params passed in
</span><span class="c1"></span>    <span class="nf">T</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">params</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// creates the cardinal translation for the locale given the &#39;key&#39;, &#39;num&#39; and &#39;digit&#39; arguments
</span><span class="c1"></span>    <span class="c1">//  and param passed in
</span><span class="c1"></span>    <span class="nf">C</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">num</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">param</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// creates the ordinal translation for the locale given the &#39;key&#39;, &#39;num&#39; and &#39;digit&#39; arguments
</span><span class="c1"></span>    <span class="c1">// and param passed in
</span><span class="c1"></span>    <span class="nf">O</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">num</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">param</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">//  creates the range translation for the locale given the &#39;key&#39;, &#39;num1&#39;, &#39;digit1&#39;, &#39;num2&#39; and
</span><span class="c1"></span>    <span class="c1">//  &#39;digit2&#39; arguments and &#39;param1&#39; and &#39;param2&#39; passed in
</span><span class="c1"></span>    <span class="nf">R</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">num1</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits1</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">num2</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits2</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">param1</span><span class="p">,</span> <span class="nx">param2</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// VerifyTranslations checks to ensures that no plural rules have been
</span><span class="c1"></span>    <span class="c1">// missed within the translations.
</span><span class="c1"></span>    <span class="nf">VerifyTranslations</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>关于该接口需要需要如下几点说明</p>
<ul>
<li>内嵌了 locales.Translator 接口；</li>
<li>几类复数规则：cardinal plural（基数复数规则，即单数和复数两种）；ordinal plural（序数复数规则，如 1st, 2nd, 3rd…）；ordinal plural （范围复数规则，如 0-1）。对中文来说，这里大部分不需要。</li>
<li>几个 Add 方法，和上面几类规则对应；一个 key 和 一个带站位符的 text；</li>
<li>单字符的几个方法和 Add 几个方法的对应关系：T -&gt; Add；C -&gt; AddCardinal；O -&gt; AddOrdinal；R -&gt; AddRange ；表示用具体的值替换 key 表示的文本 text 中的占位符。</li>
<li>以上方法参数中，num 表示占位符处的值，但对于有复数形式的语言，这个值必须符合复数语言的规范，否则会报错；digits 表示 num 值的有效数字（或者说小数位数）；</li>
<li>VerifyTranslations 确保翻译库中没有缺少对应的语言规则；</li>
</ul>
<p><strong>UniversalTranslator 结构体</strong></p>
<p>它用于保存所有语言环境和翻译数据。该结构体方法不多，我们关注几个核心的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">fallback</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="nx">supportedLocales</span> <span class="o">...</span><span class="nx">locales</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="o">*</span><span class="nx">UniversalTranslator</span>
</code></pre></div><p>New 返回一个 UniversalTranslator 实例，该实例具有后备语言环境（fallback）和应支持的语言环境（supportedLocales）。可以看到，New 函数接收的参数是 locales.Translator 类型，因此我们肯定需要用到 locales 包。</p>
<p>得到 UniversalTranslator 实例后，需要获得 universal-translator 包中的 Translator 接口实例，这就用到了下面几个方法。</p>
<p>1）GetTranslator</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">UniversalTranslator</span><span class="p">)</span> <span class="nf">GetTranslator</span><span class="p">(</span><span class="nx">locale</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">trans</span> <span class="nx">Translator</span><span class="p">,</span> <span class="nx">found</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></div><p>返回给定语言环境的指定翻译器，如果未找到，则返回后备语言环境的翻译器（即 New 中的 fallback）。</p>
<p>2）GetFallback</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">UniversalTranslator</span><span class="p">)</span> <span class="nf">GetFallback</span><span class="p">()</span> <span class="nx">Translator</span>
</code></pre></div><p>直接返回后备语言环境的翻译器。</p>
<p>3）FindTranslator</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">UniversalTranslator</span><span class="p">)</span> <span class="nf">FindTranslator</span><span class="p">(</span><span class="nx">locales</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">trans</span> <span class="nx">Translator</span><span class="p">,</span> <span class="nx">found</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></div><p>尝试根据语言环境数组查找翻译器，并返回它可以找到的第一个翻译器，否则返回后备翻译器。</p>
<p>总结来说，New 函数加上这三个方法，相当于是 locales.Translator 到 ut.Translator 的转换。</p>
<p><strong>示例</strong></p>
<p>通过一个实际的例子来学习下这两个包的使用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;fmt&#34;</span>

	<span class="s">&#34;github.com/go-playground/locales&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/en&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/zh&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/zh_Hant_TW&#34;</span>
	<span class="nx">ut</span> <span class="s">&#34;github.com/go-playground/universal-translator&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">universalTraslator</span> <span class="o">*</span><span class="nx">ut</span><span class="p">.</span><span class="nx">UniversalTranslator</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">acceptLanguage</span> <span class="o">:=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;language&#34;</span><span class="p">,</span> <span class="s">&#34;zh&#34;</span><span class="p">,</span> <span class="s">&#34;语言&#34;</span><span class="p">)</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>

	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">en</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">universalTraslator</span> <span class="p">=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">zh</span><span class="p">.</span><span class="nf">New</span><span class="p">(),</span> <span class="nx">zh_Hant_TW</span><span class="p">.</span><span class="nf">New</span><span class="p">())</span>

	<span class="nx">translator</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">universalTraslator</span><span class="p">.</span><span class="nf">GetTranslator</span><span class="p">(</span><span class="o">*</span><span class="nx">acceptLanguage</span><span class="p">)</span>

	<span class="k">switch</span> <span class="o">*</span><span class="nx">acceptLanguage</span> <span class="p">{</span>
	<span class="k">case</span> <span class="s">&#34;zh&#34;</span><span class="p">:</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;welcome&#34;</span><span class="p">,</span> <span class="s">&#34;欢迎 {0} 来到 studygolang.com！&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddCardinal</span><span class="p">(</span><span class="s">&#34;days&#34;</span><span class="p">,</span> <span class="s">&#34;你只剩 {0} 天时间可以注册&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddOrdinal</span><span class="p">(</span><span class="s">&#34;day-of-month&#34;</span><span class="p">,</span> <span class="s">&#34;第{0}天&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddRange</span><span class="p">(</span><span class="s">&#34;between&#34;</span><span class="p">,</span> <span class="s">&#34;距离 {0}-{1} 天&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="k">case</span> <span class="s">&#34;en&#34;</span><span class="p">:</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;welcome&#34;</span><span class="p">,</span> <span class="s">&#34;Welcome {0} to studygolang.com.&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddCardinal</span><span class="p">(</span><span class="s">&#34;days&#34;</span><span class="p">,</span> <span class="s">&#34;You have {0} day left to register&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOne</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddOrdinal</span><span class="p">(</span><span class="s">&#34;day-of-month&#34;</span><span class="p">,</span> <span class="s">&#34;{0}st&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOne</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddRange</span><span class="p">(</span><span class="s">&#34;between&#34;</span><span class="p">,</span> <span class="s">&#34;It&#39;s {0}-{1} days away&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">T</span><span class="p">(</span><span class="s">&#34;welcome&#34;</span><span class="p">,</span> <span class="s">&#34;polaris&#34;</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">C</span><span class="p">(</span><span class="s">&#34;days&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">O</span><span class="p">(</span><span class="s">&#34;day-of-month&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">R</span><span class="p">(</span><span class="s">&#34;between&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><p>主要通过这个例子说明相关函数的使用。</p>
<ul>
<li>根据 acceptLanguage 的不同值，设置不同的语言文案；</li>
<li>对于中文来说，没有复数，因此 AddXX 三个方法的第二个参数都是 locales.PluralRuleOther，表示该语言环境没有复数形式；</li>
<li>英文环境下，PluralRule 规则不能乱填，根据实际情况来；</li>
<li>最后在实际填充值时，num 表示占位符要填入的值，digits 表示 num 这个值最终要保留几位小数；</li>
<li>FmtNumber 方法的参数需要和前面的 num 和 digits 对应上，第一个参数是 num 的值，第二个是 digits 的值；</li>
</ul>
<h3 id="validator-怎么和以上两个库集成提供-i18n">Validator 怎么和以上两个库集成提供 i18n</h3>
<p>Validator 库提供了相应的子库，对以上两个库进行了封装。比如中文的库：github.com/go-playground/validator/translations/zh ，这些子库提供了一个 RegisterDefaultTranslations ，为所有内置标签的验证器注册一组默认翻译。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span><span class="p">,</span> <span class="nx">trans</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>具体怎么做？还是看最开始的例子，其他不变，main 函数改为如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>

	<span class="nx">user</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="nx">name</span><span class="p">,</span>
		<span class="nx">Age</span><span class="p">:</span>   <span class="nx">age</span><span class="p">,</span>
		<span class="nx">Email</span><span class="p">:</span> <span class="nx">email</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">validate</span> <span class="o">:=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">en</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">uniTrans</span> <span class="o">:=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">zh</span><span class="p">.</span><span class="nf">New</span><span class="p">(),</span> <span class="nx">zh_Hant_TW</span><span class="p">.</span><span class="nf">New</span><span class="p">())</span>
	<span class="nx">translator</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">uniTrans</span><span class="p">.</span><span class="nf">GetTranslator</span><span class="p">(</span><span class="s">&#34;zh&#34;</span><span class="p">)</span>
	<span class="nx">zh_translate</span><span class="p">.</span><span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">validate</span><span class="p">,</span> <span class="nx">translator</span><span class="p">)</span>

	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">errs</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">validator</span><span class="p">.</span><span class="nx">ValidationErrors</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">errs</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="nx">translator</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>注册一个默认的中文翻译器，在校验出错后，对错误进行翻译。不输入任何参数运行程序，输出：</p>
<blockquote>
<p>Name为必填字段
Age必须大于或等于1
Email为必填字段</p>
</blockquote>
<p>大功告成。</p>
<h2 id="将-validator-集成到-echo-中">将 Validator 集成到 Echo 中</h2>
<p>首先，需要定义一个类型，实现 Echo 的接口 Validator ：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CustomValidator</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">once</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">validate</span> <span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CustomValidator</span><span class="p">)</span> <span class="nf">Validate</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">lazyInit</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CustomValidator</span><span class="p">)</span> <span class="nf">lazyInit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">validate</span> <span class="p">=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>因为 validator.Validate 实例化做了不少事情，这里将实例化推迟到使用时。简单几行代码就实现了一个自定义的 Validator。</p>
<p>接下来和 Echo 集成起来就很容易了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Validator</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">CustomValidator</span><span class="p">{}</span>
</code></pre></div><p>之后就可以在需要进行表单校验的地方通过 <code>ctx.Validate()</code> 进行校验。</p>
<p>自此我们完成了 Validator 集成到 Echo 的功能。</p>
<p>还剩最后一块内容，那就是校验错误信息的国际化显示。国际化相关的内容，上面有了较详细的介绍，Validator 集成到 Echo 后如何国际化我们在后面实战篇再讲。</p>
<p>完整代码见：<a href="https://github.com/polaris1119/go-echo-example/blob/master/pkg/validator/validator.go" target="_blank" rel="noopener">https://github.com/polaris1119/go-echo-example/blob/master/pkg/validator/validator.go</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇1：自定义 Binder，处理 Request 数据绑定</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom01-binder/</link>
			<pubDate>Fri, 21 Feb 2020 19:26:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom01-binder/</guid>
			<description>Web 开发，数据获取和校验是两个最基本的功能。在数据获取时，我们可以通过标准库的 *http.Request 提供的相关功能进行获取。然而这样效率是很低，重复工作较多，而且考虑到数据自动校验，我们更应该做到自动绑定。 在讲述 Echo 的 Binder 前，先探讨一下客户端数据一般通过什么方式发送给服务端的。 客户端如何传递数据给服务端？ 这个问题其实对大部分人来说太简单了，然而，很多客户端的人却不清楚。工作中，我接触</description>
			<content type="html"><![CDATA[<p>Web 开发，数据获取和校验是两个最基本的功能。在数据获取时，我们可以通过标准库的 <code>*http.Request</code> 提供的相关功能进行获取。然而这样效率是很低，重复工作较多，而且考虑到数据自动校验，我们更应该做到自动绑定。</p>
<p>在讲述 Echo 的 Binder 前，先探讨一下客户端数据一般通过什么方式发送给服务端的。</p>
<h2 id="客户端如何传递数据给服务端">客户端如何传递数据给服务端？</h2>
<p>这个问题其实对大部分人来说太简单了，然而，很多客户端的人却不清楚。工作中，我接触过不少客户端的人，对于数据怎么传递给服务端，他们是没有概念的，找到一个能用的方法发送给服务端就行了。比如，一个普通的数据通过 HTTP Header 来发送；分不清自己发送的数据是 key=json 形式还是 Body 中直接放 JSON，也就是不清楚 Content-Type 相关的含义。</p>
<p>为了让大家更容易掌握相关知识点，我通过问题的形式讲解。</p>
<h3 id="问题-1get-和-post-参数如何获取">问题 1：Get 和 Post 参数如何获取</h3>
<p>讲再多都不如一个实际的程序演示来的清楚明白。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">ParseMultipartForm</span><span class="p">(</span><span class="mi">32</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span>

		<span class="nx">data</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
			<span class="s">&#34;form&#34;</span><span class="p">:</span>      <span class="nx">req</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span>
			<span class="s">&#34;post_form&#34;</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>这是一个简单的 Server，启动它：</p>
<blockquote>
<p>go run main.go</p>
</blockquote>
<p>接着，我们通过 <a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="noopener">httpie</a>
 来模拟请求，看不同的输出。（关于 httpie 的使用可以看官方文档）</p>
<p>1）<code>http -v :2020 name==polaris</code></p>
<p>命令的输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">GET /?name<span class="o">=</span>polaris HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:2020
User-Agent: HTTPie/2.0.0



HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">46</span>
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 07:27:56 GMT

map<span class="o">[</span>form:map<span class="o">[</span>name:<span class="o">[</span>polaris<span class="o">]]</span> post_form:map<span class="o">[]]</span>
</code></pre></div><p>作为一个服务端工程师，很有必要了解 HTTP 请求报文和响应报文。</p>
<p>从输出可以看出，GET 参数放在了 req.Form 中，实际开发中，一般这样获取 GET 的参数：<code>req.FormValue(&quot;name&quot;)</code>。因为默认情况下，参数并没有解析，也就是 Form 中没有，这也就是我们上面代码中 <code>req.ParseMultipartForm(32 &lt;&lt; 20)</code> 这样代码的作用。而 req.FormValue 会判断有没有解析。</p>
<p>2）<code>http -v --form :2020 name==polaris name=xuxinhua sex=male</code></p>
<p>直接看命令的输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">POST /?name<span class="o">=</span>polaris HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">22</span>
Content-Type: application/x-www-form-urlencoded<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="nv">name</span><span class="o">=</span>xuxinhua<span class="p">&amp;</span><span class="nv">sex</span><span class="o">=</span>male

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">92</span>
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 07:35:56 GMT

map<span class="o">[</span>form:map<span class="o">[</span>name:<span class="o">[</span>xuxinhua polaris<span class="o">]</span> sex:<span class="o">[</span>male<span class="o">]]</span> post_form:map<span class="o">[</span>name:<span class="o">[</span>xuxinhua<span class="o">]</span> sex:<span class="o">[</span>male<span class="o">]]]</span>
</code></pre></div><p>这里发起了一个 POST 请求。需要关注以下几点：</p>
<ul>
<li>请求中有参数：name=polaris</li>
<li>请求头：Content-Type: application/x-www-form-urlencoded; charset=utf-8</li>
<li>请求体（body）：name=xuxinhua&amp;sex=male</li>
</ul>
<p>因为 name 在 url 和 body 中分别有一个值：polaris 和 xuxinhua，因此，form 中 name 包含了两个值。从响应中结果可以看出，Form 同时包含了 url 参数和 body 的 key=value；而 PostForm 只包含 body 中的 key=value。（PUT 和 POST 是一样的效果）</p>
<p>因此，req.FormValue() 可以获取所有请求参数；而 req.PostFormValue() 获取 POST 之类的参数，如果同一个参数有多个值，只会取第一个，而 POST 参数优先级高于 URL 参数。</p>
<blockquote>
<p>小问题：上面例子中，如果想要获取 name=polaris，而不是 name=xuxinhua，怎么做？</p>
</blockquote>
<h3 id="问题-2客户端传递-json-怎么办">问题 2：客户端传递 JSON 怎么办？</h3>
<p>继续基于上面的例子，执行如下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020 <span class="nv">name</span><span class="o">=</span>xuxinhua <span class="nv">sex</span><span class="o">=</span>male
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">POST / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">35</span>
Content-Type: application/json
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">32</span>
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 07:58:05 GMT

map<span class="o">[</span>form:map<span class="o">[]</span> post_form:map<span class="o">[]]</span>
</code></pre></div><p>这次请求头的 Content-Type 值是：application/json，表明客户端将参数通过 JSON 格式传递，具体参数放在了 Body 中：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;xuxinhua&#34;</span><span class="p">,</span>
    <span class="nt">&#34;sex&#34;</span><span class="p">:</span> <span class="s2">&#34;male&#34;</span>
<span class="p">}</span>
</code></pre></div><p>从服务端的输出可以看到，Form 和 PostForm 都没有获取到这些参数，怎么办？答案是从 Body 中读取。如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">reqBody</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span>
<span class="nx">data</span><span class="p">[</span><span class="s">&#34;json_data&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">reqBody</span><span class="p">)</span>
</code></pre></div><p>最后简单说下 Content-Type 是 multipart/form-data 的情况。</p>
<p>当需要进行文件上传时，要求 Content-Type 设置为 multipart/form-data，对应的页面表单就是：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&#34;/&#34;</span> <span class="na">method</span><span class="o">=</span><span class="s">&#34;POST&#34;</span> <span class="na">enctype</span><span class="o">=</span><span class="s">&#34;multipart/form-data&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div><p>这样的表单才能进行文件上传。对文件上传的处理，Go 中对应的是 req.MultipartForm 和 req.FormFile()。</p>
<p>当然，除此之外，Content-Type 还有其他值（一般叫做 MIME），但常用的已经介绍了（相较而言，GET 只有一种 Content-Type: application/x-www-form-urlencoding）。</p>
<h2 id="echo-的-binder-是如何做的">Echo 的 Binder 是如何做的？</h2>
<p>上面介绍的都是标准库 net/http 的相关 API，回到 Echo，有如下对应关系：</p>
<ul>
<li>Conetxt#QueryParam() 和  QueryParams() 方法获取 URL 参数；</li>
<li>Context#FormValue() 和 FormParams() 方法获取 Form 参数，对应标准库的 PostForm；</li>
<li>Context#FormFile() 和 MultipartForm() 方法处理文件上传；</li>
</ul>
<p>除此之外，因为 Echo 路由支持路径参数（Path Param），对应的获取方法：Context#Param() 和 ParamNames()。</p>
<p>对于 Binder，Echo 默认提供了一个实现：echo.DefaultBinder，通常情况下，这个默认实现就能够满足要求。我们先看看它的实现。</p>
<h3 id="defaultbinder-的实现">DefaultBinder 的实现</h3>
<p>首先，Echo 定义了一个接口：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Binder</span> <span class="kd">interface</span><span class="p">{</span>
  <span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>任何 Binder 必须实现该接口，也就是提供 Bind 方法。一起看看 DefaultBinder 的 Bind 方法实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">DefaultBinder</span><span class="p">)</span> <span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Request</span><span class="p">()</span>

	<span class="nx">names</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ParamNames</span><span class="p">()</span>
	<span class="nx">values</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ParamValues</span><span class="p">()</span>
	<span class="nx">params</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">name</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">names</span> <span class="p">{</span>
		<span class="nx">params</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">bindData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">params</span><span class="p">,</span> <span class="s">&#34;param&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">bindData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">QueryParams</span><span class="p">(),</span> <span class="s">&#34;query&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ctype</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">HeaderContentType</span><span class="p">)</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEApplicationJSON</span><span class="p">):</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">ute</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">json</span><span class="p">.</span><span class="nx">UnmarshalTypeError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Unmarshal type error: expected=%v, got=%v, field=%v, offset=%v&#34;</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Field</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Offset</span><span class="p">)).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">se</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">json</span><span class="p">.</span><span class="nx">SyntaxError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Syntax error: offset=%v, error=%v&#34;</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nx">Offset</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nf">Error</span><span class="p">())).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEApplicationXML</span><span class="p">),</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMETextXML</span><span class="p">):</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">xml</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">ute</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">xml</span><span class="p">.</span><span class="nx">UnsupportedTypeError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Unsupported type error: type=%v, error=%v&#34;</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nf">Error</span><span class="p">())).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">se</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">xml</span><span class="p">.</span><span class="nx">SyntaxError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Syntax error: line=%v, error=%v&#34;</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nx">Line</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nf">Error</span><span class="p">())).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEApplicationForm</span><span class="p">),</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEMultipartForm</span><span class="p">):</span>
		<span class="nx">params</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">FormParams</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">bindData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">params</span><span class="p">,</span> <span class="s">&#34;form&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">ErrUnsupportedMediaType</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>一起分析下这个方法：</p>
<ul>
<li>DefaultBinder 的 bindData 方法进行实际的数据绑定，主要通过反射进行处理，要求被绑定的类型是 map[string]interface{} 或 struct（实际是时间它们的指针），有兴趣的可以查看它的源码；<a href="https://github.com/labstack/echo/blob/master/bind.go#L86" target="_blank" rel="noopener">https://github.com/labstack/echo/blob/master/bind.go#L86</a>
</li>
<li>通过给 Struct 的字段加上不同的 Tag 来接收不同类型的值：
<ul>
<li>param tag 对应路径参数；</li>
<li>query tag 对应 URL 参数；</li>
<li>json tag 对应 application/json 方式参数；</li>
<li>form tag 对应 POST 表单数据；</li>
<li>xml tag 对应 application/xml 或 text/xml；</li>
</ul>
</li>
<li>从代码的顺序可以看出，当同一个字段在多种方式存在值时，优先级顺序：param &lt; query &lt; 其他；</li>
</ul>
<p>讲解完了，来一个实际的例子加深理解。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`query:&#34;name&#34; form:&#34;name&#34; json:&#34;name&#34;`</span>
	<span class="nx">Sex</span>  <span class="kt">string</span> <span class="s">`query:&#34;sex&#34; form:&#34;sex&#34; json:&#34;sex&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">Any</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">user</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">User</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>同样使用 httpie 来进行测试。</p>
<p><strong>1）GET 请求</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020 <span class="nv">name</span><span class="o">==</span>xuxinhua <span class="nv">sex</span><span class="o">==</span>male
</code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">GET /?name<span class="o">=</span>xuxinhua<span class="p">&amp;</span><span class="nv">sex</span><span class="o">=</span>male HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:2020
User-Agent: HTTPie/2.0.0



HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">33</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:27:25 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>
</code></pre></div><p>能够正确绑定值。</p>
<p><strong>2）POST 请求</strong></p>
<p>特意加上 URL 参数混淆下，看看结果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ http -v --form :2020 <span class="nv">name</span><span class="o">==</span>polaris <span class="nv">name</span><span class="o">=</span>xuxinhua <span class="nv">sex</span><span class="o">=</span>male
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">POST /?name<span class="o">=</span>polaris HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">22</span>
Content-Type: application/x-www-form-urlencoded<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="nv">name</span><span class="o">=</span>xuxinhua<span class="p">&amp;</span><span class="nv">sex</span><span class="o">=</span>male

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">33</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:46:09 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>
</code></pre></div><p>从结果 name 是 xuxinhua 可以看出，URL 参数的优先级较低。</p>
<p><strong>3）请求参数是 JSON</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020  <span class="nv">name</span><span class="o">=</span>xuxinhua <span class="nv">sex</span><span class="o">=</span>male
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">POST / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">35</span>
Content-Type: application/json
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">33</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:48:48 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>
</code></pre></div><p>一切正常。</p>
<p><strong>4）试试 XML ？</strong></p>
<p>目前 XML 用的还是比较少，基本是 JSON。所以，我们的例子代码默认并没有支持 XML。</p>
<p>我们先创建一个 XML 文件，作为输入：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34;?&gt;</span>
<span class="nt">&lt;user&gt;</span>
	<span class="nt">&lt;name&gt;</span>xuxinhua<span class="nt">&lt;/name&gt;</span>
	<span class="nt">&lt;sex&gt;</span>male<span class="nt">&lt;/sex&gt;</span>
<span class="nt">&lt;/user&gt;</span>
</code></pre></div><p>接着执行如下命令：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020 @user.xml
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">POST / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">78</span>
Content-Type: application/xml
Host: localhost:2020
User-Agent: HTTPie/2.0.0

&lt;?xml <span class="nv">version</span><span class="o">=</span><span class="s2">&#34;1.0&#34;</span>?&gt;

&lt;user&gt;
	&lt;name&gt;xuxinhua&lt;/name&gt;
	&lt;sex&gt;male&lt;/sex&gt;
&lt;/user&gt;

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">21</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:55:54 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;&#34;</span>
<span class="o">}</span>
</code></pre></div><p>一方面，请求的 Content-Type 是 application/xml，但响应却不对。原因是 User 结构中，我们没有为字段指定 xml 这个 tag，加上 tag 再试一下就会正确：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`query:&#34;name&#34; form:&#34;name&#34; json:&#34;name&#34; xml:&#34;name&#34;`</span>
	<span class="nx">Sex</span>  <span class="kt">string</span> <span class="s">`query:&#34;sex&#34; form:&#34;sex&#34; json:&#34;sex&#34; xml:&#34;sex&#34;`</span>
<span class="p">}</span>
</code></pre></div><p>实际中，需要设置什么 tag，你应该心里有数，没必要把所有支持的 tag 都设置上。</p>
<h2 id="自定义-binder">自定义 Binder</h2>
<p>Echo 默认提供的 Binder 已经满足了大部分的需求，那什么时候需要自定义 Binder 呢？</p>
<p>现在一般接口都是用 JSON 作为数据交换格式，假如你老板觉得 JSON 性能不够，希望换其他格式，比如 <a href="https://msgpack.org/" target="_blank" rel="noopener">msgpack</a>
 格式。这时候，echo 默认的 DefaultBinder 已经没法满足我们的需求了，这时候就需要自定义 Binder。类似的还有 protobuf 等。</p>
<h3 id="自定义-msgpackbinder">自定义 MsgpackBinder</h3>
<p>现在，我们就自己实现一个支持 msgpack 格式的 Binder。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MsgpackBinder</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">MsgpackBinder</span><span class="p">)</span> <span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 也支持默认 Binder 相关的绑定
</span><span class="c1"></span>	<span class="nx">db</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">echo</span><span class="p">.</span><span class="nx">DefaultBinder</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrUnsupportedMediaType</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">()</span>
	<span class="nx">ctype</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HeaderContentType</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">MIMEApplicationMsgpack</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">msgpack</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrUnsupportedMediaType</span>
<span class="p">}</span>
</code></pre></div><p>我们的自定义 Binder 除了支持 msgpack 外，还支持默认 Binder 支持的绑定方式。所以，在 Bind 方法入口，先实例化了一个 DefaultBinder，用它进行绑定处理。只有它返回的 err 是 ErrUnsupportedMediaType 时，才进行我们自定义 Binder 的处理逻辑。关于 msgpack 的解析，使用了第三方库：github.com/vmihailenco/msgpack ，使用方式和 JSON 类似。</p>
<p>这样，自定义的 Binder 就完成了。接下来需要替换到 Echo 默认的 Binder：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

<span class="nx">e</span><span class="p">.</span><span class="nx">Binder</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">MsgpackBinder</span><span class="p">)</span>
</code></pre></div><p>即在得到 echo.Echo 的实例后，通过 e.Binder 来覆盖默认的 Binder。</p>
<h3 id="验证自定义的-binder">验证自定义的 Binder</h3>
<p>因为 msgpack 是二进制格式，不方便直接使用 httpie 进行验证。我们写一个简单的客户端工具进行验证。代码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;io/ioutil&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/vmihailenco/msgpack&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">Name</span> <span class="kt">string</span>
		<span class="nx">Sex</span>  <span class="kt">string</span>
	<span class="p">}</span>

	<span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">msgpack</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;xuxinhua&#34;</span><span class="p">,</span> <span class="nx">Sex</span><span class="p">:</span> <span class="s">&#34;male&#34;</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultClient</span><span class="p">.</span><span class="nf">Post</span><span class="p">(</span><span class="s">&#34;http://localhost:2020/&#34;</span><span class="p">,</span> <span class="s">&#34;application/msgpack&#34;</span><span class="p">,</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>启动服务端，然后运行客户端。我本地试验，输出结果如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span><span class="nt">&#34;name&#34;</span><span class="p">:</span><span class="s2">&#34;xuxinhua&#34;</span><span class="p">,</span><span class="nt">&#34;sex&#34;</span><span class="p">:</span><span class="s2">&#34;male&#34;</span><span class="p">}</span>
</code></pre></div><p>表明我们的自定义 Binder 生效了。</p>
<blockquote>
<p>说明一下，跟标准库的 json 一样，没有 tag 时，msgpack 库能根据导出字段识别出对应关系。默认情况，msgpack 库使用 msgpack 这个 tag，同时可以通过 UseJSONTag 方法来退而求其次使用 json 这个 tag。当然，我们这里没有使用 tag，而是根据导出字段自动识别对应关系的。</p>
</blockquote>
<h2 id="小结">小结</h2>
<p>到这里，自定义 Binder 就介绍完了。内容比较简单，但是必须掌握，这是基础知识。另外，这里没有提到 cookie，标准库和 echo 都提供了相关的方法进行处理，但一般 cookie 不需要进行数据绑定，额外处理即可。</p>
<p>本文完整代码：<a href="https://github.com/polaris1119/go-echo-example/tree/master/cmd/binder" target="_blank" rel="noopener">https://github.com/polaris1119/go-echo-example/tree/master/cmd/binder</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇0：让 Echo 更强大、更好用</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom00-intro/</link>
			<pubDate>Fri, 21 Feb 2020 19:24:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom00-intro/</guid>
			<description>一个强大的框架，一定是可以定制的，或者说可以扩展，能够根据用户自己的需求进行改变、增强，甚至某些功能的替换。作为一个强大的框架，Echo 必然也是可以定制、可以扩展的。本篇起，我们一起探讨如何对 Echo 框架进行定制或扩展，打造成符合你个性需求的框架。 定制化主要包含如下一些方面： 自定义 Binder，用来处理 Request 数据绑定 自定义 Validator，用来处理输入验证 自定义 Lo</description>
			<content type="html"><![CDATA[<p>一个强大的框架，一定是可以定制的，或者说可以扩展，能够根据用户自己的需求进行改变、增强，甚至某些功能的替换。作为一个强大的框架，Echo 必然也是可以定制、可以扩展的。本篇起，我们一起探讨如何对 Echo 框架进行定制或扩展，打造成符合你个性需求的框架。</p>
<p>定制化主要包含如下一些方面：</p>
<ul>
<li>自定义 Binder，用来处理 Request 数据绑定</li>
<li>自定义 Validator，用来处理输入验证</li>
<li>自定义 Logger，用你喜欢的日志库</li>
<li>自定义 Renderer，增强或替换模板引擎</li>
<li>自定义 HTTP Error Handler，让 HTTP 错误处理更友好</li>
<li>自定义 Server 相关，替换或扩展默认的 Server</li>
</ul>
<p>关于扩展 Echo，主要通过中间件来实现，而这部分内容，我们已经在<a href="http://blog.studygolang.com/2019/12/echo-login-example/" target="_blank" rel="noopener">《基础篇：通过一个例子串联各特性》</a>
中讲解了，具体常见中间件的使用，会在实战篇讲解。</p>
<p>除此之外，Echo#Debug 可以决定是否进入调试模式，在开发阶段，建议设置为 true，生产环境改为 false。</p>
<p>在开篇我们看到，在启动 Echo 项目时，默认会显示一个 Startup Banner，我们可以通过 Echo#HideBanner 控制它不显示。</p>
]]></content>
		</item>
		
		<item>
			<title>欢迎加入 GoLand 2020.1 抢先体验计划</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/welcome-to-the-goland-2020-1-eap/</link>
			<pubDate>Tue, 24 Dec 2019 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/welcome-to-the-goland-2020-1-eap/</guid>
			<description>GoLand 2020.1 抢先体验计划已经启动。对于此发行版，我们着重于易用性，性能以及减少浪费在样板代码和 IDE 中的冗余操作上的时间。我们还包括对 Go Modules 支持的升级，和其他更多功能。您可以在 2020.1 的路线图博客 文章中找到简短说明。
你可以通过 Toolbox App 获得它，也可以从网站上下载 ，也可以使用快照包（对于 Ubuntu）；或者直接在 GoLand 中通过自动更新的方式获取。Preferences / Settings | Appearance &amp;amp; Behavior | System Settings | Updates。
如果您想知道什么是抢先体验计划，这里有一个简短的解释：
 EAP 版本使您可以试用 Goland 仍在开发中的最新功能和增强功能。这些版本尚未经过全面测试，可能会不稳定，但是您可以在这里为我们提供帮助。通过将这些内部版本和功能用于实际项目和场景中来测试，您可以帮助我们完善它们。这样，当最终版本准备就绪时，它将为您更好地工作。
  EAP 使您可以首先试用所有最新功能; 自构建日期起 30 天内免费使用 EAP 版本。您可以将这段时间用作 GoLand 的扩展试用版； 我们会提供 EAP 版本，直到几乎可以发布稳定版本为止。对于即将推出的 2020.1 版本，EAP 期将大致持续到 3 月底； 在每个发布周期中，我们都会为他们提供免费的 1 年 GoLand 订阅和一件独家的 GoLand T 恤 ，以表彰他们中最活跃的评估人员。 此外，我们几乎每天都提供最新版本。因此，如果您不想等待正式的 EAP 版本公告，则只需下载这些夜间版本之一，即可通过 Toolbox App 获得。请注意，每晚构建的质量通常低于我们的标准，并且没有随附发行说明。与 EAP 版本一样，它们也将在发布后 30 天内过期；  因此，让我们看一下第一个 EAP 版本中包含的内容。
Go Modules 现在，您可以通过 go.mod 文件中的 Alt-Enter 来获取缺失的依赖项并删除未使用的依赖项。
Go 1.14 支持 Go 1.14 增加了对嵌入重叠接口的支持，我们也是如此！当您使用重叠的接口时，GoLand 不会将重复的方法报告为错误。
为什么将此功能添加到语言中？
主要好处是我们可以使用嵌入定义接口，而不需要手动定义。这是一个例子：
type Person interface { Name() string String() string } type Employee interface { Person Department() string String() string } 在 Go 1.14 之前，我们无法在 Employee 接口上添加 String() 方法，因为该方法已在 Person 接口上定义了。现在，我们可以使用接口嵌入定义它，如果 Person 接口有更新，我们自己更可控。
代码补全/完成增强 我们对样板代码说不！GoLand 为常见的错误处理模式添加了代码完成功能。现在，当您在函数中键入if 时，您可以选择 err！= nil {…} 以自动完成它。
为了更快地定义接口和结构，现在，当您键入type 关键字时，IDE 会为它们建议模板。当您输入 interface 或 struct 时，将显示相同的补全内容。
现在，根据格式设置规则的要求，Fill Fields 操作会在冒号后添加空格，并在复合文字中的语句末尾添加逗号。
现在，当您使用 map 时，完成键类型后，代码补全将光标移到右括号后面。
智能代码补全建议使用指向结构的指针。
最终，代码补全变得更加智能，现在在断言和 type-switch-case 中会首先建议兼容类型。
代码编辑增强 当编写多值返回函数的签名时，GoLang 2020.1 将在逗号后面的返回类型周围自动添加括号。
此外，当您在字符串中粘贴一些文本时，GoLand 会自动转义双引号。
Postfix 完成模板 .else Postfix 完成模板可以快速添加 if 语句，以检查表达式是否为假。
实时模板 我们添加了新的 consts, vars, types, 和 import 模板 。对于这些模板，默认情况下，GoLand 将在表达式周围添加括号。
fori 模板插入经典 for 循环的样板代码。
重构 现在，即使接口定义中省略了参数名称，Implement Methods（在 macOS 和 Windows/Linux 上为 Ctrl + I）也允许您指定参数名称。</description>
			<content type="html"><![CDATA[<p>GoLand 2020.1 抢先体验计划已经启动。对于此发行版，我们着重于易用性，性能以及减少浪费在样板代码和 IDE 中的冗余操作上的时间。我们还包括对 Go Modules 支持的升级，和其他更多功能。您可以在 2020.1 的<a href="https://blog.jetbrains.com/go/2019/12/24/whats-next-goland-2020-1-roadmap/" target="_blank" rel="noopener">路线图博客</a>
文章中找到简短说明。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/blog@2x.jpg"
    alt=""  />
</p>
</p>
<p>你可以通过 <a href="https://www.jetbrains.com/toolbox/app/?_ga=2.109771525.1651118980.1581665300-159533074.1581665300" target="_blank" rel="noopener">Toolbox App</a>
 获得它，也可以从<a href="https://www.jetbrains.com/go/nextversion/" target="_blank" rel="noopener">网站上下载</a>
，也可以使用快照包（对于 Ubuntu）；或者直接在 GoLand 中通过自动更新的方式获取。<em>Preferences / Settings | Appearance &amp; Behavior | System Settings | Updates</em>。</p>
<p>如果您想知道什么是抢先体验计划，这里有一个简短的解释：</p>
<blockquote>
<p>EAP 版本使您可以试用 Goland 仍在开发中的最新功能和增强功能。这些版本尚未经过全面测试，可能会不稳定，但是您可以在这里为我们提供帮助。通过将这些内部版本和功能用于实际项目和场景中来测试，您可以帮助我们完善它们。这样，当最终版本准备就绪时，它将为您更好地工作。</p>
</blockquote>
<ul>
<li>EAP 使您可以首先试用所有最新功能;</li>
<li>自构建日期起 30 天内免费使用 EAP 版本。您可以将这段时间用作 GoLand 的扩展试用版；</li>
<li>我们会提供 EAP 版本，直到几乎可以发布稳定版本为止。对于即将推出的 2020.1 版本，EAP 期将大致持续到 3 月底；</li>
<li>在每个发布周期中，我们都会为他们提供免费的 1 年 GoLand 订阅和一件独家的 <a href="https://twitter.com/GoLandIDE/status/1116361899308912645" target="_blank" rel="noopener">GoLand T 恤</a>
，以表彰他们中最活跃的评估人员。<p class="md__image">
  <img src="https://s2.ax1x.com/2020/02/15/1xBtL8.jpg"
    alt=""  />
</p>
</li>
<li>此外，我们几乎每天都提供最新版本。因此，如果您不想等待正式的 EAP 版本公告，则只需下载这些夜间版本之一，即可通过 Toolbox App 获得。请注意，每晚构建的质量通常低于我们的标准，并且没有随附发行说明。与 EAP 版本一样，它们也将在发布后 30 天内过期；</li>
</ul>
<p>因此，让我们看一下第一个 EAP 版本中包含的内容。</p>
<h2 id="go-modules">Go Modules</h2>
<p>现在，您可以通过 go.mod 文件中的 <strong>Alt-Enter</strong> 来获取缺失的依赖项并删除未使用的依赖项。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/go-mod-file-support.gif"
    alt=""  />
</p>
</p>
<h2 id="go-114-支持">Go 1.14 支持</h2>
<p>Go 1.14 增加了对嵌入重叠接口的支持，我们也是如此！当您使用重叠的接口时，GoLand 不会将重复的方法报告为错误。</p>
<p>为什么将此功能添加到语言中？</p>
<p>主要好处是我们可以使用嵌入定义接口，而不需要手动定义。这是一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
 
<span class="kd">type</span> <span class="nx">Employee</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Person</span>
	<span class="nf">Department</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div><p>在 Go 1.14 之前，我们无法在 Employee 接口上添加 String() 方法，因为该方法已在 Person 接口上定义了。现在，我们可以使用接口嵌入定义它，如果 Person 接口有更新，我们自己更可控。</p>
<h2 id="代码补全完成增强">代码补全/完成增强</h2>
<p>我们对样板代码说不！GoLand 为常见的错误处理模式添加了代码完成功能。现在，当您在函数中键入<code>if </code>时，您可以选择 <code>err！= nil {…}</code> 以自动完成它。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/code-completion-handling-errors.gif"
    alt=""  />
</p>
</p>
<p>为了更快地定义接口和结构，现在，当您键入<code>type</code> 关键字时，IDE 会为它们建议模板。当您输入 <code>interface</code> 或 <code>struct</code> 时，将显示相同的补全内容。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/type-keyword-completion-struct-interfaces.gif"
    alt=""  />
</p>
</p>
<p>现在，根据格式设置规则的要求，<strong>Fill Fields</strong> 操作会在冒号后添加空格，并在复合文字中的语句末尾添加逗号。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/field-name-completion.gif"
    alt=""  />
</p>
</p>
<p>现在，当您使用 map 时，完成键类型后，代码补全将光标移到右括号后面。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/code-compltion-map.gif"
    alt=""  />
</p>
</p>
<p><strong>智能代码补全</strong>建议使用指向结构的指针。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/code-completion-for-pointer-to-struct-initializer.gif"
    alt=""  />
</p>
</p>
<p>最终，代码补全变得更加智能，现在在断言和 type-switch-case 中会首先建议兼容类型。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/type-assertion-completion.gif"
    alt=""  />
</p>
</p>
<h2 id="代码编辑增强">代码编辑增强</h2>
<p>当编写多值返回函数的签名时，GoLang 2020.1 将在逗号后面的返回类型周围自动添加括号。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/multi-value-return-function.gif"
    alt=""  />
</p>
</p>
<p>此外，当您在字符串中粘贴一些文本时，GoLand 会自动转义双引号。</p>
<h2 id="postfix-完成模板">Postfix 完成模板</h2>
<p><code>.else</code> Postfix 完成模板可以快速添加 <code>if</code> 语句，以检查表达式是否为假。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/else-postfix-completion.gif"
    alt=""  />
</p>
</p>
<h2 id="实时模板">实时模板</h2>
<p>我们添加了新的 <em>consts</em>, <em>vars</em>, <em>types</em>, 和 <em>import</em> 模板 。对于这些模板，默认情况下，GoLand 将在表达式周围添加括号。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/consts-vars-live-templates.gif"
    alt=""  />
</p>
</p>
<p>fori 模板插入经典 for 循环的样板代码。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/fori-live-template.gif"
    alt=""  />
</p>
</p>
<h2 id="重构">重构</h2>
<p>现在，即使接口定义中省略了参数名称，<em>Implement Methods</em>（在 macOS 和 Windows/Linux 上为 Ctrl + I）也允许您指定参数名称。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/implement-methods.gif"
    alt=""  />
</p>
</p>
<h2 id="性能">性能</h2>
<p>现在 <em>Navigate to implementations</em>（在 MacOS 上为 ⌥⌘B，在 Windows/Linux 上为 Ctrl + Alt + B）和 <em>Navigate to Declaration or Usages</em>（在 macOS 上为 ⌘B，在 Windows/Linux 上为 Ctrl + B）速度更快，因为它们首先在项目范围内寻找实现。另外，搜索结果在非项目元素之前显示项目元素，而不是按字母顺序对它们进行排序。</p>
<p>我们还限制了 dep 和 Go Modules 项目的参考搜索范围，以提高其搜索性能。</p>
<h2 id="jetbrains-mono-字体">JetBrains Mono 字体</h2>
<p>如果您想知道本博客文章中的屏幕截图和 GIF 使用的是哪种字体 — 我们在 JetBrains 上为开发人员创建了一种新的字体，称为 <a href="https://www.jetbrains.com/lp/mono/" target="_blank" rel="noopener">JetBrains Mono</a>
。现在默认情况下它在 GoLand 中可用，请打开 <em>Preferences / Settings | Editor | Font</em>，然后选择 JetBrains Mono 尝试一下。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/jetbrains-mono-font.png"
    alt=""  />
</p>
</p>
<h2 id="拼写检查器">拼写检查器</h2>
<p>前一段时间，我们宣布了一个名为 Grazie 的插件。此插件可为您在 IDE 中编写的文本提供智能的拼写和语法检查，并且支持 15 种以上的语言，包括英语，德语，俄语，中文等。在此 EAP 版本和即将发布的 2020.1 版本中，默认情况下捆绑了 Grazie。要了解更多信息，请阅读此<a href="https://blog.jetbrains.com/idea/2019/11/meet-grazie-the-ultimate-spelling-grammar-and-style-checker-for-intellij-idea/" target="_blank" rel="noopener">博客文章</a>
。</p>
<h2 id="默认配色方案改回为亮色">默认配色方案改回为亮色</h2>
<p>许多用户要求我们为 Default 和 Darcula 配色方案中突出显示的语义代码增加更多种类，而我们在 2019.2 版本中进行了添加。一些用户很高兴，而其他用户则不满意，请我们还原更改。</p>
<p>因此，为了使所有人感到高兴，我们决定恢复默认配色方案，但使用了新名称 Classic Light。</p>
<p>要切换配色方案，请打开 <em>Preferences/Settings | Editor | Color Scheme</em> 选择。</p>
<h2 id="jbr8-支持终止">JBR8 支持终止</h2>
<p>从现在开始，我们将完全转向 JetBrains Runtime 11（JBR11），并且将不再分发带有 JetBrains Runtime 8（JBR8）的内部版本。请注意，IDE 和工具箱应用程序中的所有 GoLand 2020.1 更新都将随附 JBR11。</p>
<p>请记住，我们始终感谢您的反馈，因此请在留言区，Twitter 或 <a href="https://youtrack.jetbrains.com/issues/GO" target="_blank" rel="noopener">issue tracker</a>
 中与我们分享您的试用情况。</p>
<blockquote>
<p>由 Ekaterina Zharova 在 2020 年 2 月 6 日发布</p>
<p>原文：https://blog.jetbrains.com/go/2020/02/06/welcome-to-the-goland-2020-1-eap/</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——基础篇3：通过一个例子串联各特性</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/basic03-example/</link>
			<pubDate>Tue, 03 Dec 2019 20:31:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/basic03-example/</guid>
			<description>通过前面的介绍，相信对 echo 有了一个初步的认识。本文我们通过一个简单的登录页面来串联 echo 的相关特性。因为该文主要关注各个特性，所以在目录结构和代码组织方面很随意。 本节最终效果 1）登录页面 2）登录失败 3）登录成功 main 函数骨架 使用 echo 框架，在程序入口处一般包含如下内容： func main() { // 创建 echo 实例 e := echo.New() // 配置日志 configLogger(e) // 注册静态文件路由 e.Static(&amp;#34;img&amp;#34;, &amp;#34;img&amp;#34;) e.File(&amp;#34;/favicon.ico&amp;#34;, &amp;#34;img/favicon.ico&amp;#34;) // 设置中间件 setMiddleware(e) // 注册路由 RegisterRoutes(e) // 启动服务 e.Logger.Fatal(e.Start(&amp;#34;:2019&amp;#34;)) } 日</description>
			<content type="html"><![CDATA[<p>通过前面的介绍，相信对 echo 有了一个初步的认识。本文我们通过一个简单的登录页面来串联 echo 的相关特性。因为该文主要关注各个特性，所以在目录结构和代码组织方面很随意。</p>
<h2 id="本节最终效果">本节最终效果</h2>
<p>1）登录页面</p>
<p><p class="md__image">
  <img src="../imgs/login.png"
    alt=""  />
</p>
</p>
<p>2）登录失败</p>
<p><p class="md__image">
  <img src="../imgs/login-fail.png"
    alt=""  />
</p>
</p>
<p>3）登录成功</p>
<p><p class="md__image">
  <img src="../imgs/login-success.png"
    alt=""  />
</p>
</p>
<h2 id="main-函数骨架">main 函数骨架</h2>
<p>使用 echo 框架，在程序入口处一般包含如下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 创建 echo 实例
</span><span class="c1"></span>	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="c1">// 配置日志
</span><span class="c1"></span>	<span class="nf">configLogger</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>

	<span class="c1">// 注册静态文件路由
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nf">Static</span><span class="p">(</span><span class="s">&#34;img&#34;</span><span class="p">,</span> <span class="s">&#34;img&#34;</span><span class="p">)</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">File</span><span class="p">(</span><span class="s">&#34;/favicon.ico&#34;</span><span class="p">,</span> <span class="s">&#34;img/favicon.ico&#34;</span><span class="p">)</span>

	<span class="c1">// 设置中间件
</span><span class="c1"></span>	<span class="nf">setMiddleware</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>

	<span class="c1">// 注册路由
</span><span class="c1"></span>	<span class="nf">RegisterRoutes</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>

	<span class="c1">// 启动服务
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2019&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h2 id="日志">日志</h2>
<p>echo 中定义了一个接口：<a href="https://pkg.go.dev/github.com/labstack/echo?tab=doc#Logger" target="_blank" rel="noopener">Logger</a>
，而 <a href="https://pkg.go.dev/github.com/labstack/echo?tab=doc#Echo" target="_blank" rel="noopener">Echo 结构体</a>
有一个该接口的字段，这也就是 main 函数最后一句：<code>e.Logger.Fatal</code> 可以这么用的原因。框架中该接口的具体实现使用的是 <code>github.com/labstack/gommon/log</code>，如果需要，我们可以采用自己的实现，替换框架默认的。</p>
<p>默认情况下，日志输出到终端，而且 Level 级别是 ERROR，我们可以方便的通过 Logger 接口提供的方法进行修改：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">configLogger</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">echo</span><span class="p">.</span><span class="nx">Echo</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 定义日志级别
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">INFO</span><span class="p">)</span>
	<span class="c1">// 记录业务日志
</span><span class="c1"></span>	<span class="nx">echoLog</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;log/echo.log&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_APPEND</span><span class="p">,</span> <span class="mo">0644</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 同时输出到文件和终端
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetOutput</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nf">MultiWriter</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">echoLog</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>为了方便，开发中我将日志同时输出到了终端和文件中。</p>
<h2 id="中间件">中间件</h2>
<p>几乎所有的 Web 框架都支持中间件。其实这里的中间件跟传统的中间件不是一回事，这里的中间件其实是一种装饰模式。闲言少叙，我们看看 Echo 的中间件。</p>
<p>以 Recover 中间件为例讲解。</p>
<h3 id="中间件标准签名">中间件标准签名</h3>
<p>通过 <code>Echo.Use</code> 方法知晓，中间件是 MiddlewareFunc 类型，它的定义如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MiddlewareFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span>
</code></pre></div><p>也就是说，一个中间件应该是 MiddlewareFunc 类型。所以，一个函数，只要返回 MiddlewareFunc 类型就是一个 Echo 中间件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Recover</span><span class="p">()</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">MiddlewareFunc</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h3 id="支持配置的中间件">支持配置的中间件</h3>
<p>Echo 的中间件通常都支持以下功能：</p>
<ul>
<li>通过配置修改中间件的行为</li>
<li>可以选择是否跳过该中间件</li>
</ul>
<p>一般做法就是：</p>
<ul>
<li>定义一个类型，如：RecoverConfig，用于配置 Recover 中间件的行为；</li>
<li>给上述类型的一个默认实例：DefaultRecoverConfig；</li>
<li>定义一个支持传递配置的函数，返回中间件类型，如：RecoverWithConfig；</li>
<li>定义一个不带参数的函数，返回中间件类型，内部调用带参数的中间件函数，参数用默认实例，如：Recover，它的实现是直接调用 <code>RecoverWithConfig(DefaultRecoverConfig)</code>；</li>
</ul>
<p>我们的例子代码中就通过配置修改了中间件行为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// access log 输出到文件中
</span><span class="c1"></span>	<span class="nx">accessLog</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;log/access.log&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_APPEND</span><span class="p">,</span> <span class="mo">0644</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 同时输出到终端和文件
</span><span class="c1"></span>	<span class="nx">middleware</span><span class="p">.</span><span class="nx">DefaultLoggerConfig</span><span class="p">.</span><span class="nx">Output</span> <span class="p">=</span> <span class="nx">accessLog</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Logger</span><span class="p">())</span>
</code></pre></div><h3 id="自己定义一个简单中间件">自己定义一个简单中间件</h3>
<p>很多时候，我们业务的中间件，不需要那么灵活，没必要通过配置来控制行为，这时候可以像例子中的 AutoLogin 一样：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AutoLogin 如果上次记住了，则自动登录
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AutoLogin</span><span class="p">(</span><span class="nx">next</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">cookie</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Cookie</span><span class="p">(</span><span class="s">&#34;username&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cookie</span><span class="p">.</span><span class="nx">Value</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="c1">// 实际项目这里可以通过 username 读库获取用户信息
</span><span class="c1"></span>			<span class="nx">user</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span><span class="nx">Username</span><span class="p">:</span> <span class="nx">cookie</span><span class="p">.</span><span class="nx">Value</span><span class="p">}</span>

			<span class="c1">// 放入 context 中
</span><span class="c1"></span>			<span class="nx">ctx</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;user&#34;</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nf">next</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>接收一个 echo.HandlerFunc 类型，同时返回一个 echo.HandlerFunc 类型，这就是 MiddlewareFunc 的定义，因此 AutoLogin 可以直接当中间件使用。<strong>注意：在使用是这里和上面 Recover 的区别，Recover 是返回一个中间件，而 AutoLogin 本身是一个中间件，因此使用时分别是：Use(Recover()) 和 Use(AutoLogin)</strong>。</p>
<p>在具体实现中间件时，可以在调用 <code>next()</code> 函数前后增加该中间件需要的功能。</p>
<h2 id="cookie-和-session">Cookie 和 Session</h2>
<p>关于 Cookie、Session 和 Token 的介绍，可以通过 <a href="https://cloud.tencent.com/developer/article/1542456" target="_blank" rel="noopener">《一文带您彻底理解Cookie、Session、Token》</a>
 了解下。</p>
<p>在 Go 中，Session 相关功能最常用的包是 <code>github.com/gorilla/sessions</code>。Echo 提供了 Session 中间件，使用的就是该包。这里我们主要讲解一下登录需要用到的功能。</p>
<h3 id="登录成功种-cookie">登录成功种 Cookie</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 用标准库种 cookie
</span><span class="c1"></span><span class="nx">cookie</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Cookie</span><span class="p">{</span>
  <span class="nx">Name</span><span class="p">:</span>     <span class="s">&#34;username&#34;</span><span class="p">,</span>
  <span class="nx">Value</span><span class="p">:</span>    <span class="nx">username</span><span class="p">,</span>
  <span class="nx">HttpOnly</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">rememberMe</span> <span class="o">==</span> <span class="s">&#34;1&#34;</span> <span class="p">{</span>
  <span class="nx">cookie</span><span class="p">.</span><span class="nx">MaxAge</span> <span class="p">=</span> <span class="mi">7</span><span class="o">*</span><span class="mi">24</span><span class="o">*</span><span class="mi">3600</span>	<span class="c1">// 7 天
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">SetCookie</span><span class="p">(</span><span class="nx">cookie</span><span class="p">)</span>
</code></pre></div><p>我们这里直接使用了标准库的方式实现，而不是使用 ``github.com/gorilla/sessions` 包。默认情况下，浏览器关闭，cookie 删除，当“记住我”，保存 7 天。这里留一个问题：<strong>cookie.Expires 和 cookie.MaxAge 的区别？</strong></p>
<h3 id="重定向保留用户名">重定向保留用户名</h3>
<p>在登录失败后，为了避免用户再次输入用户名，这里借用 <code>github.com/gorilla/sessions</code> 包的 Flash Message 功能。</p>
<p><code>github.com/gorilla/sessions</code> 实现了 Cookie 和文件系统 Session，默认情况下，使用 Cookie。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">sess</span> <span class="o">:=</span> <span class="nf">getCookieSession</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="nx">sess</span><span class="p">.</span><span class="nf">AddFlash</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="s">&#34;username&#34;</span><span class="p">)</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">sess</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">(),</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Response</span><span class="p">())</span>
</code></pre></div><p>在读 Flash Message 的地方，一定要注意，需要再次执行 session.Save：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">sess</span> <span class="o">:=</span> <span class="nf">getCookieSession</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">flashes</span> <span class="o">:=</span> <span class="nx">sess</span><span class="p">.</span><span class="nf">Flashes</span><span class="p">(</span><span class="s">&#34;username&#34;</span><span class="p">);</span> <span class="nb">len</span><span class="p">(</span><span class="nx">flashes</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">[</span><span class="s">&#34;username&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">flashes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">sess</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">(),</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Response</span><span class="p">())</span>
</code></pre></div><h2 id="总结">总结</h2>
<p>一个简单的登录，涉及到的知识点还是不少的，但依然有不少 Echo 框架的功能没包括。后面我们会介绍更多 Echo 的特性和功能，这个简单的例子，希望能够让你对 Echo 更有感觉。</p>
<p>完整示例代码：<a href="https://github.com/polaris1119/echo-login-example" target="_blank" rel="noopener">https://github.com/polaris1119/echo-login-example</a>
</p>
]]></content>
		</item>
		
		<item>
			<title>更懂 module 的包资源中心：关于 pkg.go.dev 的前世今生和未来</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/pkg-go-dev-plan/</link>
			<pubDate>Fri, 15 Nov 2019 08:52:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/pkg-go-dev-plan/</guid>
			<description>北京时间 2019 年 11 月 14 日凌晨 1 点 16 分，Go 官方团队在 golang-nuts 邮件组宣布 go.dev 上线，这是一个新的 Go 开发人员中心。具体的介绍可以看我之前发布的文章 大家用Go都做什么？Go官方新发布的 Go.Dev 告诉你 。同时，go.dev 还提供了一个 Go 软件包和模块的新信息资源中心：pkg.go.dev，而在此之前，Go 已经存在了一个包资源网站：godoc.org。2020 年 1 月 31 日，在 Go 官方博客又发布了</description>
			<content type="html"><![CDATA[<p>北京时间 2019 年 11 月 14 日凌晨 1 点 16 分，Go 官方团队在 golang-nuts 邮件组宣布 go.dev 上线，这是一个新的 Go 开发人员中心。具体的介绍可以看我之前发布的文章 <a href="https://mp.weixin.qq.com/s/vwBlrJvHXdWhqWmVFhv7-A" target="_blank" rel="noopener">大家用Go都做什么？Go官方新发布的 Go.Dev 告诉你</a>
。同时，go.dev 还提供了一个 Go 软件包和模块的新信息资源中心：pkg.go.dev，而在此之前，Go 已经存在了一个包资源网站：godoc.org。2020 年 1 月 31 日，在 Go 官方博客又发布了一篇博文，关于 pkg.go.dev 接下来要做的事情，一时间社区讨论激烈，很多人不解。官方（Russ）对此也进行了解释。本文就官方的博文和 Google 邮件组上的相关内容进行整理总结，分享给大家。</p>
<h2 id="一官方博文-next-steps-for-pkggodev快速解读">一、官方博文 《Next steps for pkg.go.dev》快速解读</h2>
<ol>
<li>将 godoc.org 请求重定向到 pkg.go.dev，并向社区开发者征求反馈意见</li>
<li>回答了开发者比较关心的几个问题：
<ul>
<li>在迁移过程中，如果 package 没有显示在 pkg.go.dev 上，可以通过从 proxy.golang.org 获取对应版本的 module 来添加；</li>
<li>开发者的package突然出现不明的许可证限制 ，不要慌，后面会优化证书检测算法；</li>
<li>pkg.go.dev 是否会开源？很多公司想搭建自己的代码文档中心，目前这个需求在征求意见可填官方的调查问卷：https://google.qualtrics.com/jfe/form/SV_6FHmaLveae6d8Bn</li>
</ul>
</li>
</ol>
<p>以下是全文：</p>
<hr>
<h2 id="介绍">介绍</h2>
<p>在 2019 年，我们官方启动了 <a href="https://go.dev/" target="_blank" rel="noopener">go.dev</a>
，这是 Go 开发人员新的资源中心。</p>
<p>作为该站点的一部分，我们还启动了 <a href="https://pkg.go.dev" target="_blank" rel="noopener">pkg.go.dev</a>
，它是有关 Go 软件包和模块的信息资源中心。像 <a href="https://godoc.org/" target="_blank" rel="noopener">godoc.org</a>
 一样 ，pkg.go.dev 也提供 Go 文档。然而，它还了解 module，并提供有关软件包以前版本的信息！</p>
<p>今年开始，我们将在 pkg.go.dev 中添加新的更多功能，以帮助我们的用户更好地了解他们的依赖关系，并帮助他们围绕要导入的库做出更好的决策。</p>
<h2 id="将-godocorg-请求重定向到-pkggodev">将 godoc.org 请求重定向到 pkg.go.dev</h2>
<p>为了减少在过渡的过程中对用户的打扰，我们计划在今年晚些时候将流量从 godoc.org 重定向到 pkg.go.dev 上。同时我们需要您的及时意见反馈，以确保 pkg.go.dev 能够满足我们所有用户的需求。我们鼓励大家从今天开始使用pkg.go.dev，并提供反馈。</p>
<p>您的反馈将为我们的过渡计划提供信息，目的是使 pkg.go.dev 成为包和模块的主要信息和文档来源。我们确定您想在pkg.go.dev上看到一些内容，并且希望您收到有关这些功能的信息！</p>
<p>您可以通过以下渠道与我们分享您的反馈意见：</p>
<ul>
<li>在 Go 问题跟踪器上发布 (<a href="https://golang.org/s/discovery-feedback" target="_blank" rel="noopener">https://golang.org/s/discovery-feedback</a>
)；</li>
<li>发邮件：go-discovery-feedback@google.com；</li>
<li>通过 go.dev 底部的 “Share Feedback” 或 “Report an Issue”；</li>
</ul>
<p>作为过渡的一部分，我们还将讨论对 pkg.go.dev 进行 API 访问的计划 。我们将在 Go issue 33654 (<a href="https://golang.org/s/discovery-updates" target="_blank" rel="noopener">https://golang.org/s/discovery-updates</a>
) 上发布更新 。</p>
<h2 id="问答">问答</h2>
<p>自 11 月推出以来，我们已经收到 Go 用户关于 pkg.go.dev 的大量反馈 。对于本文的剩下部分，我们将回答一些常见问题，希望对大家有帮助。</p>
<h3 id="1-我的-package-未显示在-pkggodev-上该怎么做">1. 我的 package 未显示在 pkg.go.dev 上，该怎么做？</h3>
<p>我们会定期监控 <a href="https://index.golang.org/index" target="_blank" rel="noopener">Go Module Index</a>
 以查找要添加到 pkg.go.dev 的新包。如果在 pkg.go.dev 上没有找到某个包，则可以通过从 proxy.golang.org 获取模块版本来添加它 。有关说明，请参见 <a href="https://go.dev/about" target="_blank" rel="noopener">https://go.dev/about</a>
</p>
<h3 id="2--我的-package-有许可证限制它会是什么问题">2.  我的 package 有许可证限制。它会是什么问题？</h3>
<p>我们知道，无法在 pkg.go.dev 上完整地看到您想要的 package，这是一个令人沮丧的经历。感谢您在我们改进许可证检测算法过程中的耐心配合。</p>
<p>自 2019 年 11 月推出以来，我们进行了以下改进：</p>
<ul>
<li>更新了我们的许可政策(<a href="https://pkg.go.dev/license-policy" target="_blank" rel="noopener">https://pkg.go.dev/license-policy</a>
)，里面包括了我们检测和识别的许可列表；</li>
<li>与许可证检查(<a href="https://github.com/google/licensecheck" target="_blank" rel="noopener">https://github.com/google/licensecheck</a>
)团队合作，改善对版权声明的检测；</li>
<li>建立了特殊情况的手动审核流程；</li>
</ul>
<p>与往常一样，我们的许可政策位于 <a href="https://pkg.go.dev/license-policy" target="_blank" rel="noopener">https://pkg.go.dev/license-policy</a>
 。如果您遇到问题，请随时在 Go 问题跟踪器上提交问题 (<a href="https://golang.org/x/discovery-feedback" target="_blank" rel="noopener">https://golang.org/x/discovery-feedback</a>
)，或发送电子邮件至 <a href="mailto:go-discovery-feedback@google.com">go-discovery-feedback@google.com</a>
， 以便我们直接与您合作！</p>
<h3 id="3-pkggodev-会开源吗以便可以在我的私人库上运行它">3. pkg.go.dev 会开源吗，以便可以在我的私人库上运行它？</h3>
<p>我们知道，拥有私有代码库的公司希望运行提供模块支持的文档服务器。我们希望帮助满足这一需求，但是我们目前还没有深入的了解这个需求痛点。</p>
<p>我们从用户那里听说，运行 godoc.org 服务器比实际上要复杂得多，因为它是为在 Internet 范围而不是仅在公司内部提供服务而设计的。我们认为当前的 pkg.go.dev 服务将出现相同的问题。</p>
<p>我们认为使用新的服务都能够提供私有代码部署，而不是让每家公司都面临运行在公网上面。而且除了提供文档之外，新服务器还可以为 goimports 和 gopls 提供帮助 。</p>
<p>如果要运行这样的服务，请填一个 3-5 分钟的调查( <a href="https://google.qualtrics.com/jfe/form/SV_6FHmaLveae6d8Bn" target="_blank" rel="noopener">https://google.qualtrics.com/jfe/form/SV_6FHmaLveae6d8Bn</a>
 )，以帮助我们更好地了解您的需求。该调查将持续到 2020 年 3 月1日。（polaris 建议：<strong>国内用户可以反馈反馈关于大陆访问不到或慢的问题</strong>。）</p>
<p>最后，我们对 2020 年 pkg.go.dev 的未来感到兴奋，希望广大开发者也一样！我们期待听到您的反馈，并希望与 Go 社区在该迁移中紧密合作。</p>
<p>原文地址：https://blog.golang.org/pkg.go.dev-2020</p>
<h2 id="二go-团队核心成员-rscruss在邮件组的回复">二、Go 团队核心成员 RSC（Russ）在邮件组的回复</h2>
<p>以下是他邮件回复内容的整理：</p>
<p>这封邮件有点长，但我希望它能解决大部分讨论。如果您觉得缺少任何东西，请回复，我很高兴继续讨论。</p>
<h3 id="godev-出现的背景">go.dev 出现的背景</h3>
<p>过去一年左右的时间里，我们开始了解的一件事是，下一波 Go 采用者中的许多人都希望拥有一个包含 Go 资源的“一站式”网站，包括如何入门，谁正在使用它，指向学习资源，软件包文档等的链接。新的 <a href="http://go.dev" target="_blank" rel="noopener">go.dev</a>
 就是该一站式网站。在宣布它的博客中，我们将其称为 <a href="https://blog.golang.org/go.dev" target="_blank" rel="noopener">Go 开发人员的新中心</a>
。</p>
<h3 id="为什么-godev-不同于-golangorg">为什么 go.dev 不同于 golang.org？</h3>
<p>我个人认为，将两者分开可以使 <a href="http://go.dev" target="_blank" rel="noopener">go.dev</a>
 包含更多社区内容。从历史上看，<a href="http://golang.org" target="_blank" rel="noopener">golang.org</a>
 是权威地谈论 Go 的地方：它具有语言规范，标准库文档，官方下载等。对我们一直很重要的一点是，不要将它与世界上所有其他 Go 内容混在一起。新站点似乎是为其他资源创建更具包容性的场所的机会，因此是第二个站点。</p>
<h3 id="godocorg-出现的背景">godoc.org 出现的背景</h3>
<p>Gary Burd 从 2012 年末开始创建并运行了 <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
。它曾经是，现在仍然是一个绝妙的主意，并且显然是对 Go 社区的宝贵服务。大约一年后，Gary 决定不再运行并为服务器付费，因此将其交给 Go 项目采用。我们很乐意这样做，以确保所有 Go 用户仍然可以使用此资源。我们在 2014 年采用 <a href="http://godoc.com" target="_blank" rel="noopener">godoc.org</a>
 时说过 (<a href="https://groups.google.com/g/golang-nuts/c/_rbVuzl-OqA/m/N_xoNaD4kAoJ" target="_blank" rel="noopener">https://groups.google.com/g/golang-nuts/c/_rbVuzl-OqA/m/N_xoNaD4kAoJ</a>
)，我再说一遍：我非常感谢 Gary 创作的作品。</p>
<h3 id="为什么根本没有新的软件包文档站点为什么不就地更新-godocorg">为什么根本没有新的软件包文档站点？为什么不就地更新 godoc.org？</h3>
<p>通过引入模块和包的多个版本的概念，我们知道必须更新 <a href="https://godoc.org" target="_blank" rel="noopener">godoc.org</a>
。经过一番努力，似乎值得重新开始，特别是因为具有单 VM 数据库的 <a href="https://godoc.org" target="_blank" rel="noopener">godoc.org</a>
 服务器设计已经开始有点不合时宜了。除了模块工作之外，我们还要解决其他问题，例如服务的可访问性和整体可伸缩性。</p>
<p>As a side note, there&rsquo;s almost nothing in the Go distribution that has survived eight years without being redone. The compiler, the assembler, the linker, the go command itself, most of the standard library: all of them have been massively overhauled one or more times since the start of Go. That&rsquo;s how we take what we learn and make things better.</p>
<p>顺便提一句，Go 发行版中几乎没有任何内容可以重做 8 年。编译器，汇编器，链接器，go 命令本身，大多数标准库：自 Go 以来，所有这些库均已进行了一次或多次大修。这就是我们学习和改进事情的方式。</p>
<p>这种重写总是涉及一个过渡时期，在这个过渡时期中，旧版本仍然是大多数人使用的主力军，而新版本则为早期采用者测试和发现错误提供了新名称。</p>
<h3 id="为什么在-pkggodev-上有新的包文档站点">为什么在 pkg.go.dev 上有新的包文档站点？</h3>
<p>Docs for all the packages in the entire ecosystem are exactly the kind of community-generated content that <a href="http://go.dev" target="_blank" rel="noopener">go.dev</a>
 is meant to help find, so <a href="http://pkg.go.dev" target="_blank" rel="noopener">pkg.go.dev</a>
 seemed like a good name. Especially since <a href="http://go.dev" target="_blank" rel="noopener">go.dev</a>
 has a much broader scope than <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
, it makes sense to take the opportunity to fold it in and reduce the number of sites a typical user has to be aware of (once the transition is complete).</p>
<p>整个生态系统中所有软件包的文档都是 <a href="http://go.dev" target="_blank" rel="noopener">go.dev</a>
，旨在帮助查找社区产生的内容，因此 <a href="https://pkg.go.dev" target="_blank" rel="noopener">pkg.go.dev</a>
 似乎是个好名字。尤其是由于 <a href="https://go.dev" target="_blank" rel="noopener">go.dev</a>
 的范围比 <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
 更为广泛，因此有机会抓住它并减少它是有意义的。典型用户必须知道的站点数（一旦转换完成）。</p>
<h3 id="当-pkggodev-不够完善时为什么要谈论将-godocorg-重定向到-pkggodev">当 pkg.go.dev 不够完善时，为什么要谈论将 godoc.org 重定向到 pkg.go.dev？</h3>
<p>直言不讳，以便您可以帮助我们了解发生了什么问题，因此我们可以在重定向发生之前对其进行修复。我们知道一些事情，但是发现有些事情我们完全不知道也不会感到惊讶。最好是尽早发现而不是后来发现。同样，该博客文章首先是请求反馈有关在实际执行重定向之前需要发生的情况。</p>
<h3 id="为什么-pkggodev-需要检测到许可证才能显示文档为什么没有-godocorg">为什么 pkg.go.dev 需要检测到许可证才能显示文档？为什么没有 godoc.org？</h3>
<p>负责 pkg.go.dev 的团队已经花了很多时间与 Google 的律师讨论从互联网下载 Go 源码时我们可以做或不能做的事情。我们遵循的规则是，提供漂亮的 HTML 文档版本会显示原始文档的修改版本，并且只有在获得公认的已知良好许可证的情况下，我们才能这样做。</p>
<p>When we adopted <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
 from Gary Burd back in 2014, it did not occur to any of us to put it through that kind of review. If we had, maybe the community would have gone through this licensing pain earlier. For now we are focusing on making changes to <a href="http://pkg.go.dev" target="_blank" rel="noopener">pkg.go.dev</a>
 rather than correcting past mistakes on <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
. (At this point, more scrutiny of what <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
 does is not likely to have an outcome that anyone likes.)</p>
<p>当我们在 2014 年采用 Gary Burd 的 godoc.org 时，我们所有人都没有想到要进行这种审查。如果有的话，也许社区会更早地经历这种许可痛苦。目前，我们专注于对 pkg.go.dev 进行更改，而不是更正 godoc.org 上的错误。（在这一点上，对 godoc.org 所做的事情进行更严格的审查可能不会产生任何人喜欢的结果。）</p>
<h3 id="pkggodev-上不显示那些热门软件包">pkg.go.dev 上不显示那些热门软件包？</h3>
<p>现在看来 pkg.go.dev 可以看到至少 100 个其他模块导入的 1200 个模块。其中，看起来 82 被标记为不可再发行，因此我们无法显示其文档。低于 7％，我们正在努力更好地理解这一点。如果有任何是我们的错误，我们将予以解决。</p>
<p>Another thing that was suggested that I think is a great idea is to change the “no docs available” page to have a command-line to bring up the docs in your own local godoc command.</p>
<p>我认为另一个好主意是建议更改 “无可用文档” 页面，以便使用命令行在您自己的本地 godoc 命令中显示该文档。</p>
<p>题外话：一般来说（不仅仅是关于 Go 的内容），你会惊讶于在某种元数据（GitHub meta，package.json，SPDX代码等）中具有声明的 “许可证类型”  但实际上没有许可证文本的软件包数量。这使得许可证无法遵守！例如，MIT 许可证要求“以上版权声明和此许可声明应包含在软件的所有副本或重要部分中”。但是，如果没有要包含的此类通知，仅包含“ // SPDX-License-Identifier：MIT”注释，则实际上没有办法遵守。真是一团糟。如果您从未遇到过程序员如何看待世界与律师如何做之间的差异，那么让我推荐 <a href="https://ansuz.sooke.bc.ca/entry/23" target="_blank" rel="noopener">What Colour are your bits?</a>
</p>
<p>encountered the differences between how programmers see the world</p>
<p>and how lawyers do, let me recommend &ldquo;<a href="https://ansuz.sooke.bc.ca/entry/23" target="_blank" rel="noopener">What Colour are your bits?</a>
&quot;]</p>
<h3 id="为什么pkggodev没有开源">为什么pkg.go.dev没有开源？</h3>
<p>这里没有任何阴谋。最初的计划是将其开源，但是开放源代码给代码库带来了压力，要求它们可以在其他环境中重用。目前，该代码仅针对以下一种情况编写：全球 pkg.go.dev 网站。</p>
<p>我帮助编辑了博客文章，并负责“将pkg.go.dev开源，以便我可以在我的私人代码上运行它吗？”这个问题。对于造成这么多人的冒犯，我深表歉意。</p>
<p>我并不是要暗示没有其他理由来运行文档服务器，只是举例说明我认为 Go 开发人员想要代码的最常见原因。</p>
<p>与我们发布不是全局代理站点的代理的开放源代码参考实现的方式几乎相同，我仍然希望我们将发布不需要模块代码的软件包文档站点的开放源代码参考实现。全球站点。不论是在使用私有代码还是在您的笔记本电脑上使用完全开源的代码，无需在全球范围内实现的实现都可以更轻松地运行。我还希望同一台服务器可以提供索引查询，以使诸如 goimports 和 gopls 之类的工具更快。相比之下，pkg.go.dev 可能无法（至少以不同的方式）为扩展关注点和隐私关注点提供此类查询。</p>
<p>因此，博客文章中的原因是真正的原因：当前的代码不是您可能应该运行的代码，无论是在工作中还是在离线模式下的笔记本电脑上，我都认为我们可以为此提供更好的答案。</p>
<p>但是，我听到所有想要查看网站上正在运行的代码并可能对其做出贡献的所有人，无论是否在其他情况下运行都有意义。我将对此进行调查。</p>
<p>再次感谢您在我们与大家沟通不畅时给我们打招呼。确实有帮助。希望这封邮件也能对您有所帮助，否则请告知我。</p>
<p>祝好，
Russ</p>
<hr>
<p>注意：目前 godoc.org 上已经有提示，建议使用 pkg.go.dev 了。</p>
<h2 id="三关于-golangclubcom">三、关于 golangclub.com</h2>
<p>最后，go.dev 的中国本土化站点：https://golangclub.com 仍在完善中，期待您的贡献。项目地址：https://github.com/polaris1119/golangclub</p>
<p><p class="md__image">
  <img src="https://s2.ax1x.com/2020/02/10/15aZUs.png"
    alt=""  />
</p>
</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——基础篇2：Echo 核心亮点介绍</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/basic02-feature/</link>
			<pubDate>Mon, 28 Oct 2019 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/basic02-feature/</guid>
			<description>在 Echo 的官网的首页，列出了 9 个核心功能或亮点。我这里将它说成是亮点（也许并不一定都比其他框架更好）。 一、优化的路由 高度优化的 HTTP 路由，动态内存分配为零，可对路由进行优先级排序。 这一点从上一篇：[搭建 Echo 开发环境](基础篇：搭建 Echo 开发环境.md) 可以看到。 Echo 路由基于 radix tree ，查询速度非常快。路由使用 sync pool 来重用内存，实现无 GC 开销下的零动态内存分配。 路由的注册和使用方式 各大</description>
			<content type="html"><![CDATA[<p>在 Echo 的官网的首页，列出了 9 个核心功能或亮点。我这里将它说成是亮点（也许并不一定都比其他框架更好）。</p>
<h2 id="一优化的路由">一、优化的路由</h2>
<p><strong>高度优化的 HTTP 路由，动态内存分配为零，可对路由进行优先级排序。</strong></p>
<p>这一点从上一篇：[搭建 Echo 开发环境](基础篇：搭建 Echo 开发环境.md) 可以看到。</p>
<p>Echo 路由基于 <a href="http://en.wikipedia.org/wiki/Radix_tree" target="_blank" rel="noopener">radix tree</a>
 ，查询速度非常快。路由使用 <a href="https://docs.studygolang.com/pkg/sync/#Pool" target="_blank" rel="noopener">sync pool</a>
 来重用内存，实现无 GC 开销下的零动态内存分配。</p>
<h3 id="路由的注册和使用方式">路由的注册和使用方式</h3>
<p>各大框架路由的注册和使用方式都类似，通过 HTTP 方法（GET、POST、PUT、DELETE 等），将 url 路径和一个处理程序绑定在一起，唯一不太一样的一般是处理程序的函数签名不一样（主要参数类型不一样）。例如，下面的代码则展示了一个注册路由的例子：它包括 <code>GET</code> 的访问方式， <code>/hello</code> 的访问路径，以及发送 <code>Hello World</code> HTTP 响应的处理程序。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 业务处理
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">hello</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 路由
</span><span class="c1"></span><span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/hello&#34;</span><span class="p">,</span> <span class="nx">hello</span><span class="p">)</span>
</code></pre></div><p>更多路由的特性，参考文档：<a href="https://echo.labstack.com/guide/routing/" target="_blank" rel="noopener">https://echo.labstack.com/guide/routing/</a>
（英文）、 <a href="https://www.bookstack.cn/read/echo-v3-zh/guide-routing.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/echo-v3-zh/guide-routing.md</a>
 （中文）。（上篇贴的中文文档打不开了。注意，中文文档基于 V3，而不是 V4）</p>
<h2 id="二scalable">二、Scalable</h2>
<p>Echo 方便构建健壮的 RESTful API，轻松将其组织起来。</p>
<p>根据上一节路由，我们可以轻松构建出 RESTful API，比如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/user&#34;</span><span class="p">,</span> <span class="nx">createUser</span><span class="p">)</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/user/1&#34;</span><span class="p">,</span> <span class="nx">findUser</span><span class="p">)</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">PUT</span><span class="p">(</span><span class="s">&#34;/user/1&#34;</span><span class="p">,</span> <span class="nx">updateUser</span><span class="p">)</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">DELETE</span><span class="p">(</span><span class="s">&#34;/user/1&#34;</span><span class="p">,</span> <span class="nx">deleteUser</span><span class="p">)</span>
</code></pre></div><p>可以轻松对应上 RESTful API 的标准。</p>
<h2 id="三自动-tls">三、自动 TLS</h2>
<p>Echo 能够通过 “Let&rsquo;s Encrypt” 自动安装 TLS 证书。<code>Echo#StartAutoTLS</code> 接受一个接听 443 端口的网络地址。类似 <code>:443</code> 这样。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">StartAutoTLS</span><span class="p">(</span><span class="s">&#34;:443&#34;</span><span class="p">)</span>
</code></pre></div><p>可以通过 <code>e.AutoTLSManager</code> 做一些控制，比如缓存等。</p>
<h2 id="四http2">四、HTTP/2</h2>
<p>Echo 自动支持 HTTP/2。HTTP/2 (原本的名字是 HTTP/2.0) 是万维网使用的 HTTP 网络协议的第二个主要版本。HTTP/2 提供了更快的速度和更好的用户体验。</p>
<h3 id="特性">特性</h3>
<ul>
<li>使用二进制格式传输数据，而不是文本。使得在解析和优化扩展上更为方便。</li>
<li>多路复用，所有的请求都是通过一个 TCP 连接并发完成。</li>
<li>对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。</li>
<li>Server Push：服务端能够更快的把资源推送给客户端。</li>
</ul>
<h2 id="五中间件">五、中间件</h2>
<p>这是让 Echo 可扩展、功能强大、好用的关键组件。</p>
<p>中间件是一个函数，嵌入在 HTTP 的请求和响应之间。它可以获得 <code>Echo#Context</code> 对象用来进行一些特殊的操作， 比如记录每个请求或者统计请求数。</p>
<h3 id="不同级别的中间件">不同级别的中间件</h3>
<h4 id="1根级别中间件router-之前">1、根级别中间件（router 之前）</h4>
<p><code>Echo#Pre()</code> 用于注册一个在路由执行之前运行的中间件，可以用来修改请求的一些属性。比如在请求路径结尾添加或者删除一个 <code>/</code> 来使之能与路由匹配。</p>
<p>下面的这几个内建中间件应该被注册在这一级别：</p>
<ul>
<li>AddTrailingSlash</li>
<li>RemoveTrailingSlash</li>
<li>MethodOverride</li>
</ul>
<p><em>注意</em>: 由于在这个级别路由还没有执行，所以这个级别的中间件不能调用任何 <code>echo.Context</code> 的 API。</p>
<h4 id="2根级别中间件router-之后">2、根级别中间件（router 之后）</h4>
<p>大部分时间你将用到 <code>Echo#Use()</code> 在这个级别注册中间件。 这个级别的中间件运行在路由处理完请求之后，可以调用所有的 <code>echo.Context</code> API。</p>
<p>下面的这几个内建中间件应该被注册在这一级别：</p>
<ul>
<li>BodyLimit</li>
<li>Logger</li>
<li>Gzip</li>
<li>Recover</li>
<li>BasicAuth</li>
<li>JWTAuth</li>
<li>Secure</li>
<li>CORS</li>
<li>Static</li>
</ul>
<h4 id="3组级别中间件">3、组级别中间件</h4>
<p>当在路由中创建一个组的时候，可以为这个组注册一个中间件。例如，给 admin 这个组注册一个 BasicAuth 中间件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">admin</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/admin&#34;</span><span class="p">,</span> <span class="nx">middleware</span><span class="p">.</span><span class="nf">BasicAuth</span><span class="p">())</span>
</code></pre></div><p>也可以在创建组之后用 <code>admin.Use()</code>注册该中间件。</p>
<h4 id="4路由级别中间件">4、路由级别中间件</h4>
<p>当你创建了一个新的路由，可以选择性的给这个路由注册一个中间件。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="p">&lt;</span><span class="nx">Handler</span><span class="p">&gt;,</span> <span class="p">&lt;</span><span class="nx">Middleware</span><span class="o">...</span><span class="p">&gt;)</span>
</code></pre></div><h2 id="六数据绑定">六、数据绑定</h2>
<p>HTTP 请求有效负载的数据绑定，包括 JSON，XML 或表单数据。</p>
<p>可以使用 <code>Context#Bind(i interface{})</code> 将请求内容体绑定至 go 的结构体。默认绑定器支持基于 <code>Content-Type</code>  请求头包含 application/json，application/xml 和 application/x-www-form-urlencoded 的数据。</p>
<p>下面是绑定请求数据到 <code>User</code> 结构体的例子。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// User
</span><span class="c1"></span><span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`json:&#34;name&#34; form:&#34;name&#34; query:&#34;name&#34;`</span>
  <span class="nx">Email</span> <span class="kt">string</span> <span class="s">`json:&#34;email&#34; form:&#34;email&#34; query:&#34;email&#34;`</span>
<span class="p">}</span>

<span class="c1">// Handler
</span><span class="c1"></span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">u</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">User</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">u</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">u</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>以上代码支持如下请求数据的绑定：</p>
<p>1、JSON 数据</p>
<pre tabindex="0"><code>curl \
  -X POST \
  http://localhost:1323/users \
  -H 'Content-Type: application/json' \
  -d '{&quot;name&quot;:&quot;Joe&quot;,&quot;email&quot;:&quot;joe@labstack&quot;}'
</code></pre><p>2、Form 表单数据</p>
<pre tabindex="0"><code>curl \
  -X POST \
  http://localhost:1323/users \
  -d 'name=Joe' \
  -d 'email=joe@labstack.com'
</code></pre><p>3、查询参数 (Query Parameters)</p>
<pre tabindex="0"><code>curl \
  -X GET \
  http://localhost:1323/users\?name\=Joe\&amp;email\=joe@labstack.com
</code></pre><h2 id="七数据呈现">七、数据呈现</h2>
<p>有发送各种 HTTP 响应的 API，包括 JSON，XML，HTML，文件，附件，内联，流或 Blob。</p>
<h2 id="八模板">八、模板</h2>
<p>支持使用任何模板引擎进行模板渲染。</p>
<p>使用 <code>Context#Render(code int, name string, data interface{}) error</code> 命令渲染带有数据的模板，并发送带有状态代码的 <code>text/html</code> 响应。通过 <code>Echo.Renderer</code> 的设置我们可以使用任何模板引擎。</p>
<h2 id="九可扩展extensible">九、可扩展（Extensible）</h2>
<p>拥有可定制的集中 HTTP 错误处理和易于扩展的 API 等。</p>
<h2 id="总结">总结</h2>
<p>以上是 Echo 首页给出的 9 大核心亮点，后续教程会给出详细的讲解或实际例子。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——基础篇1：搭建 Echo 开发环境</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/basic01-env/</link>
			<pubDate>Mon, 21 Oct 2019 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/basic01-env/</guid>
			<description>工欲善其事必先利其器。我们先搞定 Echo 环境。 Go 开发环境 这个系列基于 Go1.14.4，Linux 系统。 安装 Go 的方式有很多，可以在这里 https://studygolang.com/dl 下载对应操作系统的版本。我自己比较喜欢通过源码安装。我将我的方式告诉大家。（Windows 环境比较建议直接下载对应的包进行安装 https://studygolang.com/dl/golang/go1.14.4.windows-amd64.msi ） 下载源码 在你本地某个目录（比如 $HOME/golang），执行如下命令（确保安装了 git）： git clone https://github.com/golang/go 因为</description>
			<content type="html"><![CDATA[<p>工欲善其事必先利其器。我们先搞定 Echo 环境。</p>
<h2 id="go-开发环境">Go 开发环境</h2>
<p>这个系列基于 Go1.14.4，Linux 系统。</p>
<p>安装 Go 的方式有很多，可以在这里 <a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a>
 下载对应操作系统的版本。我自己比较喜欢通过源码安装。我将我的方式告诉大家。（Windows 环境比较建议直接下载对应的包进行安装 <a href="https://studygolang.com/dl/golang/go1.14.4.windows-amd64.msi" target="_blank" rel="noopener">https://studygolang.com/dl/golang/go1.14.4.windows-amd64.msi</a>
）</p>
<h3 id="下载源码">下载源码</h3>
<p>在你本地某个目录（比如 $HOME/golang），执行如下命令（确保安装了 git）：</p>
<blockquote>
<p>git clone <a href="https://github.com/golang/go" target="_blank" rel="noopener">https://github.com/golang/go</a>
</p>
</blockquote>
<p>因为 Go 自从 1.5 开始实现了自举，因此要从源码安装 1.5 或以后的版本，必须先有 Go 环境，也就是必须有 Go1.4 或以下版本，这里我们安装 Go1.4。</p>
<h4 id="安装-go14">安装 Go1.4</h4>
<p>执行如下命令进行安装：（需要有 root 权限）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ git checkout -b release-branch.go1.4 origin/release-branch.go1.4
$ sudo cp -rf ../go /root/go1.4
$ sudo -s
$ <span class="nb">cd</span> /root/go1.4/src
$ ./make.bash
</code></pre></div><p>验证下 Go1.4 是否安装成功：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ /root/go1.4/bin/go version
</code></pre></div><p>如果输出版本信息表示成功！</p>
<h3 id="安装-go1144">安装 Go1.14.4</h3>
<p>接下来我们安装 Go1.14.4：（<code>ctrl + d</code> 切换回原用户）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/golang/go
$ git checkout -b release-branch.go1.14 origin/release-branch.go1.14
$ sudo cp -rf ../go /usr/local/go1.14
$ <span class="nb">cd</span> /usr/local/go1.14/src
$ sudo ./make.bash
</code></pre></div><p>然后我们加上一个软链，这样以后升级版本后，只需要重新设置软链即可：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ sudo ln -s /usr/local/go1.14 /usr/local/go
</code></pre></div><h3 id="配置-go-环境">配置 Go 环境</h3>
<p>最后，将 Go 加入 PATH 中，Linux 中可以在 <code>/etc/bashrc</code> 文件最后加上 <code>export PATH=$PATH:/usr/local/go/bin</code>。</p>
<p>MacOS 中可以在 <code>~/.bash_profile</code> 中加上这行配置。</p>
<p>Windows 下的环境变量配置请自行查找解决，实在有问题可以咨询我！</p>
<p>之后，打开新的 shell，执行 <code>go env</code> 可以看到类似如下的输出（Linux 下）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">GO111MODULE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOARCH</span><span class="o">=</span><span class="s2">&#34;amd64&#34;</span>
<span class="nv">GOBIN</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOCACHE</span><span class="o">=</span><span class="s2">&#34;/home/xuxinhua/.cache/go-build&#34;</span>
<span class="nv">GOENV</span><span class="o">=</span><span class="s2">&#34;/home/xuxinhua/.config/go/env&#34;</span>
<span class="nv">GOEXE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOFLAGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOHOSTARCH</span><span class="o">=</span><span class="s2">&#34;amd64&#34;</span>
<span class="nv">GOHOSTOS</span><span class="o">=</span><span class="s2">&#34;linux&#34;</span>
<span class="nv">GONOPROXY</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GONOSUMDB</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOOS</span><span class="o">=</span><span class="s2">&#34;linux&#34;</span>
<span class="nv">GOPATH</span><span class="o">=</span><span class="s2">&#34;/home/xuxinhua/go&#34;</span>
<span class="nv">GOPRIVATE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOPROXY</span><span class="o">=</span><span class="s2">&#34;https://proxy.golang.org,direct&#34;</span>
<span class="nv">GOROOT</span><span class="o">=</span><span class="s2">&#34;/usr/local/go1.14&#34;</span>
<span class="nv">GOSUMDB</span><span class="o">=</span><span class="s2">&#34;sum.golang.org&#34;</span>
<span class="nv">GOTMPDIR</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOTOOLDIR</span><span class="o">=</span><span class="s2">&#34;/usr/local/go1.14/pkg/tool/linux_amd64&#34;</span>
<span class="nv">GCCGO</span><span class="o">=</span><span class="s2">&#34;gccgo&#34;</span>
<span class="nv">AR</span><span class="o">=</span><span class="s2">&#34;ar&#34;</span>
<span class="nv">CC</span><span class="o">=</span><span class="s2">&#34;gcc&#34;</span>
<span class="nv">CXX</span><span class="o">=</span><span class="s2">&#34;g++&#34;</span>
<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="s2">&#34;1&#34;</span>
<span class="nv">GOMOD</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">CGO_CFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_CPPFLAGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">CGO_CXXFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_FFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_LDFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">PKG_CONFIG</span><span class="o">=</span><span class="s2">&#34;pkg-config&#34;</span>
<span class="nv">GOGCCFLAGS</span><span class="o">=</span><span class="s2">&#34;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build537145581=/tmp/go-build -gno-record-gcc-switches&#34;</span>
</code></pre></div><p>为了后续使用的顺畅，我们配置上 goproxy：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">go env -w <span class="nv">GOPROXY</span><span class="o">=</span>https://goproxy.cn,direct
</code></pre></div><p>自此，我们的 Go 环境就搞定了！</p>
<h4 id="升级-go-版本">升级 Go 版本</h4>
<p>后续如果要升级 Go，分两种情况。</p>
<p>1）升级到 Go1.14.x，执行如下操作：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/golang/go
$ git pull
$ sudo rm -rf /usr/local/go1.14
$ sudo cp -rf ../go /usr/local/go1.14
$ <span class="nb">cd</span> /usr/local/go1.14/src
$ ./make.bash
</code></pre></div><p>2）将来升级到 Go1.15 及后续版本，执行类似如下操作（注意改分支信息和目录）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/golang/go
$ git pull
$ git checkout -b release-branch.go1.15 origin/release-branch.go1.15
$ sudo cp -rf ../go /usr/local/go1.15
$ <span class="nb">cd</span> /usr/local/go1.15/src
$ ./make.bash
$ ln -s /usr/local/go1.15 /usr/local/go
</code></pre></div><p>这样就搞定了！</p>
<p>另外，如果感兴趣也可以使用类似 <a href="https://github.com/moovweb/gvm" target="_blank" rel="noopener">gvm</a>
 这样的工具进行 Go 版本管理和切换。</p>
<h2 id="开始-echo">开始 Echo</h2>
<blockquote>
<p>官方文档：https://echo.labstack.com/guide</p>
<p>中文翻译版：http://go-echo.org/</p>
</blockquote>
<p>是什么？</p>
<blockquote>
<p>High performance, extensible, minimalist Go web framework</p>
</blockquote>
<p>Echo 是一个高性能、可扩展、极简的 Go Web 框架。</p>
<h3 id="hello-world">Hello World</h3>
<p>所有的练习都在 <code>~/project/golang/studyecho</code> 下进行。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ mkdir -p ~/project/golang/studyecho
$ <span class="nb">cd</span> ~/project/golang/studyecho
</code></pre></div><p>接着初始化项目：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go mod init studyecho
</code></pre></div><p>这会在当前目录生成 go.mod 文件，内容如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">module studyecho

go 1.14
</code></pre></div><p>安装 echo（我们使用 4.x.x）：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go get -u github.com/labstack/echo/v4
</code></pre></div><p>这会在当前目录生成 <code>go.sum</code> 文件，同时修改 <code>go.mod</code> 文件。如果你对 Go module 不熟悉，建议阅读 <a href="https://studygolang.com/articles/19334" target="_blank" rel="noopener">Go Modules 的使用方法 —— Go 官方博文</a>
。</p>
<p>创建文件 main.go：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="c1">// 注意这里的路径
</span><span class="c1"></span>	<span class="nx">echo</span> <span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 得到一个 echo.Echo 的实例
</span><span class="c1"></span>	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
  <span class="c1">// 注册路由
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
	<span class="p">})</span>
  <span class="c1">// 开启 HTTP Server
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>启动服务：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">$ go run main.go
</code></pre></div><p>终端输出：</p>
<p><p class="md__image">
  <img src="../imgs/terminal.png"
    alt=""  />
</p>
</p>
<p>打开浏览器，输入：http://localhost:2020 你会看到：Hello, World!</p>
<p>本节完~</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——Go 语言 Web 框架 Echo 系列教程</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/echo/</link>
			<pubDate>Mon, 21 Oct 2019 13:42:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/echo/</guid>
			<description>大家好，从今天起，我们一起来学习 Echo 框架。 这几年，随着 Go 语言的发展，各种 Web 框架也出现了。常言道：没有选择是一种无奈，有选择是一种痛苦。所以，大家总是问：Web 框架大佬推荐哪个？ 这一年，国内推荐 Gin 的人很多，也让 Gin 的 Star 数增加到了 32k+（2019-10-17），网络上 Gin 相关的教程也很多。总体来说，Gin、Echo 等都比较轻量，易用性也差距不大，而 Gin 最大的一个优势是</description>
			<content type="html"><![CDATA[<p>大家好，从今天起，我们一起来学习 Echo 框架。</p>
<p>这几年，随着 Go 语言的发展，各种 Web 框架也出现了。常言道：没有选择是一种无奈，有选择是一种痛苦。所以，大家总是问：Web 框架大佬推荐哪个？</p>
<p>这一年，国内推荐 Gin 的人很多，也让 Gin 的 Star 数增加到了 32k+（2019-10-17），网络上 Gin 相关的教程也很多。总体来说，Gin、Echo 等都比较轻量，易用性也差距不大，而 Gin 最大的一个优势是直接使用了 <a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">httprouter</a>
，因此性能很高，从 Gin 项目中的 Benchmark 表格可以看出：</p>
<table>
<thead>
<tr>
<th>Benchmark name</th>
<th style="text-align:right">(1)</th>
<th style="text-align:right">(2)</th>
<th style="text-align:right">(3)</th>
<th style="text-align:right">(4)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>BenchmarkGin_GithubAll</strong></td>
<td style="text-align:right"><strong>30000</strong></td>
<td style="text-align:right"><strong>48375</strong></td>
<td style="text-align:right"><strong>0</strong></td>
<td style="text-align:right"><strong>0</strong></td>
</tr>
<tr>
<td>BenchmarkAce_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">134059</td>
<td style="text-align:right">13792</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkBear_GithubAll</td>
<td style="text-align:right">5000</td>
<td style="text-align:right">534445</td>
<td style="text-align:right">86448</td>
<td style="text-align:right">943</td>
</tr>
<tr>
<td>BenchmarkBeego_GithubAll</td>
<td style="text-align:right">3000</td>
<td style="text-align:right">592444</td>
<td style="text-align:right">74705</td>
<td style="text-align:right">812</td>
</tr>
<tr>
<td>BenchmarkBone_GithubAll</td>
<td style="text-align:right">200</td>
<td style="text-align:right">6957308</td>
<td style="text-align:right">698784</td>
<td style="text-align:right">8453</td>
</tr>
<tr>
<td>BenchmarkDenco_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">158819</td>
<td style="text-align:right">20224</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkEcho_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">154700</td>
<td style="text-align:right">6496</td>
<td style="text-align:right">203</td>
</tr>
<tr>
<td>BenchmarkGocraftWeb_GithubAll</td>
<td style="text-align:right">3000</td>
<td style="text-align:right">570806</td>
<td style="text-align:right">131656</td>
<td style="text-align:right">1686</td>
</tr>
<tr>
<td>BenchmarkGoji_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">818034</td>
<td style="text-align:right">56112</td>
<td style="text-align:right">334</td>
</tr>
<tr>
<td>BenchmarkGojiv2_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">1213973</td>
<td style="text-align:right">274768</td>
<td style="text-align:right">3712</td>
</tr>
<tr>
<td>BenchmarkGoJsonRest_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">785796</td>
<td style="text-align:right">134371</td>
<td style="text-align:right">2737</td>
</tr>
<tr>
<td>BenchmarkGoRestful_GithubAll</td>
<td style="text-align:right">300</td>
<td style="text-align:right">5238188</td>
<td style="text-align:right">689672</td>
<td style="text-align:right">4519</td>
</tr>
<tr>
<td>BenchmarkGorillaMux_GithubAll</td>
<td style="text-align:right">100</td>
<td style="text-align:right">10257726</td>
<td style="text-align:right">211840</td>
<td style="text-align:right">2272</td>
</tr>
<tr>
<td>BenchmarkHttpRouter_GithubAll</td>
<td style="text-align:right">20000</td>
<td style="text-align:right">105414</td>
<td style="text-align:right">13792</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkHttpTreeMux_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">319934</td>
<td style="text-align:right">65856</td>
<td style="text-align:right">671</td>
</tr>
<tr>
<td>BenchmarkKocha_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">209442</td>
<td style="text-align:right">23304</td>
<td style="text-align:right">843</td>
</tr>
<tr>
<td>BenchmarkLARS_GithubAll</td>
<td style="text-align:right">20000</td>
<td style="text-align:right">62565</td>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
</tr>
<tr>
<td>BenchmarkMacaron_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">1161270</td>
<td style="text-align:right">204194</td>
<td style="text-align:right">2000</td>
</tr>
<tr>
<td>BenchmarkMartini_GithubAll</td>
<td style="text-align:right">200</td>
<td style="text-align:right">9991713</td>
<td style="text-align:right">226549</td>
<td style="text-align:right">2325</td>
</tr>
<tr>
<td>BenchmarkPat_GithubAll</td>
<td style="text-align:right">200</td>
<td style="text-align:right">5590793</td>
<td style="text-align:right">1499568</td>
<td style="text-align:right">27435</td>
</tr>
<tr>
<td>BenchmarkPossum_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">319768</td>
<td style="text-align:right">84448</td>
<td style="text-align:right">609</td>
</tr>
<tr>
<td>BenchmarkR2router_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">305134</td>
<td style="text-align:right">77328</td>
<td style="text-align:right">979</td>
</tr>
<tr>
<td>BenchmarkRivet_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">132134</td>
<td style="text-align:right">16272</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkTango_GithubAll</td>
<td style="text-align:right">3000</td>
<td style="text-align:right">552754</td>
<td style="text-align:right">63826</td>
<td style="text-align:right">1618</td>
</tr>
<tr>
<td>BenchmarkTigerTonic_GithubAll</td>
<td style="text-align:right">1000</td>
<td style="text-align:right">1439483</td>
<td style="text-align:right">239104</td>
<td style="text-align:right">5374</td>
</tr>
<tr>
<td>BenchmarkTraffic_GithubAll</td>
<td style="text-align:right">100</td>
<td style="text-align:right">11383067</td>
<td style="text-align:right">2659329</td>
<td style="text-align:right">21848</td>
</tr>
<tr>
<td>BenchmarkVulcan_GithubAll</td>
<td style="text-align:right">5000</td>
<td style="text-align:right">394253</td>
<td style="text-align:right">19894</td>
<td style="text-align:right">609</td>
</tr>
</tbody>
</table>
<ul>
<li>(1): Total Repetitions achieved in constant time, higher means more confident result</li>
<li>(2): Single Repetition Duration (ns/op), lower is better</li>
<li>(3): Heap Memory (B/op), lower is better</li>
<li>(4): Average Allocations per Repetition (allocs/op), lower is better</li>
</ul>
<p>然而我下载 Gin 上提供的测试代码，发现 Echo 性能更好（或至少不比 Gin 差），下面是和上面对应的在我本地的测试（MacOS 4核 8G），测试代码：<a href="https://github.com/julienschmidt/go-http-routing-benchmark" target="_blank" rel="noopener">https://github.com/julienschmidt/go-http-routing-benchmark</a>
</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">BenchmarkEcho_GithubAll               	   35334	     <span class="m">34642</span> ns/op	       <span class="m">0</span> B/op	       <span class="m">0</span> allocs/op
BenchmarkGin_GithubAll                	   34724	     <span class="m">34696</span> ns/op	       <span class="m">0</span> B/op	       <span class="m">0</span> allocs/op
</code></pre></div><p>而且 Echo 上提供的测试结果也表明了这一点（我本地试验了，确实如此）：</p>
<p><p class="md__image">
  <img src="../imgs/benchmarks.png"
    alt=""  />
</p>
</p>
<h2 id="为什么是-echo">为什么是 Echo？</h2>
<p>截止 2019 年 10 月 20 日，Gin 的 Star 数高达 32k+，而 Echo 的 Star 数才 15k+，为什么不是选择讲解 Gin 而是 Echo？</p>
<p>我想理由有如下几个：</p>
<ol>
<li>Gin 的教程不少，但 Echo 教程不多；</li>
<li>Echo 1.x 时候，我就用在了 studygolang.com 上，现在更新到了 4.x，studygolang 也升级到了 Echo 最新版；</li>
<li>两者都是轻量级框架，而且性能不分伯仲，甚至 Echo 更胜一筹；</li>
<li>Gin 的 Star 数这么高，跟大家的推广很有关系；作为最早一批使用 Echo 的用户，我认为有必要推广下 Echo，好东西希望更多人学习、使用；</li>
</ol>
<h2 id="计划">计划</h2>
<p>本系列教程计划包含如下部分：</p>
<h3 id="一基础教程篇">一、基础教程篇</h3>
<p>讲解 Echo 的基础使用</p>
<h3 id="二定制篇">二、定制篇</h3>
<p>讲解如何定制或扩展 Echo</p>
<h3 id="三实战篇">三、实战篇</h3>
<p>通过一个项目讲解 Echo 的实战</p>
<h3 id="四源码学习篇">四、源码学习篇</h3>
<p>分析 Echo 的源码，了解它的设计，看看能领悟、学习到什么</p>
]]></content>
		</item>
		
		<item>
			<title></title>
			<link>https://polarisxu.studygolang.com/posts/systemprogramming/go/01/</link>
			<pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/systemprogramming/go/01/</guid>
			<description>用 Go 进行系统编程
大家好，我是站长 polarisxu。
今天起我们开始一个系列：用 Go 进行系统编程，主要介绍系统编程相关的知识。
01 准备 本系列教程基于 Unix 系统（更确切是 Linux 系统），如果你使用的是 Windows 系统，请安装 Windows Subsystem for Linux（WSL）。安装步骤如下：
 以管理员身份打开 PowerShell，运行如下命令：  Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux  按提示重启电脑； 根据你的喜好从 Microsoft Store 安装 Linux distribution；  Go 语言版本基于最新的 Go1.16。
02 什么是系统编程（System programming） 维基百科的解释 ：
 系统编程是指从事计算机系统软件的编码活动。
 那什么是系统软件呢？维基百科的解释 ：
 System software is software designed to provide a platform for other software.
 即服务于其他软件的软件就是系统软件，比如操作系统、游戏引擎、工业自动化等。相应的，面向用户的就是应用软件了。（有时界限没那么清晰）
系统编程是 Unix计 算机上编程的一个特殊领域。请注意，系统编程不限于 Unix 计算机，只是这个系列主要关注 Unix 系统。大多数与系统管理任务有关的命令，例如磁盘格式化，网络接口配置，模块加载和内核性能跟踪，都是使用系统编程技术来实现的。此外，可以在所有 Unix 系统上找到的 /etc 目录包含纯文本文件，这些文本文件处理 Unix 机器及其服务的配置，并且也可以使用系统软件进行操作。
一般可以将系统软件的各个领域和相关的系统调用分为以下几组：
 文件 I/O：这部分处理文件读取和写入操作，这是操作系统最重要的任务。文件输入和输出必须快速高效，并且最重要的是要可靠。 高级文件 I/O：除了基本的输入和输出系统调用之外，还有其他更高级的方法来读取或写入文件，包括异步 I/O 和非阻塞 I/O。 系统文件和配置：这些系统软件允许处理系统文件（例如 /etc/passwd）并获取系统特定信息（例如系统时间和 DNS 配置）等。 文件和目录：这部分包括函数和系统调用，它们允许程序员创建和删除目录并获取信息，例如文件或目录的所有者和权限。 进程控制：可以创建 Unix 进程并与之交互； 服务器进程：这套工具包括允许您开发服务器进程的技术，这些服务器进程是在后台执行而无需活动终端的进程。 Go 并不能很好地以传统的 Unix 方式编写服务器进程。诸如 Apache 之类的 Unix 服务器使用 fork(2) 创建一个或多个子进程（此过程称为 fork，是指从父进程克隆一个子进程），并从同一点继续执行相同的可执行文件，最重要的是，共享内存。尽管 Go 不提供与 fork(2) 函数等效的功能，但这不是大问题，因为你可以使用 goroutines 来做到 fork(2) 的大多数用法； 进程间通讯：这组功能允许在同一台 Unix 机器上运行的进程使用管道，FIFO，消息队列，信号量和共享内存等特性相互通信； 信号处理：信号为流程提供了一种处理异步事件的方法，该方法非常方便。几乎所有服务器进程都有额外的代码，这些代码使它们能够使用该组的系统调用来处理Unix信号； 网络编程：这是开发基于 TCP/IP 协议的程序。其实这部分严格来说不是系统编程。但是，大多数 TCP/IP 服务器和客户端都在处理系统资源，用户，文件和目录。因此，在大多数情况下，如果不进行某种系统编程就无法创建网络应用程序；  03 为什么写这个系列 04 参考 本系列教程主要参考如下资料：
 Unix 环境高级编程（第三版） System Programming with Go Go System Programming Mastering Go（Second Edition）  </description>
			<content type="html"><![CDATA[<p>用 Go 进行系统编程</p>
<p>大家好，我是站长 polarisxu。</p>
<p>今天起我们开始一个系列：用 Go 进行系统编程，主要介绍系统编程相关的知识。</p>
<h2 id="01-准备">01 准备</h2>
<p>本系列教程基于 Unix 系统（更确切是 Linux 系统），如果你使用的是 Windows 系统，请安装 Windows Subsystem for Linux（WSL）。安装步骤如下：</p>
<ul>
<li>以管理员身份打开 PowerShell，运行如下命令：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
</code></pre></div><ul>
<li>按提示重启电脑；</li>
<li>根据你的喜好从 Microsoft Store 安装 Linux distribution；</li>
</ul>
<p>Go 语言版本基于最新的 Go1.16。</p>
<h2 id="02-什么是系统编程system-programming">02 什么是系统编程（System programming）</h2>
<p><a href="https://en.wikipedia.org/wiki/Systems_programming" target="_blank" rel="noopener">维基百科的解释</a>
：</p>
<blockquote>
<p>系统编程是指从事计算机系统软件的编码活动。</p>
</blockquote>
<p>那什么是系统软件呢？<a href="https://en.wikipedia.org/wiki/System_software" target="_blank" rel="noopener">维基百科的解释</a>
：</p>
<blockquote>
<p>System software is software designed to provide a platform for other software.</p>
</blockquote>
<p>即服务于其他软件的软件就是系统软件，比如操作系统、游戏引擎、工业自动化等。相应的，面向用户的就是应用软件了。（有时界限没那么清晰）</p>
<p>系统编程是 Unix计 算机上编程的一个特殊领域。请注意，系统编程不限于 Unix 计算机，只是这个系列主要关注 Unix 系统。大多数与系统管理任务有关的命令，例如磁盘格式化，网络接口配置，模块加载和内核性能跟踪，都是使用系统编程技术来实现的。此外，可以在所有 Unix 系统上找到的 /etc 目录包含纯文本文件，这些文本文件处理 Unix 机器及其服务的配置，并且也可以使用系统软件进行操作。</p>
<p>一般可以将系统软件的各个领域和相关的系统调用分为以下几组：</p>
<ul>
<li>文件 I/O：这部分处理文件读取和写入操作，这是操作系统最重要的任务。文件输入和输出必须快速高效，并且最重要的是要可靠。</li>
<li>高级文件 I/O：除了基本的输入和输出系统调用之外，还有其他更高级的方法来读取或写入文件，包括异步 I/O 和非阻塞 I/O。</li>
<li>系统文件和配置：这些系统软件允许处理系统文件（例如 /etc/passwd）并获取系统特定信息（例如系统时间和 DNS 配置）等。</li>
<li>文件和目录：这部分包括函数和系统调用，它们允许程序员创建和删除目录并获取信息，例如文件或目录的所有者和权限。</li>
<li>进程控制：可以创建 Unix 进程并与之交互；</li>
<li>服务器进程：这套工具包括允许您开发服务器进程的技术，这些服务器进程是在后台执行而无需活动终端的进程。 Go 并不能很好地以传统的 Unix 方式编写服务器进程。诸如 Apache 之类的 Unix 服务器使用 fork(2) 创建一个或多个子进程（此过程称为 fork，是指从父进程克隆一个子进程），并从同一点继续执行相同的可执行文件，最重要的是，共享内存。尽管 Go 不提供与 fork(2) 函数等效的功能，但这不是大问题，因为你可以使用 goroutines 来做到 fork(2) 的大多数用法；</li>
<li>进程间通讯：这组功能允许在同一台 Unix 机器上运行的进程使用管道，FIFO，消息队列，信号量和共享内存等特性相互通信；</li>
<li>信号处理：信号为流程提供了一种处理异步事件的方法，该方法非常方便。几乎所有服务器进程都有额外的代码，这些代码使它们能够使用该组的系统调用来处理Unix信号；</li>
<li>网络编程：这是开发基于 TCP/IP 协议的程序。其实这部分严格来说不是系统编程。但是，大多数 TCP/IP 服务器和客户端都在处理系统资源，用户，文件和目录。因此，在大多数情况下，如果不进行某种系统编程就无法创建网络应用程序；</li>
</ul>
<h2 id="03-为什么写这个系列">03 为什么写这个系列</h2>
<h2 id="04-参考">04 参考</h2>
<p>本系列教程主要参考如下资料：</p>
<ul>
<li>Unix 环境高级编程（第三版）</li>
<li>System Programming with Go</li>
<li>Go System Programming</li>
<li>Mastering Go（Second Edition）</li>
</ul>
]]></content>
		</item>
		
	</channel>
</rss>
