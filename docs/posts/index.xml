<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>文章列表 on polarisxu</title>
		<link>https://polarisxu.studygolang.com/posts/</link>
		<description>Recent content in 文章列表 on polarisxu</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en</language>
		<copyright>本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，转载请注明 polarisxu 和出处链接。</copyright>
		<lastBuildDate>Thu, 29 Oct 2020 21:40:00 +0800</lastBuildDate>
		<atom:link href="https://polarisxu.studygolang.com/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>AI 和 数据科学领域，Go 语言可能很快会取代 Python。最后的原因有点迷</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/golang-ai-programming-language/</link>
			<pubDate>Thu, 29 Oct 2020 21:40:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/golang-ai-programming-language/</guid>
			<description>30 年前，Python 首次出现。但是花了 20 年时间才能获得开发人员的赏识。快进到 2019 年，它成为开发人员中第二受欢迎的语言。（来自 Stackoverflow 开发人员 2019 调查结</description>
			<content type="html"><![CDATA[<p>30 年前，Python 首次出现。但是花了 20 年时间才能获得开发人员的赏识。快进到 2019 年，它成为开发人员中第二受欢迎的语言。（来自 <a href="https://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted" target="_blank" rel="noopener">Stackoverflow 开发人员 2019 调查结果</a>
）</p>
<p>过去，尤其是在过去的 5 年中，它的增长是巨大的。Python 成为机器学习和数据科学开发人员的首选语言。</p>
<p>在接下来的几年中，Python 在这些领域的主导地位无疑会持续。但是与更新的语言相比，它具有一些严重的缺点。对于 21 实际 20 年代的开发者来说，这可能是一个障碍。</p>
<p>现在是检查 Python 问题并将其替换为更好的替代方法的正确时机。就 AI 开发和数据科学而言，我们的下一个入门语言可能是 Golang。</p>
<h2 id="python-受欢迎的原因">Python 受欢迎的原因</h2>
<p>Python 受欢迎的主要原因是：它易于学习。与其他语言相比，它的语法很简单，任何人都可以在几小时或几天内学习 Python 的基础知识。</p>
<p>即使在学习了其他语言（例如 C++ 或 Java）之后，开发人员通常还是更喜欢使用 Python。那是因为有一个 Python 库，几乎可以满足所有人的要求。</p>
<p>库和简单的语法使使用 Python 开发软件既简单又高效。这些优势使 Python 成为了初学者的语言。</p>
<h2 id="python-问题">Python 问题</h2>
<h3 id="速度">速度</h3>
<p>Python 是一种解释型语言，这会引起 Python 的最大问题：执行缓慢。与其他编译语言（例如 C++ 和 Go）相比，Python 的执行速度很慢，非常慢。</p>
<p>Python 是一种动态类型的语言。在运行期间会自动分配变量的数据类型。这使执行速度大大降低。</p>
<h3 id="使用-cc">使用 C/C++</h3>
<p>为了克服 Python 运行慢的缺点，Tensorflow，Numpy 和 Pandas 之类的库部分用 C 或 C++ 编写。它们有助于显著提高执行速度。</p>
<p>基本上，Python 需要其他语言的帮助才能克服其问题。</p>
<h3 id="全局解释器锁global-interpreter-lock">全局解释器锁（Global Interpreter Lock）</h3>
<p>Python 的<a href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener">全局解释器锁</a>
（GIL）一次只能执行一个线程，同时提高了单线程性能。Python 的多线程并没有真正让多个线程同时运行。</p>
<p>实际上，Python 无法执行真正的多线程。</p>
<p>（注意：Python 的非 CPython 实现（例如 Jython 和 IronPython 没有 GIL））</p>
<h2 id="为什么要使用-go-语言">为什么要使用 Go 语言？</h2>
<blockquote>
<p>Go 是一种开放源代码编程语言，可轻松构建，简单，可靠和高效。</p>
</blockquote>
<p>“ Go” 在 10 年前首次亮相。它是 Google 开发的通用性编程语言。</p>
<p>与 Python 和其他编程语言相比，它具有多个优势，这就是我们感兴趣的原因。</p>
<h3 id="快速">快速</h3>
<p>Go 是静态类型化和编译的语言。这意味着执行速度将比 Python 快几倍。与 Python 不同，Go 不需要其他语言的帮助就可以更快。</p>
<p>这是 Go 和 Python 之间的一个<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-python3.html" target="_blank" rel="noopener">小型基准测试游戏比较</a>
。Go 几乎与 C++ 和 Java 一样快。而且，Go 的代码编译速度比 C+C 和 Java 快得多。</p>
<h3 id="简单易学">简单易学</h3>
<p>Go 的语法很简单，类似于 C。它是一种易于学习的编程语言，特别是已经了解 C 或 Java 语言的基础知识。</p>
<p>要了解 Go 的基础知识，请访问 <a href="http://tour.studygolang.com/welcome/1" target="_blank" rel="noopener">Go 指南</a>
 进行交互式之旅或访问<a href="https://docs.studygolang.com/doc/" target="_blank" rel="noopener">官方文档</a>
。</p>
<h3 id="越来越受欢迎">越来越受欢迎</h3>
<p>根据此次 Hackearth 对来自 76 个国家/地区的 16,000 多名开发人员的<a href="https://www.hackerearth.com/recruit/developer-survey/" target="_blank" rel="noopener">调查</a>
，Go 是 2020 年最受欢迎的编程语言。</p>
<p>32％ 的经验丰富的开发人员和 29％ 的学生说他们想学习 Go 不足为奇。</p>
<p><p class="md__image">
  <img src="../imgs/go-for-ai-ds.png"
    alt=""  />
</p>
</p>
<h3 id="并发">并发</h3>
<p>并发是 Go 的主要优势之一。Go 具有 <a href="http://tour.studygolang.com/concurrency/1" target="_blank" rel="noopener">Goroutines</a>
 以实现并发。Goroutines 是可以同时独立运行的函数。</p>
<p>Goroutine 重量轻，仅占用 2KB（依赖于不同实现，目前 Go1.15 是 2KB） 的内存。由于 Goroutine 轻巧，因此可以同时运行成千上万个。</p>
<p>Goroutine 还有很多其他优点，比如：</p>
<ul>
<li>Goroutine 具有可增长的分段堆栈。这意味着它们仅在需要时才使用更多的内存。</li>
<li>Goroutine 具有比线程更快的启动时间。</li>
<li>Goroutine 带有内置原语，以在它们自己（通道）之间安全地通信。</li>
<li>使用 Goroutines 可以避免共享数据结构时不得不使用互斥锁。</li>
<li>此外，goroutine 和 OS 线程没有 1:1 映射。一个 goroutine 可以在多个线程上运行。 Goroutines 被多路复用到少量的 OS 线程中。</li>
</ul>
<p>参考文章：<a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65" target="_blank" rel="noopener">为什么要学习 Go？</a>
。</p>
<h2 id="是什么使-go-适用于-ai-研究">是什么使 Go 适用于 AI 研究</h2>
<p>将 Go 专门用于 AI 研究或数据科学并没有什么特别的。为什么应将 Go 用于 AI 和数据科学？我会告诉你的&hellip;但是等一下。</p>
<p>30 年前，尚未开发 Python 来构建机器学习或深度学习算法或进行数据可视化。</p>
<p>之所以是今天，是因为开发人员和学生们喜欢用 Python 进行代码编写，并且支持<em>开发该开发人员意图</em>的语言。</p>
<p>Go 旨在提高程序员的生产力。与 Python 相比，它具有多个优点。它很可能会在未来几年中成功取代 Python，成为最受欢迎的语言。</p>
<p>因此，它可以归结为 1 行：</p>
<p><strong>Go 可以支持 “21 世纪 20 年代的开发人员”发展他们的思想，这比任何其他语言都要好得多。</strong></p>
<blockquote>
<p>原文链接：<a href="https://towardsdatascience.com/golang-ai-programming-language-for-the-20s-71890baa8c47">https://towardsdatascience.com/golang-ai-programming-language-for-the-20s-71890baa8c47</a></p>
<p>本文作者：Dasaradh Saran</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>闲聊昨晚极客时间的直播</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/talk-geek-time-live/</link>
			<pubDate>Mon, 26 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/talk-geek-time-live/</guid>
			<description>昨天晚上（10 月 25 日）极客时间进行了一场直播，主题是：《未来 5 年将是 Go 语言的天下》。 客观说，这个主题还是挺唬人的，而直播的内容跟这个主题关系</description>
			<content type="html"><![CDATA[<p>昨天晚上（10 月 25 日）极客时间进行了一场直播，主题是：《未来 5 年将是 Go 语言的天下》。</p>
<p>客观说，这个主题还是挺唬人的，而直播的内容跟这个主题关系不大。有三个嘉宾，只有左耳朵耗子谈了 Go 的未来，他的判断，Go 会成为主流，只会 PHP 肯定行不通。</p>
<p>在提问环节，有人问到耗子哥关于 Python 的看法，他直言：Python 会成为新手语言。不管你认不认同，耗子哥的一些观点还是有一定道理的。</p>
<p>耗子哥的部分，我只听了结尾一点。另外两位的分享，我都听完了。简单聊聊。</p>
<h2 id="01-go-在字节跳动的地位">01 Go 在字节跳动的地位</h2>
<p>秦岩老师 PPT 第一页：</p>
<p><p class="md__image">
  <img src="../imgs/geektime01.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>提到的文章地址：<a href="https://www.infoq.cn/article/fEa7CHf9MOohbxbTYReS">https://www.infoq.cn/article/fEa7CHf9MOohbxbTYReS</a></p>
</blockquote>
<p>据我了解，字节当前后端服务超过 80% 的流量是跑在 Go 构建的服务上。高峰 QPS 超过 700 万，日处理请求量超过3000 亿，是业内最大规模的 Go 应用。</p>
<p>对于 Go 爱好者来说，如果能够进入字节跳动，在项目中进行历练，自己上进，相信 Go 水平会有一个质的提升；而应届生，我个人也强烈建议努力朝着进入字节跳动努力。</p>
<p><p class="md__image">
  <img src="../imgs/geektime02.png"
    alt=""  />
</p>
</p>
<p>如上图，Go 在这样量级的公司占据第一使用率，无论从哪方面讲，对 Go 来说都是巨大的成功，也证明了 Go 的可靠性。</p>
<h2 id="02-直播的故障">02 直播的故障</h2>
<p>抖音的老师刚开个头，突然直播故障了，持续了几分钟。</p>
<p>大家的吐槽来了：</p>
<p><p class="md__image">
  <img src="../imgs/geektime03.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/geektime04.png"
    alt=""  />
</p>
</p>
<p>秦岩老师是负责抖音、直播稳定性的，他一来不稳定了？！</p>
<p>对于这个突发的故障，不用太较真，各种系统应该常遇到。正式因为这样那样的故障，催生出各种应对办法，各种高可用、稳定性架构。</p>
<p>对此，我想说的是，如果你一直在一个小公司，没有大流量，很多问题你是没法遇到的，这些问题只学理论是不够的。你写的代码，你的架构，可能在你的公司运行的很好，但只要流量一大，他们可能就崩溃了。一定阶段，技术的提升，需要环境、需要大项目、大流量的历练。又回到那句话：趁年轻，能进大厂，一定要到大厂去历练，现在能力不够，恶补下，朝着大厂的目标去努力。</p>
<h2 id="03-毛剑老师的分享">03 毛剑老师的分享</h2>
<p>毛剑老师这次主要站在面试官的角度分享大厂面试 Go 工程师更看重哪些能力。他提到了软实力、硬实力，以及他喜欢问候选人哪些题。</p>
<p>这方面，每个人的喜好不一样，有些面试官喜欢问这个，有些喜欢问那个。就技术能力来说，大厂一般会有规范的流程，有些可能有面试考察能力的要求。所以，除了 Go 语言本身使用掌握外，还需要对核心的一些设计有所了解。比如调度、内存、并发等，此外服务端相关的其他技能，也是必须掌握的。</p>
<p>对此，我个人的看法：</p>
<ul>
<li>根据职位不同，可能侧重点不一样；不同公司、不同部门，面试的喜好也会有所区别，需要有针对性的准备；</li>
<li>Go 语言本身的基本功，底层的一些实现，作为一个 Gopher，你应该不断探索；</li>
<li>操作系统、网络、数据库、缓存等服务端相关的技能得不断加深；</li>
<li>适当刷刷题，比如 LeetCode；手写代码也可以练练。比如字节面试都会让手写代码；</li>
</ul>
<h2 id="04-未来-5-年将是-go-语言的天下">04 未来 5 年将是 Go 语言的天下？</h2>
<p>这个定义有点夸张，但 Go 确实受到越来越多的关注。别的不说，很多 PHPer 都在学习 Go。从我的网站：https://studygolang.com 流量看，这些年上升还是挺厉害的。</p>
<p>一直以来，国内的技术和国外是不太一样的。Go 语言也很明显，在国内的热度明显高于国外。因为有字节跳动、腾讯（据说 Go 在腾讯今年有望成为第二大编程语言，去年是第三大）、滴滴、B 站等大厂的大规模使用（圈内人应该发现，曾经 PHP 一统天下的好未来，这段时间也是各种 Go），Go 必然会受到越来越多的关注。从目前在线教育对 Go 的投入来看，他们也看到了 Go 的潜力。所以，我看好 Go，你呢？！</p>
]]></content>
		</item>
		
		<item>
			<title>Go error 打印灾难 —  CockroachDB errors 库（第3篇）</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-error-printing-catastrophe/</link>
			<pubDate>Mon, 26 Oct 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-error-printing-catastrophe/</guid>
			<description>这篇文章是关于 “CockroachDB errors 库” 的系列文章的第 3 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</description>
			<content type="html"><![CDATA[<p>这篇文章是关于 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">“CockroachDB errors 库”</a>
的系列文章的第 3 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</p>
<p>Go 1.13 的标准库采用了 Dave Cheney 自 2015 年以来对错误处理的主要贡献：将 Go 错误对象构造为链表的想法。 唉，这种方式给 Go 开发人员造成了巨大的障碍：使打印错误对象变得困难、几乎不可能。</p>
<p>这就是我所说的 “Go error 打印灾难&quot;，下面我们将准确地看到它是什么。</p>
<h2 id="提醒go-错误为什么是链表怎么做的">提醒：Go 错误为什么是链表，怎么做的</h2>
<p>Go 的错误 API，从 v1.13 开始，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// error is a pre-defined type.
</span><span class="c1"></span><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
   <span class="c1">// Error returns an error&#39;s short message string.
</span><span class="c1"></span>   <span class="c1">// This is used e.g. when formatting an error with %s/%v.
</span><span class="c1"></span>   <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// wrapper can be implemented by additional error
</span><span class="c1">// “layers”, to decorate an error. This interface
</span><span class="c1">// is not pre-defined in the language but should be
</span><span class="c1">// implemented by API-conformant error decorators.
</span><span class="c1">//
</span><span class="c1">// This is the interface that powers the error identification
</span><span class="c1">// facilities errors.Is() and errors.As().
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">wrapper</span> <span class="kd">interface</span> <span class="p">{</span>
   <span class="c1">// Unwrap accesses the next layer in the error object.
</span><span class="c1"></span>   <span class="c1">// This used to be called “Cause” in Dave Cheney&#39;s
</span><span class="c1"></span>   <span class="c1">// pkg/errors library.
</span><span class="c1"></span>   <span class="nf">Unwrap</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>使用此 API，Go 生态系统中的代码可以通过两种方式构造 error 对象：</p>
<ul>
<li>使用类似 fmt.Errorf() 或 errors.New() 构造&quot;叶”错误；</li>
<li>使用修饰层 &ldquo;包装&rdquo; 错误，例如使用 errors.Wrap() 为错误增加前缀信息，errors.WithStack() 附加堆栈跟踪或使用 %w 动词的 fmt.Errorf() ，这是 1.13 新增的：<code>err = fmt.Errorf(&quot;some context: %w&quot;, err)</code></li>
<li>包装类型通过实现 Unwrap() 方法来声明其&quot;剥离&quot;的能力。这是由 Go 的标准库检查和使用的，特别是 errors.Is()，它可以通过查看所有中间层来识别错误是否为特定类型的错误。</li>
</ul>
<p>抽象的链表使得使用来自不相关的 Go 包的修饰类型将修饰附加到任何错误对象成为可能。通过将层之间的关系定义为”只是 error&quot;，没有包依赖项，也不会有循环导入的问题。它还使得可以跨不同的项目分离装饰器/包装器的开发，同时保持互操作性。</p>
<p>有关这个主题的详细信息，请阅读本系列中的上一篇文章：<a href="https://dr-knz.net/cockroachdb-errors-std-api.html" target="_blank" rel="noopener">Go 标准错误 API</a>
。</p>
<h2 id="提醒go-的格式化设施">提醒：Go 的格式化设施</h2>
<p>Go 库中最常用的、功能最全的打印设施是标准 fmt 包。它包含格式化各种 Go 为字符串，或输出到文件、buffer、终端。</p>
<p>例如 fmt.Println(v) 将 v 的值打印到终端。</p>
<p>fmt 中的大多数打印函数共享基础逻辑，为更强大的 Printf() API 提供支持。Printf() 使用格式字符串和变量参数列表，并显示根据格式的参数。这直接派生自 C 中类似的<a href="https://en.wikipedia.org/wiki/C_file_input/output" target="_blank" rel="noopener">标准 API</a>
。</p>
<p>Go 的 fmt 可以打印任意数据类型，但 C 的 stdio 不能。</p>
<p>这是使用预定义逻辑的组合来处理 Go 自己的基本类型，能智能递归地打印结构类型、指针和数组类型，以及自定义类型：fmt 尝试在传递给 Print 样式函数的值上使用四个接口。</p>
<ul>
<li>fmt .Formatter 接口定义了 Format(…) 方法，可以通过实现该方法以完全覆盖格式。</li>
<li>如果 fmt.Formatter 不存在，然后 fmt 会识别预定义的 error 接口。在这种情况下，它调用 Error() 方法并打印该方法。</li>
<li>如果 fmt.Formatter 或 error 都不可用，则根据使用的格式动词，自定义类型可以实现 fmt.Stringer（一个 String() 方法）或 fmt.GoStringer（一个 GoString() 方法）用于驱动更简单、不太灵活的格式输出。</li>
</ul>
<p>只有当这些接口都未实现时，fmt 才回退到使用其预定义逻辑。</p>
<p>有关本主题的详细信息，请阅读本系列中的上一篇文章：<a href="https://dr-knz.net/go-formatting-apis.html" target="_blank" rel="noopener">Go 的格式化 API。</a>
</p>
<h2 id="提醒error-的简单打印">提醒：error 的简单打印</h2>
<p>fmt 检测 error 参数并自动调用 Error() 方法。这工作得很好，即使对于包装错误：Error() 在最外层的包装器（链接列表的头部）上调用。因此，该包装器的 Error() 实现可以覆盖其尾部图层的错误。</p>
<p>例如：</p>
<ul>
<li><code>errors.New(&quot;world&quot;).Error()</code> 返回 <code>world</code>。</li>
<li><code>errors.Wrap(errors.New(&quot;world&quot;), &quot;hello&quot;)</code> 返回 <code>hello: world</code>。</li>
<li>同上，<code>fmt.Errorf(&quot;hello %w&quot;, errors.New(&quot;world&quot;))</code> 也构造了一个包装错误。</li>
</ul>
<p>这样，当将错误传递到 fmt 时，我们会自动获得自然的&quot;更长&quot;，&ldquo;更完整”的 Error() 结果。</p>
<p>一切似乎都很好，而且自从 Go v1.0 以来一直很好，但是详细的打印又如何呢？</p>
<h2 id="提醒详细的打印模式">提醒：详细的打印模式</h2>
<p>当使用 %+v 格式参数时，fmt 内部逻辑将采用&quot;详细&quot;模式，以显示参数列表中的相应值。默认情况下，详细模式会触发例如在结构类型中显示字段名称。</p>
<p>例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">a</span> <span class="kt">int</span> <span class="p">}{</span><span class="mi">123</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>  <span class="c1">// prints {123}
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="c1">// verbose mode: prints {a:123}
</span></code></pre></div><p>&ldquo;详细模式”的定义有一个新的抽象：某些数据在常见情况下不可见，但可根据请求变为可见。</p>
<p>这在进行 “printf debugging” 或事件日志记录时非常有用，因为查看调试或日志记录输出是给专业用户查看的，可以查看比程序常规输出中显示更多的信息。</p>
<p>自定义类型只能通过实现 fmt.Formatter 接口来自定义详细模式的输出。formatter 接口。只有该接口的 Format() 方法能获取有关是否请求详细模式的信息。fmt 包的其他接口不够强大。</p>
<p>特别是，error 接口和隐式 wrapper 接口都没有为错误类型提供一种自定义 fmt 中显示方式的方法。</p>
<h2 id="详细打印-go-错误的可取之处">详细打印 Go 错误的可取之处</h2>
<p>除了调用 Error() 方法提供的简单模式外，Go 生态系统还构建了单独的详细模式来打印错误对象的需求。</p>
<p>例如，Dave Cheney 的 pkg/errors 包和 CockroachDB 的 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">errors</a>
 库都会自动在错误对象中嵌入堆栈跟踪。此堆栈跟踪不会出现在 Error() 的输出中，因此在简单模式下打印错误对象时不包括此堆栈跟踪。当程序遇到错误，发现自己无法令人满意地处理它时，程序员可以使用 %+v 进入详细模式以查看堆栈跟踪。这有助于了解错误的来源和在程序中的位置。</p>
<p>此外，程序可以选择使用错误包装器将不是错误消息的控制信息嵌入到程序中，例如，指示调用方函数中错误处理期间应执行操作的特殊数字代码。调用方函数可以使用标准 API errors.As() 从错误链接链表中提取此数据。</p>
<p>如果程序员在排除的疑难 Bug 时想要可视化此信息，该信息不包括在 Error() 的输出中，怎么办？同样，将此信息输出为&quot;详细模式”的一部分，似乎这是一种自然的选择。</p>
<p>不幸的是，实现这个目标是相当困难的。</p>
<h2 id="基本缺陷-1在包装器中无法自定义">基本缺陷 1：在包装器中无法自定义</h2>
<p>我们试验和设计自己的错误类型，其中一些隐藏的信息只在详细模式下显示。我们可以这样做，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myError</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">msg</span> <span class="kt">string</span> <span class="c1">// public message
</span><span class="c1"></span>   <span class="nx">code</span> <span class="kt">int</span> <span class="c1">// hidden code
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Error implements the error interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>

<span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myError</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">verb</span> <span class="o">==</span> <span class="sc">&#39;v&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Verbose mode.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;(code: %d) %s&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">code</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>说明：当我们用 %v 打印 <code>*myError</code> 的实例时，我们得到 msg 的值；使用 %+v 时，我们得到相同的内容，但有前缀 (code: NNN)  和字段 code 的值。</p>
<p>精明的读者可能会注意到此代码看起来不完整，因为它不处理 %q 等格式动词。这在本节中不直接相关，因此我们暂时忽略它。</p>
<p>除了最后一点， 代码似乎工作正常？</p>
<p>唉！</p>
<p>尝试以下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">myError</span><span class="p">{</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">123</span><span class="p">}</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;wazaa: %w&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>         <span class="c1">// simple mode: prints just &#34;wazaa: hello&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// verbose: prints... what?
</span></code></pre></div><p>我们希望本示例中的代码打印 <code>zawaa: (code: 213) hello</code>。不幸的是，它不是：由 fmt.Errorf 返回的错误类型，fmt.Formatter 接口不起作用。因此，使用 fmt.Errorf 时，myError 中的自定义信息丢失了！</p>
<p>换句话说，在 “标准 Go” 中，通过 <code>Unwrap()</code> 方法创建良好的包装错误类型还不够；因此，在&quot;标准 Go&quot;中创建成形良好的错误包装类型是不够的。还必须实现适当的 Format() 方法，在包装错误中，通过 fmt.Formatter  处理任何可能的自定义格式。</p>
<p>这样有两个主要问题：</p>
<ul>
<li>有一点很明确：必须实现 Format() 方法，即使自定义包装不需要自定义格式，以免 fmt.Formatter 接口对于所有参与者都毫无用处。</li>
<li>Go 库中没有文档说明此问题。所以大家根本不了解也不知道。实际上，粗略的检查显示，Go 生态系统中的许多自定义错误包装器类型均未实现 Format()，因此会在其 “尾巴” 中破坏格式自定义。</li>
</ul>
<h2 id="基本缺陷-2转发forwarding-fmtformatter-的困难">基本缺陷 2：转发（forwarding） fmt.Formatter 的困难</h2>
<p>如果我们愿意支付抽象税，并同意所有包装错误类型也将实现 fmt.Formatter，那又会这样？怎么会这样呢？</p>
<p>作为支持示例，让我们尝试一个非常简单的包装，它没有任何特殊功能：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myWrapper</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">cause</span> <span class="kt">error</span> <span class="c1">// tail of linked list
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Error implements the error interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span> <span class="p">}</span>

<span class="c1">// Unwrap implements the unwrap interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Unwrap</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span> <span class="p">}</span>
</code></pre></div><p>然后，我们可以开始实现 fmt.Formatter。至少，它应该区分冗长和非冗长模式。</p>
<p>但是，如果我们不确定错误原因（error cause）是否实际实现 fmt.Formatter？也许没有。因此，为了减少的惊讶，我们需要做&quot;与 fmt 相同的一些事&rdquo;。实现此目的的最佳方法是调用 fmt 本身逻辑：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">verb</span> <span class="o">==</span> <span class="sc">&#39;v&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Verbose mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself verbosely.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;%+v&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Simple mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself simply.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这是一个繁琐的模式，只是为了确保 e. cause 得到打印。</p>
<p>此外，如果 e.cause 想要了解有关原始格式的信息，那该内容会如何呢？如果与 %#v 一起使用时，使用 #v？还是 %#+v？还是 %q？</p>
<p>遗憾的是，fmt 中没有标准 API 来正确将所有状态转发到递归调用。自 Go 1.15 起，将所有格式状态（formatting state）完全转发到错误原因而不打印任何其他内容的代码量最低如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">f</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Builder</span>
    <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;%&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">wp</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Width</span><span class="p">();</span> <span class="nx">wp</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">w</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">pp</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Precision</span><span class="p">();</span> <span class="nx">pp</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">)</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="nx">f</span><span class="p">.</span><span class="nf">WriteRune</span><span class="p">(</span><span class="nx">verb</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这看起来非常不方便，容易出错。</p>
<p>即使是 Dave Cheney 的 pkg/errors 包也没有做到这一点，它仅在包装器中按如下方式实现 Format()，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">withMessage</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">verb</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;v&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Cause</span><span class="p">())</span>
            <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="k">fallthrough</span>
    <span class="k">case</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="sc">&#39;q&#39;</span><span class="p">:</span>
        <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>此代码对于谓词 %q 不正确，同时完全省略其他格式标记（如 %#v 等），并且无法识别除 v、s 或 q 以外的任何谓词。</p>
<p>在 Go 生态系统中探索发现，很少有自定义错误包装类型实现 Format()。</p>
<p>实现适当的自定义 Format()， 以及没有预定义 （也不建议） 机制在 fmt 中转发 Format() 调用这一事实是如此困难，这是 Go 标准库的基本限制。</p>
<p>（安利：上面的正确代码的副本可作为可重用的 fmtfwd.MakeFormat() 函数，在 <a href="https://github.com/knz/go-fmtfwd" target="_blank" rel="noopener">go-mtfwd</a>
 包中。然而，这不是万能药。）</p>
<h2 id="基本缺陷-3不更改-api-无法修复的问题">基本缺陷 3：不更改 API 无法修复的问题</h2>
<p>Go 的团队称自己构建的语言可以最大限度地保持向后兼容性。标准库的添加是通过引入或替换功能，但不会影响现有代码的语义。</p>
<p>在这种情况下，Go 开发人员可以做什么来&quot;修复&quot;上面确定的问题，而不破坏现有的 error 代码，也不需要现有包添加&quot;缺失&quot;的粘附代码，如缺少的 Format() 转发器？</p>
<p>事实证明，在 fmt 包中可以直接做的工作不多。</p>
<p>在高级别上，不可能的任务是确保错误链中的所有细节以详细模式打印，同时考虑 Format() 方法中的自定义行为。</p>
<p>由于不是链中的每一个错误都提供 Format() 方法，因此 fmt 代码需要使用 Unwrap() 方法迭代自身。然后在每个层上都需要打印&hellip;东西。但究竟是什么？</p>
<ul>
<li>它无法调用 Error()，因为包装器上的 Error() 本身将递归，并获取链中其他层的字符串片段；</li>
<li>它无法调用 Format()，因为包装器上的 Format() 已经（根据当前生态系统）对错误原因递归递处理。</li>
</ul>
<p>因为 fmt.Formatter 接口 Format() 方法的第一个参数 fmt.State，是一个接口类型，因此实际在 fmt 中会是一个特定的 State 实例，可以&quot;分离&quot;当前错误层内的直接打印，从进一步递归执行打印。</p>
<p>例如，如下 Format() 实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">verb</span> <span class="o">==</span> <span class="sc">&#39;v&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Verbose mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself verbosely.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;(code %d) %+v&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">code</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Simple mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself simply.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>通过此代码可见，在 Format 内部调用的 fmt.Fprintf 或 fmt.Fprint 的第一参数是 fmt.State 的实例，这是 fmt 包负责注入的。简单字符串和非错误值可以传递，每次看到错误值时，它都会被”忽略”，以便外部 fmt 循环可以转到下一层，而不会重复输出。</p>
<p>这个想法的问题， 要知晓 Format() 方法中是怎么使用 fmt.State 的。它不适用于实现以下函数的软件包：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">withMessage</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">verb</span> <span class="p">{</span>
        <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">case</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="sc">&#39;q&#39;</span><span class="p">:</span>
        <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>（这个例子来自 pkg/errors）。</p>
<p>请注意，与 Go 生态系统中的许多其他实现一样，此实现也挫败了我们的想法：某些打印使用 fmt.State 的 io.Writer 子接口并将 <code>.Error()</code> 字符串直接传递给它。当包装器的 Format() 正在打印下一层错误时，无法可靠地从 fmt.State 中进行检测，从而捕获该错误以执行其他操作。</p>
<p>因此，Go 生态系统中“将错误作为链接列表”的集成与 fmt.Formatter 抽象发生冲突，并创建了一个坑，社区中的每个人都陷入困境，而 Go 标准库无法帮助任何人在 fmt 中使用魔术。</p>
<h2 id="也许是救星pre-113-xerrors">也许是救星：pre-1.13 xerrors</h2>
<p>在进行 Go 1.13 的工作中，2017 年成立了一个工作组，研究采用“错误作为链接列表”的方法，并基本上接管了 Dave Cheney 在 pkg/errors 中的工作。</p>
<p>这就是由 Jonathan Amsterdam，Russ Cox，Marcel van Lohuizen 和 Damien Neil 组成的小组开始开发 <a href="https://github.com/golang/xerrors" target="_blank" rel="noopener">xerrors</a>
 包，以作为新抽象的原型和研究依据。</p>
<p>这项工作指导作者提出了一些建议：</p>
<ul>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/go2draft-error-printing.md" target="_blank" rel="noopener">Marcel van Lohuizen: Error Printing — Draft Design</a>
 (August 2018)</li>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/29934-error-values.md" target="_blank" rel="noopener">Jonathan Amsterdam, Russ Cox, Marcel van Lohuizen, Damien Neil: Proposal: Go 2 Error Inspection</a>
 (January 2019)</li>
</ul>
<p>他们的工作主要集中在 Unwrap() 的语义以及新 API error.Is() 和 errors.As() 的创建上，以可靠地从错误对象中识别和提取信息。</p>
<p>Marcel van Lohuizen 更加关注错误处理的打印方面，并设计了以下提案：</p>
<ul>
<li>
<p>除了 fmt.Formatter，error，fmt.Stringer 和 fmt.GoStringer 外，fmt 包支持一个新接口：errors.Formatter。</p>
</li>
<li>
<p>新接口将通过错误包装和叶类型实现。</p>
</li>
<li>
<p>提议的接口如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">errors</span>
  
<span class="kd">type</span> <span class="nx">Formatter</span> <span class="p">{</span>
     <span class="kt">error</span>
  
     <span class="c1">// FormatError can be implemented to customize the formatting
</span><span class="c1"></span>     <span class="c1">// of errors, instead of fmt.Formatter&#39;s Format.
</span><span class="c1"></span>     <span class="c1">//
</span><span class="c1"></span>     <span class="c1">// It has access to an errors.Printer (see below)
</span><span class="c1"></span>     <span class="c1">// to actually produce output.
</span><span class="c1"></span>     <span class="c1">//
</span><span class="c1"></span>     <span class="c1">// In the common case, the code in FormatError details
</span><span class="c1"></span>     <span class="c1">// the current layer and returns the next error layer
</span><span class="c1"></span>     <span class="c1">// to print, or `nil` to indicate the tail of the
</span><span class="c1"></span>     <span class="c1">// linked list has been reached.
</span><span class="c1"></span>     <span class="c1">//
</span><span class="c1"></span>     <span class="c1">// Optionally, the code for a wrapper&#39;s FormatError
</span><span class="c1"></span>     <span class="c1">// can take over formatting of both itself *and all
</span><span class="c1"></span>     <span class="c1">// subsequent layers* by producing its custom
</span><span class="c1"></span>     <span class="c1">// representation for all and then returning `nil`,
</span><span class="c1"></span>     <span class="c1">// even though its Unwrap() method is still used
</span><span class="c1"></span>     <span class="c1">// by errors.Is() to iterate through the tail.
</span><span class="c1"></span>     <span class="nf">FormatError</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Printer</span><span class="p">)</span> <span class="p">(</span><span class="nx">next</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
  
<span class="kd">type</span> <span class="nx">Printer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1">// can be used to output stuff
</span><span class="c1"></span>    <span class="nf">Printf</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1">// can be used to output stuff
</span><span class="c1"></span>  
    <span class="c1">// Detail is a “magic” predicate which both indicates whether
</span><span class="c1"></span>    <span class="c1">// verbose mode is requested via %+v, and also starts indenting
</span><span class="c1"></span>    <span class="c1">// the output performed by subsequent Print()/Printf() calls in
</span><span class="c1"></span>    <span class="c1">// the interface, so that the details are visually “pushed to
</span><span class="c1"></span>    <span class="c1">// the right”.
</span><span class="c1"></span>    <span class="nf">Detail</span><span class="p">()</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<p>一个示例用法如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// FormatError implements the errors.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">FormatError</span><span class="p">(</span><span class="nx">p</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">Printer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;always&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Detail</span><span class="p">()</span> <span class="p">{</span>
       <span class="nx">p</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;hidden: &#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">code</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span>
<span class="p">}</span>
</code></pre></div><p>使用此代码，我们将得到以下行为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">myWrapper</span><span class="p">{</span><span class="nx">cause</span><span class="p">:</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">code</span><span class="p">:</span> <span class="mi">123</span><span class="p">}</span>
<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">myWrapper</span><span class="p">{</span><span class="nx">cause</span><span class="p">:</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">code</span><span class="p">:</span> <span class="mi">456</span><span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// simple mode: prints &#34;always: always: hello&#34;
</span><span class="c1"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="c1">// prints:
</span><span class="c1">//
</span><span class="c1">//   always:
</span><span class="c1">//      hidden: 456
</span><span class="c1">//   always:
</span><span class="c1">//      hidden: 123
</span><span class="c1">//   hello
</span></code></pre></div><p>（请注意一些特性：错误是从最外层/头部到最内层/尾部打印的，并且在每个前缀之后，细节之前插入了冒号）。</p>
<p>因此，将 fmt 代码修改为使用新接口的方式是：</p>
<ol>
<li>检测 Format() 方法是否可用。如果是这样，它被调用，结束。</li>
<li>否则，如果要打印的对象是错误，它将对其进行迭代：调用 FormatError()（如果存在）并使用其返回值作为下一次迭代的输入进行迭代。</li>
<li>当错误对象上不存在 FormatError() 或返回 nil 时，迭代将停止。</li>
<li>如果在迭代结束时仍有 Format() 或 Error() 方法可供调用，则将调用该方法以“完成”格式化。</li>
</ol>
<p>xerror 原型能够集中精力仅格式化一层包装器，而又不知道如何正确地将 Format() 调用转发给其他层。</p>
<p>因此，这是解决上述第二个基本限制的尝试。</p>
<p>哎，它根本无法解决第一个基本限制：如果包装层未实现 FormatError()，则 fmt 代码将仅停止在该级别尝试，并且在错误中进一步进行任何 FormatError() 或 Format() 定制链会被丢弃。</p>
<p>此外，许多人不喜欢“从前到后”打印错误的方式：在对错误详细信息进行故障排除时，开发人员发现重要是首先显示链接列表的“最内层”（尾部），然后才是“最外层”（头）。 xerrors 实现不允许这样做。</p>
<p>最后，无论如何，所有讨论都是没有争议的：没有选择将 xerror 打印抽象（包括 errors.Formatter，errors.Printer 和相应的 fmt 更改）包含在 Go 1.13 中。从 Go 1.16 开始，<a href="https://github.com/golang/go/issues/29934#issuecomment-591488854" target="_blank" rel="noopener">朝着这个方向进行的任何进一步工作都被推迟</a>
，具体另行通知。</p>
<h2 id="战略失误打破与pkgerrors-的兼容性">战略失误：打破与pkg/errors 的兼容性</h2>
<p>依赖于 Dave Cheney 的 pkg/errors 的社区项目超过 50,000 个，该软件包已成为事实上的扩展，能够提供错误包装程序的基本库，并作为错误打印自定义示例，尽管不完善。</p>
<p>甚至有一个扩展的生态系统，它依靠基本的链表抽象，使用一种名为 Cause() 的方法来接受链中的下一个层次。</p>
<p>Go 团队可能已经接受了这种方法，并且可以在“所有错误包装程序都必须以类似于 pkg/errors 的方式实现 Format”的方式进行区分。然后，errors.Is()/errors.As() 可能选择了 pkg/errors 的 Cause() 抽象。</p>
<p>遗憾的是，Go 团队选择了不同的方法名称：Unwrap()。因此，Go 1.13 发布后开发的新一代错误包已无法重用 pkg/errors。</p>
<p>因此，1.13 不仅引入了基本限制；这也阻止了 Go 社区继续可靠地使用 pkg/errors。</p>
<h2 id="总结go-error-打印灾难">总结：Go error 打印灾难</h2>
<p>在 2019 年，Go 1.13 采纳了 Dave Cheney 的 2015 年建议，将错误对象视为链表。因此，对 Unwrap() 方法进行了标准化，并使用 Is() 和 As() 函数增强了错误包，这些函数可以从以这种方式构造的错误中可靠地提取信息。</p>
<p>不幸的是，fmt 软件包没有学习如何打印这种错误的新形状，并且可靠地自定义错误对象的显示已变得不可能。</p>
<p>这是因为与以前的版本一样，fmt 仅了解 Format()，Error() 和 String()，并且仅在错误链的顶端或“头”考虑这些方法。</p>
<p>如果一个包定义了自定义包装错误类型，但忘记定义了自定义 Format() 方法，则 fmt 将忽略链接列表“尾部”中的任何其他 Format() 方法，并且自定义项将丢失。</p>
<p>此外，只有 Format() 方法可以为“详细”和“简单”格式（％v /％+v）提供不同的实现。在实践中，以递归方式在错误链尾部调用进一步的自定义方式，几乎不可能实现包装错误的 Format()。</p>
<p>简而言之，错误打印的自定义变得容易出错，并且在 Go 1.13 中基本上不可靠。Go 1.13 中放弃了的关键 Cause() 接口，导致与另一个具有某些人们可以达成共识的逻辑的程序包 Dave Cheney 的 pkg/errors 不兼容。 Go 团队通过 xerrors 包来尝试修复 Go 标准库中的这种情况，实际上并没有成功解决这些问题，存在重大的新缺陷，最终不令人满意。</p>
<p>这就是我们程序员无所适从的方式。</p>
<p>这是 Go error 打印灾难，它的悬念留在 Go 1.16 中。</p>
<h2 id="接下来">接下来</h2>
<p>CockroachDB error 库在错误打印方面花费了大量精力。尽管它不能填补所有空白，但确实可以减轻很多的痛苦。</p>
<p>本系列的下一篇文章进一步说明。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">Dave Cheney: Don’t just check errors, handle them gracefully</a>
.</li>
<li><a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">The Go Blog: Working with errors in Go 1.13</a>
.</li>
<li><a href="https://github.com/golang/go/issues/29934" target="_blank" rel="noopener">Jonathan Amsterdam, et al: Go 2 error values</a>
.</li>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/go2draft-error-printing.md" target="_blank" rel="noopener">Marcel van Lohuizen: Error Printing — Draft Design</a>
.</li>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/29934-error-values.md" target="_blank" rel="noopener">Jonathan Amsterdam, Russ Cox, Marcel van Lohuizen, Damien Neil: Proposal: Go 2 Error Inspection</a>
.</li>
</ul>
<blockquote>
<p>原文链接：https://dr-knz.net/go-error-printing-catastrophe.html</p>
<p>本文作者：Raphael ‘kena’ Poss</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Go 格式化 API —  CockroachDB errors 库（第2篇）</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-formatting-apis/</link>
			<pubDate>Sat, 24 Oct 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-formatting-apis/</guid>
			<description>这篇文章是关于 “CockroachDB errors 库” 的系列文章的第 2 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</description>
			<content type="html"><![CDATA[<p>这篇文章是关于 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">“CockroachDB errors 库”</a>
的系列文章的第 2 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</p>
<p>以下面的代码为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">x</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">v</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="mi">123</span><span class="p">}</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这个程序打印 {123}，尽管我们没有教 Go 如何打印我们的 T 类型。它是如何做到这一点的？</p>
<h2 id="printer-的等效性">printer 的等效性</h2>
<p>fmt 包中的逻辑在所有 printer 之间共享，因此以下调用都保证等效：</p>
<ul>
<li><code>fmt.Print(x)</code></li>
<li><code>fmt.Printf(&quot;%v&quot;, x)</code></li>
<li><code>os.Stdout.Write([]byte(fmt.Sprint(x)))</code></li>
<li><code>os.Stdout.Write([]byte(fmt.Sprintf(&quot;%v&quot;, x)))</code></li>
</ul>
<p>换句话说，fmt.Print 的逻辑始终与将 Printf 与动词 %v 一起使用相同，前者实际使用后者作为实现。</p>
<p>同样，fmt.Println 使用 fmt.Print，外加 %v 动词，<code>fmt.Sprintln</code> 和 <code>fmt.Sprint</code> 是同样的道理。</p>
<h2 id="fmtstringer-和-fmtformatter">fmt.Stringer 和 fmt.Formatter</h2>
<p>现在，在上面的代码底部添加以下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
</code></pre></div><p>再次运行程序。会发生什么？它打印 <code>boo</code>。值 123 没有了。</p>
<p>这里发生的情况是，方法 String() 返回字符串实现了标准接口 fmt.Stringer，fmt 中的函数如果发现有它就会使用它。另外，尝试删除上面的 String() 函数定义，并将其替换为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>现在会发生什么？程序打印 <code>baa</code>。值 123 依然没有了。</p>
<p>如果这两个方法都可用怎么办？程序会打印 baa： fmt.Formatter 优先 fmt.Stringer。</p>
<p>当两个方法都不可用时，fmt 的逻辑会&quot;回&quot;在它自己的内部显示代码上，从而在表示值方面尽最大努力。</p>
<h2 id="fmt-对-error-知道多少">fmt 对 error 知道多少？</h2>
<p>Go 的标准 error 接口只提供返回字符串的 Error() 方法，而没有别的。</p>
<p>fmt 的逻辑知道 error，并知道如何使用其 Error() 方法，扩展上面解释的偏好规则：</p>
<ul>
<li>fmt.Formatter 优先级最高；</li>
<li>如果 fmt.Formatter 不存在，但是 error，则会使用 Error() 方法；</li>
<li>否则如果存在 fmt.Stringer，则使用它。</li>
</ul>
<h2 id="svq-和-xx-的关系">%s、%v、%q 和 %x/%X 的关系</h2>
<p>到目前为止，我们已经看到了，针对 %v 动词，fmt 的逻辑是如何可选地使用 fmt.Formatter、error 和 fmt.Stringer。</p>
<p>然而，在 Go 代码中使用的更常见的动词可能是 %s。%s 与 %v 的关系如何？</p>
<p>通常，%s 使用的逻辑与 %v 大致相同：如果 fmt.Stringer、error 或 fmt.Formatter 存在，将使用相同的偏好使用它。</p>
<p>当对象既不实现 String()，Error() 也不实现 Format() 时，就会出现区别。在这种情况下，％v 具有一些预定义的表示形式（例如，上例中的{123}），而 ％s 会提示“参数的类型错误”并且无法表示任何内容。</p>
<p>这就是为什么除非代码使用特定类型的字符串操作值，否则 Go 习惯用法通常是使用 ％v 而不是 ％s。</p>
<p>附加动词 ％q 和 ％x/％X 是 ％s 的变体（当 String()，Error() 和 Format() 都不可用时具有相同的限制）：</p>
<ul>
<li>%q 用引号引起来字符串，所以 fmt.Printf(&quot;%q&quot;, <code>he said &quot;hi&quot;</code>) 打印出 <code>he said &quot;hi&quot;</code>。</li>
<li>％x/％X 显示字符串中字节的十六进制表示形式。在实践中很少使用该方法（该方法更多用于整数）。</li>
</ul>
<h2 id="打印值指针方法集">打印值，指针方法集</h2>
<p>现在考虑上面的程序，以及以下实现的组合（注意接收器的类型）：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>现在打印的是 boo。为什么是这样？上面的代码按值传递 T 实例。根据方法集的概念，只实现了 fmt.Stringer 接口，因此输出 boo。如果现在改为这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>输出什么？这次再次输出：{123}，因为 fmt 的逻辑“看不到”上面的方法。</p>
<p>因此有如下规则：如果对象按值打印，则只考虑其按值方法。（其实就是方法集问题）</p>
<h2 id="打印引用值方法集">打印引用，值方法集</h2>
<p>现在，让我们用以下主程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">v</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span><span class="mi">123</span><span class="p">}</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>现在考虑以下程序变体：</p>
<ul>
<li>
<p>变体 A：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
<li>
<p>变体 B：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
<li>
<p>变体 C：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
<li>
<p>变体 D：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
</ul>
<p>针对这些情况，上面的程序输出什么？都是 &ldquo;baa&rdquo;。</p>
<p>指针接收器 <code>*T</code> 的方法集包含 T 和 <code>*T</code> 的方法集。（原文作者写的不对，说变体 C 输出 &ldquo;boo&rdquo;）。</p>
<h2 id="使用-v-动词打印">使用 %+v 动词打印</h2>
<p>数字类型的 + 标志强制显示正值的加号，以便始终显示符号位。</p>
<p>然而，与 v 结合，它会触发&quot;详细打印&quot;。</p>
<p>根据 fmt 的默认逻辑，这会将字段的名称添加到结构中。</p>
<p>如果实现了 <code>fmt.Stringer</code> 接口，+ 不会对结果有任何改变， 如果实现了 fmt.Formatter 接口，根据约定，Format() 方法输出的信息比未指定 + 时的信息更详细。</p>
<p>Go 库没有规定应如何实现：不同的包往往以不同的方式实现。然而，缺乏规范不是问题；在这两种情况下，输出都供人眼使用，因此小显示不一致并不被视为问题。</p>
<h2 id="go-语法表示和-v-动词">Go 语法表示和 %#v 动词</h2>
<p>最后，将原来的主程序改为使用 %#v 动词：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">v</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="mi">123</span><span class="p">}</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这会打印什么？</p>
<ul>
<li>如果 String() 方法可用，会忽略它；</li>
<li>如果 Format() 方法可用，则使用它；</li>
<li>如果 GoString() 方法可用（fmt.GoStringer 接口），则使用它；</li>
<li>否则，将使用 Go 语法结构的打印输出。</li>
</ul>
<p>这里发生的情况是，%#v 说明符打算打印值的 “Go表示”，而不是它的“人类可读表示”。fmt 逻辑知道如何这样做，但是自定义类型可以用 fmt 自定义这种行为：即实现 fmt.Formatter 或 GoStringer 接口。</p>
<p>注意，出于完整性考虑，上面解释了 GoStringer，但在实践中，发现它很少被使用。</p>
<p>我个人推荐 <a href="https://github.com/kr/pretty">https://github.com/kr/pretty</a> 这个工具，它比 Go 的标准库更清晰地打印 Go 语法表示。例如：<code>fmt.Printf(&quot;%# v&quot;, pretty.Formatter(x))</code>。</p>
<h2 id="格式化动词标识和修改器">格式化动词、标识和修改器</h2>
<p>到目前为止，我们已经看到 %v 与 %s 在意图和目的上的不同，以及例 %v 与 %+v 的不同。</p>
<p>如果我们想用不同的结果来定义我们自己的定制呢？</p>
<p>对于上面三种情况，可靠的定制机制是 fmt.Formatter 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">fmt</span>

<span class="c1">// Formatter can be implemented by your custom types.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Formatter</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// An object of type State is provided by the fmt
</span><span class="c1">// logic to your custom Format() method.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">State</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="c1">// inherits the Write() method
</span><span class="c1"></span>
     <span class="nf">Flag</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>

     <span class="nf">Width</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
     <span class="nf">Precision</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>最让我感兴趣的是：</p>
<ul>
<li>参数 verb 直接传递给我们自定义的 Format() 方法。这表示主“格式化动词”：对于 %v，verb == ‘v’。对于 %#v，依然是 verb == ‘v’。对于 %s，verb 是 s，以此类推。</li>
<li>有 Flag() 方法的 fmt.State 作为参数传递给 Format() 方法。如果设置了相应的格式化标志，Flag() 返回 true。例如，对于 %v，<code>Flag('#') == false</code>，而对于 %#v，<code>Flag('#') == true</code>。</li>
<li>此外，fmt.State 也实现了 io.Writer 接口。这样就可以直接将状态变量作为第一个参数传递给另一个对 fmt.Fprint 的调用，进一步简化了自定义 Format() 方法的实现。</li>
</ul>
<p>fmt.State 上的 Width() 和 Precision() 方法也很有趣，因为它们允许访问格式化字符串中的附加数值参数或修饰符。例如，在 %3.2f 中，我们有宽度 3 和精度 2。然而，这些在实践中很少被使用。</p>
<p>下面是一个符合 Go 习惯的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Response</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">code</span> <span class="kt">int</span>
     <span class="nx">msg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Response</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="nx">verb</span> <span class="p">{</span>
   <span class="k">case</span> <span class="sc">&#39;v&#39;</span><span class="p">:</span>
       <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// With %+v, we print both the message and the code.
</span><span class="c1"></span>          <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;%s (%d)&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">code</span><span class="p">)</span>
       <span class="p">}</span>
       <span class="k">fallthrough</span>
   <span class="k">case</span> <span class="sc">&#39;s&#39;</span><span class="p">:</span>
       <span class="c1">// For %s, or %v without +, we just print the message.
</span><span class="c1"></span>       <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// String is provided for convenience.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Response</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>简单解释下：</p>
<ul>
<li>以上实现中，对于 %+v，它将同时输出 msg 和 code。当只有 %v/%s，它只打印 msg。</li>
<li>为了让类型兼容 fmt.Stringer 接口，以便用于其他需要 String() 方法的地方，通过调用 fmt.Sprint 实现 String()。</li>
</ul>
<p>下面会进一步讨论。</p>
<p>上面代码一个有趣的点是，它不处理 %q/%x/%x。对于这些动词，它不输出任何内容。</p>
<p>它也不支持除了 + 之外的其他标志，例如，它对待 %#v 和 %v 是相同的。</p>
<p>事实上，Go API 并没有使实现与自身内部逻辑一样通用和强大的自定义 Format() 变得容易，而且“野生的” Go 包常常包含像上面那样的不完整实现。</p>
<h2 id="实践中自定义-formatter">实践中自定义 Formatter</h2>
<p>我在实践中发现，在整个生态系统的包经常按如下方式处理：</p>
<ul>
<li>自定义 Format() 方法总是为 v 动词做一些有效和有用的事情，而不考虑提供的标志。</li>
<li>带有动词 v 但没有标志的 Format() 的行为（即一个简单的 %v），通常与 String() 的行为保持一致。</li>
<li>如果自定义格式化程序同时具有“简单”和“详细”模式，那么它通常将 + 识别为访问详细模式的标志。</li>
<li>如果 %s 和 %v（没有标志）都被识别，它们通常输出相同的内容。</li>
<li>在自定义 Format() 方法中正确处理 %q、%x 和 %X 的情况并不常见。</li>
<li>非数值类型的自定义格式化程序几乎从不处理宽度和精度修饰符。</li>
</ul>
<p>最后一点特别说明了为什么关心固定宽度字符串格式的代码应该在以下两个步骤中拼写输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%30s&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>  <span class="c1">// instead of printing v directly
</span></code></pre></div><h2 id="在-fmtstringerfmtformatter-和-error-之间重用代码">在 fmt.Stringer、fmt.Formatter 和 error 之间重用代码</h2>
<p>上面的一个例子是通过调用 fmt.Sprint 实现 String()。它又在同一类型上使用 Format() 方法。简化为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
   <span class="c1">// This causes fmt to call Format() above and ultimately
</span><span class="c1"></span>   <span class="c1">// print r.msg.
</span><span class="c1"></span>   <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在这种情况下，为什么人们会选择通过返回 fmt.Sprint(r) 而不是返回 r.msg 来实现 String() 呢?</p>
<p>这是遵循 DRY 原则的实例：如果以后逻辑需要更改为&quot;打印更多内容&quot;，则只需修改 Format() 方法；String() 方法会自动从中受益。</p>
<p>这种模式比较常见。以下是另一种形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span> <span class="c1">// or: s.Write([]byte(r.String()))
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>同样，一个方法实现&quot;使用另一个&quot;，因此一个方法只需要更改其中任何一个，在两者中获得相同的行为。</p>
<p>同样，如果涉及 error 接口，我们会在实践中看到所有重用组合：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">U</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">U</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">U</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">U</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">V</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">V</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">V</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">V</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>Q：为什么我们看到如此多样性？</p>
<p>A：我不太确定，但我责怪 Go 库文档中缺乏方案。另请参阅下面的两个答案。</p>
<p>Q：既然我们在每个情况下都得到相同的结果，这有关系吗？</p>
<p>A：从功能的角度来看，这些示例都是等效的。从性能角度来看，应考虑在程序中更经常使用哪些变体。如果常用 String() 方法，比打印出对象更是如此，那么让 String() 包含最简单的实现可能会产生更好的性能。这是因为 fmt 包中的逻辑有点重量级。然而请注意，在实践中，我并没有发现这种情况经常发生，所以我要说，这并不重要。</p>
<p>Q：我正在实现自己的自定义类型。我应该瞄准什么模式？</p>
<p>A：如果您的类型只有一个表示形式，直接使用 String() 即可；如果您实现错误类型，自然使用 Error() 更合适，一般都不需要实现 Format()。但如果需要区分&quot;简单&quot;和&quot;详细&quot;显示，则首先实现 Format() 然后从中派生 String() 或 Error()。</p>
<h2 id="总结">总结</h2>
<p>Go 在其标准 fmt 包中提供了通用格式 API。</p>
<p>该 API 中的所有函数都由通用逻辑提供支持，这是 Print/Sprintf 在引擎下使用的逻辑：每个对象都显示在某种格式&quot;动词&quot;的上下文中。</p>
<p>最常见和可靠的动词是 v（提示：它是 &ldquo;v&rdquo;，如&quot;value&quot;），也被 Print() 和 Println() 使用。它可以打印几乎任何东西，并不挑剔的值是零或实现一个特定的接口。</p>
<p>同时，在实现自己的类型时，可以通过实现某些接口自定义 fmt 的行为：</p>
<ul>
<li>fmt.Stringer，一个简单的 String() string 方法；</li>
<li>error，一个简单的 Error() string 方法；</li>
<li>fmt.Formatter，一个 Format() 方法。当通过 %v 与 %+v 以及其他动词和标志组合使用时，这可用于显示不同的东西。</li>
</ul>
<p>在实践中，我们看到同时提供 String() 和 Format() 方法或 Error() 和 Format() 方法的包。一个通常是通过调用另一个来实现的，以避免代码重复。Go 的标准库允许所有的组合重用，实际上我们可以在生态系统中找到所有变体。</p>
<blockquote>
<p>原文链接：https://dr-knz.net/go-formatting-apis.html</p>
<p>本文作者：Raphael ‘kena’ Poss</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Go 标准错误 API — CockroachDB errors 库（第1篇）</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/cockroachdb-errors-std-api/</link>
			<pubDate>Fri, 23 Oct 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/cockroachdb-errors-std-api/</guid>
			<description>这篇文章是关于 “CockroachDB errors 库” 的系列文章的第 1 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</description>
			<content type="html"><![CDATA[<p>这篇文章是关于 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">“CockroachDB errors 库”</a>
的系列文章的第 1 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</p>
<p>那本篇文章主要谈论什么呢？</p>
<h2 id="基本的-go-错误error-是值">基本的 Go 错误：error 是值</h2>
<p>Go 生态有一些非常流行、也非常基本的学习资源（文档）：</p>
<ul>
<li><a href="http://tour.studygolang.com/methods/19" target="_blank" rel="noopener">A Tour of Go: Errors</a>
。这是 Go 的官方教程。</li>
<li><a href="http://books.studygolang.com/gobyexample/errors/" target="_blank" rel="noopener">Go By Example: errors</a>
。Go By Example 是一些系列文章，推荐给那些希望通过示例学习 Go 的朋友们。</li>
<li><a href="https://golangdocs.com/errors-exception-handling-in-golang" target="_blank" rel="noopener">Goland Docs: Errors and Exception handling in GoLang</a>
。“Golang Docs” 是一系列文章，它涵盖了 Go 中的常见软件模式。</li>
</ul>
<p>我们可以从这些文章中学到什么？</p>
<ul>
<li>
<p>Go 提供了一个预定义的接口类型 error，定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// an &#34;error&#34; is an object with an `Error()` method
</span><span class="c1">// which describes the situation that occurred.
</span><span class="c1"></span><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>编写 Go 函数/方法的惯用方法是让它们在常规返回值之外，再返回一个 error 类型值，并在每个调用点上进行测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">div</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
       <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;boo&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">/</span> <span class="nx">y</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
  
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">div</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;woops: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
       <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;result:&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>如上面的示例所示，fmt.Printf 会知道如何调用 error 的 Error() 方法来显示错误文本。如果错误是通过%s、%q、%x/%X 打印的，它也会这样做。</p>
</li>
</ul>
<h2 id="error-也是链表">error 也是链表</h2>
<p>如果你还不知道 <a href="https://dave.cheney.net/" target="_blank" rel="noopener">Dave Cheney</a>
 是谁，现在是时候去了解下这位及其高产的 Go 大师程序员。</p>
<p>2015 年，Dave 创建了 pkg/errors 包（<a href="https://github.com/pkg/errors" target="_blank" rel="noopener">源代码</a>
，<a href="https://pkg.go.dev/github.com/pkg/errors" target="_blank" rel="noopener">文档</a>
），随后在 2016 年东京举行的 GoCon 春季会议上展示了它。下面这篇文章用散文的形式解释了这个故事：</p>
<p><a href="https://studygolang.com/articles/12484" target="_blank" rel="noopener">Dave Cheney：优雅的处理错误，而不仅仅只是检查错误</a>
</p>
<p>以下是 Dave 提到的主要创新：</p>
<ul>
<li>Go error 对象像链表一样构建，而且是不可变的。</li>
<li>err 在任何时候都会指向列表的头部。</li>
<li>在首次发生错误时，将构造一个原子或&quot;叶&quot;错误对象，该对象将在列表的尾部。</li>
<li>当错误通过调用堆栈和软件组件返回时，通过向错误添加更多&quot;层&quot;、在现有错误列表的头部 push 更多列表元素或&quot;包装器&quot;来增加错误。</li>
</ul>
<p>这在实践中给我们什么启发呢？主要用途是向错误对象添加消息前缀，以给出有关&quot;错误发生在哪&quot;的更多上下文。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;github.com/pkg/errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;boo&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nf">foo</span><span class="p">(),</span> <span class="s">&#34;bar&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">baz</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nf">foo</span><span class="p">(),</span> <span class="s">&#34;baz&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="nx">r</span> <span class="o">:=</span> <span class="nf">rollDice</span><span class="p">()</span>
     <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
     <span class="k">if</span> <span class="p">(</span><span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nf">bar</span><span class="p">()</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nf">baz</span><span class="p">()</span>
     <span class="p">}</span>
     <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>使用 <code>errors.Wrap()</code>，添加一个前缀到错误消息，main 函数能报告：<code>bar: boo</code> 或 <code>baz:boo</code> 这样人类可读错误消息，方便知晓哪个函数被调用。如果没有 <code>errors.Wrap()</code>，哪个调用路径导致错误将不容易知晓。</p>
<p>在实践中，这是如何工作的，看起来有点像这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// errorString represents a leaf error. This
</span><span class="c1">// is what gets constructed by e.g. fmt.Errorf().
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">errorString</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">msg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Error implements the error interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">errorString</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>

<span class="c1">// msgWrap represents a wrapper which adds a prefix
</span><span class="c1">// to an error. This is what gets constructed
</span><span class="c1">// by e.g. pkg/errors.Wrap().
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">msgWrap</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">cause</span> <span class="kt">error</span>
     <span class="nx">msg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// instances of msgWrap are also instances of the error
</span><span class="c1">// interface, by implementing the Error() method.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">msgWrap</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s: %v&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="错误消息包装注释和-cause-发现">错误消息、包装注释和 cause 发现</h2>
<p>Dave Cheney 的基础逻辑是：</p>
<blockquote>
<p>The <code>Error</code> method on the <code>error</code> interface exists for humans, not code.</p>
</blockquote>
<p>换句话说，程序代码不应检查或比较 Error() 方法的结果。</p>
<p>Dave 继续谴责两种 Go 编程模式，他认为令人厌恶，现在仍然不赞成：</p>
<ul>
<li>“哨兵错误（sentinel errors）&ldquo;的概念，这是在代码中通过 error 实例进行比较。例如，<code>if err == ErrNotExists</code>。这种方式的主要问题是，如果错误是链表，也许是在列表的尾部找到哨兵，而头部有其他内容（例如，消息前缀）。Sentinel 的另一个更实际的问题是，为了能够执行比较，发生比较的包必须导入定义 sentinel 所在的包。这将导致依赖项。这种类型的硬依赖性使软件组合更加困难。</li>
<li>引用 &ldquo;error types&rdquo;（或错误包装类型）的概念，进行错误类型断言，例如，<code>if e, ok := err.(SomeType); ok</code>。此处的问题与上述问题相同：如果错误是链表，则它可能不起作用，并且还导致了包依赖。</li>
</ul>
<p>Dave 建议应该采用这两种方式：</p>
<ul>
<li>为调用者感兴趣的错误对象的属性定义接口。例如，错误是否可恢复可以通过 IsRecoverable() 方法来定义。然后，在任何包都可以断言此接口的实现，没有依赖关系：在 Go 中，接口断言基于结构相等，而不是命名相等。</li>
<li>注意错误链接列表结构，并在检查错误对象时正确遍及链表层级。</li>
</ul>
<p>为了实现后一点，Dave Cheney 在 pkg/errors 中引入了 causer 接口，从而有了以下可重用的代码模式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NB: causer is not exported by pkg/errors; instead
</span><span class="c1">// any package can re-defined it as needed
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">causer</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Cause</span><span class="p">()</span> <span class="kt">error</span> <span class="p">}</span>

<span class="o">...</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">{</span>
       <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">SomeInterfaceWithProperty</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
          <span class="c1">// ... do something ...
</span><span class="c1"></span>       <span class="p">}</span>

       <span class="c1">// Peel one layer, if wrapped.
</span><span class="c1"></span>       <span class="k">if</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.(</span><span class="nx">causer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
          <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Cause</span><span class="p">()</span>
          <span class="k">continue</span>
       <span class="p">}</span>
       <span class="k">break</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>此模式会将错误展开，根据错误链访问，直到叶子节点或链表尾部。</p>
<h2 id="在-errors-中内嵌堆栈追踪">在 errors 中内嵌堆栈追踪</h2>
<p>包 pkg/errors 的一个被低估的特性是，每次构造错误或包装错误时，它都会自动保留堆栈跟踪的副本。</p>
<p>这一点很重要，因为它使得在排除问题时能够分析”错误发生在哪里&rdquo;：通常情况下，该错误仅对开发人员可见，或在实例化后很长一段时间，在调用者中的某个地方出现问题。各种 Go 并发模式使这种困难更加复杂，其中错误对象通过通道将错误对象从一个 goroutine 传输到下一个 goroutine。因此，仅仅查看源代码中的&quot;一行&quot;来查找错误的来源是不够的。</p>
<p>为此，pkg/error 使用极其轻量级且相当聪明的机制来在每个错误构造时保留调用堆栈的副本。</p>
<p>此堆栈跟踪不出现在 Error() 方法的结果中；相反，当通过 Printf 中的 %+v 谓词（这是最常见的情况，例如在调试期间）或通过检查错误链接列表某些层（例如与 <a href="https://sentry.io/" target="_blank" rel="noopener">Sentry.io</a>
 集成）上是否存在 StackTrace() 方法时，将显示错误对象。</p>
<p>这种机制特别巧妙的是，堆栈跟踪的所有详细信息（包括函数/包名称）不会直接存储在错误对象中，而是在打印堆栈跟踪时检索它们。通常情况下，错误发生，但可能是无害的，这样可以节省时间和内存。</p>
<h2 id="go-113-中的提升和-api-分裂">Go 1.13 中的提升和 API 分裂</h2>
<p>很难说 pkg/errors 包多么基础和重要。但目前直接依赖它的公开 Go 项目超过 5 万个，还有无法统计的私有 Go 存储库。</p>
<p>Go 语言的设计者认识到了这一点，并<a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">在 2019 年将其语义集成到 Go 标准库</a>
中，从 Go 1.13 开始：</p>
<ul>
<li>Go 1.13 的错误也是链表。</li>
<li>Go 1.13 没有提供 <code>errors.Wrap()</code>，但是为 fmt.Errorf 做了扩充：使用格式化动词 %w，构造一个包装错误，并保持原来的错误对象放在链表尾部供检测；
<ul>
<li>在 <code>pkg/errors</code>: <code>errors.Wrapf(err, &quot;hello %s&quot;, &quot;world&quot;)</code></li>
<li>在 Go 1.13: <code>fmt.Errorf(&quot;hello %s: %w&quot;, &quot;world&quot;, err)</code></li>
</ul>
</li>
<li>Go 1.13 简化了在错误链表的每个中间级别上测试属性的任务，使用以下 api：
<ul>
<li>errors.Is(err1, err2) 检查 err1 中的任何层是否等于 err2（会递归地测试哨兵）。这可以用来识别许多标准库的哨兵，例如 errors.Is(err, os.ErrNotExist) 检查是否由于找不到某个文件/目录而导致错误。</li>
<li><code>errors.As(err1, &lt;type&gt;)</code> 检查 err1 中的任何层是否可以被转换为 <code>&lt;type&gt;</code>（接口或具体类型），并返回转换的结果。这可以用来断言错误属性，就 Dave Cheney 在 2015 年建议的那样。</li>
</ul>
</li>
</ul>
<p>然而存在一些争议，因为 Go 1.13 在社区中引发了 API 的分裂：</p>
<ul>
<li>error 对象上的展开方法称为 Unwrap()，而不是 Cause()。我个人很讨厌 Go 团队选择一个单独的方法名，因为这直接破坏了与所有基于 pkg/errors 构建的包的兼容性，而且没有很好这么做的原因。</li>
<li>Go 1.13 没有提供像 pkg/errors 中的 error.Cause() 那样的 “unwrap 一切”的函数。</li>
<li>另外，遗憾的是，因为 Go 1.13 没有定义 Cause() 方法，所以不可能使用 pkg/errors 中的 error.Cause() 来解包装来自 Go 1.13 项目和为 pkg/errors API 设计的项目的混合错误对象。</li>
<li>非常遗憾的是，Go 1.13 没有像 pkg/errors 那样提供捕获堆栈跟踪的工具。由于上述 API 的不兼容性，不可能将 pkg/errors 与特定于 Go 1.13 的代码混合匹配来获得这种行为。</li>
</ul>
<p>总结为如下表格：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Feature</th>
<th style="text-align:left">Go’s &lt;1.13 <code>errors</code></th>
<th style="text-align:left"><code>github.com/pkg/errors</code></th>
<th style="text-align:left">Go 1.13 <code>errors</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">leaf error constructors (<code>New</code>, <code>Errorf</code> etc)</td>
<td style="text-align:left">✔</td>
<td style="text-align:left">✔</td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">abstraction: errors are linked lists</td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">error causes via <code>Cause()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">error causes via <code>Unwrap()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">best practice: test interfaces, not values/types</td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left">(partial)</td>
</tr>
<tr>
<td style="text-align:left"><code>errors.As()</code>, <code>errors.Is()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left"><code>errors.Wrap()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">automatic error wrap when format ends with : %w</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">standard wrappers with efficient stack trace capture</td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>这种分裂是真实而悲哀的。发生这种情况的原因（也许令人惊讶）是 Go 团队无法确定一种好的方法来标准化打印错误。我们将在本系列的后续文章中了解其中的原因。</p>
<p>然而，pkg/error 社区的用户不能简单地加入到 Go 1.13 的潮流中去。这里有一个缺口，需要一些交叉兼容的库来弥补这个缺口。</p>
<p>这就是为什么 <a href="https://github.com/cockroachdb/errors/" target="_blank" rel="noopener">CockroachDB 错误库</a>
能够做到这一点。您可以使用它作为 pkg/errors 和 Go 1.13 自己的 errors 包的临时替代。</p>
<blockquote>
<p>原文链接：https://dr-knz.net/cockroachdb-errors-std-api.html</p>
<p>本文作者：Raphael ‘kena’ Poss</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>一道关于 json 和 slice 的题难倒了 80% 的人</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/interview-slice-json/</link>
			<pubDate>Sun, 18 Oct 2020 14:18:50 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/interview-slice-json/</guid>
			<description>昨天在 Go语言爱好者周刊：第 65 期 刊首语发了一道题，以下代码输出什么？ package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; ) type AutoGenerated struct { Age int `json:&amp;#34;age&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` Child []int `json:&amp;#34;child&amp;#34;` } func main() { jsonStr1 := `{&amp;#34;age&amp;#34;: 14,&amp;#34;name&amp;#34;: &amp;#34;potter&amp;#34;, &amp;#34;child&amp;#34;:[1,2,3]}` a := AutoGenerated{} json.Unmarshal([]byte(jsonStr1), &amp;amp;a) aa</description>
			<content type="html"><![CDATA[<p>昨天在 <a href="https://mp.weixin.qq.com/s/CqcOPluw5RFMYRzrnWCoHA" target="_blank" rel="noopener">Go语言爱好者周刊：第 65 期</a>
 刊首语发了一道题，以下代码输出什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">AutoGenerated</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Age</span>   <span class="kt">int</span>    <span class="s">`json:&#34;age&#34;`</span>
	<span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
	<span class="nx">Child</span> <span class="p">[]</span><span class="kt">int</span>  <span class="s">`json:&#34;child&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">jsonStr1</span> <span class="o">:=</span> <span class="s">`{&#34;age&#34;: 14,&#34;name&#34;: &#34;potter&#34;, &#34;child&#34;:[1,2,3]}`</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nx">AutoGenerated</span><span class="p">{}</span>
	<span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">jsonStr1</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">aa</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Child</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">aa</span><span class="p">)</span>
	<span class="nx">jsonStr2</span> <span class="o">:=</span> <span class="s">`{&#34;age&#34;: 12,&#34;name&#34;: &#34;potter&#34;, &#34;child&#34;:[3,4,5,7,8,9]}`</span>
	<span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">jsonStr2</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">aa</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果 80% 的人都答错了。</p>
<p><p class="md__image">
  <img src="../imgs/json01.png"
    alt=""  />
</p>
</p>
<p>结果为什么是 [1 2 3] [3 4 5] 呢？</p>
<p>这道题涉及到两个知识点：</p>
<ul>
<li>json 解析；</li>
<li>slice；</li>
</ul>
<h2 id="1json-解析">1、json 解析</h2>
<p>关于 json.Unmarshal 的文档，不少人可能没认真看。借此机会正好一起看下。<a href="https://docs.studygolang.com/pkg/encoding/json/#Unmarshal">https://docs.studygolang.com/pkg/encoding/json/#Unmarshal</a>。</p>
<blockquote>
<p>Unmarshal 解析 JSON 编码的数据，并将结果存入 v 指向的值。如果 v 为 nil 或不是指针，则 Unmarshal 返回 InvalidUnmarshalError。</p>
<p>Unmarshal 和 Marshal 做相反的操作，必要时申请 map、slice 或指针，有如下的附加规则：</p>
<ul>
<li>
<p>为了将 JSON 数据解码写入一个指针，Unmarshal 首先处理 JSON 数据为 JSON 字面值 null 的情况。此时，Unmarshal 会将指针设置为 nil。否则，Unmarshal 会将 JSON 数据解码为指针所指向的值。如果指针为 nil，则 Unmarshal 为其分配一个新值并使指针指向它。</p>
</li>
<li>
<p>为了将 JSON 数据解码为实现 Unmarshaler 接口的值，Unmarshal 调用该值的 UnmarshalJSON 方法，包括当输入为 JSON  null 时。否则，如果该值实现 encoding.TextUnmarshaler 且输入是带引号的 JSON 字符串，则 Unmarshal 会使用该字符串的未加引号形式来调用该值的 UnmarshalText 方法。</p>
</li>
<li>
<p>要将 json 数据解码写入一个结构体，函数会匹配输入对象的键和 Marshal 使用的键（结构体字段名或者它的标签指定的键名），优先选择精确的匹配，但也接受大小写不敏感的匹配；</p>
</li>
<li>
<p>为了将 JSON 数据解码到结构中，Unmarshal 将传入的对象键与 Marshal 使用的键（结构字段名称或其 Tag）进行匹配，希望使用精确匹配，但还接受不区分大小写的匹配。默认情况下，没有相应结构字段的对象键将被忽略（有关替代方法，请参见 Decoder.DisallowUnknownFields）。</p>
</li>
<li>
<p>要将 JSON 数据解码写入一个接口类型值，Unmarshal 将其中之一存储在接口值中：</p>
<pre><code>Bool                   对应JSON布尔类型
float64                对应JSON数字类型
string                 对应JSON字符串类型
[]interface{}          对应JSON数组
map[string]interface{} 对应JSON对象
nil                    对应JSON的null
</code></pre></li>
<li>
<p>要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。</p>
</li>
<li>
<p>为了将 JSON 数组解码为 Go 数组，Unmarshal 将 JSON 数组元素解码为对应的 Go 数组元素。如果 Go 数组长度小于 JSON 数组，则其他 JSON 数组元素将被丢弃。如果 JSON 数组长度小于 Go 数组，则将其他 Go 数组元素会设置为零值。</p>
</li>
<li>
<p>要将 JSON 对象解码到 map 中，Unmarshal 首先要建立将使用的 map。如果 map 为零，Unmarshal 会分配一个新 map。否则，Unmarshal 会重用现有 map，保留现有条目（item）。然后，Unmarshal 将来自 JSON 对象的键/值对存储到 map 中。map 的键类型必须是任意字符串类型、整数或实现了 json.Unmarshaler 或 encoding.TextUnmarshaler 接口的类型。</p>
</li>
<li>
<p>如果 JSON 值不适用于给定的目标类型，或者 JSON 数字写入目标类型时溢出，则 Unmarshal 会跳过该字段并尽最大可能完成解析。如果没有遇到更多的严重错误，则 Unmarshal 返回一个 UnmarshalTypeError 来描述最早的此类错误。但无法确保有问题的字段之后的所有其余字段都将被解析到目标对象中。</p>
</li>
<li>
<p>JSON 的 null 值解码为 Go 的接口、指针、切片时会将它们设为 nil，因为 null 在 JSON 里一般表示“不存在”。 因此将 JSON null 解码到任何其他 Go 类型中不会影响该值，并且不会产生任何错误。</p>
</li>
<li>
<p>解析带引号的字符串时，无效的 UTF-8 或无效的 UTF-16 不会被视为错误。而是将它们替换为 Unicode 字符 U+FFFD。</p>
</li>
</ul>
</blockquote>
<p>跟此题相关的是下面这点：</p>
<blockquote>
<p>要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。</p>
</blockquote>
<p>因此第一次解析时，a.Child 是 [1 2 3]，aa 自然也是 [1 2 3]。第二次解析时，a.Child 的长度会被重置为 0，也就说里面的值会被重置（比如 a.Child = a.Child[:0]），然后将 3,4,5,7,8,9 一个个 append 到 a.Child 中。</p>
<p>而 append 操作可能会涉及到底层数组的扩容：当原来的容量不足时，会进行扩容。怎么扩容的呢？目前的版本（Go1.15.x）按照如下规则扩容：（扩容规则依赖具体实现，不同版本可能不一样）</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Get element of array, growing if necessary.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">==</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span> <span class="p">{</span>
  <span class="c1">// Grow slice if necessary
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Cap</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Cap</span><span class="p">()</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Cap</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="mi">4</span> <span class="p">{</span>
      <span class="nx">newcap</span> <span class="p">=</span> <span class="mi">4</span>
    <span class="p">}</span>
    <span class="nx">newv</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">MakeSlice</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Type</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Len</span><span class="p">(),</span> <span class="nx">newcap</span><span class="p">)</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">newv</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="nx">v</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">newv</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v</span><span class="p">.</span><span class="nf">SetLen</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>初始容量最小为 4；</li>
<li>之后按照容量的一半扩容，所以容量是 4、6、9、13、19&hellip;</li>
</ul>
<p>有人问上题为什么 aa 的容量是 4，这里正好解释了。</p>
<p>因此，第一次解析，aa.Child 是：[1 2 3]，cap = 4。第二次解析，aa.Child 先被重置，之后将 3,4,5,7,8,9 一个个 append，最后 aa.Child 是：[3 4 5 6 7 8 9], cap = 6。</p>
<h2 id="2slice">2、slice</h2>
<p>以上就是能从 json Unmarshal 文档能学到的相关知识。接下来关键在于 slice。关于 slice 的知识，网上很多教程，这里只讲解和该题相关的内容。</p>
<p>1）aa := a.Child 意味着什么？</p>
<p>先看 a.Child 的内部结构。</p>
<p><p class="md__image">
  <img src="../imgs/json02.png"
    alt=""  />
</p>
</p>
<p>赋值给 aa 后呢？aa 和 a.Child 共用底层数组。</p>
<p><p class="md__image">
  <img src="../imgs/json03.png"
    alt=""  />
</p>
</p>
<p>这里有引入一个小知识点，aa := a.Child 后，以下代码输出的两个地址是一样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p,%p\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Child</span><span class="p">,</span> <span class="nx">aa</span><span class="p">)</span>
</code></pre></div><p>它们输出的都是底层数组的地址，这里一定要注意。通过它们，你可以验证底层数组扩容了（地址变了，表明扩容了）。</p>
<p>如果要输出 slice 本身的地址，应该这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p,%p\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">.</span><span class="nx">Child</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">aa</span><span class="p">)</span>
</code></pre></div><p>2）执行第二次 json 解析后</p>
<p>根据上文的讲解，底层数组从索引 0 位置开始依次被 3、4、5、7 填充。因为 aa 的 len 是 3，所以即使底层数组变成了 3、4、5、7，aa 看到却是 3、4、5。</p>
<p>当再继续解析时，底层数组容量不够，因此进行扩容，cap 变成 6，将原底层数组的元素拷贝一份到新的数组中。所以最后 a.Child 的底层数组是这个新的底层数组：[3 4 5 7 8 9]，cap = 6。而 aa 的底层数组还是原来的。最后的内部表示是这样的。</p>
<p><p class="md__image">
  <img src="../imgs/json04.png"
    alt=""  />
</p>
</p>
<h2 id="3小结">3、小结</h2>
<p>总结起来两点：</p>
<ul>
<li>json 解析的规则，文档上明确说明了；（有人评论说跟 json 没关系，但我觉得很多人根本不知道 json 对这块是怎么处理的，正因为有这样的处理，才引出了 slice 扩容的问题）</li>
<li>slice 内部表示和 append 导致扩容。</li>
</ul>
<p>希望你已经彻底掌握了以上知识点。</p>
]]></content>
		</item>
		
		<item>
			<title>你喜欢的 Go 第三方库：一步为系统集成可视化实时运行时统计</title>
			<link>https://polarisxu.studygolang.com/posts/go/pkg/statsviz/</link>
			<pubDate>Thu, 15 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/pkg/statsviz/</guid>
			<description>大家好，我是站长 polarisxu。 掌握系统运行状态，知道系统哪些地方可能存在问题，方便进行优化，这是一个实际系统必备的。裸奔，对系统一无所</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>掌握系统运行状态，知道系统哪些地方可能存在问题，方便进行优化，这是一个实际系统必备的。裸奔，对系统一无所知，迟早是要出大事的。</p>
<p>在 Go 语言中，官方标准库提供了方法，让我们能够获得内存分配、GC 和 Goroutine 等情况。比如内存、GC 等情况，可以通过 runtime.MemStats 获取：<a href="https://docs.studygolang.com/pkg/runtime/#MemStats">https://docs.studygolang.com/pkg/runtime/#MemStats</a>，Goroutine 数量可以通过 runtime.NumGoroutine() 函数获得。</p>
<p>一般我们我们需要自己解析 MemStats 信息、做展示，也可以做图表。</p>
<p>今天我给大家推荐一个库：<a href="https://github.com/arl/statsviz">https://github.com/arl/statsviz</a>，它是一个在浏览器中实时查看 Go 应用程序运行时统计信息（GC，MemStats 等）的库。</p>
<p>它能展示的信息如下图：</p>
<p><p class="md__image">
  <img src="../imgs/statsviz01.png"
    alt=""  />
</p>
</p>
<p>再看其中 Heap 的实时动图：</p>
<p><p class="md__image">
  <img src="../imgs/statsviz02.gif"
    alt=""  />
</p>
</p>
<p>上面这些通过运行下面这段代码就可以了：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/arl/statsviz&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Force the GC to work to make the plots &#34;move&#34;.
</span><span class="c1"></span>	<span class="k">go</span> <span class="nf">work</span><span class="p">()</span>

	<span class="c1">// Register statsviz handlers on the default serve mux.
</span><span class="c1"></span>	<span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">work</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Generate some allocations
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">byte</span><span class="p">{}</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">512</span><span class="o">+</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="p">))</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">100</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">b</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">byte</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="1如何使用">1、如何使用</h2>
<blockquote>
<p>都 Go1.15.x 了，请使用 go module。</p>
</blockquote>
<p>statsviz 的使用很简单。假设基于 net/http 使用。</p>
<ul>
<li>import &ldquo;github.com/arl/statsviz”</li>
<li>注册 statsviz HTTP handlers</li>
<li>启动程序</li>
<li>打开浏览器访问：http://host:port/debug/statsviz</li>
<li>尽情享受吧~</li>
</ul>
<p>具体看看实际中怎么集成到项目中，根据可能的情况分别介绍。</p>
<h3 id="基于-nethttp">基于 net/http</h3>
<p>如果你的项目没有使用框架，直接基于 net/http；或者你的项目并没有提供 HTTP 服务。集成 statsviz 可以按照下面的方式。</p>
<p><strong>1）一个使用 net/http 的 Web 项目</strong></p>
<p>只需要 import statsviz 包后，在注册路由的地方加上如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
</code></pre></div><p>这是使用默认的 http.DefaultServeMux，如果你使用的是自定义 Mux，则加上如下类似如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">mux</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewServeMux</span><span class="p">()</span>
<span class="nx">statsviz</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">mux</span><span class="p">)</span>
</code></pre></div><p>其中，mux 使用你定义好的。</p>
<p>实际上，statsviz.RegisterDefault() 内部是这么实现的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RegisterDefault</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">Register</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">DefaultServeMux</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><strong>2）没有提供 HTTP 服务的项目</strong></p>
<p>这时最简单的方式就是使用 statsviz.RegisterDefault() ，同时需要启动一个 HTTP 服务：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div><h3 id="基于兼容-nethttp-的框架">基于兼容 net/http 的框架</h3>
<p>因为兼容 net/http 框架，因此可以直接将 statsviz 的 Handler 集成进去。比如对于 gorilla/mux 库，可以这么做：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">NewRouter</span><span class="p">()</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Path</span><span class="p">(</span><span class="s">&#34;/debug/statsviz/ws&#34;</span><span class="p">).</span><span class="nf">Name</span><span class="p">(</span><span class="s">&#34;GET /debug/statsviz/ws&#34;</span><span class="p">).</span><span class="nf">HandlerFunc</span><span class="p">(</span><span class="nx">statsviz</span><span class="p">.</span><span class="nx">Ws</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">PathPrefix</span><span class="p">(</span><span class="s">&#34;/debug/statsviz/&#34;</span><span class="p">).</span><span class="nf">Name</span><span class="p">(</span><span class="s">&#34;GET /debug/statsviz/&#34;</span><span class="p">).</span><span class="nf">Handler</span><span class="p">(</span><span class="nx">statsviz</span><span class="p">.</span><span class="nx">Index</span><span class="p">)</span>

<span class="nx">mux</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewServeMux</span><span class="p">()</span>
<span class="nx">mux</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="nx">mux</span><span class="p">)</span>
</code></pre></div><p>这里主要是 statsviz.Ws 和 statsviz.Index，因为 gorilla/mux 库兼容 net/http，所以可以这么做。</p>
<h3 id="不兼容-nethttp-的框架">不兼容 net/http 的框架</h3>
<p>比如集成进 Gin 框架。做法就是和“没有提供 HTTP 服务的项目”一样，另开一个 HTTP 端口。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div><p>因此这里实际上和具体框架没关系。</p>
<h3 id="最佳实践">最佳实践</h3>
<p>因为 runtime 信息属于系统内部信息，不适合暴露给公网用户。因此，实际上中，最佳实践是，不管什么情况下，都单独开一个 HTTP 端口，类似下面这样，对公网不可访问。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div><h2 id="原理简单说明">原理简单说明</h2>
<p>该库使用 WebSocket 协议，定时将系统的 runtime 数据发送给浏览器，浏览器接收到之后，利用 JS 绘制图表，展示出来。Go 核心代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sendStats indefinitely send runtime statistics on the websocket connection.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sendStats</span><span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">defaultSendPeriod</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">tick</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

	<span class="kd">var</span> <span class="nx">stats</span> <span class="nx">stats</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
			<span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stats</span><span class="p">.</span><span class="nx">Mem</span><span class="p">)</span>
			<span class="nx">stats</span><span class="p">.</span><span class="nx">NumGoroutine</span> <span class="p">=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">WriteJSON</span><span class="p">(</span><span class="nx">stats</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>对客户端代码感兴趣的请自行阅读源码。</p>
<h2 id="总结">总结</h2>
<p>如果你需要实时图表的方式查看系统运行时的一些数据，可以尝试下它。用类似这样几行代码一步将它集成进你的系统：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go Playground 还能这么玩？</title>
			<link>https://polarisxu.studygolang.com/posts/go/project/usingg-gpgsync/</link>
			<pubDate>Fri, 09 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/project/usingg-gpgsync/</guid>
			<description>大家好，我是 polarisxu。 之前我为大家推荐过 Playground，对比了三款 Go Playground 。今天发现了另外一款 Playground，它最核心的特</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>之前我为大家推荐过 Playground，<a href="https://mp.weixin.qq.com/s/SYngjiM8M2T6KS0OQNonCQ" target="_blank" rel="noopener">对比了三款 Go Playground</a>
。今天发现了另外一款 Playground，它最核心的特点是，可以多人协同编辑。</p>
<p>协同编辑，目前是很流行的一种多人协作模式。GitHub 的编辑器 Atom 就有这方面的支持。</p>
<h2 id="简介">简介</h2>
<p>先简单看看这款 Playground：gpgsync。这是 <a href="https://github.com/syumai" target="_blank" rel="noopener">syumai</a>
 开发的一款多人协同编辑的 Go Playground，他是一个 TypeScript 和 Go 爱好者。</p>
<p>项目地址：<a href="https://github.com/syumai/gpgsync">https://github.com/syumai/gpgsync</a>，这是一个 Node 项目，你可以本地搭建，也可以直接试用作者提供的 Demo：<a href="https://gpgsync.herokuapp.com/">https://gpgsync.herokuapp.com/</a>。</p>
<h2 id="如何使用">如何使用</h2>
<p>打开 <a href="https://gpgsync.herokuapp.com/">https://gpgsync.herokuapp.com/</a>，会让你提供一个 Room ID，可以使用随机生成的，也可以自定义。</p>
<p><p class="md__image">
  <img src="../imgs/gpgsync01.png"
    alt=""  />
</p>
</p>
<p>点击 Join 后，进入编辑界面。</p>
<p><p class="md__image">
  <img src="../imgs/gpgsync02.png"
    alt=""  />
</p>
</p>
<p>这个界面和官方的 Playground 基本类似，但多了一个 Options。这个功能来自作者的另一个项目：<a href="https://github.com/syumai/go-playground-custom">https://github.com/syumai/go-playground-custom</a>，好吧，又一个 Playground。这个项目的目标是为 Playground 提供一些额外的特性，包括：</p>
<ul>
<li>基于 CodeMirror 的丰富编辑器；
<ul>
<li>语法高亮（官方 Playground 是不支持语法高亮的）；</li>
<li>Vim 模式（我太喜欢这点了）；</li>
</ul>
</li>
<li>go2go 支持。这是对 Go 泛型的支持；</li>
</ul>
<p>点击 Options 后，在底部有相关配置：</p>
<p><p class="md__image">
  <img src="../imgs/gpgsync03.png"
    alt=""  />
</p>
</p>
<p>回到主题。</p>
<p>当你进入后，你可以将你的 Room ID 告诉你的协作者，或者直接复制链接发给 TA，你们就可以协同了。你或 TA 的改动，另一方能实时看到。</p>
<p>我的 Room：<a href="https://gpgsync.herokuapp.com/rooms/polarisxu">https://gpgsync.herokuapp.com/rooms/polarisxu</a>，大家可以试试，看看一堆人是啥效果，会不会崩溃~</p>
<p>你自己想单独试验，可以开两个浏览器看看效果。</p>
<p><strong>特别说明</strong>：最终的运行是交给 play.golang.org 的，因此要实际运行，请自备梯子。</p>
<h2 id="有啥用">有啥用</h2>
<p>我想到的有两点：</p>
<ul>
<li>请教大牛问题，实时看 TA 怎么写代码的；</li>
<li>面试，特别远程面试时，可以让对方通过这个写代码，你实时看到对方的整个 coding 过程；</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>终于找到了一款我喜欢的安装和管理 Go 版本的工具</title>
			<link>https://polarisxu.studygolang.com/posts/go/project/go-version-manager/</link>
			<pubDate>Fri, 09 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/project/go-version-manager/</guid>
			<description>一直以来，我都习惯通过源码安装 Go。我是这么做的： 1）Git clone Go 源码 $ git clone https://github.com/golang/go 2）需要安装什么版本就切换到对应的分支，比如安装 1.15.x $ git checkout -b release-branch.go1.15 origin/release-branch.go1.15 如</description>
			<content type="html"><![CDATA[<p>一直以来，我都习惯通过源码安装 Go。我是这么做的：</p>
<p>1）Git clone Go 源码</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git clone https://github.com/golang/go
</code></pre></div><p>2）需要安装什么版本就切换到对应的分支，比如安装 1.15.x</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git checkout -b release-branch.go1.15 origin/release-branch.go1.15
</code></pre></div><p>如果本地之前已经存在该分支，直接 git checkout release-branch.go1.15 即可。</p>
<p>3）将 go 整个目录复制到 /usr/local/go1.15，编译安装</p>
<p>4）创建软链：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">ln -s go1.15 go
</code></pre></div><p>之后加上环境变量等。</p>
<p>如果想要切换版本，只需要做类似上面的步骤，最后将 go 这个软链指向要切换的版本。</p>
<p>我这种方式存在两个问题：</p>
<ul>
<li>因为 Go1.5 实现了自举，对于没有安装 Go 的系统，需要先安装 Go1.4；</li>
<li>每次都编译，还是没那么方便，而且如果是 Windows 系统，可能会有一些问题（现在的 Windows 也可能没问题了？好久没使用 Windows 了，使用 Windows 的朋友可以留言告知下）；</li>
</ul>
<p>之后看到 <a href="https://github.com/moovweb/gvm" target="_blank" rel="noopener">gvm</a>
 这个工具，我试用了，可能是国内网络的原因，根本没法安装 Go，基本卡着不动。此外还有一些其他的解决方案，比如 <a href="https://github.com/syndbg/goenv" target="_blank" rel="noopener">goenv</a>
，这是仿照 pyenv 和 rbenv 实现的，安装配置感觉略微有点复杂，直接没尝试。</p>
<p>今天发现另外一个工具，和我手动管理多版本的思路类似，所以爱上了！</p>
<h2 id="1开发-goup-的初衷">1、开发 goup 的初衷</h2>
<p>发音：Go Up。作者介绍，他开发了这个工具的原因：</p>
<p>1）操作系统发行版的包管理工具一般不会那么及时的升级 Go 到最新版本，特别是 Linux 发行版；</p>
<p>2）虽然安装和管理 Go 版本的工具不少，但作者认为要么存在一些问题，要么体验不好或缺失一些功能；（哈哈哈，很有道理是不是？造一个轮子，总是觉得别人的不够圆，自己的又大又圆，有木有？）</p>
<p>作者想要一个这样的工具：</p>
<ul>
<li>不需要先安装了 Go 的某个版本；（我上面的管理方案就是需要先安装某个版本）</li>
<li>这个工具本身安装足够简单，最好一行命令搞定；</li>
<li>跨平台，在所有操作系统运行良好，至少在类 Unix 系统运行良好；</li>
<li>能方便的安装最新的 Go 版本；</li>
<li>能方便的安装 Go 的任意版本，包括 tip；</li>
<li>不会污染你的 Shell；</li>
<li>使用 Go 语言实现；</li>
</ul>
<h2 id="2安装-goup">2、安装 goup</h2>
<p>因为 goup 本身是 Go 语言实现的，因此他通过一个脚本下载对应系统的预编译 goup 程序。当前最新版本 0.0.7 （这个工具是 9 月底开发的），当然你也可以自己手动下载这些编译好 goup 程序。（如果你本地安装了 Go 版本，直接 go get -u -v github.com/owenthereal/goup 安装也是可以的）</p>
<p><p class="md__image">
  <img src="../imgs/goup01.png"
    alt=""  />
</p>
</p>
<p>一行代码安装 goup（推荐的方式）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl -sSf https://raw.githubusercontent.com/owenthereal/goup/master/install.sh <span class="p">|</span> sh
</code></pre></div><h2 id="3使用介绍">3、使用介绍</h2>
<p>看看 goup 的帮助文档：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ goup <span class="nb">help</span>
The Go installer

Usage:
  goup <span class="o">[</span>command<span class="o">]</span>

Available Commands:
  <span class="nb">help</span>        Help about any <span class="nb">command</span>
  init        Initialize the goup environment file.
  install     Install Go by providing a version <span class="o">(</span>e.g. <span class="s2">&#34;1.15.2&#34;</span>, or <span class="s2">&#34;tip&#34;</span><span class="o">)</span>. If empty, use the latest version.
  show        Show the current version of installed Go
  version     Show goup version

Flags:
  -h, --help   <span class="nb">help</span> <span class="k">for</span> goup

Use <span class="s2">&#34;goup [command] --help&#34;</span> <span class="k">for</span> more information about a command.
</code></pre></div><ul>
<li>install：安装对应的 Go 版本，也可以是 tip。如果不提供版本，则安装当前最新版本；</li>
<li>show：显示当前生效的 Go 版本；</li>
<li>init：会在 <code>$HOME/.go</code> 目录下生成一个 env 文件，内容是设置 PATH 环境变量，即将 <code>$HOME/.go/bin</code> 和 <code>$HOME/.go/current/bin</code> 加入 PATH 中；同时会往一些系统配置文件中加上 <code>source &quot;$HOME/.go/env&quot;</code>；</li>
</ul>
<p>比如我想试试还不支持 Module 的版本：1.10.8</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ goup install 1.10.8
Downloaded   0.0% <span class="o">(</span>    <span class="m">3320</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded   3.7% <span class="o">(</span> <span class="m">3260416</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  11.7% <span class="o">(</span><span class="m">10338304</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  21.1% <span class="o">(</span><span class="m">18563072</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  27.9% <span class="o">(</span><span class="m">24592384</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  34.8% <span class="o">(</span><span class="m">30588928</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  41.6% <span class="o">(</span><span class="m">36618240</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  48.4% <span class="o">(</span><span class="m">42549248</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  55.2% <span class="o">(</span><span class="m">48611328</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  62.1% <span class="o">(</span><span class="m">54640640</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  68.9% <span class="o">(</span><span class="m">60669952</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  75.8% <span class="o">(</span><span class="m">66666496</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  82.6% <span class="o">(</span><span class="m">72695808</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  88.8% <span class="o">(</span><span class="m">78135296</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  93.3% <span class="o">(</span><span class="m">82100224</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  94.4% <span class="o">(</span><span class="m">83083264</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  98.7% <span class="o">(</span><span class="m">86851584</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded 100.0% <span class="o">(</span><span class="m">87999054</span> / <span class="m">87999054</span> bytes<span class="o">)</span>
INFO<span class="o">[</span>0016<span class="o">]</span> Unpacking /Users/xuxinhua/.go/go1.10.8/go1.10.8.darwin-amd64.tar.gz ...
INFO<span class="o">[</span>0020<span class="o">]</span> Success: go1.10.8 downloaded in /Users/xuxinhua/.go/go1.10.8
INFO<span class="o">[</span>0020<span class="o">]</span> Default Go is <span class="nb">set</span> to <span class="s1">&#39;go1.10.8&#39;</span>
</code></pre></div><p>你当前系统的 Go 版本就是 1.10.8 了。如果之前安装过，上面的下载过程就没有了：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ goup install 1.10.8
INFO<span class="o">[</span>0000<span class="o">]</span> go1.10.8: already downloaded in /Users/xuxinhua/.go/go1.10.8
INFO<span class="o">[</span>0000<span class="o">]</span> Default Go is <span class="nb">set</span> to <span class="s1">&#39;go1.10.8&#39;</span>

$ goup show
go1.10.8
</code></pre></div><p>尽情地享受吧！</p>
<h2 id="4工作原理">4、工作原理</h2>
<p>这个工具的灵感来自 Rust 的工具：<a href="https://rustup.rs/" target="_blank" rel="noopener">rustup</a>
。</p>
<p>它的工作原理很简单，在 <code>$HOME/.go</code> 目录下创建对应的版本目录，然后在这个目录创建一个软链 current 来控制当前使用哪个 Go 版本。这个思路和我一直源码安装的思路类似。唯一区别是，它是从 dl.google.com 上下载对应编译好的版本。但 tip 版本，则需要 clone Go 源码，进行编译安装，因此要求有 Go 环境。</p>
<p>我本地 <code>$HOME/.go</code> 下的文件信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">lrwxr-xr-x   <span class="m">1</span> xuxinhua  staff   <span class="m">28</span> <span class="m">10</span>  <span class="m">9</span> 17:16 current -&gt; /Users/xuxinhua/.go/go1.10.8
-rw-r--r--   <span class="m">1</span> xuxinhua  staff   <span class="m">57</span> <span class="m">10</span>  <span class="m">9</span> 16:46 env
drwxr-xr-x  <span class="m">21</span> xuxinhua  staff  <span class="m">672</span> <span class="m">10</span>  <span class="m">9</span> 17:14 go1.10.8
drwxr-xr-x  <span class="m">22</span> xuxinhua  staff  <span class="m">704</span> <span class="m">10</span>  <span class="m">9</span> 10:03 go1.14.9
drwxr-xr-x  <span class="m">22</span> xuxinhua  staff  <span class="m">704</span> <span class="m">10</span>  <span class="m">9</span> 10:02 go1.15.2
drwxr-xr-x   <span class="m">2</span> xuxinhua  staff   <span class="m">64</span> <span class="m">10</span>  <span class="m">9</span> 17:10 gotip
</code></pre></div><h2 id="5存在的一些问题">5、存在的一些问题</h2>
<p>这个工具才出来十几天，试用下来，还存在一些问题：</p>
<ul>
<li>安装最新版本，需要知道当前最新版本是哪个？这是从 <a href="https://golang.org/VERSION?m=text">https://golang.org/VERSION?m=text</a> 获取的，但这个网址咱们无法访问；同样的道理，安装 tip 版本，源码是从 <a href="https://go.googlesource.com/go">https://go.googlesource.com/go</a> 获取的。因此目前大陆还无法使用；不过我已经给作者提了 issue，应该很快就会支持；</li>
<li>缺失一些功能。比如我想安装某个版本，比如 1.12.x，但我希望安装的是 1.12 系列的最新版本，这时候你只能去找 1.12 的最新版本是哪个。</li>
<li>。。。</li>
</ul>
<p>我参照 gvm 提供的功能，给 goup 作者提了 issue，希望增加如下功能：</p>
<ul>
<li>goup list 和 goup listall</li>
<li>goup uninstall</li>
</ul>
<h2 id="6小结">6、小结</h2>
<p>整体上，目前 goup 的使用还是比较顺畅的。欢迎大家试用，可以顺便给个 star。对了，项目地址：<a href="https://github.com/owenthereal/goup">https://github.com/owenthereal/goup</a>。</p>
<p>对了，至于为什么会需要管理多版本，我想很多人还会有这样的需求吧？！你为什么需要呢？欢迎留言。</p>
]]></content>
		</item>
		
		<item>
			<title>何时使用 Rust 和何时使用 Golang</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/when-to-use-rust-and-when-to-use-golang/</link>
			<pubDate>Wed, 30 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/when-to-use-rust-and-when-to-use-golang/</guid>
			<description>Golang 和 Rust 之间有明显的区别。Golang 更加注重构建可以无限扩展的 Web API 和小型服务，尤其是在 goroutine 的强大支持下。Rust 也可以用于小型服务，但是从开发</description>
			<content type="html"><![CDATA[<p><p class="md__image">
  <img src="../imgs/use-rust-go01.png"
    alt="何时使用Rust和何时使用Golang"  />
</p>
</p>
<p>Golang 和 Rust 之间有明显的区别。Golang 更加注重构建可以无限扩展的 Web API 和小型服务，尤其是在 goroutine 的强大支持下。Rust 也可以用于小型服务，但是从开发人员的经验来看，事情要困难得多。</p>
<p>Rust 非常适合处理大量数据和其他 CPU 密集型操作，例如执行算法。这是 Rust 超过 Golang 的最大优势。要求高性能的项目通常更适合 Rust。</p>
<p>在本教程中，我们将就 Golang 和 Rust 进行比较和对比，评估这两种编程语言的性能，并发性，内存管理和整体开发人员体验。我们还将概述这些元素，以帮助您一目了然地为项目选择正确的语言。</p>
<p>如果您刚开始使用 Rust，那么在继续阅读之前，最好先阅读一下<a href="https://blog.logrocket.com/getting-up-to-speed-with-rust/" target="_blank" rel="noopener">初学者指南</a>
。</p>
<p>如果您全都都准备好了，那就让我们开始吧！</p>
<h2 id="性能">性能</h2>
<p>Golang 最初是由 Google 的工程师设计的，于 2009 年向公众推出。它的创建是为 C++提供替代方案，该替代方案易于学习和编码，并且经过优化可在多核 CPU 上运行。</p>
<p>从那时起，Golang 对于希望利用该语言提供的并发性的开发人员来说非常有用。该语言提供了 goroutine，使您可以将函数作为 goroutine 运行。</p>
<p>Golang 的一大优势是您可以轻松使用 goroutines。只需将<code>go</code>添加到函数前即可使其作为 goroutine 运行。Golang 的并发模型允许您跨多个 CPU 内核部署工作负载，从而使其成为一种非常有效的语言。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">f</span><span class="p">(</span><span class="nx">from</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="nf">f</span><span class="p">(</span><span class="s">&#34;direct&#34;</span><span class="p">)</span>

    <span class="k">go</span> <span class="nf">f</span><span class="p">(</span><span class="s">&#34;goroutine&#34;</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>尽管有多核 CPU 支持，Rust 仍然跑赢 Golang。Rust 在执行算法和资源密集型操作方面效率更高。该<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html" target="_blank" rel="noopener">基准测试游戏</a>
比较了 rust 和 golang 的不同算法，如二叉树。对于所有经过测试的算法，Rust 至少快 30％；在二叉树计算的情况下，最高可达 1,000％。<a href="https://bitbucket.org/blog/why-rust" target="_blank" rel="noopener">Bitbucket 的</a>
一项研究表明，Rust 与 C++的性能相似。</p>
<p><p class="md__image">
  <img src="../imgs/use-rust-go02.png"
    alt="根据Bitbucket的性能"  />
</p>
</p>
<p><em>（来源：<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html" target="_blank" rel="noopener">基准测试游戏</a>
）</em></p>
<h2 id="并发">并发</h2>
<p>如上所述，Golang 支持并发。例如，假设您正在运行一个处理 API 请求的 Web 服务器。您可以使用 Golang 的 goroutine 程序将每个请求作为 goroutine 运行，通过将任务分发到所有可用的 CPU 内核来最大程度地提高效率。</p>
<p>Goroutines 是 Golang 内置功能的一部分，而 Rust 仅支持本地 async/await 语法来支持并发。因此，在并发方面，Golang 的开发人员有经验优势。但是，Rust 在保证内存安全方面要好得多。</p>
<p>这是 Rust 的简化线程的示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">time</span>::<span class="n">Duration</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">   </span><span class="c1">// 1. create a new thread
</span><span class="c1"></span><span class="w">   </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">         </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;thread: number {}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">         </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span><span class="w">
</span><span class="w">      </span><span class="p">}</span><span class="w">
</span><span class="w">   </span><span class="p">});</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;hi from the main thread!&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>并发一直是开发人员的棘手问题。在不影响开发人员体验的情况下保证内存安全的并发性并不是一项容易的任务。但是，这种极端的安全重点导致创建了<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" target="_blank" rel="noopener">可证明正确的并发</a>
。Rust 尝试使用所有权概念来防止未经请求的资源访问，以防止出现内存安全错误。</p>
<p>Rust 提供了四种不同的并发范例，以帮助您避免常见的内存安全陷阱。我们将仔细研究两个常见的范例：channel 和锁。</p>
<h3 id="channel">Channel</h3>
<p><a href="https://doc.rust-lang.org/stable/rust-by-example/std_misc/channels.html" target="_blank" rel="noopener">channel</a>
 有助于从一个线程传送消息到另一个。虽然 Golang 也存在此概念，但 Rust 允许您将<a href="https://doc.rust-lang.org/std/primitive.pointer.html" target="_blank" rel="noopener">指针</a>
从一个线程转移到另一个线程，以避免争用资源。通过传递指针，Rust 可以对 channel 强制执行线程隔离。同样，Rust 在并发模型方面表现出对内存安全的痴迷。</p>
<h3 id="锁">锁</h3>
<p>仅当持有<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html" target="_blank" rel="noopener">锁</a>
时才能访问数据。Rust 依赖于锁定数据而不是 cod 的原理，而 cod 经常在诸如 Java 之类的编程语言中找到。</p>
<p>有关所有权和所有并发范例的更多详细信息，请查看“<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" target="_blank" rel="noopener">使用 Rust 进行无所畏惧的并发</a>
”。</p>
<h2 id="内存安全">内存安全</h2>
<p>较早的所有权概念是 Rust 的主要卖点之一。Rust 将<a href="https://en.wikipedia.org/wiki/Type_safety" target="_blank" rel="noopener">类型安全</a>
提升到了新的水平，这对于实现内存安全的并发性也很重要。</p>
<p>根据<a href="https://bitbucket.org/blog/why-rust" target="_blank" rel="noopener">Bitbucket 博客</a>
，“ Rust 非常严格和繁琐的编译器会检查您使用的每个变量以及您引用的每个内存地址。它避免了可能发生的数据争用情况，并通知您未定义的行为。”</p>
<p>这意味着由于 Rust 对内存安全性的极度痴迷，您最终不会出现缓冲区溢出或争用情况。但是，这也有其缺点。例如，您在编写代码时必须非常了解内存分配原则。始终保持您的内存安全防护并不容易。</p>
<h2 id="开发人员体验">开发人员体验</h2>
<p>首先，让我们看一下每种语言的学习曲线。Golang 在设计时考虑了简单性。开发人员经常将其称为“无聊”语言，也就是说，其有限的内置功能集使 Golang 易于学习、使用。</p>
<p>此外，Golang 提供了比 C++更简单的替代方案，隐藏了诸如内存安全性和内存分配等方面的内容。Rust 采用了另一种方法，迫使您考虑诸如内存安全性的概念。所有权的概念和传递指针的能力使 Rust 失去了学习的吸引力。当您不断考虑内存安全性时，您的工作效率就会降低，并且您的代码注定会变得更加复杂。</p>
<p>与 Golang 相比，Rust 的学习曲线非常陡峭。值得一提的是，与 Python 和 JavaScript 等动态语言相比，Golang 的学习曲线较为陡峭。</p>
<h2 id="何时使用-golang">何时使用 Golang</h2>
<p>Go 在各种用例中都能很好地工作，使其成为创建 Web API 的 Node.js 的绝佳替代品。正如<a href="https://kristoff.it/blog/why-go-and-not-rust/" target="_blank" rel="noopener">Loris Cro</a>
指出的那样，“ Go 的并发模型非常适合必须处理多个独立请求的服务器端应用程序”。这正是 Golang 提供 goroutines 的原因。</p>
<p>此外，Golang 内置了对 HTTP Web 协议的支持。您可以使用内置的 HTTP 支持快速设计一个小型 API，并将其作为微服务运行。因此，Golang 非常适合微服务架构并满足 API 开发人员的需求。</p>
<p>简而言之，如果您重视开发速度并且更喜欢语法简单而不是性能，那么 Golang 是一个很好的选择。最重要的是，Golang 提供了更好的代码可读性，这对于大型开发团队而言是一个重要标准。</p>
<p>在以下情况下选择 Golang：</p>
<ul>
<li>您关心简单性和可读性</li>
<li>您需要一种简单的语法来快速编写代码</li>
<li>您想使用支持 Web 开发的更灵活的语言</li>
</ul>
<h2 id="何时使用-rust">何时使用 Rust</h2>
<p>当性能很重要时，例如在处理大量数据时，Rust 是一个不错的选择。此外，Rust 为您提供了对线程行为以及线程之间资源共享方式的细粒度控制。</p>
<p>另一方面，Rust 具有陡峭的学习曲线，并且由于内存安全性的额外复杂性而减慢了开发速度。这并不一定是不利的。Rust 还保证当编译器检查每个数据指针时，您不会遇到内存安全性错误。对于复杂的系统，此保证会派上用场。</p>
<p>在以下情况下选择 Rust：</p>
<ul>
<li>您关心性能</li>
<li>您想要对线程进行细粒度的控制</li>
<li>您重视内存安全而不是简单性</li>
</ul>
<h2 id="go-vs-rust我的大实话">Go vs. Rust：我的大实话</h2>
<p>让我们从突出相似之处开始。Go 和 Rust 都是开源的，旨在支持微服务架构和并行计算环境。两者都通过并发优化了可用 CPU 内核的利用率。</p>
<p>但归根结底，哪种语言是最好的？</p>
<p>有很多方法可以解决这个问题。我建议考虑要构建哪种类型的应用程序。Golang 可很好地用于创建 Web 应用程序和 API，这些应用程序和 API 利用其内置的并发功能，同时支持微服务体系结构。</p>
<p>您还可以使用 Rust 来开发 Web API，但并不是在设计时考虑到此用例。Rust 对内存安全性的关注增加了复杂性和开发时间，尤其是对于相当简单的 Web API。但是，对代码的大量控制使您可以编写更优化，内存效率更高且性能更高的代码。</p>
<p>简而言之，Golang 与 Rust 的争论实际上是一个简单与安全的问题。</p>
<p>有关更多观点，请查看“<a href="https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/" target="_blank" rel="noopener">在 Go 和 Rust 之间选择</a>
”。</p>
<h2 id="logrocket全面了解线上-rust-应用程序">LogRocket：全面了解线上 Rust 应用程序</h2>
<p>调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能，自动显示错误以及跟踪缓慢的网络请求和加载时间感兴趣，请<a href="https://logrocket.com/signup" target="_blank" rel="noopener">尝试 LogRocket</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/use-rust-go03.png"
    alt="LogRocket仪表板免费试用横幅"  />
</p>
</p>
<p><a href="https://logrocket.com/signup" target="_blank" rel="noopener">LogRocket</a>
就像 Web 应用程序的 DVR，实际上记录了 Rust 应用程序中发生的所有事情。您可以汇总并报告问题发生时应用程序所处的状态，而不用猜测为什么会发生问题。LogRocket 还监视您的应用程序的性能，报告诸如客户端 CPU 负载，客户端内存使用情况等指标。</p>
<blockquote>
<p>原文链接：https://blog.logrocket.com/when-to-use-rust-and-when-to-use-golang/</p>
<p>原文作者：Michiel Mulders</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>这么一道“简单”的题，为什么结果出乎我的意料</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/</link>
			<pubDate>Sun, 27 Sep 2020 14:52:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/</guid>
			<description>今天在《Go语言爱好者周刊：第62期》 中贴了一道 Go101 的题，原题如下： package main const s = &amp;#34;Go101.org&amp;#34; // len(s) == 9 // 1 &amp;lt;&amp;lt; 9 == 512 // 512 / 128 == 4 var a byte = 1 &amp;lt;&amp;lt; len(s) / 128 var b byte = 1 &amp;lt;&amp;lt;</description>
			<content type="html"><![CDATA[<p>今天在<a href="https://mp.weixin.qq.com/s/xvlAcDBqb77HUzTo7gjuCw" target="_blank" rel="noopener">《Go语言爱好者周刊：第62期》</a>
中贴了一道 Go101 的题，原题如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">const</span> <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;Go101.org&#34;</span>
<span class="c1">// len(s) == 9
</span><span class="c1">// 1 &lt;&lt; 9 == 512
</span><span class="c1">// 512 / 128 == 4
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>答案是 4 0。</p>
<p>不少人对这个结果应该很吃惊，因为从答题结果看，不到一半的人答对了。而且，如果只给 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，没有 a 对比，我想答对的人会更少。因为有对比，很多人虽然直觉是 4 4，但想到一定有陷阱，所以会重新思考。</p>
<p>好几个群都问，为什么结果会是 4 0，希望我解释下。因此有了此文。</p>
<p>这个小题涉及到几个知识点。</p>
<h2 id="len-函数的结果">len 函数的结果</h2>
<p>要注意，len 是一个内置函数。在官方标准库文档<a href="https://docs.studygolang.com/pkg/builtin/#len" target="_blank" rel="noopener">关于 len 函数</a>
有这么一句：</p>
<blockquote>
<p>For some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification&rsquo;s &ldquo;Length and capacity&rdquo; section for details.</p>
</blockquote>
<p>明确支持，当参数是字符串字面量和简单 array 表达式，len 函数返回值是常量，这很重要。</p>
<p>上题中，如果 <code>const s = &quot;Go101.org”</code> 改为 <code>var s = &quot;Go101.org&quot;</code> 结果又会是什么呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;Go101.org&#34;</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果是 0 0。</p>
<p>但改为这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;G&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="sc">&#39;g&#39;</span><span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果又是 4 0。</p>
<p>接着看文档那句话的后半句，查看 Go 语言规范中<a href="https://hao.studygolang.com/golang_spec.html#id221" target="_blank" rel="noopener">关于长度和容量的说明</a>
。</p>
<blockquote>
<p>内置函数 len 和 cap 获取各种类型的实参并返回一个 int 类型结果。实现会保证结果总是一个 int 值。</p>
<p>如果 s 是一个字符串常量，那么 len(s) 是一个常量 。如果 s 类型是一个数组或到数组的指针且表达式 s 不包含 信道接收 或（非常量的） 函数调用的话， 那么表达式 len(s) 和 cap(s) 是常量；这种情况下， s 是不求值的。否则的话， len 和 cap 的调用结果不是常量且 s 会被求值。</p>
</blockquote>
<p>可见题目中：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>
</code></pre></div><p>第一句的 len(s) 是常量（因为 s 是字符串常量）；而第二句的 len(s[:]) 不是常量。这是这两条语句的唯一区别：两个 len 的返回结果数值并无差异，都是 9，但一个是常量一个不是。</p>
<h2 id="关于位移操作">关于位移操作</h2>
<p>根据上面的分析，现在问题的关键在于位移运算这里。Go 语言规范中有<a href="https://docs.studygolang.com/ref/spec#Operators" target="_blank" rel="noopener">这么一句</a>
：</p>
<blockquote>
<p>The right operand in a shift expression must have integer type or be an untyped constant representable by a value of type uint. If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.</p>
</blockquote>
<p>大意是：在位移表达式的右侧的操作数必须为整数类型，或者可以被 uint 类型的值所表示的无类型的常量。如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型。</p>
<p>这里的关键在于常量位移表达式。根据上文的分析，<code>1 &lt;&lt; len(s)</code> 是常量位移表达式，而 <code>1 &lt;&lt; len(s[:])</code> 不是。</p>
<p>规范上关于常量表达式中，还有<a href="https://docs.studygolang.com/ref/spec#Constant_expressions" target="_blank" rel="noopener">这么一句</a>
：</p>
<blockquote>
<p>If the left operand of a constant shift expression is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of integer type.</p>
</blockquote>
<p>大意是：如果常量 位移表达式 的左侧操作数是一个无类型常量，那么其结果是一个整数常量；否则就是和左侧操作数同一类型的常量（必须是 整数类型 ）</p>
<p>因此对于 <code>var a byte = 1 &lt;&lt; len(s) / 128</code>，因为 <code>1 &lt;&lt; len(s)</code> 是一个常量位移表达式，因此它的结果也是一个整数常量，所以是 512，最后除以 128，最终结果就是 4。</p>
<p>而对于 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，因为 <code>1 &lt;&lt; len(s[:])</code> 不是一个常量位移表达式，而做操作数是 1，一个无类型常量，根据规范定义它是 byte 类型（根据：如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型）。</p>
<p>为什么是 byte 类型，大家可能还是有点晕。这要回到关于常量的说明上。</p>
<h3 id="常量">常量</h3>
<p>常量是在编译的时候进行计算的。在 Go 语言中，常量分两种：无类型和有类型。Go 规范上说，字面值常量， true , false , iota 以及一些仅包含无类型的恒定操作数的 常量表达式 是无类型的。</p>
<p>那有类型常量是怎么来的呢？一般有两种：显示声明或隐式得到。比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">a</span> <span class="kt">int32</span> <span class="p">=</span> <span class="mi">23</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">0.1</span>
</code></pre></div><p>无类型常量都有一个默认类型（无类型常量的默认类型分别是 bool , rune , int , float64 , complex128 或 string）。当在上下文中需要请求该常量为一个带类型的值时，这个 默认类型 便指向该常量隐式转换后的类型。</p>
<p>所以 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code> 中，根据规范定义，1 会隐式转换为 byte 类型，因此 <code>1 &lt;&lt; len(s[:])</code> 的结果也是 byte 类型，而 byte 类型最大只能表示 255，很显然 512 溢出了，结果为 0，因此最后 b 的结果也是 0。</p>
<h2 id="小结">小结</h2>
<p>一道很具迷惑性的题目引出这么多小知识点。可能有人要喷：讨论这些有什么用？这也太细节了。我想说的是，Go 语言规范，细节点很多，能多掌握一些没坏处，说不定将来实际工作就遇到了类似的问题呢？！以上的知识点，很细节，但我认为也是挺有价值的。</p>
<p>当然了，你怎么说都行，你都是对的，你开心就好！</p>
]]></content>
		</item>
		
		<item>
			<title>在 iOS 和 Android 上运行 Go 代码</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/running-go-code-on-ios-and-android/</link>
			<pubDate>Mon, 14 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/running-go-code-on-ios-and-android/</guid>
			<description>在本教程中，我们将构建一个简单的 Go 包，您可以从 iOS 应用程序（Swift）和 Android 应用程序（Kotlin）运行该软件包。 本教程不会使用go mobile 框架。相</description>
			<content type="html"><![CDATA[<p>在本教程中，我们将构建一个简单的 Go 包，您可以从 iOS 应用程序（Swift）和 Android 应用程序（Kotlin）运行该软件包。</p>
<p>本教程不会使用<a href="https://github.com/golang/mobile" target="_blank" rel="noopener">go mobile</a>
 框架。相反，它使用 Cgo 构建可导入到您的移动项目中的原始静态（iOS）和共享（Android） C 库（Go Mobile 框架在后台进行此操作）。</p>
<h2 id="构建">构建</h2>
<p>在本教程中，我们将创建具有以下结构的简单 monorepo：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">.
├── android/
├── go/
│   ├── cmd/
│   │   └── libfoo/
│   │       └── main.go
│   ├── foo/
│   │   └── foo.go
│   ├── go.mod
│   └── go.sum
└── ios/
$ mkdir -p android ios go/cmd/libfoo go/foo
</code></pre></div><p>我们将从 Go 代码开始，稍后再返回创建 iOS 和 Android 项目。</p>
<div class="highlight"><pre class="chroma"><code class="language-zsh" data-lang="zsh">$ <span class="nb">cd</span> go
$ go mod init rogchap.com/libfoo
</code></pre></div><h2 id="foo-包">Foo 包</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// go/foo/foo.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">foo</span>

<span class="c1">// Reverse reverses the given string by each utf8 character
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Reverse</span><span class="p">(</span><span class="nx">in</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="kt">rune</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">))</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
        <span class="kt">rune</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">r</span>
        <span class="nx">n</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="kt">rune</span> <span class="p">=</span> <span class="kt">rune</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">n</span><span class="p">]</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="kt">rune</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="kt">rune</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kt">rune</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">],</span> <span class="kt">rune</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="kt">rune</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们的<code>foo</code>程序包有一个函数<code>Reverse</code>，该函数具有单个字符串参数<code>in</code>和单个字符串输出。</p>
<h2 id="导出为-c">导出为 C</h2>
<p>为了使我们的 C 库调用我们的<code>foo</code>包，我们需要导出所有要公开给 C 的函数，并带有特殊<code>export</code>注释。该包装器必须位于<code>main</code>包装中：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// go/cmd/libfoo/main.go
</span><span class="c1"></span><span class="nx">pacakge</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;C&#34;</span>

<span class="c1">// other imports should be seperate from the special Cgo import
</span><span class="c1"></span><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;rogchap.com/libfoo/foo&#34;</span>
<span class="p">)</span>

<span class="c1">//export reverse
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">in</span> <span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)</span> <span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">C</span><span class="p">.</span><span class="nf">CString</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nf">Reverse</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nf">GoString</span><span class="p">(</span><span class="nx">in</span><span class="p">)))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div><p>我们正在使用特殊的 <code>C.GoString()</code>和<code>C.CString()</code>函数在 Go 字符串和 C 字符串之间进行转换。</p>
<p>*注意：*我们要导出的函数不必是导出的 Go 函数（即以大写字母开头）。还要注意是空<code>main</code>函数；这对于 Go 代码进行编译是必需的，否则会出现 <code>function main is undeclared in the main package</code>错误。</p>
<p>让我们通过使用 <code>-buildmode</code> 标志创建一个静态 C 库来测试我们的构建：</p>
<pre><code>go build -buildmode=c-archive -o foo.a ./cmd/libfoo
</code></pre><p>这应该已经输出了 C 库：<code>foo.a</code>和头文件：<code>foo.h</code>。您应该在头文件的底部看到导出的函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="k">extern</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">reverse</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">in</span><span class="p">);</span>
</code></pre></div><h2 id="为-ios-构建">为 iOS 构建</h2>
<p>我们的目标是创建一个可以在 iOS 设备和 iOS 模拟器上使用的 <a href="https://en.wikipedia.org/wiki/Fat_binary" target="_blank" rel="noopener">Fat 二进制文件</a>
。</p>
<p>Go 标准库包含用于构建 iOS 的脚本： <a href="https://golang.org/misc/ios/clangwrap.sh" target="_blank" rel="noopener"><code>$GOROOT/misc/ios/clangwrap.sh</code></a>
，但是该脚本仅针对生成<code>arm64</code>，而<code>x86_64</code>iOS Simulator 也需要该脚本 。因此，我们将创建自己的<code>clangwrap.sh</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/sh
</span><span class="cp"></span>
<span class="c1"># go/clangwrap.sh</span>

<span class="nv">SDK_PATH</span><span class="o">=</span><span class="sb">`</span>xcrun --sdk <span class="nv">$SDK</span> --show-sdk-path<span class="sb">`</span>
<span class="nv">CLANG</span><span class="o">=</span><span class="sb">`</span>xcrun --sdk <span class="nv">$SDK</span> --find clang<span class="sb">`</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$GOARCH</span><span class="s2">&#34;</span> <span class="o">==</span> <span class="s2">&#34;amd64&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">CARCH</span><span class="o">=</span><span class="s2">&#34;x86_64&#34;</span>
<span class="k">elif</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$GOARCH</span><span class="s2">&#34;</span> <span class="o">==</span> <span class="s2">&#34;arm64&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">CARCH</span><span class="o">=</span><span class="s2">&#34;arm64&#34;</span>
<span class="k">fi</span>

<span class="nb">exec</span> <span class="nv">$CLANG</span> -arch <span class="nv">$CARCH</span> -isysroot <span class="nv">$SDK_PATH</span> -mios-version-min<span class="o">=</span>10.0 <span class="s2">&#34;</span><span class="nv">$@</span><span class="s2">&#34;</span>
</code></pre></div><p>不要忘记让它可执行：</p>
<pre><code>chmod +x clangwrap.sh
</code></pre><p>现在，我们可以为每种体系结构构建库，并使用该<code>lipo</code>工具（通过 Makefile）合并为 Fat 二进制文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-makefile" data-lang="makefile"><span class="c"># go/Makefile
</span><span class="c"></span>
<span class="nf">ios-arm64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>darwin <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>arm64 <span class="se">\
</span><span class="se"></span>	<span class="nv">SDK</span><span class="o">=</span>iphoneos <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>PWD<span class="k">)</span>/clangwrap.sh <span class="se">\
</span><span class="se"></span>	<span class="nv">CGO_CFLAGS</span><span class="o">=</span><span class="s2">&#34;-fembed-bitcode&#34;</span> <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-archive -tags ios -o <span class="k">$(</span>IOS_OUT<span class="k">)</span>/arm64.a ./cmd/libfoo

<span class="nf">ios-x86_64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>darwin <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>amd64 <span class="se">\
</span><span class="se"></span>	<span class="nv">SDK</span><span class="o">=</span>iphonesimulator <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>PWD<span class="k">)</span>/clangwrap.sh <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-archive -tags ios -o <span class="k">$(</span>IOS_OUT<span class="k">)</span>/x86_64.a ./cmd/libfoo

<span class="nf">ios</span><span class="o">:</span> <span class="n">ios</span>-<span class="n">arm</span>64 <span class="n">ios</span>-<span class="n">x</span>86<span class="n">_</span>64
	lipo <span class="k">$(</span>IOS_OUT<span class="k">)</span>/x86_64.a <span class="k">$(</span>IOS_OUT<span class="k">)</span>/arm64.a -create -output <span class="k">$(</span>IOS_OUT<span class="k">)</span>/foo.a
	cp <span class="k">$(</span>IOS_OUT<span class="k">)</span>/arm64.h <span class="k">$(</span>IOS_OUT<span class="k">)</span>/foo.h
</code></pre></div><h2 id="创建我们的-ios-应用程序">创建我们的 iOS 应用程序</h2>
<p>使用 XCode，我们可以创建一个简单的单页应用程序。我将使用 Swift UI，但这与 UIKit 一样容易：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// ios/foobar/ContentView.swift</span>

<span class="kd">struct</span> <span class="nc">ContentView</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>

    <span class="p">@</span><span class="n">State</span> <span class="kd">private</span> <span class="kd">var</span> <span class="nv">txt</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>

    <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
        <span class="n">VStack</span><span class="p">{</span>
            <span class="n">TextField</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="err">$</span><span class="n">txt</span><span class="p">)</span>
            <span class="p">.</span><span class="n">textFieldStyle</span><span class="p">(</span><span class="n">RoundedBorderTextFieldStyle</span><span class="p">())</span>
            <span class="n">Button</span><span class="p">(</span><span class="s">&#34;Reverse&#34;</span><span class="p">){</span>
                <span class="c1">// Reverse text here</span>
            <span class="p">}</span>
            <span class="n">Spacer</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="p">.</span><span class="n">padding</span><span class="p">(.</span><span class="n">all</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在 Xcode 中，将新生成的<code>foo.a</code> 和 <code>foo.h</code> 拖进我们的项目。为了使我们的 Swift 代码与我们的库互操作，我们需要创建一个桥接头文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// ios/foobar/foobar-Bridging-Header.h
</span><span class="c1"></span>
<span class="cp">#import &#34;foo.h&#34;
</span></code></pre></div><p>在 Xcode <code>Build Settings</code> 中，<code>Swift Compiler - General</code> 下，设置 <code>Objective-C Bridging Header</code> 为我们刚刚创建的文件：<code>foobar/foobar-Bridging-Header.h</code>。</p>
<p>我们还需要设置 <code>Library Search Paths</code> 为包括我们生成的头文件 <code>foo.h</code> 的目录。（当您将文件拖放到项目中时，Xcode 可能已经为您完成了此操作）。</p>
<p>现在我们可以从 Swift 调用函数，然后构建并运行：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// ios/foobar/ContentView.swift</span>

<span class="n">Button</span><span class="p">(</span><span class="s">&#34;Reverse&#34;</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nv">str</span> <span class="p">=</span> <span class="bp">reverse</span><span class="p">(</span><span class="nb">UnsafeMutablePointer</span><span class="p">&lt;</span><span class="nb">Int8</span><span class="p">&gt;(</span><span class="kr">mutating</span><span class="p">:</span> <span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">txt</span> <span class="k">as</span> <span class="n">NSString</span><span class="p">).</span><span class="n">utf8String</span><span class="p">))</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">txt</span> <span class="p">=</span> <span class="nb">String</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">cString</span><span class="p">:</span> <span class="n">str</span><span class="p">!,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span>
    <span class="c1">// don&#39;t forget to release the memory to the C String</span>
    <span class="n">str</span><span class="p">?.</span><span class="n">deallocate</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p><p class="md__image">
  <img src="https://rogchap.com/posts/img/libfoo_ios.gif"
    alt="libfoo ios应用程序"  />
</p>
</p>
<h2 id="创建-android-应用程序">创建 Android 应用程序</h2>
<p>使用 Android Studio，我们将创建一个新的 Android 项目。从 Project Templates 中选择 <code>Native C++</code>，这将创建一个带有 Empty Activity 的项目，该项目被配置为使用 Java Native Interface（JNI）。我们仍将选择 <code>Kotlin</code> 作为该项目的语言。</p>
<p>创建一个简单的 Activity 后，加上 <code>EditText</code> 和，<code>Button</code> 两个控件，为应用创建基本功能：</p>
<div class="highlight"><pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="c1">// android/app/src/main/java/com/rogchap/foobar/MainActivity.kt
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">MainActivity</span> <span class="p">:</span> <span class="n">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
        <span class="n">setContentView</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">layout</span><span class="p">.</span><span class="n">activity_main</span><span class="p">)</span>

        <span class="n">btn</span><span class="p">.</span><span class="n">setOnClickListener</span> <span class="p">{</span>
            <span class="n">txt</span><span class="p">.</span><span class="n">setText</span><span class="p">(</span><span class="n">reverse</span><span class="p">(</span><span class="n">txt</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">toString</span><span class="p">()))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
</span><span class="cm">     * A native method that is implemented by the &#39;native-lib&#39; native library,
</span><span class="cm">     * which is packaged with this application.
</span><span class="cm">     */</span>
    <span class="k">private</span> <span class="k">external</span> <span class="k">fun</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">str</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">String</span>

    <span class="k">companion</span> <span class="k">object</span> <span class="p">{</span>
        <span class="c1">// Used to load the &#39;native-lib&#39; library on application startup.
</span><span class="c1"></span>        <span class="k">init</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="n">loadLibrary</span><span class="p">(</span><span class="s2">&#34;native-lib&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>我们创建了（并调用）一个外部函数 <code>reverse</code>，我们需要在 JNI （C++）实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// android/app/src/main/cpp/native-lib.cpp
</span><span class="c1"></span>
<span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="p">{</span>
    <span class="n">jstring</span>
    <span class="nf">Java_com_rogchap_foobar_MainActivity_reverse</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Reverse text here
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>JNI 代码必须遵循约定才能在本机 C++ 和 Kotlin（JVM）之间互操作。</p>
<h2 id="为-android-构建">为 Android 构建</h2>
<p>在许多版本的 Android 和 NDK 中，JNI 与外部库的工作方式已发生变化。当前（也是最简单的方法）是将输出的库放置到一个特殊的 <code>jniLibs</code> 文件夹中，该文件夹将复制到我们的最终 APK 文件中。</p>
<p>与创建 Fat 二进制文件（就像我们在 iOS 中所做的那样）不同，我将每个体系结构放置在正确的文件夹中。同样，对于 JNI，约定很重要。</p>
<div class="highlight"><pre class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">//</span> <span class="err">go/Makefile</span>

<span class="nv">ANDROID_OUT</span><span class="o">=</span>../android/app/src/main/jniLibs
<span class="nv">ANDROID_SDK</span><span class="o">=</span><span class="k">$(</span>HOME<span class="k">)</span>/Library/Android/sdk
<span class="nv">NDK_BIN</span><span class="o">=</span><span class="k">$(</span>ANDROID_SDK<span class="k">)</span>/ndk/21.0.6113669/toolchains/llvm/prebuilt/darwin-x86_64/bin

<span class="nf">android-armv7a</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>arm <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARM</span><span class="o">=</span><span class="m">7</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/armv7a-linux-androideabi21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/armeabi-v7a/libfoo.so ./cmd/libfoo

<span class="nf">android-arm64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>arm64 <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/aarch64-linux-android21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/arm64-v8a/libfoo.so ./cmd/libfoo

<span class="nf">android-x86</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span><span class="m">386</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/i686-linux-android21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/x86/libfoo.so ./cmd/libfoo

<span class="nf">android-x86_64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>amd64 <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/x86_64-linux-android21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/x86_64/libfoo.so ./cmd/libfoo

<span class="nf">android</span><span class="o">:</span> <span class="n">android</span>-<span class="n">armv</span>7<span class="n">a</span> <span class="n">android</span>-<span class="n">arm</span>64 <span class="n">android</span>-<span class="n">x</span>86 <span class="n">android</span>-<span class="n">x</span>86<span class="n">_</span>64
</code></pre></div><p><strong>注意</strong>确保为您的 Android SDK 和已下载的 NDK 版本设置正确的位置。</p>
<p><code>make android</code> 将我们需要的所有共享库构建到正确的文件夹中。现在，我们需要将库添加到 CMake：</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="err">//</span> <span class="err">android/app/src/main/cpp/CMakeLists.txt
</span><span class="err">
</span><span class="err">//</span> <span class="err">...
</span><span class="err">
</span><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">lib_foo</span> <span class="s">SHARED</span> <span class="s">IMPORTED</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set_property</span><span class="p">(</span><span class="s">TARGET</span> <span class="s">lib_foo</span> <span class="s">PROPERTY</span> <span class="s">IMPORTED_NO_SONAME</span> <span class="s">1</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">lib_foo</span> <span class="s">PROPERTIES</span> <span class="s">IMPORTED_LOCATION</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/../jniLibs/</span><span class="o">${</span><span class="nv">CMAKE_ANDROID_ARCH_ABI</span><span class="o">}</span><span class="s">/libfoo.so</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/../jniLibs/</span><span class="o">${</span><span class="nv">CMAKE_ANDROID_ARCH_ABI</span><span class="o">}</span><span class="s">/</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err">//</span> <span class="err">...
</span><span class="err">
</span><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">native-lib</span> <span class="s">lib_foo</span> <span class="o">${</span><span class="nv">log-lib</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></code></pre></div><p>我花了一段时间才弄清楚这些设置，再次命名很重要，因此使用库命名 <code>lib_xxxx</code> 并设置属性很重要，同时设置 <code>IMPORTED_NO_SONAME 1</code>，否则您的 apk 会在错误的位置查找你的库。</p>
<p>现在，我们可以将 JN I 代码连接到 Go 库中，然后运行我们的应用程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// android/app/src/main/cpp/native-lib.cpp
</span><span class="c1"></span>
<span class="cp">#include</span> <span class="cpf">&#34;libfoo.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="p">{</span>
    <span class="n">jstring</span>
    <span class="nf">Java_com_rogchap_foobar_MainActivity_reverse</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cstr</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetStringUTFChars</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">cout</span> <span class="o">=</span> <span class="n">reverse</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">cstr</span><span class="p">));</span>
        <span class="n">jstring</span> <span class="n">out</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
        <span class="n">env</span><span class="o">-&gt;</span><span class="n">ReleaseStringUTFChars</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">cstr</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><p class="md__image">
  <img src="https://rogchap.com/posts/img/libfoo_android.gif"
    alt="libfoo android应用"  />
</p>
</p>
<h2 id="结论">结论</h2>
<p>Go 的优势之一就是它是跨平台的，这不仅意味着 Window，Mac 和 Linux，Go 还可以针对许多其他体系结构，包括 iOS 和 Android。现在，您可以在工具栏中找到另一个选项，以创建在服务器、移动应用程序甚至 Web（通过 Web 程序集）上运行的共享库。</p>
<p>本教程的所有代码均可在 GitHub 上获得：<a href="https://github.com/rogchap/libfoo">https://github.com/rogchap/libfoo</a></p>
<p>期待听到您使用 Go 构建的新杀手级应用程序。</p>
<blockquote>
<p>原文链接：https://rogchap.com/2020/09/14/running-go-code-on-ios-and-android/</p>
<p>作者：Roger Chapman</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>观点：Go 尚未准备好用于企业系统，原因在这里</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/golang-is-not-ready-for-enterprise-systems-yet-and-heres-why/</link>
			<pubDate>Sat, 12 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/golang-is-not-ready-for-enterprise-systems-yet-and-heres-why/</guid>
			<description>译注：发表这篇文章，不代表我认同作者的观点。大家都知道，在国内，Go 已经被很多大厂使用，早就可以用于企业系统。 对一门语言的爱，可以接受任何不</description>
			<content type="html"><![CDATA[<blockquote>
<p>译注：发表这篇文章，不代表我认同作者的观点。大家都知道，在国内，Go 已经被很多大厂使用，早就可以用于企业系统。</p>
<p>对一门语言的爱，可以接受任何不同的观点，真理总是越辩越明，相信有不同的声音，Go 也会越来越好。欢迎大家留言发表你的看法。</p>
</blockquote>
<h2 id="介绍">介绍</h2>
<p>企业应用程序是一个寿命长、可靠的系统，具有多年的持久数据。如今，Golang 的世界并没有提供以企业系统构建方式构建系统的可能性。</p>
<p><p class="md__image">
  <img src="../imgs/not-ready-enterprice01.png"
    alt="Martin Fowler 的“企业应用程序”"  />
</p>
</p>
<h2 id="golang-的发展文化">Golang 的发展文化</h2>
<p>让我们考虑几个问题，如错误处理不当、 手动组合的 SQL 查询和面向轮子开发。</p>
<h3 id="错误处理不当">错误处理不当</h3>
<p>Golang 在错误处理方面提供了更多的自由。由于开发人员方面缺乏责任，这通常会导致应用程序中的错误处理不当。</p>
<p>最常见的情况与 sql 查询的执行有关：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">defer</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span> <span class="c1">// omitted errors from sql driver
</span></code></pre></div><p>没有明确的方法来处理此返回的错误。实际上，该语言提供了捕获错误的特定方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">()</span>
</code></pre></div><p>该错误是一个典型的返回值，可以通过各种方式忽略：</p>
<pre><code>defer rows.Close() // omitted errors from sql driver
defer body.Close() // omitted IO errors
result, _ := foo() // omitted errors from foo function
</code></pre><p><p class="md__image">
  <img src="../imgs/not-ready-enterprice02.png"
    alt="sketch: Now you come to Me and you say “Don Gopher, handle Me.” But you don’t ask with respect. you don’t offer friendship."  />
</p>
</p>
<p>此外，它会导致应用程序在 panic 函数调用后立即崩溃的风险增加，并且通常会降低可靠性。</p>
<blockquote>
<p>根据 M.Nygard 的 “Release it!”，可靠的系统必须处理每个不重要的错误而不会崩溃。没有权衡。</p>
</blockquote>
<p>作为解决方案，我们可以使用其他语言的 try/catch/finally 结构添加可靠的机制。此外，还需要消除 panic 函数。当然，这将是一种较慢的方法，但更可靠。</p>
<hr>
<h3 id="手动编写-sql-查询语句">手动编写 SQL 查询语句</h3>
<p>Golang 中处理数据库查询的典型方法是手动编写查询。如果 <strong>SQL 查询被手工编写的</strong>，那么数据库集成将是一个<strong>瓶颈</strong>。并非所有开发人员都擅长 SQL 和使用数据库。诸如 Hibernate（Java）和 Entity Framework（.NET）之类的功能齐全的 ORM 生成的典型查询已开放，用于数据库和缓存数据优化。<strong>这是根据 ‘Release it’ 来编写可靠的应用程序的最有效方法之一。</strong></p>
<p>有些库将来可能是功能齐全的ORM（例如 GORM 和 XORM）。我相信，与手工编写的 SQL  查询相比，它们将来会更受欢迎。</p>
<h3 id="重新发明轮子">重新发明轮子</h3>
<p>通常，Golang 开发人员都在选择重新发明轮子。轮子无处不在：task scheduler，迁移工具，logger，worker pool，十进制数字的库，授权库和其他工具。</p>
<blockquote>
<p>它们没有经过良好的测试，没有良好的文档，在生产中使用不足。风险太高，不能在企业应用程序中使用它们。</p>
</blockquote>
<p>为了减少使用风险代码的可能性，检查是否有可用的解决方案。例如可以查看 <a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">awesome-go</a>
。</p>
<hr>
<h2 id="生态系统">生态系统</h2>
<p>Go 世界的生态系统包括 Consul, Kubernetes, Zipkin 和 Træfik 等。它是一个非常年轻且发展迅速的技术栈，没有公认的使用标准。</p>
<blockquote>
<p>Golang 生态系统中没有任何工具可以帮助建立可靠的企业系统。</p>
</blockquote>
<p>考虑到以上所有情况，我们需要非常谨慎地将第三方中间件集成到基础架构中，公司必须有足够的专业知识支持该过程。否则，它将成为具有不同技术的生产环境中的雷区。好消息是，市场有很多管理解决方案，以最大限度地降低风险。不幸的是，它很贵。</p>
<hr>
<p>Golang 生态系统太年轻，缺乏工具、编程文化，但我相信它将来会成为一个伟大的生态系统，并拥有伟大的程序员。语言社区正朝着正确的方向努力：性能和简化。但是，我们不能忘记可靠性也很重要。我们越早了解可靠性的价值，我们就会越快地用 Golang 编码更多、更好的企业系统。</p>
<h2 id="ps">P.S.</h2>
<p>我很惊讶，这篇文章有这么多的解释。可惜很多人错过了文章的重点。</p>
<p>这篇文章：</p>
<p><em>1）不是关于我</em></p>
<p><em>2）不是关于我的技能</em></p>
<p><em>3）不是关于我的狗</em></p>
<p>*4）*不是关于“为什么我的狗在其企业狗系统中不需要使用 Golang”</p>
<p><em>5）不是关于 Golang 的最佳编码实践</em></p>
<p><em>6）不是关于与处理 go 错误有关的最佳实践</em></p>
<p><em>7）不是关于如何以正确的方式选择正确的工具</em></p>
<p><em>8）不是关于 Golang 的一般设计</em></p>
<p><em>9）不是关于“没有人可以将 Go 用于企业系统”</em></p>
<p><em>10）不是关于“没有人需要将 Go 用于企业系统”</em></p>
<p>正如我所观察到的，这涉及将 Golang 用于企业的风险（在“ Golang”下，我的意思更多在于文化和生态系统，而不是语言设计）。这是我的看法。</p>
<p>当然，很多大公司，如谷歌和 Netflix 在企业中使用 Golang，在我看来，他们一样有风险（记住，谷歌使用 Golang 时，这种语言还没有包带版本的管理器 ）。其他开发人员可以有其他观点和其他经验并观察。</p>
<p>本文的主要目的是进行讨论，看看有多少人有相同的看法。</p>
<h2 id="参考">参考</h2>
<p>图书：《Release It! Design and Deploy Production-Ready Software》</p>
<p>图书：《Patterns of Enterprise Application Architecture》by Martin Fowler</p>
<blockquote>
<p>原文链接：https://medium.com/@afondmitro/golang-is-not-ready-for-enterprise-systems-yet-and-heres-why-c0ee72069963</p>
<p>作者：Dmitry Afonkin</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Google 的核心数据解决方案团队是如何使用 Go 的？</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/google-go-coredata/</link>
			<pubDate>Tue, 08 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/google-go-coredata/</guid>
			<description>关于 Google 的核心数据： Google 是一家技术公司，其使命是组织全世界的信息，并使其普遍可访问和有用。 在这个案例研究中，Google 的核心数据解决方案团队分</description>
			<content type="html"><![CDATA[<p>关于 Google 的核心数据：</p>
<blockquote>
<p>Google 是一家技术公司，其使命是组织全世界的信息，并使其普遍可访问和有用。</p>
<p>在这个案例研究中，Google 的核心数据解决方案团队分享了他们的 Go 旅程，包括他们决定在 Go 中重写 web 索引服务，利用 Go 的内置并发性，并观察 Go 如何帮助改进开发过程。</p>
</blockquote>
<p><p class="md__image">
  <img src="../imgs/go_core_data_case_study.png"
    alt="核心数据"  />
</p>
</p>
<p>Google 的使命是“组织世界各地的信息，并使其普遍可访问和有用。” Google 的核心数据解决方案团队是负责组织该信息的团队之一。除此之外，该团队维护服务以索引全球的网页。这些网络索引服务通过保持搜索结果的更新和全面来帮助支持诸如 Google 搜索之类的产品，这些产品都是用 Go 语言编写的。</p>
<p>2015 年，为了跟上 Google 的规模，我们的团队需要我们将索引堆栈从用 C++ 编写的单个整体二进制代码重写为微服务架构中的多个组件。我们决定使用 Go 重写许多索引服务，现在我们将其用于支持大多数架构。</p>
<p>“ 因为鼓励团队中的工程师使用并发和并行算法，所以 Go 的内置并发是很自然的选择。” —Minjae Hwang， 软件工程师</p>
<p>选择语言时，我们的团队发现 Go 的多种特性特别适合。例如，因为鼓励团队中的工程师使用并发和并行算法，所以 Go 的内置并发是很自然的选择。工程师还发现，“ Go 代码更为自然”，使他们可以将时间花在业务逻辑和分析上，而不是在管理内存和优化性能上。</p>
<p>使用 Go 时，编写的代码要简单的多，因为它有助于减轻开发过程中的认知负担。例如，当使用 C++ 时，复杂的 IDE 可能“显示出源代码没有编译错误实际上确实有错误”，而“在 Go 中，当 IDE 指出代码没有错误时，代码总是会编译。” Core Data Solutions 团队的软件工程师 MinJae Hwang 说。减少开发过程中的小摩擦点，例如缩短修复编译错误的周期，有助于我们的团队在原始重写期间更快地发布，并有助于保持较低的维护成本。</p>
<p>“当我使用 C++ 并想使用更多软件包时，必须写一些 header 文件。当我用 Go 语言时，<strong>内置工具使我可以更轻松地使用软件包。我的开发速度要快得多</strong>。</p>
<p>通过简单的语言语法和 Go 工具的支持，我们团队中的一些成员发现用 Go 编写代码要容易的多。我们还发现 Go 在静态类型检查方面做得非常好，并且某些 Go 基础知识（例如 godoc 命令）已帮助团队围绕编写文档建立了更规范的规则。</p>
<p>“…在一年内重新设计了 Google 的网络索引。更令人印象深刻的是，团队中的大多数开发人员在学习 Go 的同时也用 Go 进行了重写。”— Prasanna Meda，软件工程师</p>
<p>研发在全球范围内被广泛使用的产品绝非易事，而我们团队使用 Go 的决定并不是一件容易的事，但是这样做有助于我们更快地行动。结果，在一年内重新设计了 Google 的网络索引。更令人印象深刻的是，该团队中的大多数开发人员在学习 Go 的同时就用 Go 完成重写。</p>
<p>除了核心数据解决方案团队外，Google 的工程团队在开发过程中也采用了Go。了解 <a href="https://go.dev/solutions/google/chrome/" target="_blank" rel="noopener">Chrome</a>
 和 <a href="https://go.dev/solutions/google/firebase/" target="_blank" rel="noopener">Firebase 托管</a>
团队如何使用 Go 来大规模构建快速，可靠和高效的软件。关于他们的下次分享。</p>
<blockquote>
<p>原文链接：https://go.dev/solutions/google/coredata/</p>
<p>作者：Prasanna Meda, Software Engineer, Core Data Solutions</p>
<p>翻译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>GoUI：一个非常简单的 GUI 框架</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/goui-a-very-simple-ui-framework/</link>
			<pubDate>Mon, 17 Aug 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/goui-a-very-simple-ui-framework/</guid>
			<description>最近，我一直想开发一些桌面（主要是 Windows，但也可以考虑 MacOS 或 Linux）应用程序。虽然 Go 不是开发 UI 应用程序时首选语言，但是该语言的简单</description>
			<content type="html"><![CDATA[<p>最近，我一直想开发一些桌面（主要是 Windows，但也可以考虑 MacOS 或 Linux）应用程序。虽然 Go 不是开发 UI 应用程序时首选语言，但是该语言的简单性和健壮性仍然使它成为我的首选语言。是的，这是我的锤子（hammer）&hellip; 但这是一个该死的漂亮锤子。</p>
<p>以前，我曾将 Ebiten 图形库用于 Go，以便与孩子们一起编写一些游戏。但是，对于一般的“应用程序”开发（即需要“小部件 widgets”，例如按钮，菜单等），Ebiten 并非真的适合。因此，我一直在寻找可以使用的 Go UI 库。然而大多数都使用 cgo，但我真的希望我的应用程序是纯 Go。这纯粹是个人喜好，我不知道使用 cgo 而不是纯 Go 会有什么影响。如果我要使用 cgo，我认为首选的 UI 库肯定是 <a href="https://fyne.io/" target="_blank" rel="noopener">Fyne</a>
。Fyne 看起来是一个非常全面的框架，如果您不介意 cgo，我绝对会建议你看看看 Fyne。</p>
<p>还有其他一些库，但没有吸引我。他们说你永远不应该编写自己的安全性代码，并且我也相信你不应该编写自己的 UI 库。但是我忽略了这个建议&hellip;</p>
<p>因此，我写了一个 <a href="https://github.com/kpfaulkner/goui" target="_blank" rel="noopener">GoUI</a>
 !!</p>
<p>这纯粹是那些“抓痒”的项目之一。虽然现在还很早，但 UI 库的基本知识（由 Ebiten 进行实际渲染）正在慢慢融合。在详细介绍下面细节之前，我想先说明一下，我认为程序在 CLI 达到了顶峰。其次，我不是 UI 编程人员……写这些是我个人的兴趣。</p>
<p>GoUI 的基本思想是两种类型的图形元素。一个是可以包含其他面板或小部件的面板（Panel）。另一个是小部件，它是基本的 UI 元素（按钮，文本输入等）。我们目前使用的面板类型有 HPanel（水平添加）和 VPanel（我让你猜）。从技术上讲，我们确实有其他面板，例如工具栏，但这实际上只是 HPanel，需要一点点定制工作。总体而言，如果我可以结合其他现有面板/小工具来构造一些“新”东西，那么我会做的。如果我需要优化或与已有产品脱节，那么我将做一些全新的事情。</p>
<p>我们目前拥有的小部件是：</p>
<ul>
<li>
<p>ImageButton：（由应用程序提供的单击/未单击的图像）。</p>
</li>
<li>
<p>TextButton：基本的彩色矩形，其中包含您想要的任何文本。</p>
</li>
<li>
<p>Checkbox：与 TextButton 相同，但是旁边有一个小方框，可以打对勾。</p>
</li>
<li>
<p>EmptySpace：完全由我控制。用于强制其他小部件之间的空间。一旦添加适当的填充，该填充可能会消失。</p>
</li>
<li>
<p>Label：文本标签，不能输入。</p>
</li>
<li>
<p>Text Input：文本输入框。</p>
</li>
<li>
<p>RadioButtonGroup：这是一个面板，其中包含 vpanel 或 hpanel（取决于标志），然后其中包含许多复选框。复选框将图像（带有刻度）替换为常规的单选按钮。这是重新使用现有窗口小部件的好例子。如果事实证明我需要对复选框进行足够的修改以使其不适合用作单选按钮，那么我将不得不放入一个真正的单选按钮。但是目前，它运行良好。</p>
</li>
</ul>
<p>我还没有完成菜单，模态窗口等，但是正如我所说的……这还是早期。</p>
<p>现在，让我们尝试一个超级简单的 Demo。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
 
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/hajimehoshi/ebiten&#34;</span>
    <span class="s">&#34;github.com/kpfaulkner/goui/pkg&#34;</span>
    <span class="s">&#34;github.com/kpfaulkner/goui/pkg/widgets&#34;</span>
    <span class="nx">log</span> <span class="s">&#34;github.com/sirupsen/logrus&#34;</span>
    <span class="s">&#34;image/color&#34;</span>
<span class="p">)</span>
 
<span class="kd">type</span> <span class="nx">MyApp</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">window</span> <span class="nx">pkg</span><span class="p">.</span><span class="nx">Window</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">NewMyApp</span><span class="p">()</span> <span class="o">*</span><span class="nx">MyApp</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="nx">MyApp</span><span class="p">{}</span>
    <span class="nx">a</span><span class="p">.</span><span class="nx">window</span> <span class="p">=</span> <span class="nx">pkg</span><span class="p">.</span><span class="nf">NewWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="s">&#34;test app&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">a</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">SetupUI</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">vPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewVPanel</span><span class="p">(</span><span class="s">&#34;main vpanel&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">})</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">AddPanel</span><span class="p">(</span><span class="nx">vPanel</span><span class="p">)</span>
    <span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">button1</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nf">SetupUI</span><span class="p">()</span>
    <span class="nx">ebiten</span><span class="p">.</span><span class="nf">SetRunnableInBackground</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
    <span class="nx">ebiten</span><span class="p">.</span><span class="nf">SetWindowResizable</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">MainLoop</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">DebugLevel</span><span class="p">)</span>
    <span class="nx">app</span> <span class="o">:=</span> <span class="nf">NewMyApp</span><span class="p">()</span>
    <span class="nx">app</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>让我们解释一下以上代码。</p>
<p>首先，该程序的核心仍然是直接调用 Ebiten。这些尚未封装。因此，你将在 main 和 Run 函数中看到，我们基本上已经制作了 MyApp 结构的实例，然后调用 SetupUI，设置一些 Ebiten 标志，然后调用 MainLoop。</p>
<p>NewMyApp 函数调用 pkg.NewWindow 函数。这是应用程序的主窗口。一旦添加了模态/其他窗口，这可能会更改，但是就目前而言，这将创建给定大小的主 UI 窗口。</p>
<p>SetupUI 是你需要注意的地方。我们要做的第一件事是创建一个 VPanel。请记住，VPanel 把小部件垂直堆叠放置。我们将 vPanel 添加到主窗口。实际上（当前），我们应该只在主窗口中添加 1 个面板，其他所有内容都应放入该面板中。因此，在这种情况下，我们创建 button1（新的 TextButton）并将其添加到 vPanel。</p>
<p><p class="md__image">
  <img src="../imgs/goui-01.png"
    alt=""  />
</p>
</p>
<p>花点时间来学习理解一下上面的 UI 技能。</p>
<p>下面，让我们做一些更有趣的事情。假设我们要在按下按钮时做出响应。创建 TextButton 的行是：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</code></pre></div><p>所有细节就不描述了，但是最后一个参数是带有 <strong>func (event IEvent) error</strong> 签名的事件处理程序。因此，如果我们创建一个带有该签名的方法，并将其作为最后一个参数传递给 NewTextButton。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">ButtonAction1</span><span class="p">(</span><span class="nx">event</span> <span class="nx">events</span><span class="p">.</span><span class="nx">IEvent</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;My button1 action 1!!!&#34;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>然后我们将按钮创建修改为</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ButtonAction1</span><span class="p">)</span>
</code></pre></div><p>现在，当单击按钮时，将调用 ButtonAction1 函数，我们可以触发所需的任何功能。</p>
<p>是不是很简单。</p>
<p>现在，如果我想要在按钮旁边放点东西该怎么办？我们在这里要做的是创建一个 HPanel，并将其首先放入 VPanel。然后，将按钮添加到 HPanel。如果这样做，我们最终将得到如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">SetupUI</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
 
    <span class="nx">vPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewVPanel</span><span class="p">(</span><span class="s">&#34;main vpanel&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">})</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">AddPanel</span><span class="p">(</span><span class="nx">vPanel</span><span class="p">)</span>
 
    <span class="nx">hPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewHPanel</span><span class="p">(</span><span class="s">&#34;hpanel1&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">})</span>
    <span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">hPanel</span><span class="p">)</span>
 
    <span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ButtonAction1</span><span class="p">)</span>
    <span class="nx">hPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">button1</span><span class="p">)</span>
 
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>从视觉上看，什么都不会改变。我们仍然只显示 1 个小部件。</p>
<p>现在，如果我们在同一 HPanel 中添加一个复选框怎么办？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">SetupUI</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
 
    <span class="nx">vPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewVPanel</span><span class="p">(</span><span class="s">&#34;main vpanel&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">})</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">AddPanel</span><span class="p">(</span><span class="nx">vPanel</span><span class="p">)</span>
 
    <span class="nx">hPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewHPanel</span><span class="p">(</span><span class="s">&#34;hpanel1&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">})</span>
    <span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ButtonAction1</span><span class="p">)</span>
    <span class="nx">hPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">button1</span><span class="p">)</span>
 
    <span class="nx">cb1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewCheckBox</span><span class="p">(</span><span class="s">&#34;my checkbox1&#34;</span><span class="p">,</span> <span class="s">&#34;check me please&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="nx">hPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">cb1</span><span class="p">)</span>
 
    <span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">hPanel</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>因此，与之前完全相同，但只有这额外的两条：创建复选框，然后添加到 hPanel。</p>
<p>现在 UI 看起来是这样：</p>
<p><p class="md__image">
  <img src="../imgs/goui-02.png"
    alt=""  />
</p>
</p>
<p>现在不担心这里的间距了。</p>
<p>现在让我们在 TextButton 下面添加一个 ImageButton。这意味着我们将向 vPanel 添加第二项（第一项是 hPanel）</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">imageButton</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewImageButton</span><span class="p">(</span><span class="s">&#34;ib1&#34;</span><span class="p">,</span> <span class="s">&#34;images/pressedbutton.png&#34;</span><span class="p">,</span> <span class="s">&#34;images/nonpressedbutton.png&#34;</span><span class="p">,</span><span class="kc">nil</span> <span class="p">)</span>
<span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">imageButton</span><span class="p">)</span>
</code></pre></div><p>这是效果如下：</p>
<p><p class="md__image">
  <img src="../imgs/goui-03.png"
    alt=""  />
</p>
</p>
<p>这时，我们有了 2 张图片（屏幕截图中只显示了一张）。按下按钮时一个，不按下时一个（只更改了阴影）。懂了吧。</p>
<p>好了，介绍就这么多。虽然该 UI 库还不完善，但 GUI 的基本功能已经可以实现了。再次放上该库的地址：<a href="https://github.com/kpfaulkner/goui">https://github.com/kpfaulkner/goui</a>。</p>
<blockquote>
<p>作者：<a href="https://kpfaulkner.wordpress.com/author/kpfaulkner/" target="_blank" rel="noopener">kpfaulkner</a>
</p>
<p>日期：2020 年 8 月 17 日</p>
<p>原文链接：<a href="https://kpfaulkner.wordpress.com/2020/08/17/goui-a-very-simple-ui-framework/">https://kpfaulkner.wordpress.com/2020/08/17/goui-a-very-simple-ui-framework/</a></p>
<p>译者：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Go 源代码中的复活节彩蛋</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/easter-eggs-in-go-source-code-2l02/</link>
			<pubDate>Fri, 17 Jul 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/easter-eggs-in-go-source-code-2l02/</guid>
			<description>前言 前段时间，我在某个 Slack 工作区与朋友聊天： 朋友：“有人知道为什么time.minWall 的默认值是 1885 吗？” 我：“不知道，也许是从《回到未来 3</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>前段时间，我在某个 Slack 工作区与朋友聊天：</p>
<blockquote>
<p>朋友：“有人知道为什么<code>time.minWall</code> 的默认值是 1885 吗？”
我：“不知道，也许是从《<em>回到未来 3</em>》那一年开始的？”</p>
</blockquote>
<p>我那么说基本是在开玩笑，因为我也不知道为什么将其设置为 1885 年。尽管其背后的事实与我在 Go 中的日常编码没有任何关系，但我还是情不自禁地询问了幕后花絮。我在团队聊天中问了我的同伴 Gophers，但似乎没人能找到相关的线索。</p>
<p>最后，我直接向 Russ Cox（<a href="https://twitter.com/_rsc" target="_blank" rel="noopener">@_rsc</a>
）发送了一封电子邮件，以了解背景。</p>
<h2 id="timeminwall">time.minWall</h2>
<p>一个 const 值<code>time.minWall</code>设置为 1885，在如下代码中：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/release-branch.go1.15/src/time/time.go#L153" target="_blank" rel="noopener">src/time/time.go</a>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">hasMonotonic</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span>
    <span class="nx">maxWall</span>      <span class="p">=</span> <span class="nx">wallToInternal</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">33</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// year 2157
</span><span class="c1"></span>    <span class="nx">minWall</span>      <span class="p">=</span> <span class="nx">wallToInternal</span>               <span class="c1">// year 1885
</span><span class="c1"></span>    <span class="nx">nsecMask</span>     <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nx">nsecShift</span>    <span class="p">=</span> <span class="mi">30</span>
<span class="p">)</span>
</code></pre></div><p>这是个常数值，它定义了时间包中值的时代。这是一个常量值，它定义了 time 包的时间纪元。我们经常使用 UNIX 纪元（即 1970 年 1 月 1 日 UTC 的 00:00:00），但这只是几个用于表示日期时间值的标准或实现中的一个纪元，当然 Go 是一种多平台语言，因此 Go 中的纪元需要涵盖所有这些平台。</p>
<p>Russ Cox 在以下地方公开评论了 Go 的纪元。第一个是在 <a href="https://github.com/golang/go/issues/12914#issuecomment-277335863" target="_blank" rel="noopener">GitHub issue 上</a>
：</p>
<blockquote>
<p>已合入 Go 1.9。我将内部纪元移到 1885 年（最大年份为 2157 年），以避免 NTP 纪元派生的时间出现任何可能的问题。我还调整了设计文档，以调整此更改和一些较小的编码更改。</p>
</blockquote>
<p>但是这个评论只提到了为什么以及何时将内部纪元移到 1885 年，而没有提及为什么他们没有移至其他年份，例如 1900 年。</p>
<p>第二个是内部纪元移动的提案文档。</p>
<ul>
<li><a href="https://github.com/golang/proposal/blob/master/design/12914-monotonic.md" target="_blank" rel="noopener">提案：Go 中的单调时间测量</a>
</li>
</ul>
<blockquote>
<p>基于 Unix 的系统通常使用 1970，而基于 Windows 的系统通常使用 1980。我们不知道任何使用更早默认壁钟时间（Wall Time）的系统，但是由于 NTP 协议纪元使用 1900，因此选择 1900 之前的年份似乎更具前瞻性。</p>
</blockquote>
<p>可见，理论依据也只是支持 1900 年之前的任何年份，而不是特指 1885 年。我几乎可以肯定，这一年来自“<em>回到未来 3”</em>，但我想 100％ 确定这一年，所以我联系了肯定知道这一点的人，即向 Russ Cox 发送了一封电子邮件，询问原因。他在一天之内做出了回应（考虑到 EDT 和 JST 之间的时区差异，这是非常快的）：</p>
<blockquote>
<p>是的，人们说服我移到 1900 年之前，而 1885 年是显而易见的选择，因为它对加利福尼亚的希尔山谷（Hill Valley）具有历史意义。:-)</p>
</blockquote>
<p>这就是我知道的！！同样，我很高兴能够从谁做出决定中得到真正的答案。</p>
<h2 id="httpalongtimeago">http.aLongTimeAgo</h2>
<p>尽管我很欣赏 Russ 的回答，但这还不是故事的结局。Russ 的回信中还有另外一行。</p>
<blockquote>
<p>另请参见 http.aLongTimeAgo，现在将其设置为 time.Unix(1, 0)，但以前是 time.Unix(233431200, 0)。</p>
</blockquote>
<p>正如他所说，在 Go1.15 中，它设置为<code>time.Unix(1, 0)</code>。</p>
<ul>
<li><a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.15/src/net/http/http.go#L30" target="_blank" rel="noopener">Go 1.15: src/net/http/http.go</a>
</li>
</ul>
<pre><code>// aLongTimeAgo is a non-zero time, far in the past, used for
// immediate cancellation of network operations.
var aLongTimeAgo = time.Unix(1, 0)
</code></pre><p>因此，我们在源码中确认其原始值。你可以在 Go 1.8 中找到它。</p>
<ul>
<li><a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.8/src/net/http/http.go#L23" target="_blank" rel="noopener">Go 1.8: src/net/http/http.go</a>
</li>
</ul>
<pre><code>// aLongTimeAgo is a non-zero time, far in the past, used for
// immediate cancelation of network operations.
var aLongTimeAgo = time.Unix(233431200, 0)
</code></pre><p>我们将 UNIX 时间转换为人类可读的格式。当然，Go 提供了超级简单的方法。</p>
<ul>
<li><a href="https://play.golang.org/p/c4u1lF5Q6xQ" target="_blank" rel="noopener">示例代码：以人类可读的格式读取 UNIX 时间</a>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">pdt</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">LoadLocation</span><span class="p">(</span><span class="s">&#34;America/Los_Angeles&#34;</span><span class="p">)</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Unix</span><span class="p">(</span><span class="mi">233431200</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="nf">In</span><span class="p">(</span><span class="nx">pdt</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果是：</p>
<pre><code>1977-05-25 11:00:00 -0700 PDT
</code></pre><p>我们得到 2 条提示：“A Long Time Ago”和 “1977-05-25”。这两个是：</p>
<p><p class="md__image">
  <img src="../imgs/eggs01.jpeg"
    alt=""  />
</p>
</p>
<p>当然，除了*《星球大战：第四集》外*，别无其他。它于1977年5月25日发布的（<a href="https://en.wikipedia.org/wiki/Star_Wars_%28film%29" target="_blank" rel="noopener">Wikipedia</a>
）</p>
<p>Go 包中如何使用此值呢？这是通过指定过去时间的截止日期来强制取消现有连接，例如：</p>
<pre><code>cr.conn.rwc.SetReadDeadline(aLongTimeAgo)
</code></pre><p>当该值被改为 <code>time.Unix(1, 0)</code> 时，有人注意到了，因此对此作了一些评论（比如 1977-05-25 是谁的生日吗？）。我喜欢看到这些评论。这些有趣的聊天有时会在更改列表中进行。</p>
<ul>
<li><a href="https://github.com/golang/go/commit/6983b9a57955fa12ecd81ab8394ee09e64ef21b9" target="_blank" rel="noopener">net, net/http: 调整过去的时间到更早的时间</a>
</li>
</ul>
<h2 id="致谢">致谢</h2>
<ul>
<li>Russ Cox：感谢您回答我的问题和其他信息。另外，感谢您允许公开分享此内容。引用他的评论：</li>
</ul>
<blockquote>
<p>放心吧。这里没有秘密。</p>
</blockquote>
<ul>
<li><a href="https://twitter.com/broady" target="_blank" rel="noopener">Chris Broadfoot</a>
 和 <a href="https://twitter.com/val_deleplace" target="_blank" rel="noopener">Valentin Deleplace</a>
：感谢你们在群聊中一起找到线索。</li>
<li><a href="https://twitter.com/mattn_jp" target="_blank" rel="noopener">mattn</a>
：感谢您让我知道人们对此价值<a href="https://twitter.com/mattn_jp" target="_blank" rel="noopener">有何</a>
反应的 GitHub 评论线。</li>
</ul>
<h2 id="注意">注意</h2>
<p>该文最初于 2020-07-17 发布于我的日语博客中。</p>
<ul>
<li><a href="https://ymotongpoo.hatenablog.com/entry/2020/07/17/093000">https://ymotongpoo.hatenablog.com/entry/2020/07/17/093000</a></li>
</ul>
<blockquote>
<p>原文链接：https://dev.to/ymotongpoo/easter-eggs-in-go-source-code-2l02</p>
<p>作者：Yoshi Yamaguchi</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>GoLand 2020.2 Beta 版发布：go.mod 升级以及对泛型的实验性支持</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/2020.2.beta/</link>
			<pubDate>Thu, 16 Jul 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/2020.2.beta/</guid>
			<description>GoLand 2020.2 达到 Beta。这意味着我们将结束一连串的新功能开发，将重点转移到完善我们已经完成的工作上，并开始计算发布日之前的日子！
与我们的“抢先体验计划”版本相比，该测试版非常稳定，但请记住，可能仍然在某处存在 Bug。
同样请注意，此 Beta 版本是 EAP 周期中的最后一个版本，不需要订阅即可使用（如果您只是想尝试 GoLand，请尝试）。测试版通常会在发布候选版本之后出现，一旦我们发现该版本足够好并且可以在您的计算机上安装了。
在此发布周期中，我们为即将推出的 GoLand 2020.2 打包了 Go 模块的新功能，更好地呈现了代码中可能存在的问题和薄弱环节，提供了新的代码检查功能以及新的代码编辑功能，例如期待已久的 “Add Caret Per Selected Line”，改进了后台流程，使其更透明，更快，更多！
让我们来看看即将发布的版本中的新功能。选择您感兴趣的主题，或浏览整个博客文章以了解每个新功能。
 Go Modules Generics a.k.a. Type Parameters Code Editing Code Inspections Take Variadic Arguments Under Сontrol References from Comments Save Projects as Templates Under the Hood Processes Version Control  Go Modules 支持 GOMODCACHE 环境变量 从 Go 1.15 开始，可以使用新的 GOMODCACHE 环境变量将 Go Modules 缓存的默认位置从 $GOPATH/pkg/mod 更改为另一个文件夹。</description>
			<content type="html"><![CDATA[<p>GoLand 2020.2 达到 Beta。这意味着我们将结束一连串的新功能开发，将重点转移到完善我们已经完成的工作上，并开始计算发布日之前的日子！</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-1.png"
    alt=""  />
</p>
</p>
<p>与我们的“抢先体验计划”版本相比，该测试版非常稳定，但请记住，可能仍然在某处存在 Bug。</p>
<p>同样请注意，此 Beta 版本是 EAP 周期中的最后一个版本，不需要订阅即可使用（如果您只是想尝试 GoLand，请尝试）。测试版通常会在发布候选版本之后出现，一旦我们发现该版本足够好并且可以在您的计算机上安装了。</p>
<p>在此发布周期中，我们为即将推出的 GoLand 2020.2 打包了 Go 模块的新功能，更好地呈现了代码中可能存在的问题和薄弱环节，提供了新的代码检查功能以及新的代码编辑功能，例如期待已久的 “Add Caret Per Selected Line”，改进了后台流程，使其更透明，更快，更多！</p>
<p>让我们来看看即将发布的版本中的新功能。选择您感兴趣的主题，或浏览整个博客文章以了解每个新功能。</p>
<ul>
<li>Go Modules</li>
<li>Generics a.k.a. Type Parameters</li>
<li>Code Editing</li>
<li>Code Inspections</li>
<li>Take Variadic Arguments Under Сontrol</li>
<li>References from Comments</li>
<li>Save Projects as Templates</li>
<li>Under the Hood Processes</li>
<li>Version Control</li>
</ul>
<h2 id="go-modules">Go Modules</h2>
<h3 id="支持-gomodcache-环境变量">支持 GOMODCACHE 环境变量</h3>
<p>从 Go 1.15 开始，可以使用新的 GOMODCACHE 环境变量将 Go Modules 缓存的默认位置从 $GOPATH/pkg/mod 更改为另一个文件夹。</p>
<p>为此，只需在 “<em>Preferences/Settings | Go Modules | Environment</em>” 设置 GOMODCACHE 即可。</p>
<p>IDE 将识别自定义位置，并将其用于具有依赖关系的所有后续操作。同步依赖项快速修复程序（可通过 Alt + Enter 实现）会将依赖项下载到 GOMODCACHE，外部库也将在新的自定义位置显示依赖项。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-2.png"
    alt=""  />
</p>
</p>
<h2 id="升级-gomod-文件">升级 go.mod 文件</h2>
<p>行注释（在 Windows/Linux 上为 Ctrl + /，在 macOS 上为 ⌘ + /）可用于 go.mod 文件。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-3.gif"
    alt=""  />
</p>
</p>
<p>现在，当您键入 replace，exclude 和 require 语句的左括号时，GoLang 立即自动为你添加右括号。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-4.gif"
    alt=""  />
</p>
</p>
<h2 id="泛型又称类型参数">泛型（又称类型参数）</h2>
<p>6月16日，Go Team 宣布了泛型（也称为类型参数）设计草案。请访问 Golang 文档以获取有关该概念的<a href="https://go.googlesource.com/proposal/&#43;/refs/heads/master/design/go2draft-type-parameters.md" target="_blank" rel="noopener">完整详细信息</a>
。</p>
<p>这是一个重大的发展，因此我们立即着手增加对它的支持。GoLand 2020.2 Beta 提供了对泛型的实验性支持，您可以通过在 <em>Settings/Preferences | Go</em> 启用对泛型的实验性支持。</p>
<p>此初始支持提供语法高亮显示和基本参考解析，并且仅在 go2 文件中有效。</p>
<p>请注意，有关泛型的工作仍在进行中，我们目前尚无法提供全面的支持。</p>
<p>尽管如此，请分享您的体验和您可能有的任何建议。它确实可以帮助我们完善到目前为止已完成的工作，因此我们可以使其可靠并使用更高级的功能进行填充。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-5.png"
    alt=""  />
</p>
</p>
<h2 id="代码编辑">代码编辑</h2>
<p>想要将快速修复的结果应用于代码之前预览其结果，请使用 Alt + Enter 快捷方式调用显示上下文操作，选择所需的快速修复，然后在 macOS 上按 Alt + Space 或在 Windows 和 Linux 上为 Ctrl + Shift + I。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-6.gif"
    alt=""  />
</p>
</p>
<p>新的“按选定的行添加插入（多行操作）”操作会在每个选定行的末尾插入，并取消选择这些行。在 Windows/Linux 上使用快捷键 Alt + Shift + G 或在 macOS 上使用 ⌥ + ⇧ + G 调用它。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-7.gif"
    alt=""  />
</p>
</p>
<p>在 <em>Preferences/Settings | Editor | Code Style | Go | Wrapping and Braces</em> 中为调用参数，函数参数和复合文字元素配置换行。或者，您可以使用 Alt + Enter 键，调出 <em>Put arguments on separate lines</em> 和 *Put arguments on one line，*以手动拆分和合并元素。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-8.gif"
    alt=""  />
</p>
</p>
<h2 id="代码检查">代码检查</h2>
<p>GoLand 2020.2 有了一个新的检查部件（<em>Inspections Widget</em>）！它位于代码编辑器的右上角，显示当前文件中的警告，错误和错别字数量。您可以使用箭头图标或“下一个错误”操作（F2）遍历它们。</p>
<p>该小部件可让您配置突出显示级别（从无、仅错误或所有问题中选择），更改检查的严重性级别以及切换紧凑视图。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-9.gif"
    alt=""  />
</p>
</p>
<p>我们还添加了一个“问题视图”工具窗口，该窗口显示当前文件中的警告和错误列表，为您提供这些问题的描述，并让您立即使用 Alt + Enter 进行修复。在“问题视图”工具窗口中右键单击问题，以直接移至发生错误的代码行。要打开“问题视图”，请单击“检查”小部件或转到 <em>View | Tool Window | Problems</em>。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-10.gif"
    alt=""  />
</p>
</p>
<p>GoLand 2020.2 现在在所有情况下都在项目视图中标记包含错误的文件，以使您更容易发现它们。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-11.png"
    alt=""  />
</p>
</p>
<p>现在，新的代码检查可以处理 string(int) 转换可能出现的问题，这些转换返回 Unicode代码点 x 的 UTF-8 表示形式，而不是预期的 x 十进制字符串表示形式。GoLand 将通知您有关此类潜在错误的信息，并提供专用的快速修复程序。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-12.gif"
    alt=""  />
</p>
</p>
<p>GoLand 会通知您有关测试和示例的常见错误用法，因此您不再需要为此而明确地使用 go vet。在简单情况下，IDE 还提供了快速修复程序。例如，它建议将 Testme 重命名为 TestMe。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-13.png"
    alt=""  />
</p>
</p>
<p>格式错误的 struct tags 代码检查将检查 struct tags 是否符合 Go 约定，并通知您潜在的问题。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-14.png"
    alt=""  />
</p>
</p>
<p>不可能的接口类型断言代码检查将检查类型断言 v.(T) 和相应的 type-switch case，其中 v 的静态类型 V 是无法实现目标接口 T 的接口。这发生在当 V 和 T 包含相同名称但签名不同的方法时。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-15.png"
    alt=""  />
</p>
</p>
<h2 id="在控制下接受可变参数的论证">在控制下接受可变参数的论证</h2>
<p>引入变量重构（在 Windows 和 Linux 上为 Ctrl + Alt + V，在 macOS 上为 ⌘ + ⌥ + V）可以将一些可变参数打包到新的 slice 变量中；相反的，内联变量（在 MacOS 上为 ⌥ + ⌘ + N 和在 Linux 上为 Ctrl + Alt + N），则将切片分解为可变参数。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-16.gif"
    alt=""  />
</p>
</p>
<p>此外，您现在可以通过 Unpack slice 快速修复来处理解包的可变参数的问题。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-17.gif"
    alt=""  />
</p>
</p>
<h2 id="注释中的引用">注释中的引用</h2>
<p>IDE 显示注释中对相关程序包级别声明的引用，并允许您通过“导航到声明或使用”操作（在 macOS 上为 ⌘ + B，在Windows / Linux上为 Ctrl + B）来跳转。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-18.gif"
    alt=""  />
</p>
</p>
<h2 id="将项目另存为模板">将项目另存为模板</h2>
<p>现在，您可以通过将项目或文件另存为自定义项目模板来重复使用它们：选择 <em>Tools</em> | <em>Save Project as Template</em>。IDE 将使用文件、文件夹和构建配置重新创建项目树。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-19.png"
    alt=""  />
</p>
</p>
<h2 id="后台进程">后台进程</h2>
<h3 id="更好地解决带有-vendor-文件夹的项目">更好地解决带有 Vendor 文件夹的项目</h3>
<p>启用 vendoring 模式后，仅使用项目中 Vendor 文件夹中存储的依赖项包来构建应用程序。</p>
<p>现在，如果项目有一个 vendor 文件夹，并且您已经选中了 <em>Settings/Preferences | Go | Go Modules</em> 中的 <em>Enable vendoring mode**automatically</em>，这时只会使用 vendor 文件夹，而不会查询模块缓存。一个重要的优点是您可以更快地发现未解决的依赖项。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-20.gif"
    alt=""  />
</p>
</p>
<h2 id="go-list-命令">Go list 命令</h2>
<p>GoLand 依序运行 go list 命令，并提供一个进度条，其中包含有关队列中 go list 命令的实际数量的信息。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-21.png"
    alt=""  />
</p>
</p>
<h2 id="版本控制">版本控制</h2>
<h3 id="wsl2-在-windows-上对-git-的支持">WSL2 在 Windows 上对 Git 的支持</h3>
<p>GoLand 2020.2 将允许您使用 WSL2 中的 Git，该版本在 Windows 10（2004 年 5 月更新）的本地版本中可用。如果 Windows 中未安装 Git，GoLand 将在 WSL 中自动查找 Git 并使用它。对于从 WSL 打开的项目，它还将自动从 WSL 切换到 Git（通过 \wsl$ 路径）。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-22.gif"
    alt=""  />
</p>
</p>
<h3 id="改进的-git-操作对话框">改进的 Git 操作对话框</h3>
<p>我们针对 <em>Merge</em>, <em>Pull</em> 和 <em>Rebase</em> 之类的操作重新设计了 Git 对话框，以使它们更加一致和好用。我们还使您更容易理解将执行哪个 Git 命令，并在 “Pull” 对话框中添加了 &ndash;rebase 选项，在“Merge”对话框中添加了&ndash;no-verify 选项。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-23.png"
    alt=""  />
</p>
</p>
<h3 id="全面支持-github-pull-request">全面支持 GitHub Pull Request</h3>
<p>GitHub Pull Requests 配备齐全！在不离开 GoLand 的情况下浏览，分配，管理，甚至合并拉取请求，查看时间线和内联注释，提交注释和评论以及接受更改。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-24.png"
    alt=""  />
</p>
</p>
<h3 id="从日志中压缩squash本地提交">从日志中压缩（Squash）本地提交</h3>
<p>现在，您可以在 Git 工具窗口的“日志”选项卡中选择多个本地提交，并将其压缩为一个。可以从右键单击上下文菜单中执行此操作。</p>
<h3 id="改进了比较分支结果的表示方式">改进了“比较分支”结果的表示方式</h3>
<p>现在，当您在 GoLand 中比较 2 个分支时，可以在一个视图中查看比较后的分支的提交。IDE 现在将在编辑器中而不是在 VCS 工具窗口中打开要比较的两个分支的日志，在该窗口中没有足够的空间来显示所有信息。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-25.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/2020/07/16/goland-2020-2-reaches-beta/</p>
<p>作者：<a href="https://blog.jetbrains.com/author/ekaterina-zharovajetbrains-com" target="_blank" rel="noopener">Ekaterina Zharova</a>
</p>
<p>日期：2020-07-16</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>对 gRPC 的 Rust 和 Go 版本进行基准测试</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/benchmarking-grpc-in-rust-go/</link>
			<pubDate>Thu, 16 Jul 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/benchmarking-grpc-in-rust-go/</guid>
			<description>背景 如果你计划构建可靠，内存安全 ，高性能的应用程序，那么 Rust＆Go 无疑会是你的选择。 如果您希望从内部应用程序中获得更高的性能，则可能还需</description>
			<content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>如果你计划构建可靠，<a href="https://blog.gds-gov.tech/appreciating-rust-memory-safety-438301fee097" target="_blank" rel="noopener">内存安全</a>
，高性能的应用程序，那么 Rust＆Go 无疑会是你的选择。</p>
<p>如果您希望从内部应用程序中获得更高的性能，则可能还需要考虑使用 <a href="https://grpc.io/docs/what-is-grpc/introduction/" target="_blank" rel="noopener">gRPC</a>
 而不是普通的 <a href="https://restfulapi.net/" target="_blank" rel="noopener">REST</a>
 API。所有这些都是减少您的计算开销的解决方案。</p>
<p>我尝试比较各种库以了解它们的性能，并希望对你有所帮助。</p>
<h2 id="关注的库">关注的库</h2>
<ul>
<li>
<p><a href="https://github.com/tower-rs/tower-grpc" target="_blank" rel="noopener">tower-grpc</a>
 (Rust)</p>
<p>高性能 rust 库，尽管已被 tonic 替代</p>
</li>
<li>
<p><a href="https://github.com/grpc/grpc-go" target="_blank" rel="noopener">grpc-go</a>
 (Golang)</p>
<p>grpc 的官方 Go 模块</p>
</li>
<li>
<p><a href="https://github.com/stepancheg/grpc-rust" target="_blank" rel="noopener">grpc-rust</a>
 (Rust)</p>
<p>仍在开发中，另一个 rust grpc 库。看起来很不错</p>
</li>
<li>
<p><a href="https://github.com/hyperium/tonic" target="_blank" rel="noopener">tonic</a>
 (Rust)</p>
<p>tower-grpc 库的改进更新，支持新的 await 语法</p>
</li>
<li>
<p><a href="https://github.com/grpc/grpc-node" target="_blank" rel="noopener">grpc-node</a>
 (NodeJs)</p>
<p>包含有基准基准点</p>
</li>
<li>
<p><a href="https://github.com/tikv/grpc-rs" target="_blank" rel="noopener">grpc-rs</a>
 (Rust — C bindings)</p>
<p>使用 <a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">grpc</a>
 的 rust 库</p>
</li>
</ul>
<h2 id="基准测试工具">基准测试工具</h2>
<p>对于基准测试，我将在 gRPC 中使用与 <a href="https://github.com/rakyll/hey" target="_blank" rel="noopener">Hey</a>
 等效的 <a href="https://github.com/bojand/ghz" target="_blank" rel="noopener">ghz</a>
。</p>
<p>该测试将重点关注如果使用上述每个库将 10,000 个并发请求的相同负载发送到服务器，将有多少开销。我将为每个使用相同的 <a href="https://github.com/grpc/grpc-go/blob/master/examples/helloworld/helloworld/helloworld.proto" target="_blank" rel="noopener">helloworld</a>
 greeter。不会为任何测试启用 TLS，因此我们可以大致了解每种测试的原始性能。</p>
<h3 id="grpc-go">grpc-go</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 229.40 ms
  Slowest: 6.26 ms
  Fastest: 0.11 ms
  Average: 1.04 ms
  Requests/sec: 43591.54Response <span class="nb">time</span> histogram:
  0.114 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  0.728 <span class="o">[</span>3355<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.343 <span class="o">[</span>4580<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.957 <span class="o">[</span>1519<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎
  2.572 <span class="o">[</span>294<span class="o">]</span>  <span class="p">|</span>∎∎∎
  3.187 <span class="o">[</span>36<span class="o">]</span>   <span class="p">|</span>
  3.801 <span class="o">[</span>11<span class="o">]</span>   <span class="p">|</span>
  4.416 <span class="o">[</span>74<span class="o">]</span>   <span class="p">|</span>∎
  5.030 <span class="o">[</span>52<span class="o">]</span>   <span class="p">|</span>
  5.645 <span class="o">[</span>45<span class="o">]</span>   <span class="p">|</span>
  6.259 <span class="o">[</span>33<span class="o">]</span>   <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 0.46 ms
  <span class="m">25</span> % in 0.64 ms
  <span class="m">50</span> % in 0.88 ms
  <span class="m">75</span> % in 1.24 ms
  <span class="m">90</span> % in 1.68 ms
  <span class="m">95</span> % in 2.00 ms
  <span class="m">99</span> % in 4.77 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="tonic">tonic</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 581.81 ms
  Slowest: 6.39 ms
  Fastest: 0.17 ms
  Average: 2.84 ms
  Requests/sec: 17187.66Response <span class="nb">time</span> histogram:
  0.174 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  0.796 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>
  1.418 <span class="o">[</span>6<span class="o">]</span>    <span class="p">|</span>
  2.040 <span class="o">[</span>167<span class="o">]</span>  <span class="p">|</span>∎
  2.662 <span class="o">[</span>3427<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.284 <span class="o">[</span>5074<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.906 <span class="o">[</span>1048<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎
  4.528 <span class="o">[</span>217<span class="o">]</span>  <span class="p">|</span>∎∎
  5.150 <span class="o">[</span>29<span class="o">]</span>   <span class="p">|</span>
  5.773 <span class="o">[</span>21<span class="o">]</span>   <span class="p">|</span>
  6.395 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 2.35 ms
  <span class="m">25</span> % in 2.55 ms
  <span class="m">50</span> % in 2.79 ms
  <span class="m">75</span> % in 3.07 ms
  <span class="m">90</span> % in 3.39 ms
  <span class="m">95</span> % in 3.66 ms
  <span class="m">99</span> % in 4.22 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="grpc-node">grpc-node</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 589.25 ms
  Slowest: 12.56 ms
  Fastest: 1.21 ms
  Average: 2.88 ms
  Requests/sec: 16970.81Response <span class="nb">time</span> histogram:
  1.206 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  2.341 <span class="o">[</span>2592<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.476 <span class="o">[</span>5516<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  4.612 <span class="o">[</span>1588<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎
  5.747 <span class="o">[</span>180<span class="o">]</span>  <span class="p">|</span>∎
  6.882 <span class="o">[</span>42<span class="o">]</span>   <span class="p">|</span>
  8.017 <span class="o">[</span>32<span class="o">]</span>   <span class="p">|</span>
  9.152 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>
  10.288 <span class="o">[</span>20<span class="o">]</span>  <span class="p">|</span>
  11.423 <span class="o">[</span>6<span class="o">]</span>   <span class="p">|</span>
  12.558 <span class="o">[</span>18<span class="o">]</span>  <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 2.14 ms
  <span class="m">25</span> % in 2.33 ms
  <span class="m">50</span> % in 2.62 ms
  <span class="m">75</span> % in 3.24 ms
  <span class="m">90</span> % in 3.85 ms
  <span class="m">95</span> % in 4.26 ms
  <span class="m">99</span> % in 6.41 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="tower-grpc">tower-grpc</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 571.88 ms
  Slowest: 10.59 ms
  Fastest: 0.25 ms
  Average: 2.76 ms
  Requests/sec: 17486.12Response <span class="nb">time</span> histogram:
  0.246 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  1.280 <span class="o">[</span>139<span class="o">]</span>  <span class="p">|</span>∎
  2.314 <span class="o">[</span>2927<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.348 <span class="o">[</span>5198<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  4.382 <span class="o">[</span>1390<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎
  5.416 <span class="o">[</span>114<span class="o">]</span>  <span class="p">|</span>∎
  6.450 <span class="o">[</span>61<span class="o">]</span>   <span class="p">|</span>
  7.484 <span class="o">[</span>80<span class="o">]</span>   <span class="p">|</span>∎
  8.518 <span class="o">[</span>47<span class="o">]</span>   <span class="p">|</span>
  9.552 <span class="o">[</span>31<span class="o">]</span>   <span class="p">|</span>
  10.586 <span class="o">[</span>12<span class="o">]</span>  <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 1.80 ms
  <span class="m">25</span> % in 2.20 ms
  <span class="m">50</span> % in 2.65 ms
  <span class="m">75</span> % in 3.13 ms
  <span class="m">90</span> % in 3.64 ms
  <span class="m">95</span> % in 4.05 ms
  <span class="m">99</span> % in 7.18 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="grpc-rust">grpc-rust</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 479.30 ms
  Slowest: 8.15 ms
  Fastest: 0.90 ms
  Average: 2.34 ms
  Requests/sec: 20863.64Response <span class="nb">time</span> histogram:
  0.901 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  1.626 <span class="o">[</span>193<span class="o">]</span>  <span class="p">|</span>∎
  2.351 <span class="o">[</span>5587<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.076 <span class="o">[</span>3562<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.801 <span class="o">[</span>506<span class="o">]</span>  <span class="p">|</span>∎∎∎∎
  4.526 <span class="o">[</span>119<span class="o">]</span>  <span class="p">|</span>∎
  5.251 <span class="o">[</span>16<span class="o">]</span>   <span class="p">|</span>
  5.976 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>
  6.701 <span class="o">[</span>2<span class="o">]</span>    <span class="p">|</span>
  7.426 <span class="o">[</span>2<span class="o">]</span>    <span class="p">|</span>
  8.151 <span class="o">[</span>7<span class="o">]</span>    <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 1.87 ms
  <span class="m">25</span> % in 2.03 ms
  <span class="m">50</span> % in 2.25 ms
  <span class="m">75</span> % in 2.57 ms
  <span class="m">90</span> % in 2.90 ms
  <span class="m">95</span> % in 3.23 ms
  <span class="m">99</span> % in 4.11 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="grpc-rs">Grpc-rs</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 289.82 ms
  Slowest: 4.22 ms
  Fastest: 0.22 ms
  Average: 1.36 ms
  Requests/sec: 34504.74Response <span class="nb">time</span> histogram:
  0.222 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  0.621 <span class="o">[</span>195<span class="o">]</span>  <span class="p">|</span>∎∎
  1.021 <span class="o">[</span>1829<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.420 <span class="o">[</span>4059<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.820 <span class="o">[</span>2625<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  2.219 <span class="o">[</span>972<span class="o">]</span>  <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎
  2.618 <span class="o">[</span>239<span class="o">]</span>  <span class="p">|</span>∎∎
  3.018 <span class="o">[</span>45<span class="o">]</span>   <span class="p">|</span>
  3.417 <span class="o">[</span>18<span class="o">]</span>   <span class="p">|</span>
  3.817 <span class="o">[</span>6<span class="o">]</span>    <span class="p">|</span>
  4.216 <span class="o">[</span>11<span class="o">]</span>   <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 0.87 ms
  <span class="m">25</span> % in 1.07 ms
  <span class="m">50</span> % in 1.30 ms
  <span class="m">75</span> % in 1.62 ms
  <span class="m">90</span> % in 1.90 ms
  <span class="m">95</span> % in 2.07 ms
  <span class="m">99</span> % in 2.56 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h2 id="汇总概要">汇总概要</h2>
<p><p class="md__image">
  <img src="../imgs/rust-go-bench-01.png"
    alt="总响应时间（以毫秒为单位）。越低越好。"  />
</p>
</p>
<p>总响应时间（以毫秒为单位）。越低越好。</p>
<p><p class="md__image">
  <img src="../imgs/rust-go-bench-02.png"
    alt="吞吐量（请求/秒）。越高越好。"  />
</p>
</p>
<p>吞吐量（请求/秒）。越高越好。</p>
<h2 id="总结">总结</h2>
<p>结果表明，在性能方面，rust 与 node 相当，这是一个令人震惊的结果。</p>
<p>Go 库在并发性和最小开销方面均表现出色。</p>
<p>如果有人对 Go 库表现优异有些疑惑，请给留言给出你的看法！</p>
<blockquote>
<p>原文链接：<a href="https://medium.com/@Rustling_gopher/benchmarking-grpc-in-rust-go-184545e7688a">https://medium.com/@Rustling_gopher/benchmarking-grpc-in-rust-go-184545e7688a</a></p>
<p>作者：Rustler</p>
<p>编译：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>从这些角度看 Go 是一门很棒的语言</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-is-awesome/</link>
			<pubDate>Mon, 22 Jun 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-is-awesome/</guid>
			<description>Go 当前引起了很多关注。让我们看一下 Go 好的部分。 我最近用 Go 写了一个 SSH 服务器 ，在其中启动容器。该项目已经发展到很大规模，并且我还向 Go 发起了 PR ，以</description>
			<content type="html"><![CDATA[<p>Go 当前引起了很多关注。让我们看一下 Go 好的部分。</p>
<p><p class="md__image">
  <img src="../imgs/go-is-awesome.jpg"
    alt=""  />
</p>
</p>
<p>我最近用 Go 写了一个 <a href="https://github.com/janoszen/containerssh" target="_blank" rel="noopener">SSH 服务器</a>
，在其中启动容器。该项目已经发展到很大规模，并且我还向 Go <a href="https://go-review.googlesource.com/c/crypto/&#43;/236517" target="_blank" rel="noopener">发起了 PR</a>
，以修复我发现的错误。在积累了比 “Hello world！” 更多的经验之后，现在我有信心写出我真正喜欢的 Go 语言部分。</p>
<h2 id="跨平台">跨平台</h2>
<p>Go 引起我注意的原因之一是其构建系统。Java 的最初承诺是它是跨平台的，但是它需要安装运行时的事实显然是一个失败。而 Go 编译为本地二进制文件。在 Windows 上，您将获得一个 .exe 文件，在 Linux 上，您将获得一个 ELF 二进制文件，依此类推。而且，除非您使用 cgo，否则 Go 程序可以在几乎没有外部依赖的情况下运行。无需安装任何 .dll 或 .so 文件，Go 程序即可<a href="https://www.youtube.com/watch?v=YPN0qhSyWy8" target="_blank" rel="noopener">直接使用</a>
。</p>
<p>大部分时候，除了某些函数需要 libc 外，Go 程序可以在完全没有外部依赖的情况下运行。</p>
<p>Go 可以用来构建真正的跨平台二进制文件而无需安装笨拙的运行时（例如使用 Java 或 Python），这一事实是 Go 的主要吸引点。</p>
<h2 id="goroutines-和-channels">Goroutines 和 Channels</h2>
<p>当我开始使用 Go 语言时，我意识到它对并发的处理是多么的酷。传统上，您将使用线程或单独的进程来同时运行多个任务（例如 Java，C，C ++）。另外，您也可以依靠协作式多任务处理（例如 Javascript）来达到相同的效果。</p>
<p>对于线程和进程，操作系统必须执行的每个切换都会造成资源损耗。这称为上下文切换。换句话说，一个使用大量线程的粗心程序员将带来性能问题。</p>
<p>另一方面，协作多任务将在单个线程上运行。每当一项任务必须等待某件事时，另一项任务就会运行。如果一个任务占用了 CPU，其他任务将被饿死。</p>
<p>Go 以巧妙的方式将两者结合在一起。让我们以以下示例为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nf">someOtherFunction</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>注意 go 关键字。通过使用此关键字，someOtherFunction() 可在 goroutine 中运行。想象一下 Go 作为线程池处理并发的方式。每当您运行 goroutine 时，它将在这些线程之一中运行。这样 Go 可以优化线程的使用以提高性能。</p>
<p>为了促进 goroutine 之间的数据传输，Go 引入了通道（channel），通道是应用程序中的消息队列，用于发送数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">chan</span> <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kt">bool</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kc">true</span>
    <span class="p">}()</span>

    <span class="c1">//This will wait until the goroutine finishes
</span><span class="c1"></span>    <span class="o">&lt;-</span> <span class="nx">done</span>
<span class="p">}</span>
</code></pre></div><p>从上面的代码中可以看到，<code>&lt;- channelname</code> 将堵塞当前 goroutine 的执行，直到有可用数据为止，这使得并发编程非常容易。</p>
<p>如果您对更多细节感兴趣，请查看 <a href="https://gobyexample.com/channels" target="_blank" rel="noopener">channel</a>
，<a href="https://gobyexample.com/context" target="_blank" rel="noopener">上下文</a>
和<a href="https://gobyexample.com/mutexes" target="_blank" rel="noopener">互斥锁</a>
。</p>
<h2 id="指针defer-和垃圾收集">指针，Defer 和垃圾收集</h2>
<p>当提到指针时，首先想到的是 C 或 C++。通常，这种记忆并不愉快。</p>
<p>在 Go 中，指针更像是引用。指针并非总是将数据复制到变量中，而是指向原始的内存。不管传递包含指针的变量多少次，任何修改都将始终更改原始值。</p>
<p>让我们看一个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">someVar</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">someStruct</span><span class="p">{}</span>
</code></pre></div><p>现在，变量包含指向该结构的指针。传递时，无论您复制指针多少次，它始终指代相同的内存空间。</p>
<p>但是，与 C 指针不同，Go 指针在不再需要时会自动进行垃圾回收。您无需担心使用后释放或缓冲区溢出漏洞，这些在 Go 中都不是问题。太棒了！</p>
<p>此外，您还可以使用 defer 语句来帮助您进行函数清除。考虑以下函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">close</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Do somehing to clean up stuff
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// Do something else
</span><span class="c1"></span>    <span class="nb">close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>如您所见，我们在此函数中调用了 close() 两次。如果 foo 函数有多个出口（返回），则需要为每个出口重复 close() 调用。</p>
<p>defer 语句完全可以解决此问题：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">close</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Do somehing to clean up stuff
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">defer</span> <span class="nb">close</span><span class="p">()</span>

    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// Do something else
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>defer 语句保证 close 总是会被调用。</p>
<h2 id="多返回值">多返回值</h2>
<p>这看似没什么，但是在编程语言中却很少见。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sshConn</span><span class="p">,</span> <span class="nx">chans</span><span class="p">,</span> <span class="nx">reqs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ssh</span><span class="p">.</span><span class="nf">NewServerConn</span><span class="p">(</span><span class="nx">tcpConn</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span>
</code></pre></div><p>有什么理由不喜欢？</p>
<h2 id="oop好的部分">OOP（好的部分）</h2>
<p>尽管 Go 没有类的概念，但仍然可以编写面向对象的代码。</p>
<p>假设有以下 Java 代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">TreeNode</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addChild</span><span class="o">(</span><span class="n">child</span> <span class="n">TreeNode</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">child</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在 Go 中，类似的代码如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TreeNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">children</span> <span class="p">[]</span><span class="nx">treeNode</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">()</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">treeNode</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="nf">AddChild</span><span class="p">(</span><span class="nx">child</span> <span class="o">*</span> <span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Go 将（<code>treeNode *TreeNode</code>）部分称为接收器。Go 中的 Receiver 可以使用与其他语言中的 this 关键字非常相似的任何数据类型和功能。</p>
<h2 id="slices">Slices</h2>
<p>和许多其他低级语言一样，Go 将数组实现为固定大小的元素列表。创建后无法更改其大小。</p>
<p>另一方面，切片（Slice）是使它们动态化的技巧。当切片已满时，Go 会创建一个更大的切片新副本。Go 以尽可能少的复制的方式优化过程。</p>
<p>此外，Go slice 还具有创建不占用额外内存的子切片的简洁功能。这些切片引用原始的数组。如果更改切片中的数据，则原始数据也将更改。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">,</span> <span class="s">&#34;d&#34;</span><span class="p">}</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
	<span class="c1">// Will print [c]
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
	<span class="nx">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;f&#34;</span>
	<span class="c1">//Will print [a b f d]
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>如果您想深入了解，请继续阅读 <a href="https://gobyexample.com/slices" target="_blank" rel="noopener">Go by Example</a>
。</p>
<h2 id="库">库</h2>
<p>选择 Go 的原因之一是库数量众多。SSH 客户端和服务器库？<a href="https://godoc.org/golang.org/x/crypto/ssh" target="_blank" rel="noopener">有</a>
。适用于 AWS 的 SDK？<a href="https://aws.amazon.com/sdk-for-go/" target="_blank" rel="noopener">同样有</a>
。GitHub 操作库？<a href="https://github.com/google/go-github" target="_blank" rel="noopener">当然有</a>
。让我们尝试一些非常少用的东西……FastCGI 协议实现如何？<a href="https://golang.org/pkg/net/http/fcgi/" target="_blank" rel="noopener">当然也有</a>
。</p>
<p>我可以继续，但是没多大必要了。Go 的普及无疑对生态系统有所帮助。</p>
<h2 id="工具">工具</h2>
<p>构建 Go 拥有大量可用的工具。您拥有从<a href="https://blog.golang.org/gofmt" target="_blank" rel="noopener">自动代码格式化</a>
，测试到<a href="https://goreleaser.com/" target="_blank" rel="noopener">完整发布工具</a>
的全套工具。几乎所有的都有很多工具。</p>
<h2 id="结论">结论</h2>
<p>在代码组织方面，Go 当然有其缺点。但是，它特别适合用于各种任务的高性能软件开发。</p>
<p>那 Go 具体有哪些缺点呢？下次我们“喷一喷” Go 的缺点。</p>
<blockquote>
<p>原文链接：https://pasztor.at/blog/go-is-awesome
编译：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>从这些角度看 Go 是一门糟糕的语言</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-is-terrible/</link>
			<pubDate>Mon, 22 Jun 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-is-terrible/</guid>
			<description>上篇文章作者讲到了 Go 的优点，这篇文章提到一些缺点。然而，不少内容我是不认可的。欢迎留言说说你的观点。 Go 当前引起了很多关注。让我们看一下 Go 不好</description>
			<content type="html"><![CDATA[<blockquote>
<p>上篇文章作者讲到了 Go 的优点，这篇文章提到一些缺点。然而，不少内容我是不认可的。欢迎留言说说你的观点。</p>
</blockquote>
<p>Go 当前引起了很多关注。让我们看一下 Go 不好的部分。</p>
<p><p class="md__image">
  <img src="../imgs/go-is-terrible.jpg"
    alt=""  />
</p>
</p>
<p>作为开发人员，如今很难忽视 Go。因为诸如 Docker 和 Kubernetes 之类的软件，它已迅速崛起。但是，如果仅看一下该语言的流行度图表，Go 就与最流行或增长最快的编程语言相去甚远。</p>
<p>为何每个人似乎都在谈论和招聘 Go？从系统级工程到建立网上商店，似乎每个人都想使用 Go？这仅仅是炒作曲线吗，Go 适用于它正在执行的任务吗？</p>
<p>我最近用 Go 写了一个 <a href="https://github.com/janoszen/containerssh" target="_blank" rel="noopener">SSH 服务器</a>
，在其中启动容器。该项目已经发展到很大规模，并且我还向 Go <a href="https://go-review.googlesource.com/c/crypto/&#43;/236517" target="_blank" rel="noopener">发起了 PR</a>
，以修复我发现的错误。</p>
<p>在本文中，我将介绍一些不好的部分：语言设计的缺陷，Go 需要进一步成熟的部分，甚至是令人讨厌的地方。</p>
<p>但是，这并非完全不好：Go 具有一些很棒的功能，使其成为许多应用程序的宝贵工具。如果您对此感兴趣，请“继续”阅读上篇文章。</p>
<p>让我们看一下令人讨厌的部分。请记住，本文是基于 Go 1.14 撰写的。时间推移，这些可能会改进。</p>
<h2 id="错误处理">错误处理</h2>
<p>Go 没有异常。在我看来，尽管对异常有非常有效的批评，但 Go 选择用于处理错误的方法却更加糟糕。</p>
<p>你会看到，在 Go 中可以声明如下的函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;this is an error&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>调用此函数时，可以选择处理此错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">doSomethingElse</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">//More things to do
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这里有很多东西要解释。首先，没有什么可以强制您处理此潜在错误。当然，像 Goland 这样的 IDE 会警告您，但是编译器不会强制您处理此错误。（这个问题也可以通过 linter 来部分缓解，因为 linter 会检查您的源代码是否有类似的意外遗漏。）</p>
<p>更进一步，在 99.9％ 的情况下，错误基本上是字符串。是的，错误是您可以根据需要实现的任何接口，但是我见过的大多数 Go 代码都没有利用此接口来提供类型错误。提供类型错误的标准方法似乎如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">MyError</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;this is an error&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">MyError</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">doSomethingElse</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">MyError</span> <span class="p">{</span>
            <span class="c1">// Handle MyError specifically
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Handle other errors
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//More things to do
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这是样板代码，用于简单的错误处理。但是，更大的问题是函数无法声明它们返回的错误类型。当我使用第三方库的函数进行此操作时，有两个选择：</p>
<ol>
<li>我使用 IDE 跳入第三方库，对它引发的错误类型进行反向工程，然后对其进行处理。在我的职业生涯中，我已经用大约十二种编程语言编写了生产级代码，但是我从来没有像 Go 那样做过这么多的逆向工程。</li>
<li>将错误视为一串未知内容。</li>
</ol>
<p>我研究过的几乎所有 Go 代码都使用选项 2。难怪，这是更简单的代码选项。这导致以下两种模式之一：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;an error happened (%v)&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>第一种选择基本上等同于异常。除了会导致大量的样板代码。第二个选项使程序崩溃，并显示无用的错误消息。</p>
<p>我有强迫开发人员显式处理错误的想法，但是我见过的大多数 Go 代码都只是使用这两种无意识模式之一。</p>
<p>为什么我们不仅仅拥有捕获类型错误的异常？这样会更简单，并且会导致更少的样板代码。哎，现在可能为时已晚。</p>
<h2 id="nullability可空性">Nullability（可空性）</h2>
<p>Go 中的 nil 值可用于任何<a href="https://tour.golang.org/moretypes/1" target="_blank" rel="noopener">指针类型</a>
。指针保存一块内存的地址。在 Go 中，您无法直接分配内存，但是其他编程语言（例如 C）可以实现这一点。指针地址 0 是不指向任何地方的同义词。当然，内存地址为 0 并不一定意味着内存位置无效，但是现代的编译器可以理解这一点，并将空指针转换为要编译的 CPU 体系结构的相应无值类型。</p>
<p>现在，在 Go 中，nil 值实际上是一个问题，因为没有用语言的方式来指示值是否可以为 null。</p>
<pre><code class="language-ggo" data-lang="ggo">something := getSomething()
something.process()
</code></pre><p>如果 something 是 nil，此代码可能会导致崩溃。是的，全面崩溃。当然，您可以重写代码以包括错误处理，但是，如果 Go 从其他语言的错误中学到什么了，那就更好了。</p>
<h2 id="范围界定和代码结构">范围界定和代码结构</h2>
<p>到目前为止，我发现最大的 Bug 是范围界定。Go 没有公开，私有或受保护的限定词。编译器将所有 .go 文件放在同一包中并合并。如果变量名，接口等以小写开头字母书写，则将其视为“私有”，并且仅在程序包中可见。如果以大写首字母书写，则为“公开”。</p>
<p>换句话说，小写字母只能在同一包中访问，大写字母是全局可见的。不幸的是，没有办法限制同一程序包中的可见性。</p>
<blockquote>
<p>注意：使用 Go 模块（这是首选方法）时，一个软件包表示一个目录。其他构建系统（如 Bazel）允许每个目录包含多个软件包。这在某种程度上减轻了范围界定的不足。</p>
</blockquote>
<p>假设您有一个数据结构，以及一组实现非常特定的业务逻辑的函数。某些不熟悉业务逻辑的人可能不会考虑太多，而是在同一包中实现了一种功能，该功能以一种从业务角度来看并不理想的方式更改数据。</p>
<p>在其他编程语言中，通常可以通过更精细的作用域来防止这种情况。例如，您可以使用类并创建私有成员变量来封装数据。</p>
<p>您有两种选择来解决此问题：</p>
<ol>
<li>相信没有人会违反任何存储数据的完整性。</li>
<li>以这样的方式组织您的代码，即每个软件包仅包含最少数量的代码。</li>
</ol>
<p>当然，您可以选择选项 1，但我从未见过这样的选择。总是有一个同事匆忙地执行某些事情而没有思考。范围界定可以使不好的事情变得困难，而让好事情变得容易。这称为防御性编程。</p>
<p>在 Go 防御性编程中，您必须创建许多目录。我认为太多了。可能你会认为 Java 的文件和目录太多了……</p>
<h2 id="缺乏不变性">缺乏不变性</h2>
<p>防御性编程中的另一个有用工具是不变性。不变的数据结构可防止在创建数据结构后对其进行修改，因此只能对其进行复制。尽管就性能而言这不是很有效，但也需要防止意外的副作用。</p>
<p>想象一下一个 HTTP 请求结构体：应用程序的第一层创建它，然后将其向下传递给几个模块。如果将请求结构作为指针向下传递，则修改请求的任何层都将对其进行全局修改，从而在顶层产生潜在的副作用。</p>
<p>即使您不使用指针而按值切片传递结构，仍然是可变的数据结构。</p>
<p>Go 似乎在很大程度上优先考虑性能，而不是避免潜在的错误。除了<a href="https://github.com/jinzhu/copier" target="_blank" rel="noopener">第三方深层复制库</a>
之外，没有语言可以在模块边界创建安全的数据传输。</p>
<p>换句话说，除非使用深层复制库，否则开发人员必须知道整个应用程序中的数据会发生什么，以确保没有意外的副作用。</p>
<h2 id="缺乏泛型">缺乏泛型</h2>
<p>泛型是创建可重用代码的便捷方法。假设我们要建造一棵树。在 Java 中，它可能如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">()</span>
<span class="n">tree</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span>
    <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="s">&#34;Hello world!&#34;</span><span class="o">)</span>
<span class="o">)</span>
<span class="c1">//...
</span><span class="c1"></span><span class="n">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">getChild</span><span class="o">(</span><span class="n">0</span><span class="o">).</span><span class="na">getData</span><span class="o">()</span>
</code></pre></div><p>如果我们这样编写代码，则数据变量将具有 Object 类型，而没有特定信息。实际上，它是一个字符串，因此我们将没有代码自动提示。我们将需要进行类型转换：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">tree</span><span class="o">.</span><span class="na">getChild</span><span class="o">(</span><span class="n">0</span><span class="o">).</span><span class="na">getData</span><span class="o">()</span>
</code></pre></div><p>如果包含的数据不是字符串，则将导致错误。要变通解决此问题，我们可以使用泛型为包含的数据指定类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span>
<span class="n">tree</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span>
    <span class="k">new</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span><span class="s">&#34;Hello world!&#34;</span><span class="o">)</span>
<span class="o">)</span>
<span class="c1">//...
</span><span class="c1"></span><span class="n">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">getChild</span><span class="o">(</span><span class="n">0</span><span class="o">).</span><span class="na">getData</span><span class="o">()</span>
</code></pre></div><p>在这种情况下，数据将是字符串，并且我们可以确保树中只有字符串。</p>
<p>现在 Go 缺乏此特性。因为我们总是需要强制转换为我们相信或希望将返回的数据类型。</p>
<h2 id="oop不好的部分">OOP（不好的部分）</h2>
<p>既然我们讨论了树结构，让我们看一下如何在 Go 中实现树节点。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">tree</span>

<span class="kd">type</span> <span class="nx">TreeNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">children</span> <span class="p">[]</span><span class="nx">treeNode</span>
    <span class="nx">data</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nf">TreeNode</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">treeNode</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="nf">AddChild</span><span class="p">(</span><span class="nx">child</span> <span class="o">*</span> <span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">treeNode</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="nf">GetChild</span><span class="p">(</span><span class="nx">childIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">childIndex</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p>是的，它没有错误处理，但你知晓了。我们本身没有一个类，但是我们有一个叫做接收器的怪异结构，它是这部分的：<code>（treeNode *TreeNode）</code>。接收者基本上就是其他 OOP 语言中的 this 或 self 关键字。</p>
<p>在 Go 中，您将像这样使用 TreeNode：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tree</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">(</span><span class="nx">data</span> <span class="nx">here</span><span class="p">)</span>
<span class="nx">tree</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="nf">New</span><span class="p">(</span><span class="nx">data</span> <span class="nx">here</span><span class="p">))</span>
</code></pre></div><p>您甚至可以实现接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TreeNodeInterface</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">AddChild</span><span class="p">(</span><span class="nx">child</span> <span class="nx">TreeNode</span><span class="p">)</span>
    <span class="nf">GetChild</span><span class="p">(</span><span class="nx">childIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">TreeNode</span>
<span class="p">}</span>
</code></pre></div><p>非常简单，上面的接口已经实现了此接口。不需要特殊的关键字，当深入研究新代码时，这并不是完全有帮助。像 Goland 这样的 IDE 可以帮助您进行代码导航，但是很难知道哪种实现在哪里。此外，如果因为没有实现某个接口的一个方法，则代码导航将不再起作用。</p>
<p>此外值得一提的是，缺少继承和泛型，使编写可重用代码非常困难。</p>
<h2 id="没有枚举">没有枚举</h2>
<p>有一个古怪的问题，可能是由于语言的构建方式引起的。现在我们彻头彻尾的傻了。在实现 <a href="https://github.com/janoszen/containerssh" target="_blank" rel="noopener">SSH 服务器</a>
时，我遇到了一段代码，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">newChannel</span><span class="p">.</span><span class="nf">Reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
</code></pre></div><p>参数 reason 是一个 channel.RejectionReason 类型。你认为该类型是什么？让我们使用 IDE 的功能来解决它。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// RejectionReason is an enumeration used when rejecting channel creation
</span><span class="c1">// requests. See RFC 4254, section 5.1.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RejectionReason</span> <span class="kt">uint32</span>
</code></pre></div><p>酷！这是一个 32 位无符号整数。它可以有什么值？不清楚。可以检查我是否发送了无效的值吗？不能。Go 中没有枚举。可能的值分别定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Prohibited</span> <span class="nx">RejectionReason</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">ConnectionFailed</span>
	<span class="nx">UnknownChannelType</span>
	<span class="nx">ResourceShortage</span>
<span class="p">)</span>
</code></pre></div><p>这些值与上面的类型定义无关。世界上没有任何 IDE 可以为您提供代码完成功能，因此您必须深入研究用于解决此问题的库。</p>
<h2 id="包管理">包管理</h2>
<p>长期以来，Go 中的软件包管理绝对是糟糕的。值得庆幸的是，从 1.11 Go 起引入了模块，但是依赖管理距离其他语言还有很长的路要走。</p>
<p>一个主要问题是，它们使用 git 作为软件包管理工具。程序包通常不包含有关其作者，许可证，版本号等的任何元信息。发布版本后，不会冻结任何代码，这完全打破了以后不会更改版本的假设。没有简洁的方法来遵守 Apache 许可要求，以任何合理的方式在您的最终版本中包括 NOTICE 文件。是的，我知道，大多数人不会瞎弄，但实际上你能保证吗？</p>
<h2 id="炒作">炒作</h2>
<p>最后，最愚蠢的是：炒作。如果您想构建系统级的东西，甚至微小优化都可以带来明显的好处，那么 Go 是一种很棒的语言。很明显，它是在考虑执行速度的基础上构建的，以及代码的可维护性。</p>
<p>我遇到的每个较大的 Go 项目都存在一个可怕的混乱局面，它比普通的 Javascript 框架具有更多的依赖项。您必须专注于微小的实现细节，而不是宏观的概念。</p>
<p>Go 不太适合具有大量业务逻辑的应用程序。或网上商店。或您作为普通开发人员遇到的 99％ 的项目 。您不是 Google，并且没有类似 Google 的性能问题。</p>
<h2 id="结论">结论</h2>
<p>Go 当然是系统级开发的绝佳工具，但付出的代价是认知负担。我绝对不想编写带有沉重业务逻辑的内容，但我一直在努力寻找一种更好的工具来编写高性能的系统工具或实用程序。</p>
<blockquote>
<p>原文链接：<a href="https://pasztor.at/blog/go-is-terrible">https://pasztor.at/blog/go-is-terrible</a></p>
<p>编译：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——实战篇0：使用 Echo 开发一个博客系统</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/action00-intro/</link>
			<pubDate>Sat, 16 May 2020 15:08:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/action00-intro/</guid>
			<description>实战是掌握一门技术很好的方式：纸上得来终觉浅，绝知此事要躬行！ 在初步了解了 Echo 框架的特性、功能后，我们通过具体的一个项目来掌握 Echo 框架，这个项目</description>
			<content type="html"><![CDATA[<p>实战是掌握一门技术很好的方式：纸上得来终觉浅，绝知此事要躬行！</p>
<p>在初步了解了 Echo 框架的特性、功能后，我们通过具体的一个项目来掌握 Echo 框架，这个项目就是写一个博客系统。</p>
<h2 id="实战篇目标">实战篇目标</h2>
<ul>
<li>掌握 go/echo 开发项目的方法；</li>
<li>通过项目更深入掌握 echo；</li>
<li>完善完善，甚至可以作为自己的一个博客系统使用；</li>
</ul>
<p>因此，在项目实战过程中可能引申讲解 Echo 的特性，毕竟基础篇对 Echo 的特性没有深入讲解。</p>
<h2 id="依赖技术">依赖技术</h2>
<p>该实战项目计划采用前后端分离的方式进行。前端采用 Vue + ElementUI。前端不是强项，目标就是争取能做出来，还凑合，如果你是 Vue 老手，欢迎帮忙处理这块。</p>
<h2 id="主要功能">主要功能</h2>
<p>我们会实现博客系统常用的一些功能，包括：</p>
<ul>
<li>列表页</li>
<li>详情页</li>
<li>归档</li>
<li>标签</li>
<li>浏览数</li>
<li>简单的管理后台</li>
</ul>
<p>该项目代码放在 GitHub 上：<a href="https://github.com/polaris1119/go-echo-example">https://github.com/polaris1119/go-echo-example</a> ，欢迎 star 。</p>
]]></content>
		</item>
		
		<item>
			<title>当 GoLand 遇到 Kubernetes：如何调试和运行 Go 程序</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/using-kubernetes-from-goland/</link>
			<pubDate>Mon, 11 May 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/using-kubernetes-from-goland/</guid>
			<description>这是我们使用 Docker，Docker Compose 或 Kubernetes 运行 Go 服务的系列文章的最后一部分。在这一部分中，我们将专注于使用 Kubernetes 集群时的运行和调试。
虽然我们不会介绍如何安装和配置 Kubernetes 集群，但是可以使用各种工具（例如 kubeadm ，minikube 和 microk8s ）来实现这一目标。如果您使用的是 Windows，则 Docker Desktop for Windows 附带内置的 Kubernetes 支持 。如果您打算使用基于 ARM 芯片的平台（例如 Raspberry Pi 4 ），则可以使用 k3s 之类的东西来入门。
在开始之前，还应该安装 Kubernetes 插件，因为它没有与 IDE 捆绑在一起。您可以通过打开 Settings/Preferences | Plugins | Marketplace并搜索 Kubernetes 找到并安装插件。
在 IDE 中使用 Kubernetes 运行服务 如果您到目前为止一直在关注本系列，那么您会知道所有代码都可以在此 下载和使用，使用 Kubernetes 也是这种情况。我们可以从 kubernetes 分支 开始。
在这里我们可以找到两个不同的文件：db.yaml 和 web.yaml。这些文件包含了我们开始使用 Kubernetes 集群中的应用程序所需的所有定义。为了方便起见，他们还假定 Kubernetes 与 IDE 在同一台计算机上运行。
打开 db.yaml：</description>
			<content type="html"><![CDATA[<p>这是我们使用 Docker，Docker Compose 或 Kubernetes 运行 Go 服务的系列文章的最后一部分。在这一部分中，我们将专注于使用 Kubernetes 集群时的运行和调试。</p>
<p>虽然我们不会介绍如何安装和配置 Kubernetes 集群，但是可以使用各种工具（例如 <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">kubeadm</a>
，<a href="https://kubernetes.io/docs/setup/learning-environment/minikube/" target="_blank" rel="noopener">minikube</a>
 和 <a href="https://microk8s.io/" target="_blank" rel="noopener">microk8s</a>
）来实现这一目标。如果您使用的是 Windows，则 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker Desktop for Windows</a>
 附带<a href="https://docs.docker.com/docker-for-windows/kubernetes/" target="_blank" rel="noopener">内置的 Kubernetes 支持</a>
。如果您打算使用基于 ARM 芯片的平台（例如 <a href="https://blog.jetbrains.com/go/2020/02/18/running-goland-on-a-raspberry-pi-4/" target="_blank" rel="noopener">Raspberry Pi 4</a>
），则可以使用 <a href="https://k3s.io/" target="_blank" rel="noopener">k3s</a>
 之类的东西来入门。</p>
<p>在开始之前，还应该安装 Kubernetes 插件，因为它没有与 IDE 捆绑在一起。您可以通过打开 <code>Settings/Preferences | Plugins | Marketplace</code>并搜索 Kubernetes 找到并安装插件。</p>
<h2 id="在-ide-中使用-kubernetes-运行服务">在 IDE 中使用 Kubernetes 运行服务</h2>
<p>如果您到目前为止一直在关注本系列，那么您会知道所有代码都可以<a href="https://github.com/dlsniper/dockerdev" target="_blank" rel="noopener">在此</a>
下载和使用，使用 Kubernetes 也是这种情况。我们可以从 <a href="https://github.com/dlsniper/dockerdev/tree/kubernetes" target="_blank" rel="noopener">kubernetes 分支</a>
开始。</p>
<p>在这里我们可以找到两个不同的文件：db.yaml 和 web.yaml。这些文件包含了我们开始使用 Kubernetes 集群中的应用程序所需的所有定义。为了方便起见，他们还假定 Kubernetes 与 IDE 在同一台计算机上运行。</p>
<p>打开 db.yaml：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ConfigMap</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-config</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w"></span><span class="nt">data</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">POSTGRES_DB</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">  </span><span class="nt">POSTGRES_USER</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">  </span><span class="nt">POSTGRES_PASSWORD</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">StatefulSet</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">serviceName</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">          </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">postgres:12.2-alpine</span><span class="w">
</span><span class="w">          </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">IfNotPresent</span><span class="w">
</span><span class="w">          </span><span class="nt">envFrom</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">configMapRef</span><span class="p">:</span><span class="w">
</span><span class="w">                </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-config</span><span class="w">
</span><span class="w">          </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span><span class="w">
</span><span class="w">          </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-init</span><span class="w">
</span><span class="w">              </span><span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/docker-entrypoint-initdb.d/init.sql</span><span class="w">
</span><span class="w">              </span><span class="nt">subPath</span><span class="p">:</span><span class="w"> </span><span class="l">init.sql</span><span class="w">
</span><span class="w">      </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-init</span><span class="w">
</span><span class="w">           </span><span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span><span class="w">             </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/d/GoLandProjects/dockerdev</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db-exported</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">NodePort</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span>-<span class="l">tcp</span><span class="w">
</span><span class="w">      </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span><span class="w">
</span><span class="w">      </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span><span class="w">
</span><span class="w">      </span><span class="nt">nodePort</span><span class="p">:</span><span class="w"> </span><span class="m">30432</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span></code></pre></div><p><strong>注意</strong>：在启动此示例之前，我们需要确保更改了 init.sql 文件在主机上的位置。您可以通过将路径：/d/ GoLandProjects / dockerdev 替换为先前克隆该项目的位置的路径来实现。</p>
<p>完成此操作后，我们可以使用文件顶部编辑器装订线上的绿色箭头在 Kubernetes 中部署数据库。</p>
<p>部署数据库将创建一个 StatefulSet 并在 pod 中运行数据库。将出现 “Services Tool” 窗口，并显示用于创建资源的命令以及该命令的输出。</p>
<h2 id="kubernetes-集群概述">Kubernetes 集群概述</h2>
<p>在 Kubernetes 集群中，我们将看到工作负载信息，例如正在运行的 Pods, Deployments, Stateful Sets, Daemon Sets, Jobs, Cron Jobs, Replica Sets, 和 Replication Controllers。</p>
<p><p class="md__image">
  <img src="../imgs/14-Launching-a-Kubernetes-ReplicaSet-from-GoLand.gif"
    alt=""  />
</p>
</p>
<p>我们还可以查看有关集群中服务和入口点的网络信息。</p>
<p><p class="md__image">
  <img src="../imgs/15-Kubernetes-Services-and-Ingress-points.gif"
    alt=""  />
</p>
</p>
<p>“Configuration” 部分包含当前名称空间或群集的所有配置信息，例如有关运行名称空间，节点，群集角色，角色，配置 map 和秘钥的信息。</p>
<p><p class="md__image">
  <img src="../imgs/16-Kubernetes-Configuration-options.gif"
    alt=""  />
</p>
</p>
<p>最后，“Storage” 部分将向我们显示当前配置中的“持久卷”，“持久卷声明”和“存储类”。</p>
<p><p class="md__image">
  <img src="../imgs/17-Kubernetes-Storage-options.gif"
    alt=""  />
</p>
</p>
<h2 id="在-ide-中使用-kubernetes-集群运行-go-应用程序">在 IDE 中使用 Kubernetes 集群运行 Go 应用程序</h2>
<p>让我们在同一个 Kubernetes 集群中运行 Go 应用程序，看看它是如何工作的。</p>
<p>不过，在运行该应用程序之前，我们首先需要构建该应用程序所在的 Docker 容器。示例代码库中包含一个名为 build Dockerfile 的运行配置，需要运行该配置才能在集群中使用我们的容器。</p>
<p>正如您可能已经猜到的那样，此后，我们终于可以使用先前与 db.yaml 文件一起使用的绿色箭头在 Kubernetes 中运行 Go 应用程序，只有这次我们才在 web.yaml 文件中使用它。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-web</span><span class="w">
</span><span class="w">          </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-web:latest</span><span class="w">
</span><span class="w">          </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Never</span><span class="w">
</span><span class="w">          </span><span class="nt">env</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">DD_DB_HOST</span><span class="w">
</span><span class="w">              </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;dockerdev-db-exported&#34;</span><span class="w">
</span><span class="w">          </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-web-exported</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">NodePort</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span>-<span class="l">tcp</span><span class="w">
</span><span class="w">      </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span><span class="w">
</span><span class="w">      </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span><span class="w">
</span><span class="w">      </span><span class="nt">nodePort</span><span class="p">:</span><span class="w"> </span><span class="m">30800</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span></code></pre></div><p><p class="md__image">
  <img src="../imgs/18-Run-a-Go-service-in-Kubernetes-with-GoLand.gif"
    alt=""  />
</p>
</p>
<p><strong>Pro tip</strong>：我们可以使用 HTTP 请求文件的方式从 IDE 运行请求，以检查服务是否已启动并正在运行。</p>
<p><p class="md__image">
  <img src="../imgs/19-Run-HTTP-Request-from-IDE.gif"
    alt=""  />
</p>
</p>
<h2 id="从-kubernetes-调试服务">从 Kubernetes 调试服务</h2>
<p>在使用 GoLand 调试 Kubernetes 服务之前，我们需要对 web.yaml 文件进行一些更改。这些变化可以在我们代码库的 kubernetes-debug 分支中看到。</p>
<p>我们需要进行一些与调试常规 Docker 容器非常相似的更改。</p>
<p>首先，我们需要调整 Dockerfile，然后我们必须使用 <code>Run | Run … | ‘build Dockerfile’ </code>来配置。</p>
<p>接着我们可以使用 <code>Run | Debug … | Kubernetes Service</code>，它将启动 Go Remote 调试配置。</p>
<p><p class="md__image">
  <img src="../imgs/20-Debugging-Go-Service-running-in-Kubernetes.gif"
    alt=""  />
</p>
</p>
<p>调试器将跟之前我们习惯的调试形式一样工作。</p>
<p>这个系列文章是我们使用 Docker，Docker Compose 和 Kubernetes 运行和调试 Go 微服务的总结。</p>
<p>在本文中，我们讨论了如何使用 Kubernetes 插件来编辑 Deployment 文件，以便它将正常启动，从而可以对其进行调试。</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/go/2020/05/11/using-kubernetes-from-goland/</p>
<p>作者：Florin Pățan</p>
<p>翻译：Go语言中文网 polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>在 GoLang 中使用 Docker Compose 运行 Go 应用程序</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/running-go-applications-using-docker-compose-in-goland/</link>
			<pubDate>Fri, 08 May 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/running-go-applications-using-docker-compose-in-goland/</guid>
			<description>今天，我们将继续有关如何使用 Docker 运行 和调试 Go 应用程序 的系列文章。
在本文中，我们将使用 Docker Compose 运行和调试我们的应用程序。对于本文，我们将使用此处的源代码 ，在开始之前切换到 compose 分支 。
使用 Docker Compose 运行 Go 应用程序 让我们从使用 Docker Compose 运行应用程序开始。
查看我们已经创建的项目，可以在代码仓库中找到 docker-compose.yaml 文件：
version:&amp;#34;3.5&amp;#34;services:web:container_name:dockerdevbuild:./ports:- &amp;#34;8000:8000&amp;#34;environment:DD_DB_HOST:dbcommand:/serverdepends_on:- dbdb:container_name:dockerdev-dbimage:postgres:12.2-alpineports:- &amp;#34;5432:5432&amp;#34;environment:POSTGRES_USER:golandPOSTGRES_PASSWORD:golandPOSTGRES_DB:golandvolumes:- ./init.sql:/docker-entrypoint-initdb.d/init.sql在数据库部分，我们需要创建一个名为 init.sql 的新文件。该文件的内容用于设置服务运行所需的数据库。
最后，让我们在 main.go 文件中运行 Sync packages of &amp;lt;project&amp;gt; 来 quick-fix，以下载 pgx 库并运行该应用程序。注意：如果你的模块缓存中还没有 pgx 的 4.5.0 版本，则需要执行此步骤。
运行基于 Docker Compose 的应用程序类似于其他 Run Configurations。单击 docker-compose.yaml 中 services 指令旁边的双绿色箭头按钮。要仅运行一项服务，请点击要运行的服务类型旁边的绿色箭头，例如上面的示例配置中的 web 或 db。
配置运行后，在 Docker 节点下的 Services Tool 窗口中会有一个名为 Compose 的新节点。这里会显示正在运行的每个 Docker Compose 服务套件。</description>
			<content type="html"><![CDATA[<p>今天，我们将继续有关<a href="https://mp.weixin.qq.com/s/2tajxPBhGwgwlT4TzAgmVw" target="_blank" rel="noopener">如何使用 Docker 运行</a>
和<a href="https://mp.weixin.qq.com/s/4-fkIWcr_3LdLFALVk4ZTA" target="_blank" rel="noopener">调试 Go 应用程序</a>
的系列文章。</p>
<p>在本文中，我们将使用 Docker Compose 运行和调试我们的应用程序。对于本文，我们将使用<a href="https://github.com/dlsniper/dockerdev/tree/compose" target="_blank" rel="noopener">此处的源代码</a>
，在开始之前切换到 <a href="https://github.com/dlsniper/dockerdev/tree/compose" target="_blank" rel="noopener">compose 分支</a>
。</p>
<h2 id="使用-docker-compose-运行-go-应用程序">使用 Docker Compose 运行 Go 应用程序</h2>
<p>让我们从使用 Docker Compose 运行应用程序开始。</p>
<p>查看我们已经创建的项目，可以在代码仓库中找到 docker-compose.yaml 文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3.5&#34;</span><span class="w">
</span><span class="w"> 
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">web</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev</span><span class="w">
</span><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;8000:8000&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">DD_DB_HOST</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">/server</span><span class="w">
</span><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">db</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">postgres:12.2-alpine</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;5432:5432&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_USER</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_PASSWORD</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_DB</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">./init.sql:/docker-entrypoint-initdb.d/init.sql</span><span class="w">
</span></code></pre></div><p>在数据库部分，我们需要创建一个名为 init.sql 的新文件。该文件的内容用于设置服务运行所需的数据库。</p>
<p>最后，让我们在 main.go 文件中运行 <code>Sync packages of &lt;project&gt;</code> 来 quick-fix，以下载 <a href="https://github.com/jackc/pgx/" target="_blank" rel="noopener">pgx</a>
 库并运行该应用程序。注意：如果你的模块缓存中还没有 pgx 的 4.5.0 版本，则需要执行此步骤。</p>
<p>运行基于 Docker Compose 的应用程序类似于其他 <code>Run Configurations</code>。单击 docker-compose.yaml 中 services 指令旁边的双绿色箭头按钮。要仅运行一项服务，请点击要运行的服务类型旁边的绿色箭头，例如上面的示例配置中的 web 或 db。</p>
<p><p class="md__image">
  <img src="../imgs/11-Running-Docker-Compose-from-the-IDE.gif"
    alt=""  />
</p>
</p>
<p>配置运行后，在 Docker 节点下的 <code>Services Tool</code> 窗口中会有一个名为 Compose 的新节点。这里会显示正在运行的每个 Docker Compose 服务套件。</p>
<p>可以浏览每个服务定义，并为每个服务显示所有正在运行的实例。Docker Compose 服务中可用于容器的信息与常规 Docker 容器可使用的信息相同。</p>
<p><strong>注意</strong>：如果你要启动较重的服务（例如数据库服务器），或者这些服务需要一些初始化时间，则我们的 Go 程序服务需要考虑这些服务的启动时间。</p>
<p>在我们的示例代码中，这是使用 getDBConnection 函数处理的，该函数尝试在放弃之前尝试几次以指数退避的方式连接到数据库。</p>
<h2 id="重启动-docker-compose-服务">重启动 Docker Compose 服务</h2>
<p>更改我们的代码后，我们需要重新启动服务以重新加载这些更改。目前，使用 IDE 重新启动它有点复杂，因为这样做需要你执行以下步骤：</p>
<ul>
<li>执行 <code>Run | Edit Configurations</code> 并复制一份现有的 Docker Compose 配置；</li>
<li>编辑新创建的配置以添加重新启动的服务的名称，并启用 <code>–build</code> 选项以强制在运行镜像之前对其进行重建；</li>
</ul>
<p>完成这些步骤之后，你可以停止现有服务，删除现有容器，然后启动新创建的配置。</p>
<p><p class="md__image">
  <img src="../imgs/12-Restart-Docker-Compose-service.gif"
    alt=""  />
</p>
</p>
<p><strong>Pro tip</strong>：你可以使用 “Delete” 功能同时停止和删除服务。</p>
<h2 id="使用-docker-compose-调试-go-应用程序">使用 Docker Compose 调试 Go 应用程序</h2>
<p>要使用 Docker Compose 调试应用程序，我们需要同时更改 Dockerfile 和 docker-compose.yaml 文件。我们可以切换到代码库的 <a href="https://github.com/dlsniper/dockerdev/tree/compose-debug" target="_blank" rel="noopener">compose-debug 分支</a>
，这样更容易理解。</p>
<p>现在，docker-compose.yaml 文件如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3.5&#34;</span><span class="w">
</span><span class="w"> 
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">web</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev</span><span class="w">
</span><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;8000:8000&#34;</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;40000:40000&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">DD_DB_HOST</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">    </span><span class="nt">security_opt</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;seccomp:unconfined&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">cap_add</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">SYS_PTRACE</span><span class="w">
</span><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">/dlv --headless --listen=:40000 --api-version=2 exec /server</span><span class="w">
</span><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">db</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">postgres:12.2-alpine</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;5432:5432&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_USER</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_PASSWORD</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_DB</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">./init.sql:/docker-entrypoint-initdb.d/init.sql</span><span class="w">
</span></code></pre></div><p><strong>注意</strong>：这里的重要部分是 security_opt 和 cap_add 属性，因为它们允许调试器在 Docker 环境中运行。</p>
<p>运行此操作类似于运行常规 Docker Compose 配置。我们可以使用 Go Remote 配置连接到容器，调试器会话将像调试常规配置一样开始。</p>
<p><p class="md__image">
  <img src="../imgs/13-Debugging-Go-Service-in-Docker-Compose.gif"
    alt=""  />
</p>
</p>
<p>今天我们的文章到此结束。我们已经讨论了如何使用 Docker Compose，以及如何从 GoLand 运行和调试我们的应用程序。</p>
<p>在下一篇文章中，我们将介绍如何在 IDE 中使用 Kubernetes，以及如何使用它运行和调试我们的应用程序。</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/go/2020/05/08/running-go-applications-using-docker-compose-in-goland/</p>
<p>作者：Florin Pățan</p>
<p>翻译：Go语言中文网 polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>基于 GoLand 使用 Docker 容器进行 Go 开发</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/debugging-a-go-application-inside-a-docker-container/</link>
			<pubDate>Mon, 04 May 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/debugging-a-go-application-inside-a-docker-container/</guid>
			<description>今天，我们开始撰写一系列有关 GoLand 内部对 Docker，Docker Compose 和 Kubernetes 的支持以及它如何帮助我们在 Go 中编写（微）服务的文章。
我们将研究如何在 IDE 中配置项目，如何使用 Docker 或 Kubernetes 运行或调试我们的项目，以及如何将项目连接到我们选择的数据库 PostgreSQL。
让我们从介绍普通的 Docker 工作流程开始，然后我们将构建容器并运行它。
在继续之前，我们需要 GoLand 2020.1.1 或更高版本，该版本带有最新的 Docker 插件。我们还需要一个相当现代的 Docker 版本，例如 17.06 或更高版本。注意：虽然旧版本的 IDE 在一定程度上可以使用，但是本文使用了新功能，并且 IDE 的外观可能有所不同。
项目设置 让我们开始设置我们的项目。
我们可以创建一个新的 Go Modules 项目，也可以使用现有的项目。
项目结构应类似于此仓库中的结构：https://github.com/dlsniper/dockerdev。
本教程不会介绍如何为你的系统安装和配置 Docker。
相反，我们将从配置 Docker 服务器开始，以便我们可以运行我们的应用程序。将 Docker 安装到系统中后，转到 Settings/Preferences | Build, Execution, Deployment | Docker，然后单击 + 按钮添加新的 Docker 服务器连接。
默认情况下，该插件将创建与本地计算机 Docker 服务器的连接，对于我们的教程而言已经足够了。单击确定按钮以创建服务器配置。
使用 Dockerfile 首先，让我们在项目的根目录中打开 Dockerfile。
# Compile stage FROM golang:1.</description>
			<content type="html"><![CDATA[<p>今天，我们开始撰写一系列有关 GoLand 内部对 Docker，Docker Compose 和 Kubernetes 的支持以及它如何帮助我们在 Go 中编写（微）服务的文章。</p>
<p>我们将研究如何在 IDE 中配置项目，如何使用 Docker 或 Kubernetes 运行或调试我们的项目，以及如何将项目连接到我们选择的数据库 PostgreSQL。</p>
<p>让我们从介绍普通的 Docker 工作流程开始，然后我们将构建容器并运行它。</p>
<p>在继续之前，我们需要 GoLand 2020.1.1 或更高版本，该版本带有最新的 Docker 插件。我们还需要一个相当现代的 Docker 版本，例如 17.06 或更高版本。注意：虽然旧版本的 IDE 在一定程度上可以使用，但是本文使用了新功能，并且 IDE 的外观可能有所不同。</p>
<h2 id="项目设置">项目设置</h2>
<p>让我们开始设置我们的项目。</p>
<p>我们可以创建一个新的 Go Modules 项目，也可以使用现有的项目。</p>
<p>项目结构应类似于此仓库中的结构：<a href="https://github.com/dlsniper/dockerdev">https://github.com/dlsniper/dockerdev</a>。</p>
<p>本教程不会介绍如何为你的系统安装和配置 Docker。</p>
<p>相反，我们将从配置 Docker 服务器开始，以便我们可以运行我们的应用程序。将 Docker 安装到系统中后，转到 <code>Settings/Preferences | Build, Execution, Deployment | Docker</code>，然后单击 + 按钮添加新的 Docker 服务器连接。</p>
<p>默认情况下，该插件将创建与本地计算机 Docker 服务器的连接，对于我们的教程而言已经足够了。单击确定按钮以创建服务器配置。</p>
<p><p class="md__image">
  <img src="../imgs/01-Configure-Docker-Server.gif"
    alt=""  />
</p>
</p>
<h2 id="使用-dockerfile">使用 Dockerfile</h2>
<p>首先，让我们在项目的根目录中打开 Dockerfile。</p>
<pre><code class="language-dockefile" data-lang="dockefile"># Compile stage
FROM golang:1.13.8 AS build-env
 
ADD . /dockerdev
WORKDIR /dockerdev
 
RUN go build -o /server
 
# Final stage
FROM debian:buster
 
EXPOSE 8000
 
WORKDIR /
COPY --from=build-env /server /
 
CMD [&quot;/server&quot;]
</code></pre><p>该 Dockerfile 使用多阶段构建，该方式使我们能够生成最小的 Docker 映像，因为构建应用程序二进制文件的编译阶段与构建容器的最终阶段是分开的。</p>
<p>将上面的代码粘贴到 Dockerfile 中后，第一个 <code>FROM […]</code> 指令旁边会出现一个绿色箭头。这是运行容器的最快方法。</p>
<p>但是，我们需要进行一些编辑才能运行它，因为我们需要为容器公开正确的端口以接收连接。</p>
<p><p class="md__image">
  <img src="../imgs/02-Dockerfile.png"
    alt="02 - Dockerfile"  />
</p>
</p>
<h2 id="为容器创建一个新的运行配置">为容器创建一个新的运行配置</h2>
<p>我们可以创建一个新的运行配置，也可以编辑仓库中存在的配置。为了简单起见，直接使用现有的，因为它已经预先填写了我们需要的所有值。要对其进行编辑，请单击选项列表底部的 <code>Edit ‘Docker – Web – Standalone’ </code> 选项。</p>
<p>在这里，我们可以设置运行 Docker 容器所需的所有选项。我们的运行配置已经填上了重要内容，例如配置名称：“ Docker – Web Dev – Standalone”。容器名称设置为 docker-web-dev-standalone。最后，在“绑定端口”字段中，我们将“主机”端口和“容器”端口都设置为 8000，以便可以访问应用程序。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/05/03-Edit-Dockerfile-Run-Configuration.png"
    alt="03 - Edit Dockerfile Run Configuration"  />
</p>
</p>
<p>现在，我们可以单击对话框底部的 “Run” 按钮，来启动我们的容器。</p>
<h2 id="了解服务工具窗口">了解服务工具窗口</h2>
<p>Docker 完成构建过程后，我们可以查看 “Services Tool Window” 窗口，并在 “Containers” 部分中看到新创建的容器。我们还将在 “Images” 部分中看到使用的镜像。</p>
<p>对于每个容器，有以下可用选项卡：</p>
<ul>
<li>Build Log：它显示用于构建容器的日志；</li>
<li>Log：显示容器的输出；</li>
<li>Attached console：如果可以的话，这允许我们与容器的应用程序/shell 交互；</li>
<li>Properties：将显示有关容器的更多信息，例如 镜像 ID 或容器 ID；</li>
<li>Environment variables：显示容器使用的环境变量；</li>
<li>Port bindings：显示容器暴露给主机的所有端口；</li>
<li>Volume bindings：显示为容器安装的卷；</li>
<li>Files：如果它支持运行 ls 命令，则允许我们浏览容器中的文件。对于像我们这样的基于 Alpine 的容器，我们可以添加 RUN apk add &ndash;no-cache coreutils 指令来启用此功能；</li>
</ul>
<p><p class="md__image">
  <img src="../imgs/04-Running-a-Docker-Container.gif"
    alt=""  />
</p>
</p>
<p>在左侧，我们可以看到各种按钮。首先，有一个 “Redeploy” 按钮，它使我们可以再次运行容器的构建配置。</p>
<p>还有 “Edit Configuration” 按钮，可用于对容器的 “Run Configuration” 进行任何调整。</p>
<p>最后， “Start/Stop” 按钮，用于启动或停止容器，以及 “Delete” 按钮，用于删除容器。</p>
<p><p class="md__image">
  <img src="../imgs/05-Docker-Tool-Window-Service-Overview.gif"
    alt=""  />
</p>
</p>
<p>容器上的右键单击操作可以访问一些其他有用的功能。我们可以使用 List Processes 看到正在运行的进程的列表，也可以使用 Exec 在正在运行的容器中执行命令。最后，Inspect 将提供有关容器及其当前配置的更多信息。</p>
<p><p class="md__image">
  <img src="../imgs/06-Docker-Container-menu-options.gif"
    alt=""  />
</p>
</p>
<p><strong>Pro tip</strong>：如果将鼠标悬停在容器名称上，则可以看到容器的正常运行时间。</p>
<p><strong>Pro tip</strong>：要加快容器的构建速度，请使用 Go vendoring mode。在 IDE 终端中运行 go mod vendor 命令可确保 IDE 自动选择 vendor 文件夹。为此，您还需要在容器的环境变量列表中添加 <code>GOFLAGS =&quot;-mod = vendor&quot;</code>。</p>
<h2 id="总结">总结</h2>
<p>我们讨论了如何创建和运行 Docker 配置。在下一篇文章中，我们将介绍如何调试 Docker 中的应用程序。</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/go/2020/05/04/go-development-with-docker-containers/</p>
<p>作者：Florin Pățan</p>
<p>翻译：Go语言中文网 polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>还在用 2019.3 就 Out 了：GoLand 2020.1 版本正式发布</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/goland-2020-1-release/</link>
			<pubDate>Fri, 10 Apr 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/goland-2020-1-release/</guid>
			<description>北京时间 2020 年 4 月 10 日凌晨，Jetbrains 宣布正式发布 GoLand 2020.1 版本。
该版本主要的变化有：
引入了对 Go 模块支持的各种升级以及代码编辑功能，这些功能几乎不需要用户交互，也不需要扩展的代码补全系列。
除此之外，还添加了新的代码检查、快速修复和其他改进，例如新的 LightEdit 模式（可让您在文本编辑器中打开文件，而无需创建或加载项目）、智能拼写和语法检查以及用于 Web 开发和数据库处理的新功能。
Go 语言中文网在 2020.1 还未正式发布之前，就发过关于该版本特性的文章，现在 2020.1 正式发布了，相关功能特性稳定了，我们再次介绍下相关新特性。
Go 模块改进 2020.1 现已支持 Go 1.13 的环境变量 GOPROXY、GOPRIVATE、GOSUMDB、GONOPROXY 和 GONOSUMB。
使用 Go Modules 项目模板配置其默认值。只需点击 Environment 字段中的 Browse 图标即可打开新的 Environment Variables 对话框。
go.mod 文件支持 go、module、require、replace 和 exclude 关键字代码补全、依赖项名称以及本地路径替换。
此外，也可以使用 Rename 和 Move 重构。 重命名或移动由 replace 语句引用的目录时，GoLand 将相应地更改 go.mod 文件中的路径。
现在，您还可以通过 Project 视图调用 Find Usages，以探索 go.mod 文件中特定目录路径的使用位置。</description>
			<content type="html"><![CDATA[<p>北京时间 2020 年 4 月 10 日凌晨，Jetbrains 宣布正式发布 GoLand 2020.1 版本。</p>
<p>该版本主要的变化有：</p>
<p>引入了对 Go 模块支持的各种升级以及代码编辑功能，这些功能几乎不需要用户交互，也不需要扩展的代码补全系列。</p>
<p>除此之外，还添加了新的代码检查、快速修复和其他改进，例如新的 LightEdit 模式（可让您在文本编辑器中打开文件，而无需创建或加载项目）、智能拼写和语法检查以及用于 Web 开发和数据库处理的新功能。</p>
<p>Go 语言中文网在 2020.1 还未正式发布之前，就发过关于该版本特性的文章，现在 2020.1 正式发布了，相关功能特性稳定了，我们再次介绍下相关新特性。</p>
<h2 id="go-模块改进">Go 模块改进</h2>
<p>2020.1 现已支持 Go 1.13 的环境变量 GOPROXY、GOPRIVATE、GOSUMDB、GONOPROXY 和 GONOSUMB。</p>
<p>使用 Go Modules 项目模板配置其默认值。只需点击 Environment 字段中的 Browse 图标即可打开新的 Environment Variables 对话框。</p>
<p>go.mod 文件支持 go、module、require、replace 和 exclude 关键字代码补全、依赖项名称以及本地路径替换。</p>
<p>此外，也可以使用 Rename 和 Move 重构。 重命名或移动由 replace 语句引用的目录时，GoLand 将相应地更改 go.mod 文件中的路径。</p>
<p>现在，您还可以通过 Project 视图调用 Find Usages，以探索 go.mod 文件中特定目录路径的使用位置。</p>
<p>在 GoLand 2020.1 中，您可以通过 Alt-Enter 获取缺失的依赖项并移除未使用的依赖项。</p>
<p>最后但同样重要的是，如果存在本地路径替换，则新版本将在您提交之前显示一条通知，这样您就不会意外提交它们。</p>
<h2 id="您无需学习如何使用的代码补全功能">您无需学习如何使用的代码补全功能</h2>
<p>GoLand 2020.1 将建议 if err != nil { &hellip; } 来补全错误处理模式。 只需在表达式内输入 if。</p>
<p>只需输入 type 关键字或 struct 和 interface，即可更快地定义结构和接口类型。</p>
<p>Fill Fields 操作在格式化规则要求时会在冒号后面添加空格。 它还会在组合文字声明中语句的末尾添加逗号。</p>
<p>现在，使用 map 时，代码补全会在您补全键类型后将光标移到右中括号后面。</p>
<p>对于函数的返回类型，补全功能将为局部变量和零值提供适合相应返回值类型的建议。</p>
<h2 id="智能代码补全space-或-ctrlshiftspace">智能代码补全（⌥⇧Space 或 Ctrl+Shift+Space）</h2>
<p>智能代码补全会建议一个指向结构初始值设定项的指针。</p>
<p>它还会建议在断言和类型 switch 用例中首先使用兼容类型。</p>
<p>在类型断言中，它提供已赋值变量的类型。</p>
<p>最后，它提供了表达式中可能指针的建议列表。</p>
<h2 id="基本代码补全空格或-ctrl空格">基本代码补全（⌃空格或 Ctrl+空格）</h2>
<p>为注释添加了基本代码补全，这将使编写文档更加轻松！ 它可为当前包声明建议名称，并为函数和方法建议参数名称。除此之外，基本代码补全还可以建议文字和转换。</p>
<h2 id="代码编辑">代码编辑</h2>
<p>编写多值返回函数的签名时，GoLand 2020.1 会在逗号后面的返回类型周围添加括号。当您在字符串文字中粘贴一些文本时，IDE 会转义双引号。</p>
<h2 id="go-114-支持">Go 1.14 支持</h2>
<p>1）支持重叠接口</p>
<p>Go 1.14 添加了对嵌入重叠接口的支持，我们也添加了此功能！ 当您使用重叠接口描述类型的不同方面时，GoLand 不会将这些方面的重复方法报告为错误。</p>
<p>2）自动 vendoring 模式</p>
<p>如果模块根包含 vendor 目录，则会在 Go 1.14 中自动启用 vendoring 模式。 对于 GoLand 2020.1，我们决定为 Go 1.13 及更早版本实现类似的行为。 IDE 会自动将导入解析到 vendor/ 文件夹（如果模块中存在）。</p>
<h2 id="调试器更新">调试器更新</h2>
<p>1）分析器标签支持</p>
<p>为了帮助您在调试或核心转储分析过程中更轻松地区分 goroutine，我们为其添加了分析器标签。更多详情请参考：<a href="https://mp.weixin.qq.com/s/ANNUlYvWshNikNwCw6qSHw" target="_blank" rel="noopener">如何在调试过程中查找 Goroutine</a>
。</p>
<p>2）宏支持</p>
<p>现在，可以将宏用作运行或调试应用程序的参数。 在 Run/Debug Configurations 对话框中，点击 Go Tool 中的 + 或 Program arguments 字段即可打开新的 Macros 对话框，其中会列出要使用的可用宏。</p>
<p>此外，您现在还可以将配置文件存储在项目中。 在 Run/Debug Configurations 对话框的顶部，选择 Store 作为项目文件选项。</p>
<h2 id="后缀补全">后缀补全</h2>
<p><code>.else</code> <em>Postfix Completion</em> 模板可以快速添加 <code>if</code> 语句来检查表达式是否为假。</p>
<h2 id="快速修复">快速修复</h2>
<p>按下 Alt+Enter，可立即将非格式化调用更改为格式化调用。现在，Create variable 快速修复会显示预期的类型提示，以便您更轻松地输入正确的值。</p>
<h2 id="代码检查">代码检查</h2>
<p>新代码检查可以警告您注意非指针接收器上指针方法的无效调用，并提供了快速修复。</p>
<p>如果错误使用 uintptr 和 unsafe.Pointer 将整数转换为指针，Invalid conversions of uintptr to unsafe.Pointer 代码检查会发出警告。</p>
<p>Unmarshal is called with incorrect argument 检查可以分析对 json.Unmarshal 以及 encoding/json、encoding/xml 和 encoding/gob 包的类似函数的调用。</p>
<p>Locks mistakenly passed by value 代码检查可帮助您避免意外复制包含锁定的值。</p>
<h2 id="实时模板">实时模板</h2>
<p>添加了新模板来帮助您快速创建声明组。 其中包括 consts、vars、types 和 imports。 当您使用这些模板之一时，GoLand 将在声明名称周围添加大括号。</p>
<p>fori 模板可为经典的 for 循环插入样板代码。</p>
<h2 id="重构">重构</h2>
<p>Extract Method 重构会保留父函数和方法参数的原始顺序。Rename 重构现在会自动检测声明的重命名。 这意味着当您手动重命名声明时，IDE 将显示一个间距图标，此图标会建议重命名其所有用法。</p>
<h2 id="导航">导航</h2>
<p>Navigate to implementations（macOS 上为 ⌥⌘B，Windows/Linux 上为 Ctrl+Alt+B）和 Navigate to Declaration 或 Usages（macOS 上为 ⌘B，Windows/Linux 上为 Ctrl+B）现在会首先显示当前项目中的结果。</p>
<p>此外，默认情况下，Find Usages（Windows/Linux 上为 Alt+F7，macOS 上为 ⌥F7）操作现在会始终查找接口方法的用法。 要像以前一样查找当前方法的用法，请在 Windows/Linux 上使用 Alt+Shift+Ctrl+F7 或在 macOS 上使用 ⌥⇧⌘F7。</p>
<h2 id="改进-vcs">改进 VCS</h2>
<p>1）新 Commit 工具窗口</p>
<p>现在，新的 Commit 工具窗口包含 <em>Local Changes</em> 和 <em>Shelf</em> 选项卡。 此工具窗口涵盖了与提交有关的所有任务，例如检查差异，选择要提交的文件和块，以及输入提交消息。 Commit 是位于屏幕左侧的垂直工具窗口，这样就为整个编辑器留出了显示差异的空间。</p>
<p>2）改进了 Branches 弹出窗口</p>
<p><em>Branches</em> 弹出窗口在多个方面进行了重新设计：</p>
<ul>
<li>我们添加了一个显式搜索字段，您可以借助此字段查找现有的远程和本地分支。</li>
<li>现在，您可以使用 <em>Refresh</em> 按钮更新现有的远程分支。</li>
<li>传入（蓝色）和传出（绿色）提交指示器已添加到状态栏。</li>
</ul>
<p>3）Interactively Rebase from Here 对话框</p>
<p>大幅重新设计了 Interactively Rebase from Here。 您可以利用此对话框编辑、组合及移除之前的提交，从而让您的提交历史记录更加清晰易懂。</p>
<p>要调用此对话框，请转到 Git 工具窗口的 Log 选项卡，在要编辑的一系列提交中选择最旧的提交，点击右键，然后选择 Interactively Rebase from Here。</p>
<h2 id="数据库更新">数据库更新</h2>
<ul>
<li>使用 <em>Run configurations</em> 运行脚本文件和代码段。 这样，您可以在启动前一次运行多个文件，对它们进行重新排序，添加新文件以及运行其他程序或配置。</li>
<li>现在，您可以在代码编辑器中查看结果。 默认情况下，此选项处于禁用状态。 要启用此功能，请转到 <em>Settings/Preferences | Database | General | Show output results in the editor</em>。</li>
<li>创建 SSH 隧道的配置，并在许多数据源或项目中使用。</li>
<li>我们添加了以 Excel 格式导出数据的功能。</li>
<li>另外，您也可以在提取程序下拉列表中选择首选数据格式。</li>
</ul>
<h2 id="web开发">Web开发</h2>
<p>1）用于 JavaScript 和 TypeScript 的新智能意图和检查</p>
<p>使用新的智能意图和检查 (Alt+Enter) 可在编码时节省时间！ 例如，您现在可以快速地将现有代码转换为可选链和/或空值合并，该语法已在最新版本的 JavaScript 和 TypeScript 中引入。</p>
<p>2）更有帮助的快速文档</p>
<p>对于 JavaScript 和 TypeScript，<em>Documentation</em> 弹出窗口现在会显示更多有用的信息，包括符号类型和可视性的详细信息以及定义符号的位置。</p>
<h2 id="其他变更">其他变更</h2>
<ul>
<li>JetBrains 的新字体 <em>JetBrains Mono</em> 默认可用。 要详细了解该字体，请访问<a href="https://www.jetbrains.com/lp/mono/" target="_blank" rel="noopener">此页面</a>
。</li>
<li>默认捆绑了 <em>Grazie</em>，此插件可为您在 IDE 中编写的文本提供智能的拼写和语法检查。</li>
<li>新的 <em>LightEdit 模式</em>允许您在文本编辑器中打开文件，而无需创建或加载项目。 要试用此这一功能，您首先需要从 <em>Tools | Create Command-line Launcher</em> 创建命令行启动器，如<a href="https://www.jetbrains.com/help/idea/working-with-the-ide-features-from-command-line.html" target="_blank" rel="noopener">此处</a>
所述（如果您使用的是 Toolbox App，步骤<a href="https://www.jetbrains.com/help/idea/working-with-the-ide-features-from-command-line.html#toolbox" target="_blank" rel="noopener">略有不同</a>
）。 有关如何打开文件、比较/合并文件甚至运行代码检查的详细说明，请参阅<a href="https://www.jetbrains.com/help/idea/opening-files-from-command-line.html" target="_blank" rel="noopener">此 Web 帮助部分</a>
。</li>
<li>我们添加了新的 <em>Zen 模式</em>，它消除了可能的干扰，可帮助您完全专注于代码。 本质上，此模式结合了<em>免打扰模式</em>和<em>全屏模式</em>。 要启用此模式，请转到 <em>View | Appearance | Enter Zen Mod</em>，或者从 <em>Quick Switch Scheme</em> 弹出窗口中选择 (<em>Ctrl+` | View mode | Enter Zen Mode</em>)。</li>
<li><em>外部文档</em>现在指向 <a href="https://pkg.go.dev/" target="_blank" rel="noopener">https://pkg.go.dev</a>
 而不是 <a href="https://godoc.org/" target="_blank" rel="noopener">https://godoc.org</a>
。</li>
<li>我们恢复了<em>默认</em>配色方案，但采用新名称 <em>Classic Light</em>。</li>
</ul>
<h2 id="结语">结语</h2>
<p>新版本可以免费试用 30 天。新版本下载地址：<a href="https://www.jetbrains.com/zh-cn/go/download/">https://www.jetbrains.com/zh-cn/go/download/</a>。该下载页面支持通过微信和支付宝支付。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇4：自定义 Renderer，增强或替换模板引擎</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom04-renderer/</link>
			<pubDate>Mon, 16 Mar 2020 10:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom04-renderer/</guid>
			<description>Render，顾名思义，要进行页面渲染。Go 语言不但自带有强大的 http 库，还自带了 HTML 模板引擎。Echo 框架对模板引擎进行了一些额外处理，并提供了</description>
			<content type="html"><![CDATA[<p>Render，顾名思义，要进行页面渲染。Go 语言不但自带有强大的 http 库，还自带了 HTML 模板引擎。Echo 框架对模板引擎进行了一些额外处理，并提供了给用户自定义页面渲染的接口。本文就相关问题进行探讨。</p>
<h2 id="模板渲染">模板渲染</h2>
<p>Echo 框架的 Context 接口提供了下面的方法进行页面渲染：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// echo 包中 Context 接口的方法
</span><span class="c1"></span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></div><p>其中，code 是 HTTP Status，name 是定义的模板名，data 是模板可能需要的数据。执行这个方法后，通过数据渲染模板，并发送带有 HTTP 状态的 text/html 响应。可以通过 Echo.Renderer 来注册模板，从而允许我们使用任何模板引擎。</p>
<p>Renderer 接口定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Renderer is the interface that wraps the Render function.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Renderer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">Render</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>这里可能会有点迷糊，怎么有两个 Render 方法，而且它们的签名还不一样。这里的逻辑是这样的：</p>
<ul>
<li>echo.Echo 类型有一个 Renderer 接口类型的字段，用来注册模板引擎；</li>
<li>echo.Context 接口类型有一个 Render 方法，在 Handle 中我们通过调用 Context 的 Render 方法进行模板渲染；</li>
<li>在 Context 的 Render 方法内部（当然是 echo 中 Context 接口的默认实现），会调用 echo.Echo 的字段 Renderer 的 Render 方法，进行具体的模板渲染；</li>
</ul>
<p>这里是具体的渲染源码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">context</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">echo</span><span class="p">.</span><span class="nx">Renderer</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ErrRendererNotRegistered</span>
	<span class="p">}</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">echo</span><span class="p">.</span><span class="nx">Renderer</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">HTMLBlob</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><p>可见，如果调用了 Context#Render 进行模板渲染，但并没有注册模板引擎则会报错（ErrRendererNotRegistered）。</p>
<h3 id="集成标准库模板引擎">集成标准库模板引擎</h3>
<p>1、我们先定义一个类型：Template，然后实现 Echo.Renderer 接口，即提供 Render 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Template</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">templates</span> <span class="o">*</span><span class="nx">template</span><span class="p">.</span><span class="nx">Template</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">templates</span><span class="p">.</span><span class="nf">ExecuteTemplate</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>2、接着预编译一个模板。定义一个模板文件：template/index.html，内容如下：</p>
<pre><code>{{define &quot;index&quot;}}Hello, {{.}}!{{end}}
</code></pre><p>然后预编译得到 Template 的实例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tpl</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Template</span><span class="p">{</span>
    <span class="nx">templates</span><span class="p">:</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">ParseGlob</span><span class="p">(</span><span class="s">&#34;template/*.html&#34;</span><span class="p">)),</span>
<span class="p">}</span>
</code></pre></div><p>3、注册模板引擎：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

<span class="nx">e</span><span class="p">.</span><span class="nx">Renderer</span> <span class="p">=</span> <span class="nx">tpl</span>
</code></pre></div><p>4、在 Handler 中渲染模板：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;index&#34;</span><span class="p">,</span> <span class="s">&#34;studygolang&#34;</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div><p>注意这里的 index 是模板文件中 <code>define &quot;index&quot;</code> ，而不是文件名。</p>
<p>编译后运行，浏览器正常显示：Hello，studygolang!</p>
<p><p class="md__image">
  <img src="https://s2.ax1x.com/2020/03/08/3v2XQ0.png"
    alt=""  />
</p>
</p>
<h2 id="通用化定制">通用化定制</h2>
<p>一般的，页面会有一些通用的部分，比如头部、尾部等。所以业界通常的做法是有一个 layout，而且还可能不止一个 layout，因为普通用户看到的和后台看到的头部、尾部一般会不一样。那这样的通用化定制需求该如何集成到 Echo 的 Render 中呢？</p>
<p>先考虑只有一种 layout 的情况。定义一个类型 layoutTemplate，实现 Echo.Renderer 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">layoutTemplate</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">var</span> <span class="nx">LayoutTemplate</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">layoutTemplate</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">layoutTemplate</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">contentTpl</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">layout</span> <span class="o">:=</span> <span class="s">&#34;layout.html&#34;</span>
	<span class="nx">tpl</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">layout</span><span class="p">).</span><span class="nf">ParseFiles</span><span class="p">(</span><span class="s">&#34;template/common/&#34;</span><span class="o">+</span><span class="nx">layout</span><span class="p">,</span> <span class="s">&#34;template/&#34;</span><span class="o">+</span><span class="nx">contentTpl</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">tpl</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>然后注册该 Renderer，并在 Handler 中渲染，注意 ctx.Render 的第二个参数，跟上面说的不一样，我们传递的是子模板的文件名：index.html。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

<span class="nx">e</span><span class="p">.</span><span class="nx">Renderer</span> <span class="p">=</span> <span class="nx">render</span><span class="p">.</span><span class="nx">LayoutTemplate</span>

<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;index.html&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div><p>这里用到了两个模板文件：layout.html 和  index.html，来源 Hugo 的 <a href="https://themes.gohugo.io/theme/soho/" target="_blank" rel="noopener">soho 这个模板</a>
。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">xmlns</span><span class="o">=</span><span class="s">&#34;http://www.w3.org/1999/xhtml&#34;</span> <span class="na">xml:lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;content-type&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;text/html; charset=utf-8&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Echo博客系统<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;author&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;Go语言中文网站长polaris&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;keywords&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;&#34;</span> <span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;description&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;&#34;</span> <span class="p">/&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/static/css/print.css&#34;</span> <span class="na">media</span><span class="o">=</span><span class="s">&#34;print&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/static/css/poole.css&#34;</span><span class="p">&gt;</span> 
  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/static/css/hyde.css&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span>
        <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&amp;display=swap&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span>
        <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css&#34;</span>
        <span class="na">integrity</span><span class="o">=</span><span class="s">&#34;sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=&#34;</span>
        <span class="na">crossorigin</span><span class="o">=</span><span class="s">&#34;anonymous&#34;</span> <span class="p">/&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;apple-touch-icon-precomposed&#34;</span>
        <span class="na">sizes</span><span class="o">=</span><span class="s">&#34;144x144&#34;</span>
        <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://themes.gohugo.io//theme/soho/apple-touch-icon-144-precomposed.png&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;shortcut icon&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://themes.gohugo.io//theme/soho/favicon.png&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">aside</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;sidebar&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;container&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;sidebar-about&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;author-image&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">img</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://themes.gohugo.io/theme/soho/images/profile.png&#34;</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;img-circle img-headshot center&#34;</span> <span class="na">alt</span><span class="o">=</span><span class="s">&#34;Profile Picture&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Echo-Gopher<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">nav</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">ul</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;sidebar-nav&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/&#34;</span><span class="p">&gt;</span>Home<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span> <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/about/&#34;</span><span class="p">&gt;</span> About <span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span> <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">nav</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">section</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;social-icons&#34;</span><span class="p">&gt;</span>

            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://github.com/polaris1119&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;me&#34;</span> <span class="na">title</span><span class="o">=</span><span class="s">&#34;GitHub&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">i</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;fab fa-github&#34;</span> <span class="na">aria-hidden</span><span class="o">=</span><span class="s">&#34;true&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">i</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
            
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://weibo.com/studygolang&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;me&#34;</span> <span class="na">title</span><span class="o">=</span><span class="s">&#34;Weibo&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">i</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;fab fa-weibo&#34;</span> <span class="na">aria-hidden</span><span class="o">=</span><span class="s">&#34;true&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">i</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
            
        <span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">aside</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">main</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;content container&#34;</span><span class="p">&gt;</span>
    {{template &#34;content&#34; .}}
  <span class="p">&lt;/</span><span class="nt">main</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">footer</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;copyright&#34;</span><span class="p">&gt;</span>
      <span class="ni">&amp;copy;</span> polaris 2020 · <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://creativecommons.org/licenses/by-sa/4.0&#34;</span><span class="p">&gt;</span>CC BY-SA 4.0<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">footer</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js&#34;</span>
  <span class="na">integrity</span><span class="o">=</span><span class="s">&#34;sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=&#34;</span>
  <span class="na">crossorigin</span><span class="o">=</span><span class="s">&#34;anonymous&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
  
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><p>这是 layout.html 的内容，核心在于 <code>{{template &quot;content&quot; .}}</code>，表示具体内容模板需要定义 content，所以看看 index.html 文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">{{define &#34;content&#34;}}
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;posts&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">article</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h2</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-title&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/&#34;</span><span class="p">&gt;</span>Echo 系列教程 — 定制篇3：自定义 Logger，用你喜欢的日志库<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-date&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">time</span> <span class="na">datetime</span><span class="o">=</span><span class="s">&#34;2020-03-06T00:00:00Z&#34;</span><span class="p">&gt;</span>Mar 06, 2020<span class="p">&lt;/</span><span class="nt">time</span><span class="p">&gt;</span> · 3 min read
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
        在知识星球简书项目中，我们分析对比了目前的一些日志库。虽然 Go 标准库有一个 log，但功能有限，所以才出现了很多第三方的日志库。
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;read-more-link&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;http://blog.studygolang.com/2020/03/echo-custom-logger/&#34;</span><span class="p">&gt;</span>阅读全文<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>

    <span class="p">&lt;</span><span class="nt">article</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h2</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-title&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/&#34;</span><span class="p">&gt;</span>Echo 系列教程 — 定制篇2：自定义 Validator，进行输入校验<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-date&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">time</span> <span class="na">datetime</span><span class="o">=</span><span class="s">&#34;2020-02-28T00:00:00Z&#34;</span><span class="p">&gt;</span>Feb 28, 2020<span class="p">&lt;/</span><span class="nt">time</span><span class="p">&gt;</span> · 4 min read
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
        上一篇讲 Binder 时提到，参数自动绑定和校验是 Web 框架很重要的两个功能，可以极大的提升开发速度，并更好的保证数据的可靠性（服务端数据校验很重要）。
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;read-more-link&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;http://blog.studygolang.com/2020/02/echo-custom-validator/&#34;</span><span class="p">&gt;</span>阅读全文<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
{{end}}
</code></pre></div><p>运行后打开浏览器访问 http://localhost:2020 ：</p>
<p><p class="md__image">
  <img src="https://s1.ax1x.com/2020/03/13/8uzXAf.png"
    alt=""  />
</p>
</p>
<p>接下来看看如何处理多个 layout 的情况。</p>
<p>因为 Render 的签名是固定的，不同的 layout 通过什么方式告知 Render 呢？观察 Render 方法的参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">Render</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span>
</code></pre></div><p>可以在 data 和 ctx 上下功夫：</p>
<ol>
<li>
<p>将 data 指定为 map[string]interface{}，layout 通过 data 传递；</p>
</li>
<li>
<p>通过 ctx 的 Set 方法设置 layout，方法内通过 ctx.Get 获取 layout；</p>
</li>
</ol>
<p>先看第 1 种方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NoNavRender 没有导航的 layout html 输出
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NoNavRender</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">contentTpl</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">data</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">data</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
	<span class="p">}</span>
	<span class="nx">data</span><span class="p">[</span><span class="s">&#34;layout&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;nonav_layout.html&#34;</span>

	<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">contentTpl</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在 render 包中增加了一个 NoVaRender 函数，该函数要求 data 必须是 map[string]interface{}，这样就可以做到将 layout 传递给 Render 方法，不过因为 Render 方法的 data 参数是 interface{} 类型，因此得做类型断言。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">layout</span> <span class="o">:=</span> <span class="s">&#34;layout.html&#34;</span>

<span class="k">if</span> <span class="nx">data</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">dataMap</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">.(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{});</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">layoutInter</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">dataMap</span><span class="p">[</span><span class="s">&#34;layout&#34;</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
      <span class="nx">layout</span> <span class="p">=</span> <span class="nx">layoutInter</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>看看第 2 种方式如何实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NoNavRender 没有导航的 layout html 输出
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NoNavRender</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">contentTpl</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ctx</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;layout&#34;</span><span class="p">,</span> <span class="s">&#34;nonav_layout.html&#34;</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">contentTpl</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在 Render 中获取 layout 的值：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">layout</span> <span class="o">:=</span> <span class="s">&#34;layout.html&#34;</span>

<span class="nx">layoutInter</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;layout&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">layoutInter</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">layout</span> <span class="p">=</span> <span class="nx">layoutInter</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>两种方式个人觉得第 2 种更优雅。不过需要注意的是，两种方式要注意 layout 不能冲突，也就是不能他用。</p>
<p>另外，我个人建议，data 参数永远要么传递 nil，要么传递 map[string]interface{} 。个人感觉 Echo 的 Render 方法 data 参数的类型不应该用 interface{} 而是用 map[string]interface{}，这样可以更方便地往 data 中加入更多全局的数据。在简书项目中，我们会通过其他方式弥补这个问题。</p>
<h2 id="小结">小结</h2>
<p>通过本节，你应该掌握了 Render 的使用、集成和大项目 layout 的处理。</p>
<p>额外提一句，因为 Context.Render 方法最终是调用的 Context.HTML 方法进行渲染，因此我们也完全可以抛弃 Render 方法，而是使用自己的 Render。目前简书的代码（后续会改掉）和 studygolang 的源码采用的就是完全抛弃 Context.Render 的方式，主要考虑还是有一些 Render 不能很好满足的地方，比如上面说的多 layout、data 类型等，不过也是可以解决的。因此还是建议采用 Echo 框架的 Render。</p>
<p>本节<a href="https://github.com/polaris1119/go-echo-example/tree/0cd46e8b1f38317439e95d55e3fe29a173a2e3c1" target="_blank" rel="noopener">完整代码点这里</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇5：自定义 HTTP Error Handler，让 HTTP 错误处理更友好</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom05-error-handler/</link>
			<pubDate>Mon, 16 Mar 2020 10:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom05-error-handler/</guid>
			<description>Echo 倡导通过从中间件和 Handler 返回错误来进行集中式 HTTP 错误处理。集中式错误处理程序使我们能够从统一位置将错误记录到外部服务，并向客户端发送自定义的 HTTP 响</description>
			<content type="html"><![CDATA[<p>Echo 倡导通过从中间件和 Handler 返回错误来进行集中式 HTTP 错误处理。集中式错误处理程序使我们能够从统一位置将错误记录到外部服务，并向客户端发送自定义的 HTTP 响应。本节一起学习如何定制化，进行集中式错误处理。</p>
<h2 id="默认的错误处理">默认的错误处理</h2>
<p>在定制篇 4 中，我们讲到了 Render。如果在 Handler 中调用了 Render，但是并没有给 Echo.Renderer 赋值或其他原因，导致出错，页面看到的信息如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
	<span class="nt">&#34;message&#34;</span><span class="p">:</span> <span class="s2">&#34;Internal Server Error&#34;</span>
<span class="p">}</span>
</code></pre></div><p>这是 Echo 默认的 HTTP Error Handler，表示发生了 500 - Internal Server Error 错误。看看该默认 Error Handler 的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// DefaultHTTPErrorHandler is the default HTTP error handler. It sends a JSON response
</span><span class="c1">// with status code.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">DefaultHTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">he</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">HTTPError</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Internal</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">herr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Internal</span><span class="p">.(</span><span class="o">*</span><span class="nx">HTTPError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">he</span> <span class="p">=</span> <span class="nx">herr</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">he</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">HTTPError</span><span class="p">{</span>
			<span class="nx">Code</span><span class="p">:</span>    <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">,</span>
			<span class="nx">Message</span><span class="p">:</span> <span class="nx">http</span><span class="p">.</span><span class="nf">StatusText</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">),</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Issue #1426
</span><span class="c1"></span>	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Code</span>
	<span class="nx">message</span> <span class="o">:=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Message</span>
	<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Debug</span> <span class="p">{</span>
		<span class="nx">message</span> <span class="p">=</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.(</span><span class="kt">string</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">message</span> <span class="p">=</span> <span class="nx">Map</span><span class="p">{</span><span class="s">&#34;message&#34;</span><span class="p">:</span> <span class="nx">m</span><span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Send response
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">Response</span><span class="p">().</span><span class="nx">Committed</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Request</span><span class="p">().</span><span class="nx">Method</span> <span class="o">==</span> <span class="nx">http</span><span class="p">.</span><span class="nx">MethodHead</span> <span class="p">{</span> <span class="c1">// Issue #608
</span><span class="c1"></span>			<span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">NoContent</span><span class="p">(</span><span class="nx">he</span><span class="p">.</span><span class="nx">Code</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>如果是非 HTTPError，会包装成 HTTPError，并设置为 500 - Internal Server Error；</li>
<li>如果开启了 Debug 模式，则会输出具体的错误信息；</li>
</ul>
<p>因此，开启 Debug 模式（e.Debug = true）后，输出是：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="s2">&#34;renderer not registered&#34;</span>
</code></pre></div><p>这对于调试很方便。</p>
<h2 id="集中化自定义错误处理">集中化自定义错误处理</h2>
<p>在有些时候，默认错误 HTTP 处理程序可能足够了；但是，如果你想捕获其他类型的错误并采取相应的处理，比如，发送通知电子邮件或将错误记录到外部日志系统中，这时集中化自定义错误处理就很有用了。除此之外，你可能还希望错误页面更好看，或发送个性化的 JSON 响应。</p>
<p>通过给 Echo#HTTPErrorHandler 设置一个 HTTPErrorHandler 来设置自定义的错误处理程序，HTTPErrorHandler 的定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// HTTPErrorHandler is a centralized HTTP error handler.
</span><span class="c1"></span><span class="kd">type</span>	<span class="nx">HTTPErrorHandler</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">,</span> <span class="nx">Context</span><span class="p">)</span>
</code></pre></div><h3 id="自定义错误页面">自定义错误页面</h3>
<p>一般来说，通过 Go 语言渲染页面的话，在发生错误时，渲染对应的错误页面，比如：404.html、500.html 等。</p>
<p>以下自定义 HTTP 错误处理程序根据不同类型的错误显示对应的错误页面并记录错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 放在 http 包下的 error.go 中
</span><span class="c1">// CustomHTTPErrorHandler 自定义 HTTP 错误处理
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">CustomHTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span>
	<span class="k">if</span> <span class="nx">he</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HTTPError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">code</span> <span class="p">=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Code</span>
	<span class="p">}</span>
	<span class="nx">errorPage</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d.html&#34;</span><span class="p">,</span> <span class="nx">code</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">File</span><span class="p">(</span><span class="s">&#34;template/&#34;</span> <span class="o">+</span> <span class="nx">errorPage</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在项目的 template 目录下加上相应的 html 文件，比如：404.html、500.html。之后设置上自定义的 CustomHTTPErrorHandler：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nx">HTTPErrorHandler</span> <span class="p">=</span> <span class="nx">myhttp</span><span class="p">.</span><span class="nx">CustomHTTPErrorHandler</span>
</code></pre></div><p>页面简单的包含一些内容，如 404.html 页面内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>404<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>这是404错误页面<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><p>编译启动程序后，随意访问一个不存在的路径：http://localhost:2020/notfound ，结果如下：</p>
<p><p class="md__image">
  <img src="../imgs/404.png"
    alt=""  />
</p>
</p>
<p>这里的错误，我们简单的记录下来。实际业务中，根据你的情况，可以发送到你需要记录的第三方系统中。</p>
<p>另外，这里给客户端的响应，不一定是 HTML 页面，还有可能是 JSON，根据实际的情况进行相应的处理。而且，实际中，HTML 页面也不会是这么简单的一个页面，可能涉及到一些通用数据，比如通用的头尾等。比如让这个错误页面更符合我们网站的风格，可以这么做：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// CustomHTTPErrorHandler 自定义 HTTP 错误处理
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">CustomHTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span>
	<span class="k">if</span> <span class="nx">he</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HTTPError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">code</span> <span class="p">=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Code</span>
	<span class="p">}</span>
	<span class="nx">errorPage</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d.html&#34;</span><span class="p">,</span> <span class="nx">code</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">errorPage</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>404.html 页面内容变为：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">{{define &#34;content&#34;}}
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;posts&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">article</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h2</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-title&#34;</span><span class="p">&gt;</span>你想要的页面走丢了！<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">hr</span><span class="p">&gt;</span>
        404
    <span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
{{end}}
</code></pre></div><p>这时 404 页面看起来像这样：</p>
<p><p class="md__image">
  <img src="../imgs/404-pretty.png"
    alt=""  />
</p>
</p>
<h3 id="怎么做到的">怎么做到的？</h3>
<p>为什么这么一句：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nx">HTTPErrorHandler</span> <span class="p">=</span> <span class="nx">myhttp</span><span class="p">.</span><span class="nx">CustomHTTPErrorHandler</span>
</code></pre></div><p>就可以接管错误处理？在 Echo 框架源码中搜索 <code>Echo#HTTPErrorHandler</code> 在哪里调用的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ServeHTTP implements `http.Handler` interface, which serves HTTP requests.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Acquire context
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="o">*</span><span class="nx">context</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span>

	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">NotFoundHandler</span>

	<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">premiddleware</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">e</span><span class="p">.</span><span class="nf">findRouter</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Host</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nf">getPath</span><span class="p">(</span><span class="nx">r</span><span class="p">),</span> <span class="nx">c</span><span class="p">)</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Handler</span><span class="p">()</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nf">applyMiddleware</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">middleware</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="nx">e</span><span class="p">.</span><span class="nf">findRouter</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Host</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nf">getPath</span><span class="p">(</span><span class="nx">r</span><span class="p">),</span> <span class="nx">c</span><span class="p">)</span>
			<span class="nx">h</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Handler</span><span class="p">()</span>
			<span class="nx">h</span> <span class="p">=</span> <span class="nf">applyMiddleware</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">middleware</span><span class="o">...</span><span class="p">)</span>
			<span class="k">return</span> <span class="nf">h</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nf">applyMiddleware</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">premiddleware</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Execute chain
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">h</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">e</span><span class="p">.</span><span class="nf">HTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Release context
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>以上代码的逻辑大体是：</p>
<ul>
<li>从池中获取一个 Context；</li>
<li>解析路由和中间件；</li>
<li>执行中间件链，发生错误时，调用 <code>e.HTTPErrorHandler</code>；</li>
<li>将 Context 放回池中；</li>
</ul>
<p>如果中间件（包括 Handler）执行没有出错，HTTPErrorHandler 自然执行不到。因此，我们可以不用上文提到的方式进行集中错误处理。**你知道是什么方式吗？**当然我们应该使用 HTTPErrorHandler 的方式，这是使用该框架的正确姿势。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇6：自定义 Server 相关，替换或扩展默认的 Server</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom06-ext-server/</link>
			<pubDate>Mon, 16 Mar 2020 10:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom06-ext-server/</guid>
			<description>这是定制篇的最后一节，讲解 Server 的自定义。 默认 Server 通常情况下，Echo 通过如下方式启动一个 HTTP Server： e := echo.New() e.GET(&amp;#34;/&amp;#34;, func(c echo.Context) error { return c.String(http.StatusOK, &amp;#34;Hello, World!&amp;#34;) }) e.Logger.Fatal(e.Start(&amp;#34;:2020&amp;#34;)) 我们打开源码</description>
			<content type="html"><![CDATA[<p>这是定制篇的最后一节，讲解 Server 的自定义。</p>
<h2 id="默认-server">默认 Server</h2>
<p>通常情况下，Echo 通过如下方式启动一个 HTTP Server：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
</code></pre></div><p>我们打开源码一探究竟：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Start starts an HTTP server.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">Start</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Server</span><span class="p">.</span><span class="nx">Addr</span> <span class="p">=</span> <span class="nx">address</span>
	<span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nf">StartServer</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Server</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>原来调用的是 StartServer，参数是默认的 Server 实例，它是一个 http.Server 的指针类型。</p>
<h2 id="自定义-server">自定义 Server</h2>
<p>知道了 Echo#Start 最终调用的是 Echo#StartServer，而且它的参数是一个 <code>*http.Server</code> 类型，所以自定义一个 Server 很容易。我们先看看 http.Server 这个结构。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Server</span> <span class="kd">struct</span> <span class="p">{</span>
  	<span class="c1">// 指定 TCP 的监听地址，形式：&#34;host:port&#34;。如果空，则使用 &#34;:http&#34;，即 80 端口
</span><span class="c1"></span>    <span class="nx">Addr</span> <span class="kt">string</span>
	
		<span class="c1">// 当前服务器的 Handler，如果未设置，使用 http.DefaultServeMux
</span><span class="c1"></span>    <span class="nx">Handler</span> <span class="nx">Handler</span>

  	<span class="c1">// TLS 配置
</span><span class="c1"></span>    <span class="nx">TLSConfig</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>

  	<span class="c1">// 读取整个 request（包括 body）的最大允许时间（超时时间）
</span><span class="c1"></span>    <span class="nx">ReadTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

  	<span class="c1">// 从 Go1.8 开始增加。只是读取请求头的最大允许时间（超时时间）
</span><span class="c1"></span>    <span class="nx">ReadHeaderTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// Go 1.8
</span><span class="c1"></span>
  	<span class="c1">// 和 ReadTimeout 对应，这是写 response 的最大允许时间（超时时间）
</span><span class="c1"></span>    <span class="nx">WriteTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

  	<span class="c1">// 从 Go1.8 开始增加。下个请求到来前允许的最大空闲时间（keep-alive 启用时）。
</span><span class="c1"></span>  	<span class="c1">// 如果是 0，使用 ReadTimeout，都为 0 ，不会超时。
</span><span class="c1"></span>    <span class="nx">IdleTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// Go 1.8
</span><span class="c1"></span>
  	<span class="c1">// 允许的最大请求头（单位字节），默认值 DefaultMaxHeaderBytes
</span><span class="c1"></span>    <span class="nx">MaxHeaderBytes</span> <span class="kt">int</span>
		
  	<span class="c1">// 其他字段忽略。。。
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>默认情况下启动的 Server，超时时间是 0，也就是不会超时。我们自定义一个 Server，设置超时时间：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
  <span class="nx">Addr</span><span class="p">:</span>         <span class="s">&#34;:2020&#34;</span><span class="p">,</span>
  <span class="nx">ReadTimeout</span><span class="p">:</span>  <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
  <span class="nx">WriteTimeout</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">StartServer</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</code></pre></div><p>为了方便验证，我们将超时时间设置的较短：10s，实际项目这个肯定太短了。</p>
<h3 id="验证读超时是否生效">验证读超时是否生效</h3>
<p>往下看之前，你想想用什么办法可以验证？</p>
<p>因为 HTTP 是基于 TCP 的，我们可以简单的通过建立 TCP 连接，然后等待一段时间后，再发送 HTTP 报文，具体代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:2020&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">11</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="s">&#34;GET / HTTP/1.0\r\n\r\n&#34;</span><span class="p">)</span>
	<span class="nx">status</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">conn</span><span class="p">).</span><span class="nf">ReadString</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">status</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>通过修改 Sleep 的时间来控制等待时间，可以看看 10s 以内是否成功（刚好 10s 可能也会失败），10s 以上又是什么情况。</p>
<blockquote>
<p>注意，这里的 HTTP/1.0 不能改为 1.1 等，否则得提供 Host 头部</p>
</blockquote>
<p>Sleep 设置为 11s ，运行客户端后，如果返回 EOF，则表明超时设置生效了。</p>
<h2 id="自定义-listener">自定义 Listener</h2>
<p>Echo 框架支持自定义 Listener，即通过 <code>Echo#Listener</code> 进行设置。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:1323&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Listener</span> <span class="p">=</span> <span class="nx">l</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))</span>
</code></pre></div><p>什么场景下会需要自定义？或者说为什么 Echo 要让用户可以自定义 Listener？我认为有两种考虑：</p>
<ol>
<li>
<p>Listener 支持配置，具体就是 net.ListenConfig 类型。实际上，net 包中，net.Listen() 函数就是用了这个类型获取 Listener 实例；</p>
</li>
<li>
<p>除了使用 net.Listen 获取一个 Listener 接口的实例外，还有其他的方式可以获取 Listener 接口的实例；</p>
</li>
</ol>
<h3 id="unixlistener">UnixListener</h3>
<p>我们着重看看第 2 种情况。</p>
<p>net.Listener 是一个接口。在 net 库中，有 TCPListener 和 UnixListener，除此之外，其他的 Listener 都是基于这两种。比如 net.FileListener() 函数，最终是 TCPListener。</p>
<p>一般我们使用的就是 TCPListener，如果想在 echo 中使用 UnixListener，如何实现？（这个例子没有太多现实意义）</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">unixAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ResolveUnixAddr</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="s">&#34;/tmp/echo.sock&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">unixListener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ListenUnix</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="nx">unixAddr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello Unix！&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Listener</span> <span class="p">=</span> <span class="nx">unixListener</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>因为基于 Unix Domain Socket，所以，没法直接浏览器访问。写一个测试程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">unixAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ResolveUnixAddr</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="s">&#34;/tmp/echo.sock&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">DialUnix</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">unixAddr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="s">&#34;GET / HTTP/1.0\r\n\r\n&#34;</span><span class="p">)</span>
	<span class="nx">body</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">body</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>客户端能够输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">HTTP/1.0 <span class="m">200</span> OK
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Wed, <span class="m">25</span> Mar <span class="m">2020</span> 06:35:12 GMT
Content-Length: <span class="m">13</span>

Hello Unix！
</code></pre></div><p>表示成功！</p>
<p>再提醒下，一般不会定义 Listener，你知晓能定义即可。</p>
<h2 id="tls-相关">TLS 相关</h2>
<p>这里顺便介绍下 Echo 对 TLS 的支持。一般来说是用不到的，因为实际中，我们会使用 Web Server 进行反向代理，由 Web Server 来处理 TLS。但了解相关内容还是有利的。</p>
<h3 id="https-server">HTTPS Server</h3>
<p>看下相应的方法签名：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">StartTLS</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">certFile</span><span class="p">,</span> <span class="nx">keyFile</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>相比 Echo#Start 方法，StartTLS 多了两个参数：certFile 和 keyFile。这两个参数是什么意思？这里简单介绍下，知晓什么意思即可。</p>
<ul>
<li>certFile：证书</li>
<li>keyFile：私钥</li>
</ul>
<p>net/http 包，这两个参数是字符串，代表两个文件的路径。Echo 对此进行了扩展，除了可以代表文件的路径，还可以是字节数组，表示证书和私钥的具体内容。</p>
<p>CA 证书可以购买，也可以申请免费的（阿里云、七牛云都有），也可以使用 let’s encrypt 免费证书。这里我们先自己生成证书，本地验证。（注意，自己生成的证书，浏览器是不认的）</p>
<h4 id="证书生成">证书生成</h4>
<p>证书的生成可以用 Linux/Mac 的 OpenSSL 工具链。对于一个网站，首先必须有自己的私钥，私钥的生成方式为：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> go-cache-example <span class="c1"># 切换到我们的项目根目录</span>
$ openssl genrsa -out server.key <span class="m">2048</span>
</code></pre></div><p>会在当前目录下生成一个 server.key 文件，这就是私钥。</p>
<p>利用私钥就可以生成证书了。OpenSSL 使用 x509 命令生成证书。这里需要区分两个概念：证书（certificate）和证书请求（certificate sign request）</p>
<ul>
<li>证书是自签名或 CA 签名过的凭据，用来进行身份认证</li>
<li>证书请求是对签名的请求，需要使用私钥进行签名</li>
</ul>
<p>x509 命令可以将证书和证书请求相互转换。</p>
<p>从私钥可以生成自签名证书：（跳过了证书请求，一步到位）</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">openssl req -new -x509 -key server.key -out server.crt -days <span class="m">365</span>
</code></pre></div><p>req 命令会通过命令行要求用户输入国家、地区、组织等信息，这些信息会附加在证书中展示给连接方。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class="s1">&#39;.&#39;</span>, the field will be left blank.
-----
Country Name <span class="o">(</span><span class="m">2</span> letter code<span class="o">)</span> <span class="o">[]</span>:CN
State or Province Name <span class="o">(</span>full name<span class="o">)</span> <span class="o">[]</span>:Beijing
Locality Name <span class="o">(</span>eg, city<span class="o">)</span> <span class="o">[]</span>:Beijing
Organization Name <span class="o">(</span>eg, company<span class="o">)</span> <span class="o">[]</span>:studygolang
Organizational Unit Name <span class="o">(</span>eg, section<span class="o">)</span> <span class="o">[]</span>:
Common Name <span class="o">(</span>eg, fully qualified host name<span class="o">)</span> <span class="o">[]</span>:localhost
Email Address <span class="o">[]</span>:polaris@studygolang.com
</code></pre></div><p>以上命令会在当前目录生成 server.crt 文件。</p>
<p>这样我们有了上面需要的 cert 和 key。</p>
<h3 id="验证本地的-https-server">验证本地的 HTTPS Server</h3>
<p>在 go-cache-example 项目中的 cmd/custom/main.go 包含如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello TLS！&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">StartTLS</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">,</span> <span class="s">&#34;server.crt&#34;</span><span class="p">,</span> <span class="s">&#34;server.key&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>启动服务：go run cmd/custom/main.go</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">   ____    __
  / __/___/ /  ___
 / _// __/ _ <span class="se">\/</span> _ <span class="se">\
</span><span class="se"></span>/___/<span class="se">\_</span>_/_//_/<span class="se">\_</span>__/ v4.1.15
High performance, minimalist Go web framework
https://echo.labstack.com
____________________________________O/_______
                                    O<span class="se">\
</span><span class="se"></span>⇨ https server started on <span class="o">[</span>::<span class="o">]</span>:2020
</code></pre></div><p>打开 Chrome 浏览器，请求：https://localhost:2020 （注意是 HTTPS），出现如下错误：</p>
<p><p class="md__image">
  <img src="../imgs/custom-https.png"
    alt=""  />
</p>
</p>
<p>在浏览器输出：<code>chrome://flags/#allow-insecure-localhost</code> ，高亮的置为 Enabled，Reload Chrome。</p>
<p><p class="md__image">
  <img src="../imgs/chrome-insecure-localhost.png"
    alt=""  />
</p>
</p>
<p>再次请求 https://localhost:2020 ，能正常输出：Hello TLS！表明成功了。</p>
<p>通过 FireFox 浏览器，可以方便看到，我们这个服务支持 HTTP/2：</p>
<p><p class="md__image">
  <img src="../imgs/firefox-http2.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>Echo 还支持自动 TLS，即：Echo#StartAutoTLS 方法，它从 <a href="https://letsencrypt.org">https://letsencrypt.org</a> 获取证书。这涉及到正式域名等，在此不演示！</p>
</blockquote>
<h2 id="自定义-http2-cleartext-server">自定义 HTTP/2 Cleartext Server</h2>
<p>默认情况下，HTTP/2 是基于 TLS 的。上面也看到，当是 HTTPS Server 时，浏览器支持 HTTP/2，默认使用了它。如果我们想使用 HTTP/2，但是又不想使用 TLS，可以吗？这就是 H2C，即：HTTP/2 Cleartext Server。</p>
<p>从 Echo4.1.15 开始支持启动 H2C 服务器：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">StartH2CServer</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">h2s</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">Server</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>Go 从 1.6 开始，标准库 net/http 支持 HTTP/2，Go1.8 支持 HTTP/2 的 Push。Go 对 HTTP/2 的支持，最初通过 golang.org/x/net/http2 包实现。Echo 中，上面方法的参数 http2.Server 就是 golang.org/x/net/http2 包中的。</p>
<p>实现一个支持 H2C 的 HTTP Server：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">().</span><span class="nx">Proto</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello HTTP/2！&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">server</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http2</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
		<span class="nx">MaxConcurrentStreams</span><span class="p">:</span> <span class="mi">250</span><span class="p">,</span>
		<span class="nx">MaxReadFrameSize</span><span class="p">:</span>     <span class="mi">1048576</span><span class="p">,</span>
		<span class="nx">IdleTimeout</span><span class="p">:</span>          <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">StartH2CServer</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">,</span> <span class="nx">server</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>然而，因为现代的浏览器都不支持  H2C，所以测试我们通过 curl 来进行。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl -v --http2 -k http://localhost:2020

*   Trying ::1...
* TCP_NODELAY <span class="nb">set</span>
* Connected to localhost <span class="o">(</span>::1<span class="o">)</span> port <span class="m">2020</span> <span class="o">(</span><span class="c1">#0)</span>
&gt; GET / HTTP/1.1
&gt; Host: localhost:2020
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt; Connection: Upgrade, HTTP2-Settings
&gt; Upgrade: h2c
&gt; HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
&gt;
&lt; HTTP/1.1 <span class="m">101</span> Switching Protocols
&lt; Connection: Upgrade
&lt; Upgrade: h2c
* Received <span class="m">101</span>
* Using HTTP2, server supports multi-use
* Connection state changed <span class="o">(</span>HTTP/2 confirmed<span class="o">)</span>
* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: <span class="nv">len</span><span class="o">=</span><span class="m">0</span>
* Connection state changed <span class="o">(</span><span class="nv">MAX_CONCURRENT_STREAMS</span> <span class="o">==</span> 250<span class="o">)</span>!
&lt; HTTP/2 <span class="m">200</span>
&lt; content-type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
&lt; content-length: <span class="m">15</span>
&lt; date: Thu, <span class="m">26</span> Mar <span class="m">2020</span> 08:20:58 GMT
&lt;
* Connection <span class="c1">#0 to host localhost left intact</span>
Hello HTTP/2！* Closing connection <span class="m">0</span>
</code></pre></div><p>而且服务端的输出也确实证明是 HTTP/2。</p>
<p>另外可以通过 Echo#DisableHTTP2 禁用 HTTP/2。</p>
<p>至此，关于 Server 的定制就介绍完了。Echo 的定制也全部讲解完。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇3：自定义 Logger，用你喜欢的日志库</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom03-logger/</link>
			<pubDate>Fri, 06 Mar 2020 11:50:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom03-logger/</guid>
			<description>在知识星球简书项目中，我们分析对比了目前的一些日志库。虽然 Go 标准库有一个 log，但功能有限，所以才出现了很多第三方的日志库。在 用 Go 实现一个简</description>
			<content type="html"><![CDATA[<p>在知识星球简书项目中，我们分析对比了目前的一些日志库。虽然 Go 标准库有一个 log，但功能有限，所以才出现了很多第三方的日志库。在 <a href="https://studygolang.com/topics/10625" target="_blank" rel="noopener">用 Go 实现一个简书 8：日志记录和优秀库的学习</a>
 中，我们得出结论，推荐大家使用 <a href="https://github.com/rs/zerolog" target="_blank" rel="noopener">zerolog</a>
。现在我们就将 zerolog 集成进 Echo 框架中。</p>
<h2 id="echo-默认的-logger">Echo 默认的 Logger</h2>
<p>Echo 日志记录的默认格式是 JSON，可以通过修改标头来更改，即 <code>Echo#Logger.SetHeader(io.Writer)</code>。</p>
<h3 id="log-header">Log Header</h3>
<p>标头默认值为：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span><span class="nt">&#34;time&#34;</span><span class="p">:</span><span class="s2">&#34;${time_rfc3339_nano}&#34;</span><span class="p">,</span><span class="nt">&#34;level&#34;</span><span class="p">:</span><span class="s2">&#34;${level}&#34;</span><span class="p">,</span><span class="nt">&#34;prefix&#34;</span><span class="p">:</span><span class="s2">&#34;${prefix}&#34;</span><span class="p">,</span><span class="nt">&#34;file&#34;</span><span class="p">:</span><span class="s2">&#34;${short_file}&#34;</span><span class="p">,</span><span class="nt">&#34;line&#34;</span><span class="p">:</span><span class="s2">&#34;${line}&#34;</span><span class="p">}</span>
</code></pre></div><p>因为 Echo 默认使用的 Logger 是作者开发的 <code>github.com/labstack/gommon/log</code> 库，我们看看怎么自定义默认标头。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;github.com/labstack/gommon/log&#34;</span>

<span class="cm">/* ... */</span>

<span class="k">if</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.(</span><span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
  <span class="nx">l</span><span class="p">.</span><span class="nf">SetHeader</span><span class="p">(</span><span class="s">&#34;${time_rfc3339} ${level}&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这样输出的标头成为：<code>2018-05-08T20:30:06-07:00 INFO info</code>。</p>
<p>目前，预定义的 tag 有：</p>
<ul>
<li><code>time_rfc3339</code>：时间格式</li>
<li><code>time_rfc3339_nano</code>：带纳秒的时间格式</li>
<li><code>level</code>：级别</li>
<li><code>prefix</code>：前缀</li>
<li><code>long_file</code>：长文件名（带路径）</li>
<li><code>short_file</code>：短文件名（不带路径）</li>
<li><code>line</code>：文件行号</li>
</ul>
<h3 id="log-输出">Log 输出</h3>
<p><code>Echo#Logger.SetOutput(io.Writer)</code> 可以设置日志输出的目的地。默认输出到标准输出。如果想禁用日志，有两种方式：</p>
<ul>
<li>Echo#Logger.SetOutput(ioutil.Discard)</li>
<li>Echo#Logger.SetLevel(log.OFF)</li>
</ul>
<h3 id="log-级别">Log 级别</h3>
<p>默认情况下，日志的级别是 ERROR。可以通过 <code>Echo#Logger.SetLevel(log.Lvl)</code> 修改。一共有如下一些级别：</p>
<ul>
<li><code>DEBUG</code></li>
<li><code>INFO</code></li>
<li><code>WARN</code></li>
<li><code>ERROR</code></li>
<li><code>OFF</code></li>
</ul>
<p>以上就是 Echo 框架提供的可以定制 Log 的相关接口。</p>
<h2 id="自定义-logger">自定义 Logger</h2>
<p>Echo 支持通过<code>Echo#Logger</code> 注册自定义的 Logger，前提是这个 Logger 必须实现 Echo 提供的接口：echo.Logger：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Output</span><span class="p">()</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
    <span class="nf">SetOutput</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>
    <span class="nf">Prefix</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nf">SetPrefix</span><span class="p">(</span><span class="nx">p</span> <span class="kt">string</span><span class="p">)</span>
    <span class="nf">Level</span><span class="p">()</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Lvl</span>
    <span class="nf">SetLevel</span><span class="p">(</span><span class="nx">v</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Lvl</span><span class="p">)</span>
    <span class="nf">SetHeader</span><span class="p">(</span><span class="nx">h</span> <span class="kt">string</span><span class="p">)</span>
    <span class="nf">Print</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Printj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Debug</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Debugf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Debugj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Info</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Infof</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Infoj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Warn</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Warnf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Warnj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Error</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Errorf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Errorj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Fatal</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Fatalj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Fatalf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Panic</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Panicj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Panicf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="p">}</span>
</code></pre></div><p>这个接口看着很吓人，基本上是几个日志级别对应的方法。因此，如果我们要将 zerolog 集成进 Echo，让 zerolog 实现该接口（zerolog 本身肯定没有实现该接口）。</p>
<p>因为 zerolog 库的设计和 API 与 echo.Logger 接口差异极大，想要直接为 zerolog 实现一个 Adapter 以便实现 echo.Logger 接口不太现实。于是我们做如下处理来进行适配：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span>
	<span class="nx">ZeroLog</span> <span class="nx">zerolog</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>
</code></pre></div><p>我们定义一个自己的 Logger 结构体，内嵌一个 github.com/labstack/gommon/log 库的 Logger 指针，这样默认就实现了 echo.Logger 接口，然后再是 zerolog.Logger。看看构造函数如何实现？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">writer</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="o">*</span><span class="nx">Logger</span> <span class="p">{</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Logger</span><span class="p">{</span>
		<span class="nx">Logger</span><span class="p">:</span>  <span class="nx">log</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;-&#34;</span><span class="p">),</span>
		<span class="nx">ZeroLog</span><span class="p">:</span> <span class="nx">zerolog</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">writer</span><span class="p">).</span><span class="nf">With</span><span class="p">().</span><span class="nf">Caller</span><span class="p">().</span><span class="nf">Timestamp</span><span class="p">().</span><span class="nf">Logger</span><span class="p">(),</span>
	<span class="p">}</span>
  
	<span class="c1">// log 默认是 ERROR，将 Level 默认都改为 INFO
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">INFO</span><span class="p">)</span>

	<span class="nx">l</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetOutput</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">l</span>
<span class="p">}</span>
</code></pre></div><p>这么做有什么用？还不如干脆 echo 框架自己的日志由它处理，我们的日志使用 zerolog 处理。这样当然是可以的。但集成在一起有如下好处：</p>
<ul>
<li>形式上变成了一个日志类，也就是我们自定义的 Logger；</li>
<li>方便统一控制，比如输出目标、日志级别；</li>
<li>通过一个日志库，既可以做到单独控制 echo 的行为，也可以单独控制 zerolog 的行为；</li>
</ul>
<p>那统一控制行为如何实现呢？这里实现了两个，控制输出目的地和日志级别。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">SetOutput</span><span class="p">(</span><span class="nx">writer</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetOutput</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span><span class="p">.</span><span class="nf">Output</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">SetLevel</span><span class="p">(</span><span class="nx">level</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Lvl</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">level</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">level</span> <span class="o">==</span> <span class="nx">log</span><span class="p">.</span><span class="nx">OFF</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span><span class="p">.</span><span class="nf">Level</span><span class="p">(</span><span class="nx">zerolog</span><span class="p">.</span><span class="nx">Disabled</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">zeroLevel</span> <span class="o">:=</span> <span class="nb">int8</span><span class="p">(</span><span class="nx">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span><span class="p">.</span><span class="nf">Level</span><span class="p">(</span><span class="nx">zerolog</span><span class="p">.</span><span class="nf">Level</span><span class="p">(</span><span class="nx">zeroLevel</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>当然这种方式也有麻烦的地方，那就是通过 echo 的 Context 获得 zerolog 日志实例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">zerolog</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().(</span><span class="o">*</span><span class="nx">logger</span><span class="p">.</span><span class="nx">Logger</span><span class="p">).</span><span class="nx">ZeroLog</span>
</code></pre></div><p>这样自定义日志库就完成了。该库完整代码见：<a href="https://github.com/polaris1119/go-echo-example/blob/master/pkg/logger/logger.go">https://github.com/polaris1119/go-echo-example/blob/master/pkg/logger/logger.go</a>。</p>
<h2 id="在-echo-项目中使用自定义日志库">在 Echo 项目中使用自定义日志库</h2>
<p>在 go-echo-example 项目的 cmd 下创建一个目录 gopher，将来我们的实战篇就用它作为入口。之后创建一个 main.go 文件，核心代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span> <span class="p">=</span> <span class="nx">logger</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span>
  <span class="c1">// e.Logger.SetLevel(log.DEBUG)
</span><span class="c1"></span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Recover</span><span class="p">())</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;This is echo logger debug msg!&#34;</span><span class="p">)</span>

		<span class="nx">zerolog</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().(</span><span class="o">*</span><span class="nx">logger</span><span class="p">.</span><span class="nx">Logger</span><span class="p">).</span><span class="nx">ZeroLog</span>
		<span class="nx">zerolog</span><span class="p">.</span><span class="nf">Debug</span><span class="p">().</span><span class="nf">Str</span><span class="p">(</span><span class="s">&#34;path&#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Path</span><span class="p">()).</span><span class="nf">Msg</span><span class="p">(</span><span class="s">&#34;This is Debug msg!&#34;</span><span class="p">)</span>

		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">HTML</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>我们得到 echo 的实例后，将其日志设置为我们自定义的 logger：<code>e.Logger = logger.New(os.Stdout)</code>。注意注释掉的代码。运行程序：go run main.go，打开浏览器访问 http://localhost:2020 ，看看日志是否有两条 Debug 记录。接着将注释去掉再次测试，看日志是否有输出。</p>
<p>不出意外，一切都符合预期。恭喜你大功告成！</p>
<p><a href="https://github.com/polaris1119/go-echo-example/tree/091967f4bea4a3f9ee7c20411f15287d2c950e02" target="_blank" rel="noopener">完整代码点这里</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇2：自定义 Validator，进行输入校验</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom02-validator/</link>
			<pubDate>Fri, 28 Feb 2020 18:53:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom02-validator/</guid>
			<description>上一篇讲 Binder 时提到，参数自动绑定和校验是 Web 框架很重要的两个功能，可以极大的提升开发速度，并更好的保证数据的可靠性（服务端数据校验很重要）。本节</description>
			<content type="html"><![CDATA[<p>上一篇讲 Binder 时提到，参数自动绑定和校验是 Web 框架很重要的两个功能，可以极大的提升开发速度，并更好的保证数据的可靠性（服务端数据校验很重要）。本节，我们就一起看看如何自定义 Echo 的表单校验功能。</p>
<p>不同于 Binder，Echo 并没有内置数据校验的能力，也就是没有默认的 Validator 实现。然而，你可以很方便的集成第三方的数据校验库。跟 Binder 类似，Echo 提供了一个 Validator 接口，方便将第三方数据校验库集成进来。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Validator</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">Validate</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>通过这个实现这个接口，可以很方便的将任何第三方数据校验库集成到 Echo 中。在 Awesome-Go 上可以找到第三方数据校验库：<a href="https://github.com/avelino/awesome-go#validation">https://github.com/avelino/awesome-go#validation</a>。本文我们使用最流行的 <a href="https://github.com/go-playground/validator">https://github.com/go-playground/validator</a> 库来讲解。</p>
<h2 id="go-playgroundvalidator">go-playground/validator</h2>
<p>这是一个 Go 结构体及字段校验器，包括：跨字段和跨结构体校验，Map，切片和数组，是目前校验器相关库中 Star 数最高的一个，对国际化支持也很好，建议大家使用它。</p>
<p>它具有以下独特功能：</p>
<ul>
<li>通过使用验证标签（tag）或自定义验证程序进行跨字段和跨结构体验证；</li>
<li>切片，数组和 map，可以验证任何的多维字段或多层级；</li>
<li>能够深入（多维）了解 map 键和值以进行验证；</li>
<li>通过在验证之前确定其基础类型来处理接口类型；</li>
<li>处理自定义字段类型，例如 sql driver Valuer；</li>
<li>别名验证标签，允许将多个验证映射到单个标签，以便更轻松地定义结构上的验证；</li>
<li>提取自定义定义的字段名称，例如可以指定在验证时提取 JSON 名称，并将其用于结果 FieldError 中；</li>
<li>可自定义的 i18n 错误消息；</li>
<li>gin Web 框架的默认验证器；</li>
</ul>
<h3 id="一个简单的例子">一个简单的例子</h3>
<p>通过一个简单例子来看看如何使用该库。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;flag&#34;</span>

	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`validate:&#34;required&#34;`</span>
	<span class="nx">Age</span>   <span class="kt">uint</span>   <span class="s">`validate:&#34;gte=1,lte=130&#34;`</span>
	<span class="nx">Email</span> <span class="kt">string</span> <span class="s">`validate:&#34;required,email&#34;`</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">name</span>  <span class="kt">string</span>
	<span class="nx">age</span>   <span class="kt">uint</span>
	<span class="nx">email</span> <span class="kt">string</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;输入名字&#34;</span><span class="p">)</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">UintVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">age</span><span class="p">,</span> <span class="s">&#34;age&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;输入年龄&#34;</span><span class="p">)</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">email</span><span class="p">,</span> <span class="s">&#34;email&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;输入邮箱&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>

	<span class="nx">user</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="nx">name</span><span class="p">,</span>
		<span class="nx">Age</span><span class="p">:</span>   <span class="nx">age</span><span class="p">,</span>
		<span class="nx">Email</span><span class="p">:</span> <span class="nx">email</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">validate</span> <span class="o">:=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>执行如下命令，运行代码：</p>
<pre><code>go run main.go -name studygolang -age 7 -email polaris@studygolang.com
</code></pre><p>什么都没有输出，表示一切正常。如果我们提供一个非法的邮箱地址：</p>
<pre><code>go run main.go -name studygolang -age 7 -email polaris@studygolang
</code></pre><p>输出如下错误：</p>
<pre><code>Key: 'User.Email' Error:Field validation for 'Email' failed on the 'email' tag
</code></pre><p>错误显示不友好。怎么能够更友好，并进行国际化呢？</p>
<h3 id="国际化i18n">国际化（i18n）</h3>
<p>在介绍校验库错误消息国际化之前，有一个概念需要了解下，那就是 CLDR。</p>
<h4 id="什么是-cldr">什么是 CLDR？</h4>
<p>它是 i18n 的一套核心规范（ Common Locale Data Respository），即通用的本地化数据存储库，什么意思呢？比如我们的手机，电脑都可以选择语言模式为 英语、汉语、日语、法语等等，这套操作背后的规范，就是 CLDR；CLDR 是以 Unicode 的编码标准作为前提，将多国的语言文字进行编码的。</p>
<p>看看官方对于 CLDR 的说明，官方网址：<a href="http://cldr.unicode.org/">http://cldr.unicode.org/</a></p>
<blockquote>
<p>Unicode CLDR 提供了支持世界语言的软件的关键构建块，并且具有最大和最广泛的本地设置数据标准存储库。大量的公司使用此数据进行软件的国际化和本地化，使它们的软件适应此类通用软件任务的不同语言的约定。</p>
</blockquote>
<p>需要进行国际化和本地化的主要包括：</p>
<ul>
<li>用于格式化和解析的特定于语言环境的模式：日期，时间，时区，数字和货币值，度量单位，…</li>
<li>名称的翻译：语言，脚本，国家和地区，货币，时代，月份，工作日，白天，时区，城市和时间单位，表情符号字符和序列（和搜索关键字），…</li>
<li>语言和文字信息：使用的字符；复数情况；性别；大写；分类和搜索规则；写作方向；音译规则；拼写数字的规则；将文本分割成字符，单词和句子的规则；键盘布局…</li>
<li>国家/地区信息：语言使用情况，货币信息，日历首选项，星期惯例等…</li>
<li>有效性：Unicode 语言环境，语言，脚本，区域和扩展名的定义，别名和有效性信息，…</li>
</ul>
<h4 id="cldr-的-go-语言实现">CLDR 的 Go 语言实现</h4>
<p>本文讲解的校验库是 go-playground 这个组织创建的，它们还提供了其他的一些有用库，其中就包括了 CLDR 的 Go 语言实现，这就是 <a href="https://github.com/go-playground/locales" target="_blank" rel="noopener">locales</a>
。</p>
<blockquote>
<p>该库是从 CLDR 项目生成的一组语言环境，可以单独使用或在 i18n 软件包中使用；这些是专为 <a href="https://github.com/go-playground/universal-translator">https://github.com/go-playground/universal-translator</a> 构建的，但也可以单独他用。</p>
</blockquote>
<p>这引出了该组织的另外一个库：<a href="https://github.com/go-playground/universal-translator" target="_blank" rel="noopener">universal-translator</a>
。</p>
<p><a href="https://github.com/go-playground/universal-translator" target="_blank" rel="noopener">universal-translator</a>
：一个使用 CLDR 数据+复数规则（比如英语很多复数规则是加 s）的 Go i18n 转换器（翻译器）。该库是  <a href="https://github.com/go-playground/locales" target="_blank" rel="noopener">locales</a>
 的薄包装，以便存储和翻译文本，供你在应用程序中使用。</p>
<h4 id="universal-translator-简明教程">universal-translator 简明教程</h4>
<p>这个通用的翻译器包主要包含了两个核心数据结构：Translator 接口和 UniversalTranslator 结构体，其他的是错误类型。我们先看 Translator 接口。（注意，该包的包名是 ut）</p>
<p><strong>Translator 接口</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Translator</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">locales</span><span class="p">.</span><span class="nx">Translator</span>

    <span class="c1">// adds a normal translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {#} is the only replacement type accepted and are ad infinitum
</span><span class="c1"></span>    <span class="c1">// eg. one: &#39;{0} day left&#39; other: &#39;{0} days left&#39;
</span><span class="c1"></span>    <span class="nf">Add</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// adds a cardinal plural translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {0} is the only replacement type accepted and only one variable is accepted as
</span><span class="c1"></span>    <span class="c1">// multiple cannot be used for a plural rule determination, unless it is a range;
</span><span class="c1"></span>    <span class="c1">// see AddRange below.
</span><span class="c1"></span>    <span class="c1">// eg. in locale &#39;en&#39; one: &#39;{0} day left&#39; other: &#39;{0} days left&#39;
</span><span class="c1"></span>    <span class="nf">AddCardinal</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rule</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRule</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// adds an ordinal plural translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {0} is the only replacement type accepted and only one variable is accepted as
</span><span class="c1"></span>    <span class="c1">// multiple cannot be used for a plural rule determination, unless it is a range;
</span><span class="c1"></span>    <span class="c1">// see AddRange below.
</span><span class="c1"></span>    <span class="c1">// eg. in locale &#39;en&#39; one: &#39;{0}st day of spring&#39; other: &#39;{0}nd day of spring&#39;
</span><span class="c1"></span>    <span class="c1">// - 1st, 2nd, 3rd...
</span><span class="c1"></span>    <span class="nf">AddOrdinal</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rule</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRule</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// adds a range plural translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {0} and {1} are the only replacement types accepted and only these are accepted.
</span><span class="c1"></span>    <span class="c1">// eg. in locale &#39;nl&#39; one: &#39;{0}-{1} day left&#39; other: &#39;{0}-{1} days left&#39;
</span><span class="c1"></span>    <span class="nf">AddRange</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rule</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRule</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// creates the translation for the locale given the &#39;key&#39; and params passed in
</span><span class="c1"></span>    <span class="nf">T</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">params</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// creates the cardinal translation for the locale given the &#39;key&#39;, &#39;num&#39; and &#39;digit&#39; arguments
</span><span class="c1"></span>    <span class="c1">//  and param passed in
</span><span class="c1"></span>    <span class="nf">C</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">num</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">param</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// creates the ordinal translation for the locale given the &#39;key&#39;, &#39;num&#39; and &#39;digit&#39; arguments
</span><span class="c1"></span>    <span class="c1">// and param passed in
</span><span class="c1"></span>    <span class="nf">O</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">num</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">param</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">//  creates the range translation for the locale given the &#39;key&#39;, &#39;num1&#39;, &#39;digit1&#39;, &#39;num2&#39; and
</span><span class="c1"></span>    <span class="c1">//  &#39;digit2&#39; arguments and &#39;param1&#39; and &#39;param2&#39; passed in
</span><span class="c1"></span>    <span class="nf">R</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">num1</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits1</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">num2</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits2</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">param1</span><span class="p">,</span> <span class="nx">param2</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// VerifyTranslations checks to ensures that no plural rules have been
</span><span class="c1"></span>    <span class="c1">// missed within the translations.
</span><span class="c1"></span>    <span class="nf">VerifyTranslations</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>关于该接口需要需要如下几点说明</p>
<ul>
<li>内嵌了 locales.Translator 接口；</li>
<li>几类复数规则：cardinal plural（基数复数规则，即单数和复数两种）；ordinal plural（序数复数规则，如 1st, 2nd, 3rd…）；ordinal plural （范围复数规则，如 0-1）。对中文来说，这里大部分不需要。</li>
<li>几个 Add 方法，和上面几类规则对应；一个 key 和 一个带站位符的 text；</li>
<li>单字符的几个方法和 Add 几个方法的对应关系：T -&gt; Add；C -&gt; AddCardinal；O -&gt; AddOrdinal；R -&gt; AddRange ；表示用具体的值替换 key 表示的文本 text 中的占位符。</li>
<li>以上方法参数中，num 表示占位符处的值，但对于有复数形式的语言，这个值必须符合复数语言的规范，否则会报错；digits 表示 num 值的有效数字（或者说小数位数）；</li>
<li>VerifyTranslations 确保翻译库中没有缺少对应的语言规则；</li>
</ul>
<p><strong>UniversalTranslator 结构体</strong></p>
<p>它用于保存所有语言环境和翻译数据。该结构体方法不多，我们关注几个核心的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">fallback</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="nx">supportedLocales</span> <span class="o">...</span><span class="nx">locales</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="o">*</span><span class="nx">UniversalTranslator</span>
</code></pre></div><p>New 返回一个 UniversalTranslator 实例，该实例具有后备语言环境（fallback）和应支持的语言环境（supportedLocales）。可以看到，New 函数接收的参数是 locales.Translator 类型，因此我们肯定需要用到 locales 包。</p>
<p>得到 UniversalTranslator 实例后，需要获得 universal-translator 包中的 Translator 接口实例，这就用到了下面几个方法。</p>
<p>1）GetTranslator</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">UniversalTranslator</span><span class="p">)</span> <span class="nf">GetTranslator</span><span class="p">(</span><span class="nx">locale</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">trans</span> <span class="nx">Translator</span><span class="p">,</span> <span class="nx">found</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></div><p>返回给定语言环境的指定翻译器，如果未找到，则返回后备语言环境的翻译器（即 New 中的 fallback）。</p>
<p>2）GetFallback</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">UniversalTranslator</span><span class="p">)</span> <span class="nf">GetFallback</span><span class="p">()</span> <span class="nx">Translator</span>
</code></pre></div><p>直接返回后备语言环境的翻译器。</p>
<p>3）FindTranslator</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">UniversalTranslator</span><span class="p">)</span> <span class="nf">FindTranslator</span><span class="p">(</span><span class="nx">locales</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">trans</span> <span class="nx">Translator</span><span class="p">,</span> <span class="nx">found</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></div><p>尝试根据语言环境数组查找翻译器，并返回它可以找到的第一个翻译器，否则返回后备翻译器。</p>
<p>总结来说，New 函数加上这三个方法，相当于是 locales.Translator 到 ut.Translator 的转换。</p>
<p><strong>示例</strong></p>
<p>通过一个实际的例子来学习下这两个包的使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;fmt&#34;</span>

	<span class="s">&#34;github.com/go-playground/locales&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/en&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/zh&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/zh_Hant_TW&#34;</span>
	<span class="nx">ut</span> <span class="s">&#34;github.com/go-playground/universal-translator&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">universalTraslator</span> <span class="o">*</span><span class="nx">ut</span><span class="p">.</span><span class="nx">UniversalTranslator</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">acceptLanguage</span> <span class="o">:=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;language&#34;</span><span class="p">,</span> <span class="s">&#34;zh&#34;</span><span class="p">,</span> <span class="s">&#34;语言&#34;</span><span class="p">)</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>

	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">en</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">universalTraslator</span> <span class="p">=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">zh</span><span class="p">.</span><span class="nf">New</span><span class="p">(),</span> <span class="nx">zh_Hant_TW</span><span class="p">.</span><span class="nf">New</span><span class="p">())</span>

	<span class="nx">translator</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">universalTraslator</span><span class="p">.</span><span class="nf">GetTranslator</span><span class="p">(</span><span class="o">*</span><span class="nx">acceptLanguage</span><span class="p">)</span>

	<span class="k">switch</span> <span class="o">*</span><span class="nx">acceptLanguage</span> <span class="p">{</span>
	<span class="k">case</span> <span class="s">&#34;zh&#34;</span><span class="p">:</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;welcome&#34;</span><span class="p">,</span> <span class="s">&#34;欢迎 {0} 来到 studygolang.com！&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddCardinal</span><span class="p">(</span><span class="s">&#34;days&#34;</span><span class="p">,</span> <span class="s">&#34;你只剩 {0} 天时间可以注册&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddOrdinal</span><span class="p">(</span><span class="s">&#34;day-of-month&#34;</span><span class="p">,</span> <span class="s">&#34;第{0}天&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddRange</span><span class="p">(</span><span class="s">&#34;between&#34;</span><span class="p">,</span> <span class="s">&#34;距离 {0}-{1} 天&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="k">case</span> <span class="s">&#34;en&#34;</span><span class="p">:</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;welcome&#34;</span><span class="p">,</span> <span class="s">&#34;Welcome {0} to studygolang.com.&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddCardinal</span><span class="p">(</span><span class="s">&#34;days&#34;</span><span class="p">,</span> <span class="s">&#34;You have {0} day left to register&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOne</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddOrdinal</span><span class="p">(</span><span class="s">&#34;day-of-month&#34;</span><span class="p">,</span> <span class="s">&#34;{0}st&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOne</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddRange</span><span class="p">(</span><span class="s">&#34;between&#34;</span><span class="p">,</span> <span class="s">&#34;It&#39;s {0}-{1} days away&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">T</span><span class="p">(</span><span class="s">&#34;welcome&#34;</span><span class="p">,</span> <span class="s">&#34;polaris&#34;</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">C</span><span class="p">(</span><span class="s">&#34;days&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">O</span><span class="p">(</span><span class="s">&#34;day-of-month&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">R</span><span class="p">(</span><span class="s">&#34;between&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><p>主要通过这个例子说明相关函数的使用。</p>
<ul>
<li>根据 acceptLanguage 的不同值，设置不同的语言文案；</li>
<li>对于中文来说，没有复数，因此 AddXX 三个方法的第二个参数都是 locales.PluralRuleOther，表示该语言环境没有复数形式；</li>
<li>英文环境下，PluralRule 规则不能乱填，根据实际情况来；</li>
<li>最后在实际填充值时，num 表示占位符要填入的值，digits 表示 num 这个值最终要保留几位小数；</li>
<li>FmtNumber 方法的参数需要和前面的 num 和 digits 对应上，第一个参数是 num 的值，第二个是 digits 的值；</li>
</ul>
<h3 id="validator-怎么和以上两个库集成提供-i18n">Validator 怎么和以上两个库集成提供 i18n</h3>
<p>Validator 库提供了相应的子库，对以上两个库进行了封装。比如中文的库：github.com/go-playground/validator/translations/zh ，这些子库提供了一个 RegisterDefaultTranslations ，为所有内置标签的验证器注册一组默认翻译。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span><span class="p">,</span> <span class="nx">trans</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>具体怎么做？还是看最开始的例子，其他不变，main 函数改为如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>

	<span class="nx">user</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="nx">name</span><span class="p">,</span>
		<span class="nx">Age</span><span class="p">:</span>   <span class="nx">age</span><span class="p">,</span>
		<span class="nx">Email</span><span class="p">:</span> <span class="nx">email</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">validate</span> <span class="o">:=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">en</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">uniTrans</span> <span class="o">:=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">zh</span><span class="p">.</span><span class="nf">New</span><span class="p">(),</span> <span class="nx">zh_Hant_TW</span><span class="p">.</span><span class="nf">New</span><span class="p">())</span>
	<span class="nx">translator</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">uniTrans</span><span class="p">.</span><span class="nf">GetTranslator</span><span class="p">(</span><span class="s">&#34;zh&#34;</span><span class="p">)</span>
	<span class="nx">zh_translate</span><span class="p">.</span><span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">validate</span><span class="p">,</span> <span class="nx">translator</span><span class="p">)</span>

	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">errs</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">validator</span><span class="p">.</span><span class="nx">ValidationErrors</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">errs</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="nx">translator</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>注册一个默认的中文翻译器，在校验出错后，对错误进行翻译。不输入任何参数运行程序，输出：</p>
<blockquote>
<p>Name为必填字段
Age必须大于或等于1
Email为必填字段</p>
</blockquote>
<p>大功告成。</p>
<h2 id="将-validator-集成到-echo-中">将 Validator 集成到 Echo 中</h2>
<p>首先，需要定义一个类型，实现 Echo 的接口 Validator ：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CustomValidator</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">once</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">validate</span> <span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CustomValidator</span><span class="p">)</span> <span class="nf">Validate</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">lazyInit</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CustomValidator</span><span class="p">)</span> <span class="nf">lazyInit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">validate</span> <span class="p">=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>因为 validator.Validate 实例化做了不少事情，这里将实例化推迟到使用时。简单几行代码就实现了一个自定义的 Validator。</p>
<p>接下来和 Echo 集成起来就很容易了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Validator</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">CustomValidator</span><span class="p">{}</span>
</code></pre></div><p>之后就可以在需要进行表单校验的地方通过 <code>ctx.Validate()</code> 进行校验。</p>
<p>自此我们完成了 Validator 集成到 Echo 的功能。</p>
<p>还剩最后一块内容，那就是校验错误信息的国际化显示。国际化相关的内容，上面有了较详细的介绍，Validator 集成到 Echo 后如何国际化我们在后面实战篇再讲。</p>
<p>完整代码见：<a href="https://github.com/polaris1119/go-echo-example/blob/master/pkg/validator/validator.go">https://github.com/polaris1119/go-echo-example/blob/master/pkg/validator/validator.go</a>。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇1：自定义 Binder，处理 Request 数据绑定</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom01-binder/</link>
			<pubDate>Fri, 21 Feb 2020 19:26:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom01-binder/</guid>
			<description>Web 开发，数据获取和校验是两个最基本的功能。在数据获取时，我们可以通过标准库的 *http.Request 提供的相关功能进行获取。然而这样效率是很低，重复工作较多，而且</description>
			<content type="html"><![CDATA[<p>Web 开发，数据获取和校验是两个最基本的功能。在数据获取时，我们可以通过标准库的 <code>*http.Request</code> 提供的相关功能进行获取。然而这样效率是很低，重复工作较多，而且考虑到数据自动校验，我们更应该做到自动绑定。</p>
<p>在讲述 Echo 的 Binder 前，先探讨一下客户端数据一般通过什么方式发送给服务端的。</p>
<h2 id="客户端如何传递数据给服务端">客户端如何传递数据给服务端？</h2>
<p>这个问题其实对大部分人来说太简单了，然而，很多客户端的人却不清楚。工作中，我接触过不少客户端的人，对于数据怎么传递给服务端，他们是没有概念的，找到一个能用的方法发送给服务端就行了。比如，一个普通的数据通过 HTTP Header 来发送；分不清自己发送的数据是 key=json 形式还是 Body 中直接放 JSON，也就是不清楚 Content-Type 相关的含义。</p>
<p>为了让大家更容易掌握相关知识点，我通过问题的形式讲解。</p>
<h3 id="问题-1get-和-post-参数如何获取">问题 1：Get 和 Post 参数如何获取</h3>
<p>讲再多都不如一个实际的程序演示来的清楚明白。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">ParseMultipartForm</span><span class="p">(</span><span class="mi">32</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span>

		<span class="nx">data</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
			<span class="s">&#34;form&#34;</span><span class="p">:</span>      <span class="nx">req</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span>
			<span class="s">&#34;post_form&#34;</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>这是一个简单的 Server，启动它：</p>
<blockquote>
<p>go run main.go</p>
</blockquote>
<p>接着，我们通过 <a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="noopener">httpie</a>
 来模拟请求，看不同的输出。（关于 httpie 的使用可以看官方文档）</p>
<p>1）<code>http -v :2020 name==polaris</code></p>
<p>命令的输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">GET /?name<span class="o">=</span>polaris HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:2020
User-Agent: HTTPie/2.0.0



HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">46</span>
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 07:27:56 GMT

map<span class="o">[</span>form:map<span class="o">[</span>name:<span class="o">[</span>polaris<span class="o">]]</span> post_form:map<span class="o">[]]</span>
</code></pre></div><p>作为一个服务端工程师，很有必要了解 HTTP 请求报文和响应报文。</p>
<p>从输出可以看出，GET 参数放在了 req.Form 中，实际开发中，一般这样获取 GET 的参数：<code>req.FormValue(&quot;name&quot;)</code>。因为默认情况下，参数并没有解析，也就是 Form 中没有，这也就是我们上面代码中 <code>req.ParseMultipartForm(32 &lt;&lt; 20)</code> 这样代码的作用。而 req.FormValue 会判断有没有解析。</p>
<p>2）<code>http -v --form :2020 name==polaris name=xuxinhua sex=male</code></p>
<p>直接看命令的输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">POST /?name<span class="o">=</span>polaris HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">22</span>
Content-Type: application/x-www-form-urlencoded<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="nv">name</span><span class="o">=</span>xuxinhua<span class="p">&amp;</span><span class="nv">sex</span><span class="o">=</span>male

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">92</span>
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 07:35:56 GMT

map<span class="o">[</span>form:map<span class="o">[</span>name:<span class="o">[</span>xuxinhua polaris<span class="o">]</span> sex:<span class="o">[</span>male<span class="o">]]</span> post_form:map<span class="o">[</span>name:<span class="o">[</span>xuxinhua<span class="o">]</span> sex:<span class="o">[</span>male<span class="o">]]]</span>
</code></pre></div><p>这里发起了一个 POST 请求。需要关注以下几点：</p>
<ul>
<li>请求中有参数：name=polaris</li>
<li>请求头：Content-Type: application/x-www-form-urlencoded; charset=utf-8</li>
<li>请求体（body）：name=xuxinhua&amp;sex=male</li>
</ul>
<p>因为 name 在 url 和 body 中分别有一个值：polaris 和 xuxinhua，因此，form 中 name 包含了两个值。从响应中结果可以看出，Form 同时包含了 url 参数和 body 的 key=value；而 PostForm 只包含 body 中的 key=value。（PUT 和 POST 是一样的效果）</p>
<p>因此，req.FormValue() 可以获取所有请求参数；而 req.PostFormValue() 获取 POST 之类的参数，如果同一个参数有多个值，只会取第一个，而 POST 参数优先级高于 URL 参数。</p>
<blockquote>
<p>小问题：上面例子中，如果想要获取 name=polaris，而不是 name=xuxinhua，怎么做？</p>
</blockquote>
<h3 id="问题-2客户端传递-json-怎么办">问题 2：客户端传递 JSON 怎么办？</h3>
<p>继续基于上面的例子，执行如下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020 <span class="nv">name</span><span class="o">=</span>xuxinhua <span class="nv">sex</span><span class="o">=</span>male
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">POST / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">35</span>
Content-Type: application/json
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">32</span>
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 07:58:05 GMT

map<span class="o">[</span>form:map<span class="o">[]</span> post_form:map<span class="o">[]]</span>
</code></pre></div><p>这次请求头的 Content-Type 值是：application/json，表明客户端将参数通过 JSON 格式传递，具体参数放在了 Body 中：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;xuxinhua&#34;</span><span class="p">,</span>
    <span class="nt">&#34;sex&#34;</span><span class="p">:</span> <span class="s2">&#34;male&#34;</span>
<span class="p">}</span>
</code></pre></div><p>从服务端的输出可以看到，Form 和 PostForm 都没有获取到这些参数，怎么办？答案是从 Body 中读取。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">reqBody</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span>
<span class="nx">data</span><span class="p">[</span><span class="s">&#34;json_data&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">reqBody</span><span class="p">)</span>
</code></pre></div><p>最后简单说下 Content-Type 是 multipart/form-data 的情况。</p>
<p>当需要进行文件上传时，要求 Content-Type 设置为 multipart/form-data，对应的页面表单就是：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&#34;/&#34;</span> <span class="na">method</span><span class="o">=</span><span class="s">&#34;POST&#34;</span> <span class="na">enctype</span><span class="o">=</span><span class="s">&#34;multipart/form-data&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div><p>这样的表单才能进行文件上传。对文件上传的处理，Go 中对应的是 req.MultipartForm 和 req.FormFile()。</p>
<p>当然，除此之外，Content-Type 还有其他值（一般叫做 MIME），但常用的已经介绍了（相较而言，GET 只有一种 Content-Type: application/x-www-form-urlencoding）。</p>
<h2 id="echo-的-binder-是如何做的">Echo 的 Binder 是如何做的？</h2>
<p>上面介绍的都是标准库 net/http 的相关 API，回到 Echo，有如下对应关系：</p>
<ul>
<li>Conetxt#QueryParam() 和  QueryParams() 方法获取 URL 参数；</li>
<li>Context#FormValue() 和 FormParams() 方法获取 Form 参数，对应标准库的 PostForm；</li>
<li>Context#FormFile() 和 MultipartForm() 方法处理文件上传；</li>
</ul>
<p>除此之外，因为 Echo 路由支持路径参数（Path Param），对应的获取方法：Context#Param() 和 ParamNames()。</p>
<p>对于 Binder，Echo 默认提供了一个实现：echo.DefaultBinder，通常情况下，这个默认实现就能够满足要求。我们先看看它的实现。</p>
<h3 id="defaultbinder-的实现">DefaultBinder 的实现</h3>
<p>首先，Echo 定义了一个接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Binder</span> <span class="kd">interface</span><span class="p">{</span>
  <span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>任何 Binder 必须实现该接口，也就是提供 Bind 方法。一起看看 DefaultBinder 的 Bind 方法实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">DefaultBinder</span><span class="p">)</span> <span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Request</span><span class="p">()</span>

	<span class="nx">names</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ParamNames</span><span class="p">()</span>
	<span class="nx">values</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ParamValues</span><span class="p">()</span>
	<span class="nx">params</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">name</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">names</span> <span class="p">{</span>
		<span class="nx">params</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">bindData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">params</span><span class="p">,</span> <span class="s">&#34;param&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">bindData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">QueryParams</span><span class="p">(),</span> <span class="s">&#34;query&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ctype</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">HeaderContentType</span><span class="p">)</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEApplicationJSON</span><span class="p">):</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">ute</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">json</span><span class="p">.</span><span class="nx">UnmarshalTypeError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Unmarshal type error: expected=%v, got=%v, field=%v, offset=%v&#34;</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Field</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Offset</span><span class="p">)).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">se</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">json</span><span class="p">.</span><span class="nx">SyntaxError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Syntax error: offset=%v, error=%v&#34;</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nx">Offset</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nf">Error</span><span class="p">())).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEApplicationXML</span><span class="p">),</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMETextXML</span><span class="p">):</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">xml</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">ute</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">xml</span><span class="p">.</span><span class="nx">UnsupportedTypeError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Unsupported type error: type=%v, error=%v&#34;</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nf">Error</span><span class="p">())).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">se</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">xml</span><span class="p">.</span><span class="nx">SyntaxError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Syntax error: line=%v, error=%v&#34;</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nx">Line</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nf">Error</span><span class="p">())).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEApplicationForm</span><span class="p">),</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEMultipartForm</span><span class="p">):</span>
		<span class="nx">params</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">FormParams</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">bindData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">params</span><span class="p">,</span> <span class="s">&#34;form&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">ErrUnsupportedMediaType</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>一起分析下这个方法：</p>
<ul>
<li>DefaultBinder 的 bindData 方法进行实际的数据绑定，主要通过反射进行处理，要求被绑定的类型是 map[string]interface{} 或 struct（实际是时间它们的指针），有兴趣的可以查看它的源码；<a href="https://github.com/labstack/echo/blob/master/bind.go#L86">https://github.com/labstack/echo/blob/master/bind.go#L86</a></li>
<li>通过给 Struct 的字段加上不同的 Tag 来接收不同类型的值：
<ul>
<li>param tag 对应路径参数；</li>
<li>query tag 对应 URL 参数；</li>
<li>json tag 对应 application/json 方式参数；</li>
<li>form tag 对应 POST 表单数据；</li>
<li>xml tag 对应 application/xml 或 text/xml；</li>
</ul>
</li>
<li>从代码的顺序可以看出，当同一个字段在多种方式存在值时，优先级顺序：param &lt; query &lt; 其他；</li>
</ul>
<p>讲解完了，来一个实际的例子加深理解。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`query:&#34;name&#34; form:&#34;name&#34; json:&#34;name&#34;`</span>
	<span class="nx">Sex</span>  <span class="kt">string</span> <span class="s">`query:&#34;sex&#34; form:&#34;sex&#34; json:&#34;sex&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">Any</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">user</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">User</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>同样使用 httpie 来进行测试。</p>
<p><strong>1）GET 请求</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020 <span class="nv">name</span><span class="o">==</span>xuxinhua <span class="nv">sex</span><span class="o">==</span>male
</code></pre></div><p>输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">GET /?name<span class="o">=</span>xuxinhua<span class="p">&amp;</span><span class="nv">sex</span><span class="o">=</span>male HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:2020
User-Agent: HTTPie/2.0.0



HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">33</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:27:25 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>
</code></pre></div><p>能够正确绑定值。</p>
<p><strong>2）POST 请求</strong></p>
<p>特意加上 URL 参数混淆下，看看结果</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ http -v --form :2020 <span class="nv">name</span><span class="o">==</span>polaris <span class="nv">name</span><span class="o">=</span>xuxinhua <span class="nv">sex</span><span class="o">=</span>male
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">POST /?name<span class="o">=</span>polaris HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">22</span>
Content-Type: application/x-www-form-urlencoded<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="nv">name</span><span class="o">=</span>xuxinhua<span class="p">&amp;</span><span class="nv">sex</span><span class="o">=</span>male

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">33</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:46:09 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>
</code></pre></div><p>从结果 name 是 xuxinhua 可以看出，URL 参数的优先级较低。</p>
<p><strong>3）请求参数是 JSON</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020  <span class="nv">name</span><span class="o">=</span>xuxinhua <span class="nv">sex</span><span class="o">=</span>male
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">POST / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">35</span>
Content-Type: application/json
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">33</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:48:48 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>
</code></pre></div><p>一切正常。</p>
<p><strong>4）试试 XML ？</strong></p>
<p>目前 XML 用的还是比较少，基本是 JSON。所以，我们的例子代码默认并没有支持 XML。</p>
<p>我们先创建一个 XML 文件，作为输入：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34;?&gt;</span>
<span class="nt">&lt;user&gt;</span>
	<span class="nt">&lt;name&gt;</span>xuxinhua<span class="nt">&lt;/name&gt;</span>
	<span class="nt">&lt;sex&gt;</span>male<span class="nt">&lt;/sex&gt;</span>
<span class="nt">&lt;/user&gt;</span>
</code></pre></div><p>接着执行如下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020 @user.xml
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">POST / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">78</span>
Content-Type: application/xml
Host: localhost:2020
User-Agent: HTTPie/2.0.0

&lt;?xml <span class="nv">version</span><span class="o">=</span><span class="s2">&#34;1.0&#34;</span>?&gt;

&lt;user&gt;
	&lt;name&gt;xuxinhua&lt;/name&gt;
	&lt;sex&gt;male&lt;/sex&gt;
&lt;/user&gt;

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">21</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:55:54 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;&#34;</span>
<span class="o">}</span>
</code></pre></div><p>一方面，请求的 Content-Type 是 application/xml，但响应却不对。原因是 User 结构中，我们没有为字段指定 xml 这个 tag，加上 tag 再试一下就会正确：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`query:&#34;name&#34; form:&#34;name&#34; json:&#34;name&#34; xml:&#34;name&#34;`</span>
	<span class="nx">Sex</span>  <span class="kt">string</span> <span class="s">`query:&#34;sex&#34; form:&#34;sex&#34; json:&#34;sex&#34; xml:&#34;sex&#34;`</span>
<span class="p">}</span>
</code></pre></div><p>实际中，需要设置什么 tag，你应该心里有数，没必要把所有支持的 tag 都设置上。</p>
<h2 id="自定义-binder">自定义 Binder</h2>
<p>Echo 默认提供的 Binder 已经满足了大部分的需求，那什么时候需要自定义 Binder 呢？</p>
<p>现在一般接口都是用 JSON 作为数据交换格式，假如你老板觉得 JSON 性能不够，希望换其他格式，比如 <a href="https://msgpack.org/" target="_blank" rel="noopener">msgpack</a>
 格式。这时候，echo 默认的 DefaultBinder 已经没法满足我们的需求了，这时候就需要自定义 Binder。类似的还有 protobuf 等。</p>
<h3 id="自定义-msgpackbinder">自定义 MsgpackBinder</h3>
<p>现在，我们就自己实现一个支持 msgpack 格式的 Binder。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MsgpackBinder</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">MsgpackBinder</span><span class="p">)</span> <span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 也支持默认 Binder 相关的绑定
</span><span class="c1"></span>	<span class="nx">db</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">echo</span><span class="p">.</span><span class="nx">DefaultBinder</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrUnsupportedMediaType</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">()</span>
	<span class="nx">ctype</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HeaderContentType</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">MIMEApplicationMsgpack</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">msgpack</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrUnsupportedMediaType</span>
<span class="p">}</span>
</code></pre></div><p>我们的自定义 Binder 除了支持 msgpack 外，还支持默认 Binder 支持的绑定方式。所以，在 Bind 方法入口，先实例化了一个 DefaultBinder，用它进行绑定处理。只有它返回的 err 是 ErrUnsupportedMediaType 时，才进行我们自定义 Binder 的处理逻辑。关于 msgpack 的解析，使用了第三方库：github.com/vmihailenco/msgpack ，使用方式和 JSON 类似。</p>
<p>这样，自定义的 Binder 就完成了。接下来需要替换到 Echo 默认的 Binder：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

<span class="nx">e</span><span class="p">.</span><span class="nx">Binder</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">MsgpackBinder</span><span class="p">)</span>
</code></pre></div><p>即在得到 echo.Echo 的实例后，通过 e.Binder 来覆盖默认的 Binder。</p>
<h3 id="验证自定义的-binder">验证自定义的 Binder</h3>
<p>因为 msgpack 是二进制格式，不方便直接使用 httpie 进行验证。我们写一个简单的客户端工具进行验证。代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;io/ioutil&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/vmihailenco/msgpack&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">Name</span> <span class="kt">string</span>
		<span class="nx">Sex</span>  <span class="kt">string</span>
	<span class="p">}</span>

	<span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">msgpack</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;xuxinhua&#34;</span><span class="p">,</span> <span class="nx">Sex</span><span class="p">:</span> <span class="s">&#34;male&#34;</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultClient</span><span class="p">.</span><span class="nf">Post</span><span class="p">(</span><span class="s">&#34;http://localhost:2020/&#34;</span><span class="p">,</span> <span class="s">&#34;application/msgpack&#34;</span><span class="p">,</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>启动服务端，然后运行客户端。我本地试验，输出结果如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span><span class="nt">&#34;name&#34;</span><span class="p">:</span><span class="s2">&#34;xuxinhua&#34;</span><span class="p">,</span><span class="nt">&#34;sex&#34;</span><span class="p">:</span><span class="s2">&#34;male&#34;</span><span class="p">}</span>
</code></pre></div><p>表明我们的自定义 Binder 生效了。</p>
<blockquote>
<p>说明一下，跟标准库的 json 一样，没有 tag 时，msgpack 库能根据导出字段识别出对应关系。默认情况，msgpack 库使用 msgpack 这个 tag，同时可以通过 UseJSONTag 方法来退而求其次使用 json 这个 tag。当然，我们这里没有使用 tag，而是根据导出字段自动识别对应关系的。</p>
</blockquote>
<h2 id="小结">小结</h2>
<p>到这里，自定义 Binder 就介绍完了。内容比较简单，但是必须掌握，这是基础知识。另外，这里没有提到 cookie，标准库和 echo 都提供了相关的方法进行处理，但一般 cookie 不需要进行数据绑定，额外处理即可。</p>
<p>本文完整代码：<a href="https://github.com/polaris1119/go-echo-example/tree/master/cmd/binder">https://github.com/polaris1119/go-echo-example/tree/master/cmd/binder</a></p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇0：让 Echo 更强大、更好用</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom00-intro/</link>
			<pubDate>Fri, 21 Feb 2020 19:24:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom00-intro/</guid>
			<description>一个强大的框架，一定是可以定制的，或者说可以扩展，能够根据用户自己的需求进行改变、增强，甚至某些功能的替换。作为一个强大的框架，Echo 必然</description>
			<content type="html"><![CDATA[<p>一个强大的框架，一定是可以定制的，或者说可以扩展，能够根据用户自己的需求进行改变、增强，甚至某些功能的替换。作为一个强大的框架，Echo 必然也是可以定制、可以扩展的。本篇起，我们一起探讨如何对 Echo 框架进行定制或扩展，打造成符合你个性需求的框架。</p>
<p>定制化主要包含如下一些方面：</p>
<ul>
<li>自定义 Binder，用来处理 Request 数据绑定</li>
<li>自定义 Validator，用来处理输入验证</li>
<li>自定义 Logger，用你喜欢的日志库</li>
<li>自定义 Renderer，增强或替换模板引擎</li>
<li>自定义 HTTP Error Handler，让 HTTP 错误处理更友好</li>
<li>自定义 Server 相关，替换或扩展默认的 Server</li>
</ul>
<p>关于扩展 Echo，主要通过中间件来实现，而这部分内容，我们已经在<a href="http://blog.studygolang.com/2019/12/echo-login-example/" target="_blank" rel="noopener">《基础篇：通过一个例子串联各特性》</a>
中讲解了，具体常见中间件的使用，会在实战篇讲解。</p>
<p>除此之外，Echo#Debug 可以决定是否进入调试模式，在开发阶段，建议设置为 true，生产环境改为 false。</p>
<p>在开篇我们看到，在启动 Echo 项目时，默认会显示一个 Startup Banner，我们可以通过 Echo#HideBanner 控制它不显示。</p>
]]></content>
		</item>
		
		<item>
			<title>欢迎加入 GoLand 2020.1 抢先体验计划</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/welcome-to-the-goland-2020-1-eap/</link>
			<pubDate>Tue, 24 Dec 2019 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/welcome-to-the-goland-2020-1-eap/</guid>
			<description>GoLand 2020.1 抢先体验计划已经启动。对于此发行版，我们着重于易用性，性能以及减少浪费在样板代码和 IDE 中的冗余操作上的时间。我们还包括对 Go Modules 支持的升级，和其他更多功能。您可以在 2020.1 的路线图博客 文章中找到简短说明。
你可以通过 Toolbox App 获得它，也可以从网站上下载 ，也可以使用快照包（对于 Ubuntu）；或者直接在 GoLand 中通过自动更新的方式获取。Preferences / Settings | Appearance &amp;amp; Behavior | System Settings | Updates。
如果您想知道什么是抢先体验计划，这里有一个简短的解释：
 EAP 版本使您可以试用 Goland 仍在开发中的最新功能和增强功能。这些版本尚未经过全面测试，可能会不稳定，但是您可以在这里为我们提供帮助。通过将这些内部版本和功能用于实际项目和场景中来测试，您可以帮助我们完善它们。这样，当最终版本准备就绪时，它将为您更好地工作。
  EAP 使您可以首先试用所有最新功能; 自构建日期起 30 天内免费使用 EAP 版本。您可以将这段时间用作 GoLand 的扩展试用版； 我们会提供 EAP 版本，直到几乎可以发布稳定版本为止。对于即将推出的 2020.1 版本，EAP 期将大致持续到 3 月底； 在每个发布周期中，我们都会为他们提供免费的 1 年 GoLand 订阅和一件独家的 GoLand T 恤 ，以表彰他们中最活跃的评估人员。 此外，我们几乎每天都提供最新版本。因此，如果您不想等待正式的 EAP 版本公告，则只需下载这些夜间版本之一，即可通过 Toolbox App 获得。请注意，每晚构建的质量通常低于我们的标准，并且没有随附发行说明。与 EAP 版本一样，它们也将在发布后 30 天内过期；  因此，让我们看一下第一个 EAP 版本中包含的内容。</description>
			<content type="html"><![CDATA[<p>GoLand 2020.1 抢先体验计划已经启动。对于此发行版，我们着重于易用性，性能以及减少浪费在样板代码和 IDE 中的冗余操作上的时间。我们还包括对 Go Modules 支持的升级，和其他更多功能。您可以在 2020.1 的<a href="https://blog.jetbrains.com/go/2019/12/24/whats-next-goland-2020-1-roadmap/" target="_blank" rel="noopener">路线图博客</a>
文章中找到简短说明。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/blog@2x.jpg"
    alt=""  />
</p>
</p>
<p>你可以通过 <a href="https://www.jetbrains.com/toolbox/app/?_ga=2.109771525.1651118980.1581665300-159533074.1581665300" target="_blank" rel="noopener">Toolbox App</a>
 获得它，也可以从<a href="https://www.jetbrains.com/go/nextversion/" target="_blank" rel="noopener">网站上下载</a>
，也可以使用快照包（对于 Ubuntu）；或者直接在 GoLand 中通过自动更新的方式获取。<em>Preferences / Settings | Appearance &amp; Behavior | System Settings | Updates</em>。</p>
<p>如果您想知道什么是抢先体验计划，这里有一个简短的解释：</p>
<blockquote>
<p>EAP 版本使您可以试用 Goland 仍在开发中的最新功能和增强功能。这些版本尚未经过全面测试，可能会不稳定，但是您可以在这里为我们提供帮助。通过将这些内部版本和功能用于实际项目和场景中来测试，您可以帮助我们完善它们。这样，当最终版本准备就绪时，它将为您更好地工作。</p>
</blockquote>
<ul>
<li>EAP 使您可以首先试用所有最新功能;</li>
<li>自构建日期起 30 天内免费使用 EAP 版本。您可以将这段时间用作 GoLand 的扩展试用版；</li>
<li>我们会提供 EAP 版本，直到几乎可以发布稳定版本为止。对于即将推出的 2020.1 版本，EAP 期将大致持续到 3 月底；</li>
<li>在每个发布周期中，我们都会为他们提供免费的 1 年 GoLand 订阅和一件独家的 <a href="https://twitter.com/GoLandIDE/status/1116361899308912645" target="_blank" rel="noopener">GoLand T 恤</a>
，以表彰他们中最活跃的评估人员。<p class="md__image">
  <img src="https://s2.ax1x.com/2020/02/15/1xBtL8.jpg"
    alt=""  />
</p>
</li>
<li>此外，我们几乎每天都提供最新版本。因此，如果您不想等待正式的 EAP 版本公告，则只需下载这些夜间版本之一，即可通过 Toolbox App 获得。请注意，每晚构建的质量通常低于我们的标准，并且没有随附发行说明。与 EAP 版本一样，它们也将在发布后 30 天内过期；</li>
</ul>
<p>因此，让我们看一下第一个 EAP 版本中包含的内容。</p>
<h2 id="go-modules">Go Modules</h2>
<p>现在，您可以通过 go.mod 文件中的 <strong>Alt-Enter</strong> 来获取缺失的依赖项并删除未使用的依赖项。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/go-mod-file-support.gif"
    alt=""  />
</p>
</p>
<h2 id="go-114-支持">Go 1.14 支持</h2>
<p>Go 1.14 增加了对嵌入重叠接口的支持，我们也是如此！当您使用重叠的接口时，GoLand 不会将重复的方法报告为错误。</p>
<p>为什么将此功能添加到语言中？</p>
<p>主要好处是我们可以使用嵌入定义接口，而不需要手动定义。这是一个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
 
<span class="kd">type</span> <span class="nx">Employee</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Person</span>
	<span class="nf">Department</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div><p>在 Go 1.14 之前，我们无法在 Employee 接口上添加 String() 方法，因为该方法已在 Person 接口上定义了。现在，我们可以使用接口嵌入定义它，如果 Person 接口有更新，我们自己更可控。</p>
<h2 id="代码补全完成增强">代码补全/完成增强</h2>
<p>我们对样板代码说不！GoLand 为常见的错误处理模式添加了代码完成功能。现在，当您在函数中键入<code>if </code>时，您可以选择 <code>err！= nil {…}</code> 以自动完成它。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/code-completion-handling-errors.gif"
    alt=""  />
</p>
</p>
<p>为了更快地定义接口和结构，现在，当您键入<code>type</code> 关键字时，IDE 会为它们建议模板。当您输入 <code>interface</code> 或 <code>struct</code> 时，将显示相同的补全内容。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/type-keyword-completion-struct-interfaces.gif"
    alt=""  />
</p>
</p>
<p>现在，根据格式设置规则的要求，<strong>Fill Fields</strong> 操作会在冒号后添加空格，并在复合文字中的语句末尾添加逗号。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/field-name-completion.gif"
    alt=""  />
</p>
</p>
<p>现在，当您使用 map 时，完成键类型后，代码补全将光标移到右括号后面。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/code-compltion-map.gif"
    alt=""  />
</p>
</p>
<p><strong>智能代码补全</strong>建议使用指向结构的指针。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/code-completion-for-pointer-to-struct-initializer.gif"
    alt=""  />
</p>
</p>
<p>最终，代码补全变得更加智能，现在在断言和 type-switch-case 中会首先建议兼容类型。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/type-assertion-completion.gif"
    alt=""  />
</p>
</p>
<h2 id="代码编辑增强">代码编辑增强</h2>
<p>当编写多值返回函数的签名时，GoLang 2020.1 将在逗号后面的返回类型周围自动添加括号。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/multi-value-return-function.gif"
    alt=""  />
</p>
</p>
<p>此外，当您在字符串中粘贴一些文本时，GoLand 会自动转义双引号。</p>
<h2 id="postfix-完成模板">Postfix 完成模板</h2>
<p><code>.else</code> Postfix 完成模板可以快速添加 <code>if</code> 语句，以检查表达式是否为假。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/else-postfix-completion.gif"
    alt=""  />
</p>
</p>
<h2 id="实时模板">实时模板</h2>
<p>我们添加了新的 <em>consts</em>, <em>vars</em>, <em>types</em>, 和 <em>import</em> 模板 。对于这些模板，默认情况下，GoLand 将在表达式周围添加括号。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/consts-vars-live-templates.gif"
    alt=""  />
</p>
</p>
<p>fori 模板插入经典 for 循环的样板代码。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/fori-live-template.gif"
    alt=""  />
</p>
</p>
<h2 id="重构">重构</h2>
<p>现在，即使接口定义中省略了参数名称，<em>Implement Methods</em>（在 macOS 和 Windows/Linux 上为 Ctrl + I）也允许您指定参数名称。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/implement-methods.gif"
    alt=""  />
</p>
</p>
<h2 id="性能">性能</h2>
<p>现在 <em>Navigate to implementations</em>（在 MacOS 上为 ⌥⌘B，在 Windows/Linux 上为 Ctrl + Alt + B）和 <em>Navigate to Declaration or Usages</em>（在 macOS 上为 ⌘B，在 Windows/Linux 上为 Ctrl + B）速度更快，因为它们首先在项目范围内寻找实现。另外，搜索结果在非项目元素之前显示项目元素，而不是按字母顺序对它们进行排序。</p>
<p>我们还限制了 dep 和 Go Modules 项目的参考搜索范围，以提高其搜索性能。</p>
<h2 id="jetbrains-mono-字体">JetBrains Mono 字体</h2>
<p>如果您想知道本博客文章中的屏幕截图和 GIF 使用的是哪种字体 — 我们在 JetBrains 上为开发人员创建了一种新的字体，称为 <a href="https://www.jetbrains.com/lp/mono/" target="_blank" rel="noopener">JetBrains Mono</a>
。现在默认情况下它在 GoLand 中可用，请打开 <em>Preferences / Settings | Editor | Font</em>，然后选择 JetBrains Mono 尝试一下。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/jetbrains-mono-font.png"
    alt=""  />
</p>
</p>
<h2 id="拼写检查器">拼写检查器</h2>
<p>前一段时间，我们宣布了一个名为 Grazie 的插件。此插件可为您在 IDE 中编写的文本提供智能的拼写和语法检查，并且支持 15 种以上的语言，包括英语，德语，俄语，中文等。在此 EAP 版本和即将发布的 2020.1 版本中，默认情况下捆绑了 Grazie。要了解更多信息，请阅读此<a href="https://blog.jetbrains.com/idea/2019/11/meet-grazie-the-ultimate-spelling-grammar-and-style-checker-for-intellij-idea/" target="_blank" rel="noopener">博客文章</a>
。</p>
<h2 id="默认配色方案改回为亮色">默认配色方案改回为亮色</h2>
<p>许多用户要求我们为 Default 和 Darcula 配色方案中突出显示的语义代码增加更多种类，而我们在 2019.2 版本中进行了添加。一些用户很高兴，而其他用户则不满意，请我们还原更改。</p>
<p>因此，为了使所有人感到高兴，我们决定恢复默认配色方案，但使用了新名称 Classic Light。</p>
<p>要切换配色方案，请打开 <em>Preferences/Settings | Editor | Color Scheme</em> 选择。</p>
<h2 id="jbr8-支持终止">JBR8 支持终止</h2>
<p>从现在开始，我们将完全转向 JetBrains Runtime 11（JBR11），并且将不再分发带有 JetBrains Runtime 8（JBR8）的内部版本。请注意，IDE 和工具箱应用程序中的所有 GoLand 2020.1 更新都将随附 JBR11。</p>
<p>请记住，我们始终感谢您的反馈，因此请在留言区，Twitter 或 <a href="https://youtrack.jetbrains.com/issues/GO" target="_blank" rel="noopener">issue tracker</a>
 中与我们分享您的试用情况。</p>
<blockquote>
<p>由 Ekaterina Zharova 在 2020 年 2 月 6 日发布</p>
<p>原文：https://blog.jetbrains.com/go/2020/02/06/welcome-to-the-goland-2020-1-eap/</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——基础篇3：通过一个例子串联各特性</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/basic03-example/</link>
			<pubDate>Tue, 03 Dec 2019 20:31:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/basic03-example/</guid>
			<description>通过前面的介绍，相信对 echo 有了一个初步的认识。本文我们通过一个简单的登录页面来串联 echo 的相关特性。因为该文主要关注各个特性，所以在目录结构和代码</description>
			<content type="html"><![CDATA[<p>通过前面的介绍，相信对 echo 有了一个初步的认识。本文我们通过一个简单的登录页面来串联 echo 的相关特性。因为该文主要关注各个特性，所以在目录结构和代码组织方面很随意。</p>
<h2 id="本节最终效果">本节最终效果</h2>
<p>1）登录页面</p>
<p><p class="md__image">
  <img src="../imgs/login.png"
    alt=""  />
</p>
</p>
<p>2）登录失败</p>
<p><p class="md__image">
  <img src="../imgs/login-fail.png"
    alt=""  />
</p>
</p>
<p>3）登录成功</p>
<p><p class="md__image">
  <img src="../imgs/login-success.png"
    alt=""  />
</p>
</p>
<h2 id="main-函数骨架">main 函数骨架</h2>
<p>使用 echo 框架，在程序入口处一般包含如下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 创建 echo 实例
</span><span class="c1"></span>	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="c1">// 配置日志
</span><span class="c1"></span>	<span class="nf">configLogger</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>

	<span class="c1">// 注册静态文件路由
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nf">Static</span><span class="p">(</span><span class="s">&#34;img&#34;</span><span class="p">,</span> <span class="s">&#34;img&#34;</span><span class="p">)</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">File</span><span class="p">(</span><span class="s">&#34;/favicon.ico&#34;</span><span class="p">,</span> <span class="s">&#34;img/favicon.ico&#34;</span><span class="p">)</span>

	<span class="c1">// 设置中间件
</span><span class="c1"></span>	<span class="nf">setMiddleware</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>

	<span class="c1">// 注册路由
</span><span class="c1"></span>	<span class="nf">RegisterRoutes</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>

	<span class="c1">// 启动服务
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2019&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h2 id="日志">日志</h2>
<p>echo 中定义了一个接口：<a href="https://pkg.go.dev/github.com/labstack/echo?tab=doc#Logger" target="_blank" rel="noopener">Logger</a>
，而 <a href="https://pkg.go.dev/github.com/labstack/echo?tab=doc#Echo" target="_blank" rel="noopener">Echo 结构体</a>
有一个该接口的字段，这也就是 main 函数最后一句：<code>e.Logger.Fatal</code> 可以这么用的原因。框架中该接口的具体实现使用的是 <code>github.com/labstack/gommon/log</code>，如果需要，我们可以采用自己的实现，替换框架默认的。</p>
<p>默认情况下，日志输出到终端，而且 Level 级别是 ERROR，我们可以方便的通过 Logger 接口提供的方法进行修改：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">configLogger</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">echo</span><span class="p">.</span><span class="nx">Echo</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 定义日志级别
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">INFO</span><span class="p">)</span>
	<span class="c1">// 记录业务日志
</span><span class="c1"></span>	<span class="nx">echoLog</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;log/echo.log&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_APPEND</span><span class="p">,</span> <span class="mo">0644</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 同时输出到文件和终端
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetOutput</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nf">MultiWriter</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">echoLog</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>为了方便，开发中我将日志同时输出到了终端和文件中。</p>
<h2 id="中间件">中间件</h2>
<p>几乎所有的 Web 框架都支持中间件。其实这里的中间件跟传统的中间件不是一回事，这里的中间件其实是一种装饰模式。闲言少叙，我们看看 Echo 的中间件。</p>
<p>以 Recover 中间件为例讲解。</p>
<h3 id="中间件标准签名">中间件标准签名</h3>
<p>通过 <code>Echo.Use</code> 方法知晓，中间件是 MiddlewareFunc 类型，它的定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MiddlewareFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span>
</code></pre></div><p>也就是说，一个中间件应该是 MiddlewareFunc 类型。所以，一个函数，只要返回 MiddlewareFunc 类型就是一个 Echo 中间件。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Recover</span><span class="p">()</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">MiddlewareFunc</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h3 id="支持配置的中间件">支持配置的中间件</h3>
<p>Echo 的中间件通常都支持以下功能：</p>
<ul>
<li>通过配置修改中间件的行为</li>
<li>可以选择是否跳过该中间件</li>
</ul>
<p>一般做法就是：</p>
<ul>
<li>定义一个类型，如：RecoverConfig，用于配置 Recover 中间件的行为；</li>
<li>给上述类型的一个默认实例：DefaultRecoverConfig；</li>
<li>定义一个支持传递配置的函数，返回中间件类型，如：RecoverWithConfig；</li>
<li>定义一个不带参数的函数，返回中间件类型，内部调用带参数的中间件函数，参数用默认实例，如：Recover，它的实现是直接调用 <code>RecoverWithConfig(DefaultRecoverConfig)</code>；</li>
</ul>
<p>我们的例子代码中就通过配置修改了中间件行为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// access log 输出到文件中
</span><span class="c1"></span>	<span class="nx">accessLog</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;log/access.log&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_APPEND</span><span class="p">,</span> <span class="mo">0644</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 同时输出到终端和文件
</span><span class="c1"></span>	<span class="nx">middleware</span><span class="p">.</span><span class="nx">DefaultLoggerConfig</span><span class="p">.</span><span class="nx">Output</span> <span class="p">=</span> <span class="nx">accessLog</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Logger</span><span class="p">())</span>
</code></pre></div><h3 id="自己定义一个简单中间件">自己定义一个简单中间件</h3>
<p>很多时候，我们业务的中间件，不需要那么灵活，没必要通过配置来控制行为，这时候可以像例子中的 AutoLogin 一样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AutoLogin 如果上次记住了，则自动登录
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AutoLogin</span><span class="p">(</span><span class="nx">next</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">cookie</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Cookie</span><span class="p">(</span><span class="s">&#34;username&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cookie</span><span class="p">.</span><span class="nx">Value</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="c1">// 实际项目这里可以通过 username 读库获取用户信息
</span><span class="c1"></span>			<span class="nx">user</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span><span class="nx">Username</span><span class="p">:</span> <span class="nx">cookie</span><span class="p">.</span><span class="nx">Value</span><span class="p">}</span>

			<span class="c1">// 放入 context 中
</span><span class="c1"></span>			<span class="nx">ctx</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;user&#34;</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nf">next</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>接收一个 echo.HandlerFunc 类型，同时返回一个 echo.HandlerFunc 类型，这就是 MiddlewareFunc 的定义，因此 AutoLogin 可以直接当中间件使用。<strong>注意：在使用是这里和上面 Recover 的区别，Recover 是返回一个中间件，而 AutoLogin 本身是一个中间件，因此使用时分别是：Use(Recover()) 和 Use(AutoLogin)</strong>。</p>
<p>在具体实现中间件时，可以在调用 <code>next()</code> 函数前后增加该中间件需要的功能。</p>
<h2 id="cookie-和-session">Cookie 和 Session</h2>
<p>关于 Cookie、Session 和 Token 的介绍，可以通过 <a href="https://cloud.tencent.com/developer/article/1542456" target="_blank" rel="noopener">《一文带您彻底理解Cookie、Session、Token》</a>
 了解下。</p>
<p>在 Go 中，Session 相关功能最常用的包是 <code>github.com/gorilla/sessions</code>。Echo 提供了 Session 中间件，使用的就是该包。这里我们主要讲解一下登录需要用到的功能。</p>
<h3 id="登录成功种-cookie">登录成功种 Cookie</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 用标准库种 cookie
</span><span class="c1"></span><span class="nx">cookie</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Cookie</span><span class="p">{</span>
  <span class="nx">Name</span><span class="p">:</span>     <span class="s">&#34;username&#34;</span><span class="p">,</span>
  <span class="nx">Value</span><span class="p">:</span>    <span class="nx">username</span><span class="p">,</span>
  <span class="nx">HttpOnly</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">rememberMe</span> <span class="o">==</span> <span class="s">&#34;1&#34;</span> <span class="p">{</span>
  <span class="nx">cookie</span><span class="p">.</span><span class="nx">MaxAge</span> <span class="p">=</span> <span class="mi">7</span><span class="o">*</span><span class="mi">24</span><span class="o">*</span><span class="mi">3600</span>	<span class="c1">// 7 天
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">SetCookie</span><span class="p">(</span><span class="nx">cookie</span><span class="p">)</span>
</code></pre></div><p>我们这里直接使用了标准库的方式实现，而不是使用 ``github.com/gorilla/sessions` 包。默认情况下，浏览器关闭，cookie 删除，当“记住我”，保存 7 天。这里留一个问题：<strong>cookie.Expires 和 cookie.MaxAge 的区别？</strong></p>
<h3 id="重定向保留用户名">重定向保留用户名</h3>
<p>在登录失败后，为了避免用户再次输入用户名，这里借用 <code>github.com/gorilla/sessions</code> 包的 Flash Message 功能。</p>
<p><code>github.com/gorilla/sessions</code> 实现了 Cookie 和文件系统 Session，默认情况下，使用 Cookie。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sess</span> <span class="o">:=</span> <span class="nf">getCookieSession</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="nx">sess</span><span class="p">.</span><span class="nf">AddFlash</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="s">&#34;username&#34;</span><span class="p">)</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">sess</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">(),</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Response</span><span class="p">())</span>
</code></pre></div><p>在读 Flash Message 的地方，一定要注意，需要再次执行 session.Save：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sess</span> <span class="o">:=</span> <span class="nf">getCookieSession</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">flashes</span> <span class="o">:=</span> <span class="nx">sess</span><span class="p">.</span><span class="nf">Flashes</span><span class="p">(</span><span class="s">&#34;username&#34;</span><span class="p">);</span> <span class="nb">len</span><span class="p">(</span><span class="nx">flashes</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">[</span><span class="s">&#34;username&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">flashes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">sess</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">(),</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Response</span><span class="p">())</span>
</code></pre></div><h2 id="总结">总结</h2>
<p>一个简单的登录，涉及到的知识点还是不少的，但依然有不少 Echo 框架的功能没包括。后面我们会介绍更多 Echo 的特性和功能，这个简单的例子，希望能够让你对 Echo 更有感觉。</p>
<p>完整示例代码：<a href="https://github.com/polaris1119/echo-login-example">https://github.com/polaris1119/echo-login-example</a></p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——基础篇2：Echo 核心亮点介绍</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/basic02-feature/</link>
			<pubDate>Mon, 28 Oct 2019 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/basic02-feature/</guid>
			<description>在 Echo 的官网的首页，列出了 9 个核心功能或亮点。我这里将它说成是亮点（也许并不一定都比其他框架更好）。 一、优化的路由 高度优化的 HTTP 路由，动态内存分</description>
			<content type="html"><![CDATA[<p>在 Echo 的官网的首页，列出了 9 个核心功能或亮点。我这里将它说成是亮点（也许并不一定都比其他框架更好）。</p>
<h2 id="一优化的路由">一、优化的路由</h2>
<p><strong>高度优化的 HTTP 路由，动态内存分配为零，可对路由进行优先级排序。</strong></p>
<p>这一点从上一篇：[搭建 Echo 开发环境](基础篇：搭建 Echo 开发环境.md) 可以看到。</p>
<p>Echo 路由基于 <a href="http://en.wikipedia.org/wiki/Radix_tree" target="_blank" rel="noopener">radix tree</a>
 ，查询速度非常快。路由使用 <a href="https://docs.studygolang.com/pkg/sync/#Pool" target="_blank" rel="noopener">sync pool</a>
 来重用内存，实现无 GC 开销下的零动态内存分配。</p>
<h3 id="路由的注册和使用方式">路由的注册和使用方式</h3>
<p>各大框架路由的注册和使用方式都类似，通过 HTTP 方法（GET、POST、PUT、DELETE 等），将 url 路径和一个处理程序绑定在一起，唯一不太一样的一般是处理程序的函数签名不一样（主要参数类型不一样）。例如，下面的代码则展示了一个注册路由的例子：它包括 <code>GET</code> 的访问方式， <code>/hello</code> 的访问路径，以及发送 <code>Hello World</code> HTTP 响应的处理程序。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 业务处理
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">hello</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 路由
</span><span class="c1"></span><span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/hello&#34;</span><span class="p">,</span> <span class="nx">hello</span><span class="p">)</span>
</code></pre></div><p>更多路由的特性，参考文档：<a href="https://echo.labstack.com/guide/routing/">https://echo.labstack.com/guide/routing/</a>（英文）、 <a href="https://www.bookstack.cn/read/echo-v3-zh/guide-routing.md">https://www.bookstack.cn/read/echo-v3-zh/guide-routing.md</a> （中文）。（上篇贴的中文文档打不开了。注意，中文文档基于 V3，而不是 V4）</p>
<h2 id="二scalable">二、Scalable</h2>
<p>Echo 方便构建健壮的 RESTful API，轻松将其组织起来。</p>
<p>根据上一节路由，我们可以轻松构建出 RESTful API，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/user&#34;</span><span class="p">,</span> <span class="nx">createUser</span><span class="p">)</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/user/1&#34;</span><span class="p">,</span> <span class="nx">findUser</span><span class="p">)</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">PUT</span><span class="p">(</span><span class="s">&#34;/user/1&#34;</span><span class="p">,</span> <span class="nx">updateUser</span><span class="p">)</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">DELETE</span><span class="p">(</span><span class="s">&#34;/user/1&#34;</span><span class="p">,</span> <span class="nx">deleteUser</span><span class="p">)</span>
</code></pre></div><p>可以轻松对应上 RESTful API 的标准。</p>
<h2 id="三自动-tls">三、自动 TLS</h2>
<p>Echo 能够通过 “Let&rsquo;s Encrypt” 自动安装 TLS 证书。<code>Echo#StartAutoTLS</code> 接受一个接听 443 端口的网络地址。类似 <code>:443</code> 这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">StartAutoTLS</span><span class="p">(</span><span class="s">&#34;:443&#34;</span><span class="p">)</span>
</code></pre></div><p>可以通过 <code>e.AutoTLSManager</code> 做一些控制，比如缓存等。</p>
<h2 id="四http2">四、HTTP/2</h2>
<p>Echo 自动支持 HTTP/2。HTTP/2 (原本的名字是 HTTP/2.0) 是万维网使用的 HTTP 网络协议的第二个主要版本。HTTP/2 提供了更快的速度和更好的用户体验。</p>
<h3 id="特性">特性</h3>
<ul>
<li>使用二进制格式传输数据，而不是文本。使得在解析和优化扩展上更为方便。</li>
<li>多路复用，所有的请求都是通过一个 TCP 连接并发完成。</li>
<li>对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。</li>
<li>Server Push：服务端能够更快的把资源推送给客户端。</li>
</ul>
<h2 id="五中间件">五、中间件</h2>
<p>这是让 Echo 可扩展、功能强大、好用的关键组件。</p>
<p>中间件是一个函数，嵌入在 HTTP 的请求和响应之间。它可以获得 <code>Echo#Context</code> 对象用来进行一些特殊的操作， 比如记录每个请求或者统计请求数。</p>
<h3 id="不同级别的中间件">不同级别的中间件</h3>
<h4 id="1根级别中间件router-之前">1、根级别中间件（router 之前）</h4>
<p><code>Echo#Pre()</code> 用于注册一个在路由执行之前运行的中间件，可以用来修改请求的一些属性。比如在请求路径结尾添加或者删除一个 <code>/</code> 来使之能与路由匹配。</p>
<p>下面的这几个内建中间件应该被注册在这一级别：</p>
<ul>
<li>AddTrailingSlash</li>
<li>RemoveTrailingSlash</li>
<li>MethodOverride</li>
</ul>
<p><em>注意</em>: 由于在这个级别路由还没有执行，所以这个级别的中间件不能调用任何 <code>echo.Context</code> 的 API。</p>
<h4 id="2根级别中间件router-之后">2、根级别中间件（router 之后）</h4>
<p>大部分时间你将用到 <code>Echo#Use()</code> 在这个级别注册中间件。 这个级别的中间件运行在路由处理完请求之后，可以调用所有的 <code>echo.Context</code> API。</p>
<p>下面的这几个内建中间件应该被注册在这一级别：</p>
<ul>
<li>BodyLimit</li>
<li>Logger</li>
<li>Gzip</li>
<li>Recover</li>
<li>BasicAuth</li>
<li>JWTAuth</li>
<li>Secure</li>
<li>CORS</li>
<li>Static</li>
</ul>
<h4 id="3组级别中间件">3、组级别中间件</h4>
<p>当在路由中创建一个组的时候，可以为这个组注册一个中间件。例如，给 admin 这个组注册一个 BasicAuth 中间件。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">admin</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/admin&#34;</span><span class="p">,</span> <span class="nx">middleware</span><span class="p">.</span><span class="nf">BasicAuth</span><span class="p">())</span>
</code></pre></div><p>也可以在创建组之后用 <code>admin.Use()</code>注册该中间件。</p>
<h4 id="4路由级别中间件">4、路由级别中间件</h4>
<p>当你创建了一个新的路由，可以选择性的给这个路由注册一个中间件。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="p">&lt;</span><span class="nx">Handler</span><span class="p">&gt;,</span> <span class="p">&lt;</span><span class="nx">Middleware</span><span class="o">...</span><span class="p">&gt;)</span>
</code></pre></div><h2 id="六数据绑定">六、数据绑定</h2>
<p>HTTP 请求有效负载的数据绑定，包括 JSON，XML 或表单数据。</p>
<p>可以使用 <code>Context#Bind(i interface{})</code> 将请求内容体绑定至 go 的结构体。默认绑定器支持基于 <code>Content-Type</code>  请求头包含 application/json，application/xml 和 application/x-www-form-urlencoded 的数据。</p>
<p>下面是绑定请求数据到 <code>User</code> 结构体的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// User
</span><span class="c1"></span><span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`json:&#34;name&#34; form:&#34;name&#34; query:&#34;name&#34;`</span>
  <span class="nx">Email</span> <span class="kt">string</span> <span class="s">`json:&#34;email&#34; form:&#34;email&#34; query:&#34;email&#34;`</span>
<span class="p">}</span>

<span class="c1">// Handler
</span><span class="c1"></span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">u</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">User</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">u</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">u</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>以上代码支持如下请求数据的绑定：</p>
<p>1、JSON 数据</p>
<pre><code>curl \
  -X POST \
  http://localhost:1323/users \
  -H 'Content-Type: application/json' \
  -d '{&quot;name&quot;:&quot;Joe&quot;,&quot;email&quot;:&quot;joe@labstack&quot;}'
</code></pre><p>2、Form 表单数据</p>
<pre><code>curl \
  -X POST \
  http://localhost:1323/users \
  -d 'name=Joe' \
  -d 'email=joe@labstack.com'
</code></pre><p>3、查询参数 (Query Parameters)</p>
<pre><code>curl \
  -X GET \
  http://localhost:1323/users\?name\=Joe\&amp;email\=joe@labstack.com
</code></pre><h2 id="七数据呈现">七、数据呈现</h2>
<p>有发送各种 HTTP 响应的 API，包括 JSON，XML，HTML，文件，附件，内联，流或 Blob。</p>
<h2 id="八模板">八、模板</h2>
<p>支持使用任何模板引擎进行模板渲染。</p>
<p>使用 <code>Context#Render(code int, name string, data interface{}) error</code> 命令渲染带有数据的模板，并发送带有状态代码的 <code>text/html</code> 响应。通过 <code>Echo.Renderer</code> 的设置我们可以使用任何模板引擎。</p>
<h2 id="九可扩展extensible">九、可扩展（Extensible）</h2>
<p>拥有可定制的集中 HTTP 错误处理和易于扩展的 API 等。</p>
<h2 id="总结">总结</h2>
<p>以上是 Echo 首页给出的 9 大核心亮点，后续教程会给出详细的讲解或实际例子。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——基础篇1：搭建 Echo 开发环境</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/basic01-env/</link>
			<pubDate>Mon, 21 Oct 2019 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/basic01-env/</guid>
			<description>工欲善其事必先利其器。我们先搞定 Echo 环境。 Go 开发环境 这个系列基于 Go1.14.4，Linux 系统。 安装 Go 的方式有很多，可以在这里 https://studygolang.com/dl 下载对应操作</description>
			<content type="html"><![CDATA[<p>工欲善其事必先利其器。我们先搞定 Echo 环境。</p>
<h2 id="go-开发环境">Go 开发环境</h2>
<p>这个系列基于 Go1.14.4，Linux 系统。</p>
<p>安装 Go 的方式有很多，可以在这里 <a href="https://studygolang.com/dl">https://studygolang.com/dl</a> 下载对应操作系统的版本。我自己比较喜欢通过源码安装。我将我的方式告诉大家。（Windows 环境比较建议直接下载对应的包进行安装 <a href="https://studygolang.com/dl/golang/go1.14.4.windows-amd64.msi">https://studygolang.com/dl/golang/go1.14.4.windows-amd64.msi</a>）</p>
<h3 id="下载源码">下载源码</h3>
<p>在你本地某个目录（比如 $HOME/golang），执行如下命令（确保安装了 git）：</p>
<blockquote>
<p>git clone <a href="https://github.com/golang/go">https://github.com/golang/go</a></p>
</blockquote>
<p>因为 Go 自从 1.5 开始实现了自举，因此要从源码安装 1.5 或以后的版本，必须先有 Go 环境，也就是必须有 Go1.4 或以下版本，这里我们安装 Go1.4。</p>
<h4 id="安装-go14">安装 Go1.4</h4>
<p>执行如下命令进行安装：（需要有 root 权限）</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git checkout -b release-branch.go1.4 origin/release-branch.go1.4
$ sudo cp -rf ../go /root/go1.4
$ sudo -s
$ <span class="nb">cd</span> /root/go1.4/src
$ ./make.bash
</code></pre></div><p>验证下 Go1.4 是否安装成功：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ /root/go1.4/bin/go version
</code></pre></div><p>如果输出版本信息表示成功！</p>
<h3 id="安装-go1144">安装 Go1.14.4</h3>
<p>接下来我们安装 Go1.14.4：（<code>ctrl + d</code> 切换回原用户）</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/golang/go
$ git checkout -b release-branch.go1.14 origin/release-branch.go1.14
$ sudo cp -rf ../go /usr/local/go1.14
$ <span class="nb">cd</span> /usr/local/go1.14/src
$ sudo ./make.bash
</code></pre></div><p>然后我们加上一个软链，这样以后升级版本后，只需要重新设置软链即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo ln -s /usr/local/go1.14 /usr/local/go
</code></pre></div><h3 id="配置-go-环境">配置 Go 环境</h3>
<p>最后，将 Go 加入 PATH 中，Linux 中可以在 <code>/etc/bashrc</code> 文件最后加上 <code>export PATH=$PATH:/usr/local/go/bin</code>。</p>
<p>MacOS 中可以在 <code>~/.bash_profile</code> 中加上这行配置。</p>
<p>Windows 下的环境变量配置请自行查找解决，实在有问题可以咨询我！</p>
<p>之后，打开新的 shell，执行 <code>go env</code> 可以看到类似如下的输出（Linux 下）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">GO111MODULE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOARCH</span><span class="o">=</span><span class="s2">&#34;amd64&#34;</span>
<span class="nv">GOBIN</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOCACHE</span><span class="o">=</span><span class="s2">&#34;/home/xuxinhua/.cache/go-build&#34;</span>
<span class="nv">GOENV</span><span class="o">=</span><span class="s2">&#34;/home/xuxinhua/.config/go/env&#34;</span>
<span class="nv">GOEXE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOFLAGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOHOSTARCH</span><span class="o">=</span><span class="s2">&#34;amd64&#34;</span>
<span class="nv">GOHOSTOS</span><span class="o">=</span><span class="s2">&#34;linux&#34;</span>
<span class="nv">GONOPROXY</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GONOSUMDB</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOOS</span><span class="o">=</span><span class="s2">&#34;linux&#34;</span>
<span class="nv">GOPATH</span><span class="o">=</span><span class="s2">&#34;/home/xuxinhua/go&#34;</span>
<span class="nv">GOPRIVATE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOPROXY</span><span class="o">=</span><span class="s2">&#34;https://proxy.golang.org,direct&#34;</span>
<span class="nv">GOROOT</span><span class="o">=</span><span class="s2">&#34;/usr/local/go1.14&#34;</span>
<span class="nv">GOSUMDB</span><span class="o">=</span><span class="s2">&#34;sum.golang.org&#34;</span>
<span class="nv">GOTMPDIR</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOTOOLDIR</span><span class="o">=</span><span class="s2">&#34;/usr/local/go1.14/pkg/tool/linux_amd64&#34;</span>
<span class="nv">GCCGO</span><span class="o">=</span><span class="s2">&#34;gccgo&#34;</span>
<span class="nv">AR</span><span class="o">=</span><span class="s2">&#34;ar&#34;</span>
<span class="nv">CC</span><span class="o">=</span><span class="s2">&#34;gcc&#34;</span>
<span class="nv">CXX</span><span class="o">=</span><span class="s2">&#34;g++&#34;</span>
<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="s2">&#34;1&#34;</span>
<span class="nv">GOMOD</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">CGO_CFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_CPPFLAGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">CGO_CXXFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_FFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_LDFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">PKG_CONFIG</span><span class="o">=</span><span class="s2">&#34;pkg-config&#34;</span>
<span class="nv">GOGCCFLAGS</span><span class="o">=</span><span class="s2">&#34;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build537145581=/tmp/go-build -gno-record-gcc-switches&#34;</span>
</code></pre></div><p>为了后续使用的顺畅，我们配置上 goproxy：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">go env -w <span class="nv">GOPROXY</span><span class="o">=</span>https://goproxy.cn,direct
</code></pre></div><p>自此，我们的 Go 环境就搞定了！</p>
<h4 id="升级-go-版本">升级 Go 版本</h4>
<p>后续如果要升级 Go，分两种情况。</p>
<p>1）升级到 Go1.14.x，执行如下操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/golang/go
$ git pull
$ sudo rm -rf /usr/local/go1.14
$ sudo cp -rf ../go /usr/local/go1.14
$ <span class="nb">cd</span> /usr/local/go1.14/src
$ ./make.bash
</code></pre></div><p>2）将来升级到 Go1.15 及后续版本，执行类似如下操作（注意改分支信息和目录）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/golang/go
$ git pull
$ git checkout -b release-branch.go1.15 origin/release-branch.go1.15
$ sudo cp -rf ../go /usr/local/go1.15
$ <span class="nb">cd</span> /usr/local/go1.15/src
$ ./make.bash
$ ln -s /usr/local/go1.15 /usr/local/go
</code></pre></div><p>这样就搞定了！</p>
<p>另外，如果感兴趣也可以使用类似 <a href="https://github.com/moovweb/gvm" target="_blank" rel="noopener">gvm</a>
 这样的工具进行 Go 版本管理和切换。</p>
<h2 id="开始-echo">开始 Echo</h2>
<blockquote>
<p>官方文档：https://echo.labstack.com/guide</p>
<p>中文翻译版：http://go-echo.org/</p>
</blockquote>
<p>是什么？</p>
<blockquote>
<p>High performance, extensible, minimalist Go web framework</p>
</blockquote>
<p>Echo 是一个高性能、可扩展、极简的 Go Web 框架。</p>
<h3 id="hello-world">Hello World</h3>
<p>所有的练习都在 <code>~/project/golang/studyecho</code> 下进行。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ mkdir -p ~/project/golang/studyecho
$ <span class="nb">cd</span> ~/project/golang/studyecho
</code></pre></div><p>接着初始化项目：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ go mod init studyecho
</code></pre></div><p>这会在当前目录生成 go.mod 文件，内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">module studyecho

go 1.14
</code></pre></div><p>安装 echo（我们使用 4.x.x）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ go get -u github.com/labstack/echo/v4
</code></pre></div><p>这会在当前目录生成 <code>go.sum</code> 文件，同时修改 <code>go.mod</code> 文件。如果你对 Go module 不熟悉，建议阅读 <a href="https://studygolang.com/articles/19334" target="_blank" rel="noopener">Go Modules 的使用方法 —— Go 官方博文</a>
。</p>
<p>创建文件 main.go：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="c1">// 注意这里的路径
</span><span class="c1"></span>	<span class="nx">echo</span> <span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 得到一个 echo.Echo 的实例
</span><span class="c1"></span>	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
  <span class="c1">// 注册路由
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
	<span class="p">})</span>
  <span class="c1">// 开启 HTTP Server
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>启动服务：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ go run main.go
</code></pre></div><p>终端输出：</p>
<p><p class="md__image">
  <img src="../imgs/terminal.png"
    alt=""  />
</p>
</p>
<p>打开浏览器，输入：http://localhost:2020 你会看到：Hello, World!</p>
<p>本节完~</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——Go 语言 Web 框架 Echo 系列教程</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/echo/</link>
			<pubDate>Mon, 21 Oct 2019 13:42:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/echo/</guid>
			<description>大家好，从今天起，我们一起来学习 Echo 框架。 这几年，随着 Go 语言的发展，各种 Web 框架也出现了。常言道：没有选择是一种无奈，有选择是一种痛苦。所以，大</description>
			<content type="html"><![CDATA[<p>大家好，从今天起，我们一起来学习 Echo 框架。</p>
<p>这几年，随着 Go 语言的发展，各种 Web 框架也出现了。常言道：没有选择是一种无奈，有选择是一种痛苦。所以，大家总是问：Web 框架大佬推荐哪个？</p>
<p>这一年，国内推荐 Gin 的人很多，也让 Gin 的 Star 数增加到了 32k+（2019-10-17），网络上 Gin 相关的教程也很多。总体来说，Gin、Echo 等都比较轻量，易用性也差距不大，而 Gin 最大的一个优势是直接使用了 <a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">httprouter</a>
，因此性能很高，从 Gin 项目中的 Benchmark 表格可以看出：</p>
<table>
<thead>
<tr>
<th>Benchmark name</th>
<th style="text-align:right">(1)</th>
<th style="text-align:right">(2)</th>
<th style="text-align:right">(3)</th>
<th style="text-align:right">(4)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>BenchmarkGin_GithubAll</strong></td>
<td style="text-align:right"><strong>30000</strong></td>
<td style="text-align:right"><strong>48375</strong></td>
<td style="text-align:right"><strong>0</strong></td>
<td style="text-align:right"><strong>0</strong></td>
</tr>
<tr>
<td>BenchmarkAce_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">134059</td>
<td style="text-align:right">13792</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkBear_GithubAll</td>
<td style="text-align:right">5000</td>
<td style="text-align:right">534445</td>
<td style="text-align:right">86448</td>
<td style="text-align:right">943</td>
</tr>
<tr>
<td>BenchmarkBeego_GithubAll</td>
<td style="text-align:right">3000</td>
<td style="text-align:right">592444</td>
<td style="text-align:right">74705</td>
<td style="text-align:right">812</td>
</tr>
<tr>
<td>BenchmarkBone_GithubAll</td>
<td style="text-align:right">200</td>
<td style="text-align:right">6957308</td>
<td style="text-align:right">698784</td>
<td style="text-align:right">8453</td>
</tr>
<tr>
<td>BenchmarkDenco_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">158819</td>
<td style="text-align:right">20224</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkEcho_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">154700</td>
<td style="text-align:right">6496</td>
<td style="text-align:right">203</td>
</tr>
<tr>
<td>BenchmarkGocraftWeb_GithubAll</td>
<td style="text-align:right">3000</td>
<td style="text-align:right">570806</td>
<td style="text-align:right">131656</td>
<td style="text-align:right">1686</td>
</tr>
<tr>
<td>BenchmarkGoji_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">818034</td>
<td style="text-align:right">56112</td>
<td style="text-align:right">334</td>
</tr>
<tr>
<td>BenchmarkGojiv2_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">1213973</td>
<td style="text-align:right">274768</td>
<td style="text-align:right">3712</td>
</tr>
<tr>
<td>BenchmarkGoJsonRest_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">785796</td>
<td style="text-align:right">134371</td>
<td style="text-align:right">2737</td>
</tr>
<tr>
<td>BenchmarkGoRestful_GithubAll</td>
<td style="text-align:right">300</td>
<td style="text-align:right">5238188</td>
<td style="text-align:right">689672</td>
<td style="text-align:right">4519</td>
</tr>
<tr>
<td>BenchmarkGorillaMux_GithubAll</td>
<td style="text-align:right">100</td>
<td style="text-align:right">10257726</td>
<td style="text-align:right">211840</td>
<td style="text-align:right">2272</td>
</tr>
<tr>
<td>BenchmarkHttpRouter_GithubAll</td>
<td style="text-align:right">20000</td>
<td style="text-align:right">105414</td>
<td style="text-align:right">13792</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkHttpTreeMux_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">319934</td>
<td style="text-align:right">65856</td>
<td style="text-align:right">671</td>
</tr>
<tr>
<td>BenchmarkKocha_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">209442</td>
<td style="text-align:right">23304</td>
<td style="text-align:right">843</td>
</tr>
<tr>
<td>BenchmarkLARS_GithubAll</td>
<td style="text-align:right">20000</td>
<td style="text-align:right">62565</td>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
</tr>
<tr>
<td>BenchmarkMacaron_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">1161270</td>
<td style="text-align:right">204194</td>
<td style="text-align:right">2000</td>
</tr>
<tr>
<td>BenchmarkMartini_GithubAll</td>
<td style="text-align:right">200</td>
<td style="text-align:right">9991713</td>
<td style="text-align:right">226549</td>
<td style="text-align:right">2325</td>
</tr>
<tr>
<td>BenchmarkPat_GithubAll</td>
<td style="text-align:right">200</td>
<td style="text-align:right">5590793</td>
<td style="text-align:right">1499568</td>
<td style="text-align:right">27435</td>
</tr>
<tr>
<td>BenchmarkPossum_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">319768</td>
<td style="text-align:right">84448</td>
<td style="text-align:right">609</td>
</tr>
<tr>
<td>BenchmarkR2router_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">305134</td>
<td style="text-align:right">77328</td>
<td style="text-align:right">979</td>
</tr>
<tr>
<td>BenchmarkRivet_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">132134</td>
<td style="text-align:right">16272</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkTango_GithubAll</td>
<td style="text-align:right">3000</td>
<td style="text-align:right">552754</td>
<td style="text-align:right">63826</td>
<td style="text-align:right">1618</td>
</tr>
<tr>
<td>BenchmarkTigerTonic_GithubAll</td>
<td style="text-align:right">1000</td>
<td style="text-align:right">1439483</td>
<td style="text-align:right">239104</td>
<td style="text-align:right">5374</td>
</tr>
<tr>
<td>BenchmarkTraffic_GithubAll</td>
<td style="text-align:right">100</td>
<td style="text-align:right">11383067</td>
<td style="text-align:right">2659329</td>
<td style="text-align:right">21848</td>
</tr>
<tr>
<td>BenchmarkVulcan_GithubAll</td>
<td style="text-align:right">5000</td>
<td style="text-align:right">394253</td>
<td style="text-align:right">19894</td>
<td style="text-align:right">609</td>
</tr>
</tbody>
</table>
<ul>
<li>(1): Total Repetitions achieved in constant time, higher means more confident result</li>
<li>(2): Single Repetition Duration (ns/op), lower is better</li>
<li>(3): Heap Memory (B/op), lower is better</li>
<li>(4): Average Allocations per Repetition (allocs/op), lower is better</li>
</ul>
<p>然而我下载 Gin 上提供的测试代码，发现 Echo 性能更好（或至少不比 Gin 差），下面是和上面对应的在我本地的测试（MacOS 4核 8G），测试代码：<a href="https://github.com/julienschmidt/go-http-routing-benchmark">https://github.com/julienschmidt/go-http-routing-benchmark</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">BenchmarkEcho_GithubAll               	   35334	     <span class="m">34642</span> ns/op	       <span class="m">0</span> B/op	       <span class="m">0</span> allocs/op
BenchmarkGin_GithubAll                	   34724	     <span class="m">34696</span> ns/op	       <span class="m">0</span> B/op	       <span class="m">0</span> allocs/op
</code></pre></div><p>而且 Echo 上提供的测试结果也表明了这一点（我本地试验了，确实如此）：</p>
<p><p class="md__image">
  <img src="../imgs/benchmarks.png"
    alt=""  />
</p>
</p>
<h2 id="为什么是-echo">为什么是 Echo？</h2>
<p>截止 2019 年 10 月 20 日，Gin 的 Star 数高达 32k+，而 Echo 的 Star 数才 15k+，为什么不是选择讲解 Gin 而是 Echo？</p>
<p>我想理由有如下几个：</p>
<ol>
<li>Gin 的教程不少，但 Echo 教程不多；</li>
<li>Echo 1.x 时候，我就用在了 studygolang.com 上，现在更新到了 4.x，studygolang 也升级到了 Echo 最新版；</li>
<li>两者都是轻量级框架，而且性能不分伯仲，甚至 Echo 更胜一筹；</li>
<li>Gin 的 Star 数这么高，跟大家的推广很有关系；作为最早一批使用 Echo 的用户，我认为有必要推广下 Echo，好东西希望更多人学习、使用；</li>
</ol>
<h2 id="计划">计划</h2>
<p>本系列教程计划包含如下部分：</p>
<h3 id="一基础教程篇">一、基础教程篇</h3>
<p>讲解 Echo 的基础使用</p>
<h3 id="二定制篇">二、定制篇</h3>
<p>讲解如何定制或扩展 Echo</p>
<h3 id="三实战篇">三、实战篇</h3>
<p>通过一个项目讲解 Echo 的实战</p>
<h3 id="四源码学习篇">四、源码学习篇</h3>
<p>分析 Echo 的源码，了解它的设计，看看能领悟、学习到什么</p>
]]></content>
		</item>
		
	</channel>
</rss>
