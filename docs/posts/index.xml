<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>文章列表 on polarisxu</title>
		<link>https://polarisxu.studygolang.com/posts/</link>
		<description>Recent content in 文章列表 on polarisxu</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en</language>
		<copyright>本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可，转载请注明 polarisxu 和出处链接。</copyright>
		<lastBuildDate>Wed, 27 Jan 2021 10:20:00 +0800</lastBuildDate>
		<atom:link href="https://polarisxu.studygolang.com/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>百度终于重视码农了：专门为开发者准备的搜索</title>
			<link>https://polarisxu.studygolang.com/posts/talk/baidu-kaifa-search/</link>
			<pubDate>Wed, 27 Jan 2021 10:20:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/baidu-kaifa-search/</guid>
			<description>大家好，我是站长 polarisxu。 百度，这个国内最大的搜索引擎，大家对其是又爱又恨，特别是程序员。所以，有一些程序员会直接不用百度，甚至觉得程序员就不应该用百度，用百度是 low 的行为。 的确，百度在搜索技术相关的东西，会让人很抓狂。比如搜索世界上最好的语言 php： 我的天，全是广告。。。 反观谷歌： 第一个就是 PHP 官网。 据相关调研预测，到 2026 年国内编程教育覆盖人数也将超过</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>百度，这个国内最大的搜索引擎，大家对其是又爱又恨，特别是程序员。所以，有一些程序员会直接不用百度，甚至觉得程序员就不应该用百度，用百度是 low 的行为。</p>
<p>的确，百度在搜索技术相关的东西，会让人很抓狂。比如搜索世界上最好的语言 php：</p>
<p><p class="md__image">
  <img src="../imgs/baidu-php.png"
    alt=""  />
</p>
</p>
<p>我的天，全是广告。。。</p>
<p>反观谷歌：</p>
<p><p class="md__image">
  <img src="../imgs/google-php.png"
    alt=""  />
</p>
</p>
<p>第一个就是 PHP 官网。</p>
<p>据相关调研预测，到 2026 年国内编程教育覆盖人数也将超过 1 亿。如此庞大的用户群体，不能无视他们的搜索体验。终于，今天看到百度出了一个专门针对开发者的搜索引擎：<a href="https://kaifa.baidu.com">https://kaifa.baidu.com</a>。作为开发者，同时也是站长，我想谈谈自己的一些看法，欢迎交流。</p>
<p>首先，这是一个好消息，你看搜索 php 的结果：</p>
<p><p class="md__image">
  <img src="../imgs/kaifa-php.png"
    alt=""  />
</p>
</p>
<p>官网终于排在第一了，而且没有任何广告，至少现在没有。</p>
<p>在搜索结果的顶部，有「站点」、「语言」、「系统」三个筛选项，右侧有百科对应的词条，右下角是来自 gitee 平台的相关项目。隐约感觉，gitee 要大火？！</p>
<p>但是，细心的读者会发现，目前的版本存在一些局限，比如搜索结果固定来自几个站点：「博客园」、「CSDN」、「知乎」。。。而实际上很多个人独立技术博客的质量很高，这里却搜索不到，可见目前这个所谓的开发者搜索，只是简单的搜索这几个站点的内容。</p>
<p>此外，对于像 「Go语言中文网」 这样的站点来说，相当不友好，在 baidu.com 上搜索 golang，排除广告的话，它排第一，但在这个开发者搜索中却搜索不到它的任何内容。</p>
<p>当然，我相信这只是起步。以上的一些问题，特别是内容丰富性方面，只要百度用心，肯定可以做的更好：比如基于 AI 技术，分析出全网站点，哪些是技术类的，提升权重等。</p>
<p>如果这个搜索引擎真的做起来了，码农们都使用它，文中开头的哪些培训机构是不是不在百度投广告了？真有那一天，不知道百度能否顶住诱惑，像谷歌一样，有节制的展示广告。</p>
<p>不过，要做起来其实挺难的，虽然 PC 时代的搜索，搜狗也还好，360 也好，都没有对百度形成冲击，但现在头条搜索、微信搜索，它们在另一个维度上和百度竞争，对百度的冲击还是不小。</p>
<p>优质内容 + 好的体验，如果百度能做到，对于开发者这个人群来说，PC 搜索是更适合的，就看百度是否真要这部分市场了。</p>
]]></content>
		</item>
		
		<item>
			<title>微信 8.0 的这个功能和 Go 的 error 一样？</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/wechat-8.0/</link>
			<pubDate>Mon, 25 Jan 2021 11:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/wechat-8.0/</guid>
			<description>大家好，我是站长 polarisxu。 今天早上发了一个朋友圈，吐槽了一下微信 8.0 的一个功能，不少人有同感，其中一位朋友提到了 Go 的 error。 微信 8.0 通过好友请求时，仅聊天还是朋友圈，你必须选择一个。挺烦的。有一个朋友留言说：这就跟 err 一样，某些地方强迫你有意识的做选择，在这里就是强迫你对自己的隐私做选择。 Go 中的 error，社区的反应特别的激烈，喜欢的人夸，不喜欢的人</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天早上发了一个朋友圈，吐槽了一下微信 8.0 的一个功能，不少人有同感，其中一位朋友提到了 Go 的 error。</p>
<p><p class="md__image">
  <img src="../imgs/wechat8.0-01.png"
    alt=""  />
</p>
</p>
<ul>
<li>微信 8.0 通过好友请求时，仅聊天还是朋友圈，你必须选择一个。挺烦的。有一个朋友留言说：这就跟 err 一样，某些地方强迫你有意识的做选择，在这里就是强迫你对自己的隐私做选择。</li>
</ul>
<p>Go 中的 error，社区的反应特别的激烈，喜欢的人夸，不喜欢的人喷，出现了两级分化。就像这位朋友说的，Go 希望开发者明确知晓有可能有错误发生。Go 的初衷也许是好的，但这也导致了代码中经常出现这样的情况：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">x</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="nx">y</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">bar</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

<span class="nx">z</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">baz</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
<span class="o">...</span>
</code></pre></div><p>这样的代码必然会遭到很多人吐槽！据说 Go2.0 对错误处理会重新考虑，但 2.0 到现在也只是一个“概念”，虽知道哪天会来~</p>
<p>回到微信 8.0，虽然不是专业产品经理，对产品知识略晓皮毛，但作为用户还是想吐槽下。</p>
<p>微信 8.0 的发布，加上微信 10 周年公开课，网上各种解读、好评。这样的话也许大家也见过：</p>
<blockquote>
<p>我相信又有很多人要教龙哥做产品了。。。</p>
</blockquote>
<p>作为一个用户，我觉得不是教龙哥做产品，而是反馈下使用体验，不一定对，但却是真实使用感受！</p>
<p>读高中时经常调侃一句话：</p>
<blockquote>
<p>名人说的话是名言，凡人说的话是废话</p>
</blockquote>
<p>的确如此，人家之所以是名人，那是人家的本事，能成为名人必然有其不寻常之处。</p>
<p>达利欧在《原则》一书提到「可信度加权」：对那些能力更强的决策者的观点赋予更大的权重，给予更多的重视。大白话说就是成功的人士、成功的产品自带光环，做什么都很香，毕竟他们之前做的都很好，这次大概率做的也是很好的。听起来确实没毛病！</p>
<p>但马克思告诉我们要辩证的看待问题。我用的不爽，就不能认为它做的不好？</p>
<p>有人要说，这个很小众，毕竟大部人处理好友的请求数量很少，偶尔要处理让他们明确选择，对隐私进行保护。但我想说的是，这些好友很少的人，大概率加的好友都是真的好友，又有多少会不让看朋友圈呢？而对于有较多好友请求要处理的人来说，情况很糟糕！有些人可能不知道，微信 8.0 之前，微信好友中，最多有 5000 人可以看到朋友圈，超过 5000，再有人加你好友，微信会提示，然后自动选择仅聊天，因为之前好友是默认可以看朋友圈的。</p>
<p>现在放开了 5000 人的限制。你看，5000 人好友，这个需求难道就不小众，微信却考虑到了，满足了！而且，这么牛逼的产品，追求极致应该是必然的，小众需求也会有所考虑：<strong>毕竟微信的理念是简单，你需要它才出现</strong>。</p>
<p>因此，对于这个功能，我的一些不一定成熟的看法：</p>
<ul>
<li>处理好友请求很少的人，可以统计他们有多少会选择仅好友？我猜测大部分人都会选择朋友圈；</li>
<li>微信的渗透很强，很多农村老人都用，他们能理解「仅聊天」、「朋友圈」？求求你让我方便的加上一个好友吧；</li>
<li>好友超过 5000 的人，大概率新加好友也会很多，每个好友请求都要操作这么多步，真的好累！</li>
</ul>
<p>我这里预测，该功能会改进。要么回到之前，默认「朋友圈」；要么做到个性化，根据不同人群的习惯，给一个不同的默认选项。比如每次加好友的选择；是否从来不看朋友圈，设置关闭了朋友圈；是否从来不发朋友圈等等。</p>
<p>另外 8.0 还有一个功能：状态。功能本身我不说，但这个入口按钮的位置，给我一种感觉：要加一个状态的功能，入口放哪好呢？随便找一个显眼的位置放一下吧！总感觉特别突兀~</p>
<p><p class="md__image">
  <img src="../imgs/wechat8.0-02.png"
    alt=""  />
</p>
</p>
<p>看到我一个朋友也发了一条朋友圈吐槽，UI 像狗皮膏药。。。</p>
<p><p class="md__image">
  <img src="../imgs/wechat8.0-03.png"
    alt=""  />
</p>
</p>
<p>之前的悬浮窗口，8.0 改掉了，龙哥就评价说悬浮窗口像狗皮膏药，你看，微信的设计也不可能全部是完美的。</p>
<p>我没有能力教龙哥做产品，但就像 Go 社区对 error 不满意一样发声，作为微信用户，不爽的地方也是可以发声的。发表自己的意见，不一定对，但也是提升自己思考能力的机会！</p>
]]></content>
		</item>
		
		<item>
			<title>Unicode 和 UTF-8 是什么关系？本文为你解惑</title>
			<link>https://polarisxu.studygolang.com/posts/basic/char-set-encoding/</link>
			<pubDate>Thu, 21 Jan 2021 22:40:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/basic/char-set-encoding/</guid>
			<description>十几年前，国内 UTF-8 还不太流行，新手开发过程中，乱码问题是很常见的。记得我刚毕业那会，公司的系统是这样的：数据库 MySQL 使用的是 Latin-1 编码（ISO8859-1），程序源码使用的是 GBK，这样的情况，乱码真是满天飞~好在对数据库操作做了封装，编码问题在中间层处理了。那时候听到关于乱码问题的一个终极解决方案是：保证各个地方编码一致。 现如今，Unicode 相当普及，中文使用 UTF-8 编</description>
			<content type="html"><![CDATA[<p>十几年前，国内 UTF-8 还不太流行，新手开发过程中，乱码问题是很常见的。记得我刚毕业那会，公司的系统是这样的：数据库 MySQL 使用的是 Latin-1 编码（ISO8859-1），程序源码使用的是 GBK，这样的情况，乱码真是满天飞~好在对数据库操作做了封装，编码问题在中间层处理了。那时候听到关于乱码问题的一个终极解决方案是：保证各个地方编码一致。</p>
<p>现如今，Unicode 相当普及，中文使用 UTF-8 编码虽然比 GBK 编码占用更多的空间，但一般都不会在乎。特别是使用了 Go 语言后，乱码问题更是没有了。在 Go 语言标准库中有 unicode 包，它下面还有 utf8 和 utf16 两个子包。也许有此疑问：又是 Unicode、又是 UTF-8、UTF-16，它们是什么关系？</p>
<p>本文试着为大家解决关于字符集和字符编码的困惑。</p>
<p>本文目录：</p>
<p><p class="md__image">
  <img src="../imgs/char-set-encoding-content.png"
    alt=""  />
</p>
</p>
<h2 id="1什么是字符集">1、什么是字符集</h2>
<p>字符集，从字面看，是多个字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。因此不同的字符组合在一起就可以认为是不同的字符集。当然不是瞎组合。国人常见字符集如下：</p>
<p><p class="md__image">
  <img src="..//Users/xuxinhua/project/polarisxu/basic/imgs/charset01.png"
    alt=""  />
</p>
</p>
<h2 id="2什么是字符编码">2、什么是字符编码</h2>
<p>大家都知晓，计算机只认 0 和 1 组成的二进制数。所以整数通过进制转换转为二进制就可以被计算机处理。然而像文本、音频、视频等这样的信息，如何转为二进制被计算机处理呢？这就需要进行编码。</p>
<p><strong>编码</strong>（encode）是把数据从一种形式转换为另外一种形式的过程，它是一套算法。解码（decode）就是编码的逆过程。</p>
<p>比如对于 ASCII 字符集中的字符 1，转换为二进制是 00110001，这就是一次编码；将 00110001 显示为 1，涉及到一次解码。</p>
<p><strong>字符编码</strong>，顾名思义，是对字符进行编码，是字符和二进制数据之间转换的算法，它们之间必须一一对应，这是本文需要讨论的主题。一个二进制叫做位，8 位称为“字节”，根据计算一个字节一共可组合出 256（2 的 8 次方）种不同的状态。</p>
<p>关于字符集和字符编码，使用 ASCII 进行总结说明：</p>
<blockquote>
<p>ASCII <strong>字符集</strong>是字母、数字、标点符号以及控制符（回车、换行、退格）等组成的 128 个字符。</p>
<p>ASCII <strong>字符编码</strong>是将这 128 个字符转换为计算机可识别的二进制数据的一套规则（算法）。</p>
</blockquote>
<p>因此当我们说 ASCII 时，一般同时指 ASCII 字符集和 ASCII 字符编码。通常，字符集会同时定义一套同名的字符编码规则。然而万事都有特例，比如 Unicode 就只是代表字符集，对应的字符编码有多种，比如 UTF-8、UTF-16 等。</p>
<h2 id="3unicode-和-utf-系列">3、Unicode 和 UTF 系列</h2>
<p>现在知道了 Unicode 只是代表字符集，它的编码规则是通过 UTF 系列定义的。</p>
<p>那 Unicode 是什么？<a href="https://home.unicode.org/basic-info/overview/" target="_blank" rel="noopener">官方</a>
有这么一句话：</p>
<blockquote>
<p>Unicode provides a unique number for every character, no matter what the platform, program, or language is.</p>
</blockquote>
<p>即 Unicode 为每一个字符提供了一个唯一的数字编码（代号），叫做 Code Point（码点）。这里可以查找你要查询某个字符的码点（Code Point）：<a href="https://www.unicode.org/cgi-bin/GetUnihanData.pl">https://www.unicode.org/cgi-bin/GetUnihanData.pl</a>。注意这里的码点不是字符编码，只是字符集而已。</p>
<p>所以，Unicode 字符集一个最主要的工作就是维护这样一个表，可以把它想象成是一个数据库表，里面存储着每一个字符对应的唯一 ID（即 Code Point），统一用 U+XXXX 来表示（X 为 16 进制的字符，因为字符很多，并不一定所有的字符都是 4 个 16 进制数，比如笑哭的 Emoji 表情，Code Point 是 U+1F602），如 「徐」U+5F90、「新」U+65B0。现在这个数据表已经拥有 100 多万的字符，还在不停的更新。</p>
<p>为什么会出现 Unicode 呢？因为之前的编码方式，大多只考虑自己国家，不同国家的编码方式不同，导致使用中国 GBK 编码的文档，在日本用本地编码打开就乱码了。标准总是在混乱中诞生的，于是一些国际组织制定出了全球统一的编码格式。这就是 Unicode。</p>
<blockquote>
<p>大家可能见到过 USC，这是 ISO 制定的一种计算机行业标准，和 Unicode 目的是一样的。他们双方意识到不应该出现两种不同的国际标准。因此你可以认为它们是一样的。</p>
</blockquote>
<p>了解了 Unicode，那为什么会有 UTF-8、UTF-16？</p>
<h3 id="utf-系列">UTF 系列</h3>
<p>前面说了 Unicode 本身主要工作是维护一个表，它并没有规定一个字符到底用几个字节来表示，只规定了每个字符对应到唯一的码点（code point），码点可以从 0000 ~ 10FFFF <a href="https://unicode-table.com/cn/blocks/" target="_blank" rel="noopener">共 1114112 个值</a>
。</p>
<p>那为什么 Unicode 不规定字符编码呢？如果将 Unicode 码点直接当编码规则会如何？其实是有的，这就是 UTF-32。因为计算机没法确认两字节到底是表示 1 个字符还是 2 个字符，因此 UTF-32 粗暴的取最大值，所有字符都按 4 字节编码。很显然，这在空间上是极浪费的（英文文档直接大 3 倍），因此 UTF-32 很少使用。</p>
<p>UTF 是 Unicode Transformation Format （Unicode 转换格式）的首字母缩写，专门解决 Unicode 的编码问题。根据编码规则的不同有 UTF-8、UTF-16 和 UTF-32 等几种具体的方案。</p>
<p>由于 UTF-32 浪费空间，使用不多，本文着重介绍 UTF-8 和 UTF-16。</p>
<h2 id="4utf-8">4、UTF-8</h2>
<p>UTF-8，也可写为 UTF8，是 Unicode 的一种变长编码方案。它完全兼容 ASCII，同时避免了 UTF-16 和 UTF-32 中的字节序等复杂性。UTF-8 能够被广泛接受，跟其完全兼容 ASCII 有很大关系。</p>
<p>为什么叫 <code>-8</code>？因为它将每个 Unicode 字符编码为 1~4 个八位元（octets）（八位元即一个字节），因此叫 <code>-8</code>。其中字节的个数取决于分配给 Unicode 字符的整数值。</p>
<p>当面对 4 个字节，UTF-8 如何知晓应该把它当做 1 个字符解析、还是 2 个？亦或是 4 个？这就是 UTF-8 设计巧妙之处。</p>
<ul>
<li>单字节可编码的 Unicode 范围：\u0000~\u007F（0~127）</li>
<li>双字节可编码的 Unicode 范围：\u0080~\u07FF（128~2047）</li>
<li>三字节可编码的 Unicode 范围：\u0800~\uFFFF（2048~65535）</li>
<li>四字节可编码的 Unicode 范围：\u10000~\u1FFFFF（65536~2097151）</li>
</ul>
<p>UTF-8 从首字节就可以判断一个字符的 UTF-8 编码有几个字节， 具体判断逻辑就是，根据首字节二进制的起始内容：</p>
<ul>
<li>如果以 0 开始，肯定是单字节编码；</li>
<li>如果以 110 开头，肯定是双字节编码；</li>
<li>如果以 1110 开头，肯定是三字节编码；</li>
<li>如果以 11110 开头，肯定是四字节编码；</li>
</ul>
<p>除首字节之外，其他字节也有规定，如下：</p>
<table>
<thead>
<tr>
<th>字节数</th>
<th>用来表示码点的位数</th>
<th>Unicode 十六进制码点范围</th>
<th>字节1</th>
<th>字节2</th>
<th>字节3</th>
<th>字节4</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>7</td>
<td>0000 0000 - 0000 007F</td>
<td>0xxxxxxx</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>11</td>
<td>0000 0080 - 0000 07FF</td>
<td>110xxxxx</td>
<td>10xxxxxx</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>16</td>
<td>0000 0800 - 0000 FFFF</td>
<td>1110xxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>21</td>
<td>0001 0000 - 0010 FFFF</td>
<td>11110xxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
<td>10xxxxxx</td>
</tr>
</tbody>
</table>
<p>具体如何编码和解码呢？以中文“徐”为例，说明这个过程。</p>
<p>「徐」的 Unicode 码点是 0x5F90（二进制：101 1111 1001 0000），对照上面的表发现 0x5F90 位于第三行的范围，所以格式是 1110xxxx 10xxxxxx 10xxxxxx。接着从「徐」Unicode 码点的二进制数最后一位开始，按从右向左依次填充这个格式中的 x，多出的 x 用 0 补上。这样就得到了「徐」这个汉字的 UTF-8 编码：11100101 10111110 10010000，转成十六进制是 0xE5 0xBE 0x90。</p>
<p>解码的过程也十分简单：如果一个字节（编码的二进制表示）的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位是 1，那么连续有多少个 1，就表示该字符占用多少个字节。还是以「徐」字为例，它的 UTF-8 编码的二进制表示是：11100101 10111110 10010000，根据规则，第一个字节的第一位是 1，且有三个 1，因此占用 3 个字节。根据上面表中第三行，将第一个字节开头的 1110 去掉，第二、第三个字节开头的 10 去掉，剩下的组合在一起，即：1011 11110 010000，这就是 0x5F90。</p>
<p>关于 UTF-8 的规范参考 <a href="https://tools.ietf.org/html/rfc3629" target="_blank" rel="noopener">rfc3629</a>
，这是 Ken Thompson 和 Rob Pike 等制定的，这两位也是 Go 语言的作者。</p>
<h2 id="5utf-16">5、UTF-16</h2>
<p>UTF-16  是 16-bit Unicode Transformation Format。有一点需要特别强调，它跟 UTF-8 一样，是可变长度的。代码点（Code Point）是用一个或两个 16 位代码单元编码的。至于网上有些资料说的 UTF-16 是固定 2 个字节长度编码，那其实不是 UTF-16，而是 UCS-2 （用于 2 字节通用字符集）。UTF-16 可以看做是它的父集。</p>
<blockquote>
<p>这里涉及一个概念，简单介绍下。</p>
<p>基本多语言平面（BMP）：UCS-2 只对这些字符进行了编码，一共能编码 65,536 个字符。后来不够用了，怎么办？IEEE 引入了 UCS-4，所有字符都用 4 字节编码，这太浪费空间了，因此出现了一个折中方案：UTF-16，即超出 U+FFFF 的部分使用 4 字节，这部分叫做辅助平面（SMP），码点范围 U+010000 到 U+10FFFF。</p>
<p>注意 UCS-2 已经过时了。</p>
</blockquote>
<p>因为是变长的方案，就需要有办法标识到底是 2 个字节还是 4 个字节。上文讲解 UTF-8 时，判断首字节字节开头位即可。类似的，看如下一张表：</p>
<table>
<thead>
<tr>
<th>字节数</th>
<th>16 进制码点范围</th>
<th>16-bit code 1</th>
<th>16-bit code 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>U+0000 - U+D7FF</td>
<td>xxxxxxxxxxxxxxxx</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>U+E000 - U+FFFF</td>
<td>xxxxxxxxxxxxxxxx</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>U+00010000 - U+0010FFFF</td>
<td>110110xxxxxxxxxx</td>
<td>110111xxxxxxxxxx</td>
</tr>
</tbody>
</table>
<p>使用 UTF-16 最知名的是 Java，JVM 内部使用的就是 UTF-16 编码。因为 UTF-16 不兼容 ASCII，因此网络传输一般不会使用它。</p>
<p>但 Java 的编码方式其实没那么简单。一般地 Java 中是这样的：（来源于 《Java 核心技术手册》 一书）</p>
<ul>
<li>Java 源文件，可能使用本地编码（比如中国是 GB）；</li>
<li>类文件（class 文件），使用 modified UTF-8（即做了部分修改的 UTF-8）；</li>
<li>虚拟机，使用过 UTF-16</li>
</ul>
<p>接下来，以汉字&quot;?&ldquo;为例，说明 UTF-16 编码方式是如何工作的。</p>
<p>汉字&rdquo;?&ldquo;的 Unicode 码点为 <code>0x20BB7</code>，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 <code>0x20BB7 - 0x10000</code> 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为<code>0001000010 1110110111</code>。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。<code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>，直接填充后面的 10 个二进制位即可，得到 <code>1101100001000010</code>，转成 16 进制数则为 <code>0xD842</code>。同理可得，低位为 <code>0xDFB7</code>。因此得出汉字&rdquo;?&ldquo;的 UTF-16 编码为 <code>0xD842 0xDFB7</code>。</p>
<h2 id="6go-中-unicode-相关包">6、Go 中 Unicode 相关包</h2>
<p>Go 语言让复杂的编码问题变得简单很多，极大的减轻了程序员的心智负担。为了方便对 unicode 字符串进行处理，Go 语言标准库提供三个包：unicode、unicode/utf8 和 unicode/utf16。</p>
<p>这里简单介绍下三个包的功能：</p>
<ul>
<li>unicode：unicode 提供数据和函数来测试 Unicode 代码点（Code Point，用 rune 存储）的某些属性。</li>
<li>unicode/utf8：用于处理 UTF-8 编码的文本，提供一些常量和函数，包括在 rune（码点） 和 UTF-8 字节序列之间的转换。</li>
<li>unicode/utf16：函数比较少，主要是 UTF-16 序列的编码和解码。</li>
</ul>
<p>具体函数不讲解了，大家可以看标准库文档或通过我的开源书阅读相关章节：<a href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example">https://github.com/polaris1119/The-Golang-Standard-Library-by-Example</a>。</p>
<p>着重介绍下 Go 中字符串的写法。</p>
<p>在 Go 语言中，字符串字面值有 4 种写法，比如「徐新华」可以这么写：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s1</span> <span class="o">:=</span> <span class="s">&#34;徐新华&#34;</span>
<span class="nx">s2</span> <span class="o">:=</span> <span class="s">&#34;\u5F90\u65B0\u534E&#34;</span>
<span class="nx">s3</span> <span class="o">:=</span> <span class="s">&#34;\U00005F90\U000065B0\U0000534E&#34;</span>
<span class="nx">s4</span> <span class="o">:=</span> <span class="s">&#34;\xe5\xbe\x90\xe6\x96\xb0\xe5\x8d\x8e&#34;</span>
</code></pre></div><p>简单来生活就是 \u 紧跟四个十六进制数，\U 紧跟八个十六进制数。其中 \u 或 \U 代表后面是 Unicode 码点。而 \x 紧跟两个十六进制数，这些十六进制不是 Unicode 码点，而是 UTF-8 编码。</p>
<p>下面的代码有利于你的理解：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;unicode/utf8&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="s">`徐新华`</span>
	<span class="kd">var</span> <span class="p">(</span>
		<span class="nx">buf</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
		<span class="nx">n</span>   <span class="kt">int</span>
	<span class="p">)</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;字符\tUnicode码点\tUTF-8编码十六进制\tUTF-8编码二进制&#34;</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">n</span> <span class="p">=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nf">EncodeRune</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%q\t%U\t\t%X\t\t%b\n&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">],</span> <span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
	<span class="p">}</span>
	
	<span class="nx">s2</span> <span class="o">:=</span> <span class="s">&#34;\u5F90\u65B0\u534E&#34;</span>
	<span class="nx">s3</span> <span class="o">:=</span> <span class="s">&#34;\U00005F90\U000065B0\U0000534E&#34;</span>
	<span class="nx">s4</span> <span class="o">:=</span> <span class="s">&#34;\xe5\xbe\x90\xe6\x96\xb0\xe5\x8d\x8e&#34;</span>
	
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s4</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>运行结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">字符	Unicode码点	UTF-8编码十六进制	UTF-8编码二进制
<span class="s1">&#39;徐&#39;</span>	U+5F90		E5BE90		<span class="o">[</span><span class="m">11100101</span> <span class="m">10111110</span> 10010000<span class="o">]</span>
<span class="s1">&#39;新&#39;</span>	U+65B0		E696B0		<span class="o">[</span><span class="m">11100110</span> <span class="m">10010110</span> 10110000<span class="o">]</span>
<span class="s1">&#39;华&#39;</span>	U+534E		E58D8E		<span class="o">[</span><span class="m">11100101</span> <span class="m">10001101</span> 10001110<span class="o">]</span>
徐新华
徐新华
徐新华
</code></pre></div><p>此外，关于字符串其他方面的处理，比如编码转换等，可以到 <a href="https://pkg.go.dev/golang.org/x/text">https://pkg.go.dev/golang.org/x/text</a> 里找。</p>
<h2 id="7大小端问题little-endian-和-big-endian">7、大小端问题（Little endian 和 Big endian）</h2>
<p>最后聊一下大小端的问题。</p>
<p>一个字符使用多字节存储时，涉及到哪个在前哪个在后。以汉字「徐」为例，Unicode 码点是 5F90，需要用两个字节存储，一个字节是<code>5F</code>，另一个字节是<code>90</code>。存储的时候，<code>5F</code>在前，<code>90</code> 在后，这就是 Big endian 方式；<code>90</code>在前，<code>5F</code>在后，这是 Little endian 方式。</p>
<p>这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头（Big-endian）敲开还是从小头（Little-endian）敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。</p>
<p>第一个字节在前，就是”大端方式&rdquo;（Big endian），第二个字节在前就是”小端方式&quot;（Little endian）。</p>
<p>那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？</p>
<p>Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做&quot;零宽度非换行空格&quot;（zero width no-break space），用 FEFF 表示。这正好是两个字节，而且 FF 比 FE 大1。</p>
<p>如果一个文本文件的头两个字节是 FE FF，就表示该文件采用大端方式；如果头两个字节是 FF FE，就表示该文件采用小端方式。</p>
<p>但从上面关于 UTF-8 编码的说明可以看出，虽然 UTF-8 存在多字节表示一个字符的情况，但顺序是固定的，没有字节序的问题。Unix 系统下，UTF-8 没有任何前置字符，但 Windows 下记事本保存的 UTF-8 文件会带上 BOM（Byte Order Mark），即 EF BB BF 这三个字节。关于这一点，Unicode 之父 Rob Pike 明确说 UTF-8 不需要 BOM，所以一开始 Go 源文件是不允许有 BOM 的，否则编译不通过，不过现在已经可以有了。但建议还是别带 BOM。</p>
<blockquote>
<p>UTF-8 带 BOM 说不是为了区分字节序，而是为了更方便的知晓这是一个 UTF-8 文件。</p>
</blockquote>
<p>你可以通过 hexdump 工具查看文件开始的字符。</p>
<h2 id="8参考文献">8、参考文献</h2>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></li>
<li><a href="https://books.studygolang.com/gopl-zh/ch3/ch3-05.html">https://books.studygolang.com/gopl-zh/ch3/ch3-05.html</a></li>
<li><a href="https://blog.csdn.net/hezh1994/article/details/78899683">https://blog.csdn.net/hezh1994/article/details/78899683</a></li>
<li><a href="https://blog.csdn.net/weixin_39640298/article/details/84074498">https://blog.csdn.net/weixin_39640298/article/details/84074498</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>公众号如何涨粉</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/wechat-add-follow/</link>
			<pubDate>Wed, 20 Jan 2021 22:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/wechat-add-follow/</guid>
			<description>大家好，我是站长 polarisxu。 这是公众号系列原创文章的第 3 篇。上篇文章有人留言问公众号如何涨粉，这篇文章就聊聊这个话题。 微信是一个相对封闭的生态，不像其他平台，比如今日头条靠推荐（虽然微信公众号现在也加入了一些推荐机制）。因为是封闭的，加上触达机制，微信公众号的粉丝价值特别高。比如我的知乎账号有 9 万粉丝，但目前一分钱收入都没有，而公众号不到 1 万粉丝，就</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这是公众号系列原创文章的第 3 篇。上篇文章有人留言问公众号如何涨粉，这篇文章就聊聊这个话题。</p>
<p>微信是一个相对封闭的生态，不像其他平台，比如今日头条靠推荐（虽然微信公众号现在也加入了一些推荐机制）。因为是封闭的，加上触达机制，微信公众号的粉丝价值特别高。比如我的知乎账号有 9 万粉丝，但目前一分钱收入都没有，而公众号不到 1 万粉丝，就可以轻松月入几千。</p>
<p>但因为粉丝价值高，涨粉也不那么容易。公众号早期，有流量红利，现在流量越来越贵。</p>
<p>我的粉丝不多，粉丝也是缓慢增长，但我为什么还要写这篇文章呢？因为 Go 圈公众号还是比较少（或者说有一点粉丝的少），因此，我相信我的一些经验或认知对我的读者，对公众号感兴趣的读者会有一定帮助。</p>
<h2 id="01-常规方法">01 常规方法</h2>
<p>这里说的是从头开始做公众号，没有其他流量来源的情况，属于冷启动。</p>
<h3 id="原创投稿">原创投稿</h3>
<p>一般是选择一个领域，写原创文章，然后找该领域的大号投稿。我观察过，转载一篇文章，阅读量 2000 左右的话，应该可以带过去 80 左右的粉丝。当然这不是绝对的，看文章质量以及转载过多少次。很多原创作者最开始的粉丝都是通过这种方式获得的。</p>
<p>很多公众号菜单都有投稿的联系方式，我建议你联系某个号之前，先给他开通白名单（不知道怎么开通？这个你自己找一下吧）。我最近发现，有不少人根本没有联系我就给「Go语言中文网」开白了，而且很多是不对口的，我肯定不会转载的！</p>
<p>一般来说，接受投稿的公众号是那种非个人定位的。比如我这个 「polarisxu」公众号目前是不接受公众号投稿的。所以投稿前，应该明确对方是否接受投稿。</p>
<h3 id="进入领域圈子">进入领域圈子</h3>
<p>文章在公众号发了，及时是好文，不暴露给用户，是吸引不来粉丝的。所以，为了让目标用户看到你的好文，你应该让文章进入他们的视线。分享到微信朋友圈和群是很好的方式。</p>
<p>先说群。因为你是冷启动，我想目标用户是你微信好友的可能性比较小。这时候，你可以加一些你选择的领域的群。但提醒下，这个群是别人的，分享文章要注意下。我个人建议，可以现在群里和群友交流，混个脸熟，而且文章写的不错的话，很有可能有合适的机会分享给群友。此外，如果你在群里有了一定的知名度，可以偶尔将你认为不错的文章分享到群里，注意一定要和群的内容相关。比如在一个 Go 群，你发 Java 的文章，肯定不合适，很可能群主会踢了你。而且别只发文章就完事了，最好说下文章的亮点。你的文章不错，自然会有人关注。</p>
<p>接着说朋友圈。虽然微信公众号文章群发时会触达用户，但打开看的人数还是不那么多，而且用户还可能取消关注。因此，大家可以在文章末尾引导粉丝加你好友，交流技术。朋友圈是一个重要的私域流量，除了可以分享自己的文章，让没有读的人阅读，还会有商业价值。所以，尽可能多加目标粉丝为好友！</p>
<h3 id="其他平台引流">其他平台引流</h3>
<p>在早期，很多其他平台可以往公众号引流。比如把你的文章发布在其他平台，文末放上你的微信公众号二维码。但现在大流量的平台基本都会屏蔽二维码，流量真的是越来越难了。</p>
<p>但这些平台也并非完全无法引流。比如知乎，虽然文章不让放二维码了，但用户自己信息处还是可以写公众号名称的。如果你是有心人，可以看看目前各大平台，看看大家都是怎么引流的，总会有一些空子可以钻。</p>
<p>这里重点推荐一个还可以引流的平台，有不少人主要靠这个引流，那就是 GitHub。GitHub 上可以随便放二维码，但前提条件是你的项目火起来。怎么火？好项目应该是可以火的。另外一个方式，可以尝试整理一些大家都需要的内容。这个需要花时间和心思了。也许你刚好有一个不错的开源项目，那赶紧把你的二维码放上吧！</p>
<h2 id="02-互助">02 互助</h2>
<p>俗话说，一个人走得更快，一群人走的更远。众人拾柴火焰高。所以，做公众号的朋友应该互相帮助。其实上面说的原创投稿也是互助的一种方式。</p>
<p>经过这两年的公众号运营，我发现公众号的很多号主很会玩，我也参与了一些。</p>
<h3 id="互推">互推</h3>
<p>2019 年我开始运营公众号时，技术圈的公众号主们在组队互推，具体规则就是：一个车 10 来个号主，每个号主一段介绍加二维码，根据新榜指数排名，决定公众号的排序。每个号主安排某一天发文，可以是头条或次条，但对阅读量有要求，而且对标题也有一定要求。比如这个车要求是阅读达到 2000，如果你 24 小时没达标，需要找时间补发。</p>
<p>这种方式开始的时候效果还挺不错的，而且新增的粉丝大概率是真粉。那段时间 Go语言中文网公众号粉丝还是增加了不少。</p>
<p>不过次数多了，一方面反复那些号，增粉效果差；另一方面，读者也疲劳了，阅读量上不去。毕竟推这样的文章多了，会有点心累，而且会感觉有点对不住读者。</p>
<p>现在圈内基本不用这种方式了。也许过一些时间，可以再尝试下。不过这种方式，号主们的平均阅读量最好达到 1k 左右，否则效果太差。</p>
<h3 id="抽奖车">抽奖车</h3>
<p>2020 年春节前后，圈内流行抽奖车，即在原来的互推车基础上增加抽奖。有一个小程序，支持联合抽奖。10 来个号主联合，一起送一件礼物，比如 iPad，每个号主发文，每关注一个号增加一次抽奖机会，中奖概率将提升。</p>
<p>这种方式粉丝增加挺多的，不过真粉丝的概率很难说。如果互推车都是相关技术的，那真粉多，否则可能只是冲着奖品来的，抽奖结束，取消关注的也会不少，当然总体上粉丝还是增加的。</p>
<p>说明一句，有人怀疑抽奖有内幕，其实只要认真一想，不可能有内幕的，关键没必要。再说抽奖的小程序是第三方的，想内幕也不可能。</p>
<h3 id="单推">单推</h3>
<p>这种方式分两种：朋友圈互推和公众号送资料单推。</p>
<p>朋友圈互推是约一个号主，彼此在朋友圈介绍对方，让好友关注。找到合适的号主，这种互推方式还是不错的。</p>
<p>至于公众号送资料，就是找到合适的号主，各自准备一篇推文，关注公众号后，回复关键字获取资料。我自己这种方式用的很少，Go 圈还是有点小众，非 Go 真实粉丝我又不太想要。整体上这种方式送的资料还是挺重要的，感觉关键还是找到好的资料和合适的互推号主。</p>
<h2 id="03-小结">03 小结</h2>
<p>增粉很重要，但也是一个漫长的过程。有些人很厉害，通过爆款文章就可以增加很多粉丝，但这没有普适性。普通人，坚持原创产出，坚持，我相信会有收获！</p>
<p>另外一点，就是大家要心怀一颗利他之心，帮助别人，别人也会帮助你。加油！</p>
<p>最后欢迎给「Go语言中文网」公众号投稿，一起加油！你有其他涨粉方式，欢迎留言交流，大家一起涨粉！</p>
]]></content>
		</item>
		
		<item>
			<title>第 78 期周刊题目解析：答题正确率有点低</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/weekly-question-78/</link>
			<pubDate>Mon, 18 Jan 2021 11:25:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/weekly-question-78/</guid>
			<description>大家好，我是站长 polarisxu。 昨天在 Go语言爱好者周刊第 78 期 出了一道题，以下代码输出什么？ package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { ch1 := make(chan int) go fmt.Println(&amp;lt;-ch1) ch1 &amp;lt;- 5 time.Sleep(1 * time.Second) } A：5；B：编译不通过；C：运行时死锁 如果你没有做这道题，往下看之前，先思考下。 今天看了下答题结果，正确率有点低，才 35%： 可见不少人的基础还是不扎实。 此题如果改为这样： package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { ch1 := make(chan int) go func(){ fmt.Println(&amp;lt;-ch1) }() ch1 &amp;lt;- 5 time.Sleep(1 * time.Second)</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>昨天在 <a href="https://mp.weixin.qq.com/s/kma8hvdLVPIkZnKw_MaSKg" target="_blank" rel="noopener">Go语言爱好者周刊第 78 期</a>
出了一道题，以下代码输出什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">go</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">)</span>
	<span class="nx">ch1</span> <span class="o">&lt;-</span> <span class="mi">5</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>A：5；B：编译不通过；C：运行时死锁</p>
<p>如果你没有做这道题，往下看之前，先思考下。</p>
<p>今天看了下答题结果，正确率有点低，才 35%：</p>
<p><p class="md__image">
  <img src="../imgs/weekly-question-78.png"
    alt=""  />
</p>
</p>
<p>可见不少人的基础还是不扎实。</p>
<p>此题如果改为这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ch1</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(){</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch1</span><span class="p">)</span>
  <span class="p">}()</span>
	<span class="nx">ch1</span> <span class="o">&lt;-</span> <span class="mi">5</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果就是 A 了。对比下你能知道原因了吧！</p>
<p>在 Go 语言规范中，关于 <a href="https://docs.studygolang.com/ref/spec#Go_statements" target="_blank" rel="noopener">go 语句</a>
有这么一句描述：</p>
<blockquote>
<pre><code>GoStmt = &quot;go&quot; Expression .
</code></pre><p>The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for <a href="https://docs.studygolang.com/ref/spec#Expression_statements" target="_blank" rel="noopener">expression statements</a>
.</p>
<p>The function value and parameters are <a href="https://docs.studygolang.com/ref/spec#Calls" target="_blank" rel="noopener">evaluated as usual</a>
 in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete.</p>
</blockquote>
<p>这里说明，go 语句后面的函数调用，其参数会先求值，这和普通的函数调用求值一样。在规范中<a href="https://docs.studygolang.com/ref/spec#Calls" target="_blank" rel="noopener">调用部分</a>
是这样描述的：</p>
<blockquote>
<p>Given an expression <code>f</code> of function type <code>F</code>,</p>
<pre><code>f(a1, a2, … an)
</code></pre><p>calls <code>f</code> with arguments <code>a1, a2, … an</code>. Except for one special case, arguments must be single-valued expressions <a href="https://docs.studygolang.com/ref/spec#Assignability" target="_blank" rel="noopener">assignable</a>
 to the parameter types of <code>F</code> and are evaluated before the function is called.</p>
</blockquote>
<p>大意思是说，函数调用之前，实参就被求值好了。</p>
<p>因此这道题目 <code>go fmt.Println(&lt;-ch1)</code> 语句中的 <code>&lt;-ch1</code> 是在 main goroutine 中求值的。这相当于一个无缓冲的 chan，发送和接收操作都在一个 goroutine 中（main goroutine）进行，因此造成死锁。</p>
<p>更进一步，大家可以通过汇编看看上面两种方式的不同。</p>
<p>此外，defer 语句也要注意。比如下面的做法是不对的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">defer</span> <span class="nb">recover</span><span class="p">()</span>
</code></pre></div><p>而应该使用这样的方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">recover</span><span class="p">()</span>
<span class="p">}()</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>钉钉 6.0 发布会上提到的 Low-Code 是个什么鬼？</title>
			<link>https://polarisxu.studygolang.com/posts/talk/low-code/</link>
			<pubDate>Sat, 16 Jan 2021 20:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/low-code/</guid>
			<description>2021 年 1 月 14 日钉钉 6.0 发布会上提到了“云钉一体”战略，其中讲解了 「Low-Code」 这个词。不知道大家看到这个词是啥感觉？这是说我写的代码 low 吗？ 阿里似乎比较喜欢带节奏，比如中台，不管大小公司都模仿；前段时间看网上有说他们去中台。。。心好累！ Low-Code 这玩意竟然很早就有了，很多人不知晓，多半是因为一直不温不火！不知道大家是否知晓，反正我之前是不知道，是这两天才看的很多资料</description>
			<content type="html"><![CDATA[<p>2021 年 1 月 14 日钉钉 6.0 发布会上提到了“云钉一体”战略，其中讲解了 「Low-Code」 这个词。不知道大家看到这个词是啥感觉？这是说我写的代码 low 吗？</p>
<p>阿里似乎比较喜欢带节奏，比如中台，不管大小公司都模仿；前段时间看网上有说他们去中台。。。心好累！</p>
<p>Low-Code 这玩意竟然很早就有了，很多人不知晓，多半是因为一直不温不火！不知道大家是否知晓，反正我之前是不知道，是这两天才看的很多资料。所以，这是一篇概念普及性的文章。</p>
<h2 id="01-low-code-是什么">01 low-code 是什么？</h2>
<p>low-code 一般翻译为低代码，表示的是用很少甚至不用代码就能开发软件。看一张图：</p>
<p><p class="md__image">
  <img src="../imgs/low-code.png"
    alt=""  />
</p>
</p>
<p>35 岁，不懂代码，2小时能开发出「疫情防控应用」，最喜欢的语言不是 PHP，而是「拖拉拽」。。。</p>
<p>Low-Code 是什么，大家应该有一个初步的概念了。维基百科是这么描述的（关于 low-code development platform）：</p>
<blockquote>
<p>A <strong>low-code development platform</strong> (<strong>LCDP</strong>) provides a development environment used to create application software through graphical user interfaces and configuration instead of traditional hand-coded computer programming。</p>
</blockquote>
<p>也就是说，低代码开发平台（LCDP）本身也是一种软件，它为开发者提供了一个创建应用软件的开发环境。对于程序员而言，低代码开发平台的性质与 IDEA、VS 等代码 IDE 类似，都是服务于开发者的生产力工具。但与传统代码 IDE 不同的是，低代码开发平台提供的是更高维和易用的可视化 IDE。大多数情况下，开发者并不需要使用传统的手写代码方式进行编程，而是可以通过图形化拖拽、参数配置等更高效的方式完成开发工作。</p>
<p>所以，钉钉就是要打造一个这样的平台。</p>
<blockquote>
<p>Low-Code 这个词最早是 Forrester 在 2014 年提出来的。</p>
</blockquote>
<h2 id="02-能做什么">02 能做什么？</h2>
<p>在参考文献「1」中，阿里内部目前很看好它，认为这是一场革命。它把普通的编程比作文章，把低代码比作视频，视频越来越受欢迎，虽然文章依然有其存在市场，但视频已成为大部分人获取信息的主要渠道。</p>
<p>说起拖拽编程，很多人可能会不屑：想想 Dreamware、Visual Basic 等，提供了强大的拖拽，但实际上大家很少用拖拽。不过低代码跟之前的还是不太一样，它可以给非程序员使用。</p>
<p>计算机领域有一句至理名言：任何问题都可以通过增加一个间接的中间层来解决。低代码的思路亦是如此：与当年的操作系统和现在的云平台一样，都是想通过建立一个黑盒化的中间层抽象来降低开发者的工作量与心智负担。</p>
<p>具体来说，低代码适用于哪些场景？</p>
<ul>
<li>自动化表单系统。低代码平台提供基础组件，企业可以基于此，通过拖拽的方式创建自己的表单系统，比如常见的 OA 的各种表单、审批。基本上表单收集信息、展示这类型的应用都可以通过低代码（甚至无代码）实现。</li>
<li>低代码开发 Saas 系统。</li>
<li>低代码开发 Pass 系统。</li>
</ul>
<h2 id="03-展望">03 展望</h2>
<p>除了这次钉钉的高调发布会，腾讯云也有低代码系统，他们总体的思路都是“云端一体”，解决了云，还希望解决本地“端”的问题。</p>
<p>虽然技术都有成熟度曲线，但不同的技术，成熟度曲线的跨度等是不一样的。Saas、Pass、Faas、Serverless 等一堆技术，它们都有一定程度的应用，但没有银弹，没有那种技术是一统江湖的。像微服务、中台不是银弹一样，鼓吹低代码是新一代技术革命，我觉得有点过了。</p>
<p>总的来看，我觉得低代码比较适合的场景还是偏向服务企业，开发企业内部的应用。实话说，这部分的系统，也是很多程序员不愿意开发的。但这部分又是企业数字化很重要的部分，因此低代码还是能发挥很大的作用，特别是对于传统企业数字化转型更是如此。</p>
<p>而且，我认为低代码开发平台属于大企业会做的事情（有一些创业公司可能会做这个方向），他们服务中小企业，说白了是一个 2B 的生意，大量 2C 的公司以及大厂们，要么用不上低代码，要么自己搭建一套这样的系统。同时，这些低代码平台会吸引更多的开发者参与进来，开发基础组件，打造生态。所以，低代码咋一看，似乎要革程序员的命，实际上程序员们呵呵一笑~</p>
<p>你怎么看？欢迎留言交流！</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>「1」：https://www.cnblogs.com/aliyun-emas/p/14004815.html</li>
<li>「2」：https://www.zhihu.com/question/439292804</li>
<li>「3」：https://en.wikipedia.org/wiki/Low-code_development_platform</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>用 Go 如何实现精准统计文章字数</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/stat-words/</link>
			<pubDate>Thu, 14 Jan 2021 17:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/stat-words/</guid>
			<description>大家好，我是站长 polarisxu。 今天要聊的内容应该可以当做一道面试题，你可以先想想该怎么实现。 统计字数是一个很常见的需求，很多人印象最深的应该是微博早些时候限制 140 字，而且边输入会边统计剩余字数。现在很多社区文章也会有字数统计的功能，而且可以依据字数来预估阅读时间。比如 Go语言中文网就有这样的功能。 01 需求分析 下手之前先分析下这个需求。从我个人经验看，在实际</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天要聊的内容应该可以当做一道面试题，你可以先想想该怎么实现。</p>
<p>统计字数是一个很常见的需求，很多人印象最深的应该是微博早些时候限制 140 字，而且边输入会边统计剩余字数。现在很多社区文章也会有字数统计的功能，而且可以依据字数来预估阅读时间。比如 Go语言中文网就有这样的功能。</p>
<h2 id="01-需求分析">01 需求分析</h2>
<p>下手之前先分析下这个需求。从我个人经验看，在实际面试中，针对一个面试题，你的分析过程，循序渐进的解决方案，可以很好的展示你的思考过程。正所谓分析问题、解决问题。这会给你加分的。</p>
<p>我们采用类似词法分析的思路分析这个需求。</p>
<p>一篇文章通常包含如下元素，我们也称之为 token：</p>
<ul>
<li>普通文字</li>
<li>标点符号</li>
<li>图片</li>
<li>链接（包含各种协议的链接）</li>
<li>代码</li>
</ul>
<p>其中普通文字通常会分为欧美和中日韩（CJK），因为 CJK 属于表意文字，和欧美字母的文字差异很大。同时这里还涉及到编码的问题。本文假设使用 UTF-8 编码。</p>
<p>对于标点符号，中文标点和英文标点也会很不一样。</p>
<p>此外还有全角和半角的问题。</p>
<p>根据以上分析，对于该需求作如下假定：</p>
<ul>
<li>空格（包括换行）不算字数；</li>
<li>HTML 标签需要剔除；</li>
<li>编码方式：假定为 UTF-8 编码；</li>
<li>标点符号算不算做字数。如果算，像括号这样的按 2 个字算；</li>
<li>链接怎么算？一个链接约定为 1 个字可能更合适，大概阅读时只是把它当链接，而不太会关心链接由什么字母组成；</li>
<li>图片不算做字数，但如果计算阅读时间，可能需要适当考虑图片的影响；</li>
<li>对于技术文章，代码是最麻烦的。统计代码字数感觉是没多大意义的。统计代码行数可能更有意义；</li>
</ul>
<p>本文的解决方案针对以上的假定进行。</p>
<h2 id="02-go-语言实现">02 Go 语言实现</h2>
<p>先看最简单的。</p>
<h3 id="纯英文">纯英文</h3>
<p>根据以上分析，如果文章只包含普通文本且是英文，也就是说，每个字（单词）根据空格分隔，统计是最简单的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TotalWords</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">inWord</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="nx">wasInWord</span> <span class="o">:=</span> <span class="nx">inWord</span>
		<span class="nx">inWord</span> <span class="p">=</span> <span class="p">!</span><span class="nx">unicode</span><span class="p">.</span><span class="nf">IsSpace</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">inWord</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">wasInWord</span> <span class="p">{</span>
			<span class="nx">n</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">n</span>
<span class="p">}</span>
</code></pre></div><p>还有一种更简单的方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nb">len</span><span class="p">(</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</code></pre></div><p>不过看 strings.Fields 的实现，性能会不如第一种方式。</p>
<p>回顾上面的需求分析，会发现这个实现是有 Bug 的。比如下面的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s1</span> <span class="o">:=</span> <span class="s">&#34;Hello,playground&#34;</span>
<span class="nx">s2</span> <span class="o">:=</span> <span class="s">&#34;Hello, playground&#34;</span>
</code></pre></div><p>用上面的实现，s1 的字数是 1，s2 的字数是 2。它们都忽略了标点符号。而且因为写法的多样性（不规范统一），导致计算字数会有误差。所以我们需要对写法进行规范。</p>
<h3 id="规范排版">规范排版</h3>
<p>其实和写代码要有规范一样，文章也是有规范的。比如出版社对于一本书的排版会有明确的规定。为了让我们的文章看起来更舒服，也应该遵循一定的规范。</p>
<p>这里推荐一个 GitHub 上的排版指南：<a href="https://github.com/studygolang/GCTT/blob/master/chinese-copywriting-guidlines.md" target="_blank" rel="noopener">《中文文案排版指北》</a>
，它的宗旨，统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。这个规范开头关于空格的一段话很有意思：</p>
<blockquote>
<p>有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。</p>
</blockquote>
<p>建议大家可以看看这个指北，一些知名的网站就是按照这个做的。</p>
<p>因为 GCTT 的排版在这个规范做，但人为约束不是最好的方法，所以我开发了一个 Go 工具：<a href="https://github.com/studygolang/autocorrect">https://github.com/studygolang/autocorrect</a>，用于自动给中英文之间加入合理的空格并纠正专用名词大小写。</p>
<p>所以为了让字数统计更准确，我们假定文章是按一定的规范书写的。比如上面的例子，规范的写法是 <code>s2 := &quot;Hello, playground&quot;</code>。不过这里标点不算作字数。</p>
<p>刚去微博上试了一下，发现微博的字数计算方式有点诡异，竟然是 9 个字。</p>
<p><p class="md__image">
  <img src="../imgs/stat-words-weibo.png"
    alt=""  />
</p>
</p>
<p>测试一下发现，它直接把两个英文字母算作一个字（两个字节算一个字）。而汉字是正常的。大家可以想想微博是怎么实现的。</p>
<h3 id="中英文混合">中英文混合</h3>
<p>中文不像英文，单词之间没有空格分隔，因此开始的那两种方式不适合。</p>
<p>如果是纯中文，我们怎么计算字数呢？</p>
<p>在 Go 语言中，字符串使用 UTF-8 编码，一个字符用 rune 表示。因此在标准库中查找相关计算方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RuneCountInString</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></div><p>这个方法能计算字符串包含的 rune（字符）数，对于纯中文，就是汉字数。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">str</span> <span class="o">:=</span> <span class="s">&#34;你好世界&#34;</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">utf8</span><span class="p">.</span><span class="nf">RuneCountInString</span><span class="p">(</span><span class="nx">str</span><span class="p">))</span>
</code></pre></div><p>以上代码输出 4。</p>
<p>然而，因为很多时候文章会中英文混合，因此我们先采用上面的纯英文的处理方式，即：<code>strings.Fields()</code>，将文章用空格分隔，然后处理每一部分。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TotalWords</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">wordCount</span> <span class="o">:=</span> <span class="mi">0</span>
  
	<span class="nx">plainWords</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">plainWords</span> <span class="p">{</span>
		<span class="nx">runeCount</span> <span class="o">:=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nf">RuneCountInString</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span> <span class="o">==</span> <span class="nx">runeCount</span> <span class="p">{</span>
			<span class="nx">wordCount</span><span class="o">++</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">wordCount</span> <span class="o">+=</span> <span class="nx">runeCount</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">wordCount</span>
<span class="p">}</span>
</code></pre></div><p>增加如下的测试用例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">TestTotalWords</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tests</span> <span class="o">:=</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">name</span>  <span class="kt">string</span>
		<span class="nx">input</span> <span class="kt">string</span>
		<span class="nx">want</span>  <span class="kt">int</span>
	<span class="p">}{</span>
		<span class="p">{</span><span class="s">&#34;en1&#34;</span><span class="p">,</span> <span class="s">&#34;hello,playground&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;en2&#34;</span><span class="p">,</span> <span class="s">&#34;hello, playground&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;cn1&#34;</span><span class="p">,</span> <span class="s">&#34;你好世界&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;encn1&#34;</span><span class="p">,</span> <span class="s">&#34;Hello你好世界&#34;</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
		<span class="p">{</span><span class="s">&#34;encn2&#34;</span><span class="p">,</span> <span class="s">&#34;Hello 你好世界&#34;</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tt</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tests</span> <span class="p">{</span>
		<span class="nx">t</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">tt</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">got</span> <span class="o">:=</span> <span class="nx">wordscount</span><span class="p">.</span><span class="nf">TotalWords</span><span class="p">(</span><span class="nx">tt</span><span class="p">.</span><span class="nx">input</span><span class="p">);</span> <span class="nx">got</span> <span class="o">!=</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">want</span> <span class="p">{</span>
				<span class="nx">t</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;TotalWords() = %v, want %v&#34;</span><span class="p">,</span> <span class="nx">got</span><span class="p">,</span> <span class="nx">tt</span><span class="p">.</span><span class="nx">want</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">})</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>发现 en1 和 encn1 测试不通过，因为没有按照上面说的规范书写。因此我们通过程序增加必要的空格。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AutoSpace 自动给中英文之间加上空格
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AutoSpace</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">out</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">str</span> <span class="p">{</span>
		<span class="nx">out</span> <span class="p">=</span> <span class="nf">addSpaceAtBoundary</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">out</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">addSpaceAtBoundary</span><span class="p">(</span><span class="nx">prefix</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">nextChar</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="nx">nextChar</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">r</span><span class="p">,</span> <span class="nx">size</span> <span class="o">:=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nf">DecodeLastRuneInString</span><span class="p">(</span><span class="nx">prefix</span><span class="p">)</span>
	<span class="k">if</span> <span class="nf">isLatin</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="o">!=</span> <span class="nf">isLatin</span><span class="p">(</span><span class="nx">utf8</span><span class="p">.</span><span class="nf">RuneLen</span><span class="p">(</span><span class="nx">nextChar</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		<span class="nf">isAllowSpace</span><span class="p">(</span><span class="nx">nextChar</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">isAllowSpace</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">prefix</span> <span class="o">+</span> <span class="s">&#34; &#34;</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">nextChar</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">prefix</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">nextChar</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">isLatin</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">isAllowSpace</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">!</span><span class="nx">unicode</span><span class="p">.</span><span class="nf">IsSpace</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">unicode</span><span class="p">.</span><span class="nf">IsPunct</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这样可以在 TotalWords 函数开头增加 AutoSpace 进行规范化。这时结果就正常了。</p>
<h3 id="处理标点和其他类型">处理标点和其他类型</h3>
<p>以上例子标点没计算在内，而且如果英文和中文标点混合在一起，情况又复杂了。</p>
<p>为了更好地实现开始的需求分析，重构以上代码，设计如下的结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Counter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Total</span>     <span class="kt">int</span> <span class="c1">// 总字数 = Words + Puncts
</span><span class="c1"></span>	<span class="nx">Words</span>     <span class="kt">int</span> <span class="c1">// 只包含字符数
</span><span class="c1"></span>	<span class="nx">Puncts</span>    <span class="kt">int</span> <span class="c1">// 标点数
</span><span class="c1"></span>	<span class="nx">Links</span>     <span class="kt">int</span> <span class="c1">// 链接数
</span><span class="c1"></span>	<span class="nx">Pics</span>      <span class="kt">int</span> <span class="c1">// 图片数
</span><span class="c1"></span>	<span class="nx">CodeLines</span> <span class="kt">int</span> <span class="c1">// 代码行数
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>同时将 TotalWords 重构为 Counter 的 Stat 方法，同时记录标点数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">wc</span> <span class="o">*</span><span class="nx">Counter</span><span class="p">)</span> <span class="nf">Stat</span><span class="p">(</span><span class="nx">str</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">wc</span><span class="p">.</span><span class="nx">Links</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rxStrict</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
	<span class="nx">wc</span><span class="p">.</span><span class="nx">Pics</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">imgReg</span><span class="p">.</span><span class="nf">FindAllString</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

	<span class="c1">// 剔除 HTML
</span><span class="c1"></span>	<span class="nx">str</span> <span class="p">=</span> <span class="nf">StripHTML</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>

	<span class="nx">str</span> <span class="p">=</span> <span class="nf">AutoSpace</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>

	<span class="c1">// 普通的链接去除（非 HTML 标签链接）
</span><span class="c1"></span>	<span class="nx">str</span> <span class="p">=</span> <span class="nx">rxStrict</span><span class="p">.</span><span class="nf">ReplaceAllString</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span>
	<span class="nx">plainWords</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Fields</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">plainWord</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">plainWords</span> <span class="p">{</span>
		<span class="nx">words</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">FieldsFunc</span><span class="p">(</span><span class="nx">plainWord</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">unicode</span><span class="p">.</span><span class="nf">IsPunct</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">wc</span><span class="p">.</span><span class="nx">Puncts</span><span class="o">++</span>
				<span class="k">return</span> <span class="kc">true</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">})</span>

		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">word</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">words</span> <span class="p">{</span>
			<span class="nx">runeCount</span> <span class="o">:=</span> <span class="nx">utf8</span><span class="p">.</span><span class="nf">RuneCountInString</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">word</span><span class="p">)</span> <span class="o">==</span> <span class="nx">runeCount</span> <span class="p">{</span>
				<span class="nx">wc</span><span class="p">.</span><span class="nx">Words</span><span class="o">++</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">wc</span><span class="p">.</span><span class="nx">Words</span> <span class="o">+=</span> <span class="nx">runeCount</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">wc</span><span class="p">.</span><span class="nx">Total</span> <span class="p">=</span> <span class="nx">wc</span><span class="p">.</span><span class="nx">Words</span> <span class="o">+</span> <span class="nx">wc</span><span class="p">.</span><span class="nx">Puncts</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">rxStrict</span> <span class="p">=</span> <span class="nx">xurls</span><span class="p">.</span><span class="nf">Strict</span><span class="p">()</span>
	<span class="nx">imgReg</span>   <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nf">MustCompile</span><span class="p">(</span><span class="s">`&lt;img [^&gt;]*&gt;`</span><span class="p">)</span>
	<span class="nx">stripHTMLReplacer</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">NewReplacer</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">,</span> <span class="s">&#34;&lt;/p&gt;&#34;</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">,</span> <span class="s">&#34;&lt;br&gt;&#34;</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">,</span> <span class="s">&#34;&lt;br /&gt;&#34;</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">// StripHTML accepts a string, strips out all HTML tags and returns it.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">StripHTML</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="c1">// Shortcut strings with no tags in them
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">ContainsAny</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;&lt;&gt;&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">s</span>
	<span class="p">}</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nx">stripHTMLReplacer</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

	<span class="c1">// Walk through the string removing all tags
</span><span class="c1"></span>	<span class="nx">b</span> <span class="o">:=</span> <span class="nf">GetBuffer</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nf">PutBuffer</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">inTag</span><span class="p">,</span> <span class="nx">isSpace</span><span class="p">,</span> <span class="nx">wasSpace</span> <span class="kt">bool</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">inTag</span> <span class="p">{</span>
			<span class="nx">isSpace</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">r</span> <span class="o">==</span> <span class="sc">&#39;&lt;&#39;</span><span class="p">:</span>
			<span class="nx">inTag</span> <span class="p">=</span> <span class="kc">true</span>
		<span class="k">case</span> <span class="nx">r</span> <span class="o">==</span> <span class="sc">&#39;&gt;&#39;</span><span class="p">:</span>
			<span class="nx">inTag</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">case</span> <span class="nx">unicode</span><span class="p">.</span><span class="nf">IsSpace</span><span class="p">(</span><span class="nx">r</span><span class="p">):</span>
			<span class="nx">isSpace</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="k">fallthrough</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">inTag</span> <span class="o">&amp;&amp;</span> <span class="p">(!</span><span class="nx">isSpace</span> <span class="o">||</span> <span class="p">(</span><span class="nx">isSpace</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">wasSpace</span><span class="p">))</span> <span class="p">{</span>
				<span class="nx">b</span><span class="p">.</span><span class="nf">WriteRune</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">wasSpace</span> <span class="p">=</span> <span class="nx">isSpace</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>代码过多的细节不讨论。此外，关于文章内的代码行数统计未实现（目前没有想到特别好的方法，如果你有，欢迎交流）。</p>
<h2 id="03-总结">03 总结</h2>
<p>通过本文的分析发现，精准统计字数没那么容易，这里涉及到很多的细节。</p>
<p>当然，实际应用中，字数不需要那么特别精准，而且对于非正常文字（比如链接、代码）怎么处理，会有不同的约定。</p>
<p>本文涉及到的完整代码放在 GitHub：<a href="https://github.com/polaris1119/wordscount">https://github.com/polaris1119/wordscount</a>。</p>
]]></content>
		</item>
		
		<item>
			<title>我为什么运营微信公众号</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/why-wechat/</link>
			<pubDate>Mon, 11 Jan 2021 20:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/why-wechat/</guid>
			<description>大家好，我是站长 polarisxu。 这个话题有些人可能不喜欢，但我近期发现，越来越多的 Gopher 开始注册自己的微信公众号了，有些甚至花钱购买留言号。虽然我不是公众号运营的牛人，但这一两年还是有一些心得，因此写一些关于微信公众号的文章，希望对刚入门的 Gopher 有所帮助。 今天先谈谈我为什么运营微信公众号。 虽然 Go 语言中文网公众号很早就注册了（2014 年），但一直没有怎么运营。直到</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这个话题有些人可能不喜欢，但我近期发现，越来越多的 Gopher 开始注册自己的微信公众号了，有些甚至花钱购买留言号。虽然我不是公众号运营的牛人，但这一两年还是有一些心得，因此写一些关于微信公众号的文章，希望对刚入门的 Gopher 有所帮助。</p>
<p>今天先谈谈我为什么运营微信公众号。</p>
<p>虽然 Go 语言中文网公众号很早就注册了（2014 年），但一直没有怎么运营。直到 2018 年，因为 GCTT 的原因，组织了一些自愿者将翻译的文章发布到公众号，那时候粉丝 8k 左右，工作日几乎每天都发布，一直到 2019 年中旬，粉丝增长比较缓慢，平均阅读基本在 1000 以下。那时基本属于佛系运营。</p>
<p>因为阅读量和粉丝增长缓慢，我决定自己运营。</p>
<p>我自己运营后，开始日更。</p>
<p>很多人应该知道，微信公众号文章的标题很重要。自愿者运营，基本只是简单的搬运，我自己运营后，开始琢磨标题，琢磨公众号运营涨粉的事情。</p>
<p>随着公众号粉丝和阅读量的增加，运营的动力更足：有自己的粉丝，写的内容有不少人看，这在很多平台是得不到的。所以运营公众号能得到自我满足。</p>
<p>但毫不隐晦的说，日更的主要动力在于公众号有收入。Go 语言中文网公众号到一定粉丝后，有广告主主动找我投广告。虽然不是因为赚钱而运营的公众号，但赚钱成了自然而然的事情。至于能赚到多少钱，以后再谈！</p>
<p>运营公众号的第三点，因为要输出会督促自己不断输入。一方面，为了将文章写的更好，会尝试不断提升自己的写作水平；另一方面，为了输出高质量文章，需要不断输入技术知识，而且这个输入会让你比一般时候更细心。将输入输出，会有自己的加工过程，加工处理的过程会让你对某个知识掌握的更牢靠。如果只是输入没有输出，这个输入大概率很快就归还了。</p>
<p>最后一点，公众号可以更好的统计自己的输出情况。以下是 「polarisxu」这个号 2020 年的数据情况（从 2020 年 6 月份开始）：</p>
<ul>
<li>累计 18 万阅读；991 在看；</li>
<li>有 107 天发布了文章，一共发布了 114 篇，其中 90 篇声明了原创；</li>
<li><a href="https://mp.weixin.qq.com/s/w0_cur6qrwlcmplDoD1a4w" target="_blank" rel="noopener">《从来没有这么强烈想推荐一个工具》</a>
 这篇文章阅读量最高：4965 阅读，29 在看；</li>
<li>2020 年发布的文章一共有 46.2 万字，总阅读时长大概 962 分钟；</li>
</ul>
<p>还可以看到很多其他数据，这些都是对自己一个很好的总结。</p>
<p>总结一下，我认为运营公众号至少有以下收获：</p>
<ol>
<li>获得自我满足，实现自我价值；</li>
<li>获得额外收入，运营的好，这个收入不菲；</li>
<li>促进自己输入，鞭策提升自己，以便更好地输出；</li>
<li>一目了然的知晓自己的产出统计数据，很有成就感；</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>基于 Go1.16 实现静态文件的 HTTP Cache</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/hashfs-http-cache/</link>
			<pubDate>Sun, 10 Jan 2021 22:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/hashfs-http-cache/</guid>
			<description>大家好，我是站长 polarisxu。 之前写过一篇文章：《提前试用将在 Go1.16 中发布的内嵌静态资源功能》 ，如果之前没阅读，建议继续看本文前先阅读下该文。 现在 Go 1.16 Beta 已经发布，离正式版发布不远了，在 GitHub 发现了一个库，它实现了 io/fs.FS 接口，它能够计算文件的 SHA256 哈希值并附加到文件名中以允许进行 HTTP Cache：即控制静态文件的版本。本文对其进行介绍并顺带讲解一些涉及到的其他内容。 温馨提示</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>之前写过一篇文章：<a href="https://mp.weixin.qq.com/s/SiCTV7R2wA_I2nCQkC3GGQ" target="_blank" rel="noopener">《提前试用将在 Go1.16 中发布的内嵌静态资源功能》</a>
，如果之前没阅读，建议继续看本文前先阅读下该文。</p>
<p>现在 Go 1.16 Beta 已经发布，离正式版发布不远了，在 GitHub 发现了一个库，它实现了 io/fs.FS 接口，它能够计算文件的 SHA256 哈希值并附加到文件名中以允许进行 HTTP Cache：即控制静态文件的版本。本文对其进行介绍并顺带讲解一些涉及到的其他内容。</p>
<blockquote>
<p>温馨提示：本文内容基于 Go 1.16 Beta，之前版本不支持！</p>
</blockquote>
<h2 id="01-hashfs-包">01 hashfs 包</h2>
<p>包地址：<a href="https://github.com/benbjohnson/hashfs">https://github.com/benbjohnson/hashfs</a>，有效代码函数不到 200。</p>
<p>对于给定的一个文件，比如 scripts/main.js，hashfs.FS 文件系统处理后会生成一个带 hash 的文件，类似 scripts/main-b633a..d628.js（中间有省略），客户端请求该文件时，可以选择让客户端缓存。hash 算法使用的是 SHA256。当文件内容发生变化时，hash 值也会变。</p>
<p>该包默认提供对 net/http 的兼容。通过例子看看具体怎么使用。</p>
<h2 id="02-基于-nethttp-的使用">02 基于 net/http 的使用</h2>
<p>创建一个目录，使用 module：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ mkdir ~/embed
$ <span class="nb">cd</span> ~/embed
$ go mod init gtihub.com/polaris1119/embed
</code></pre></div><p>为了基于同一个项目演示不同使用方式，创建如下目录结构：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">├── cmd
│   ├── std
│   │   └── main.go
├── embed.go
├── go.mod
├── go.sum
├── static
│   └── main.js	// 主要处理该文件的嵌入、hash
├── template
│   └── index.html
</code></pre></div><p>其中 embed.go 的作用在本文开头文章提到过，内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">embed</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;embed&#34;</span>

	<span class="s">&#34;github.com/benbjohnson/hashfs&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">embedFS</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="c1">// 带 hash 功能的 fs.FS
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">Fsys</span> <span class="p">=</span> <span class="nx">hashfs</span><span class="p">.</span><span class="nf">NewFS</span><span class="p">(</span><span class="nx">embedFS</span><span class="p">)</span>
</code></pre></div><blockquote>
<p>再说一句，因为 //go:embed 只能相对当前源文件所在目录，所以单独创建这个文件以便和 static 在同一级目录。</p>
</blockquote>
<p>index.html 和 main.js 的内容很简单。</p>
<p>index.html：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>测试 Embed Hash<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;/assets/{{.mainjs}}&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>测试 Embed Hash<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">hr</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
      以下内容来自 JS：
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;content&#34;</span> <span class="na">style</span><span class="o">=</span><span class="s">&#34;color: red;&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><p>该模板中有一个变量：mainjs。</p>
<p>main.js：</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s1">&#39;#content&#39;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="s2">&#34;我是 JS 内容&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>如果一切正常，看到的页面如下：</p>
<p><p class="md__image">
  <img src="../imgs/hashfs.png"
    alt=""  />
</p>
</p>
<p>在 cmd/std/main.go 中写上如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;html/template&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/benbjohnson/hashfs&#34;</span>
	<span class="s">&#34;github.com/polaris1119/embed&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/assets/&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">StripPrefix</span><span class="p">(</span><span class="s">&#34;/assets/&#34;</span><span class="p">,</span> <span class="nx">hashfs</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">)))</span>

	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">tpl</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;index.html&#34;</span><span class="p">).</span><span class="nf">ParseFiles</span><span class="p">(</span><span class="s">&#34;template/index.html&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">err</span> <span class="p">=</span> <span class="nx">tpl</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
			<span class="s">&#34;mainjs&#34;</span><span class="p">:</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">HashName</span><span class="p">(</span><span class="s">&#34;static/main.js&#34;</span><span class="p">),</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">})</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>特意为静态资源加上 <code>/assets/</code> 前缀，后文解释；</li>
<li><code>hashfs.FileServer(embed.Fsys))</code> 是 hashfs 包对 net/http 的支持，即 hashfs.FileServer 是一个 http.Handler；</li>
<li><code>embed.Fsys.HashName(&quot;static/main.js&quot;)</code> 将文件生成为带 hash 的；</li>
</ul>
<p>执行 <code>go run ./cmd/std/main.go</code>，打开浏览器访问：http://localhost:8080 即可看到上面截图的页面，审查元素可以看到如下信息，缓存一年。（见代码：<a href="https://github.com/benbjohnson/hashfs/blob/main/hashfs.go#L200">https://github.com/benbjohnson/hashfs/blob/main/hashfs.go#L200</a>）</p>
<p><p class="md__image">
  <img src="../imgs/hashfs01.png"
    alt=""  />
</p>
</p>
<p>当你再次刷新浏览器，看到 js 文件直接从缓存获取的。</p>
<p><p class="md__image">
  <img src="../imgs/hashfs02.png"
    alt=""  />
</p>
</p>
<p>当 main.js 的内容发生变化，main-xxx.js 中的 hash 部分也会变化，你可以自行试验。（注意，因为资源内嵌了，修改了 js 的内容，需要重新 go run）。</p>
<h2 id="03-关于服务静态文件">03 关于服务静态文件</h2>
<p>这块有必要单独拿出来说下，因为比较容易搞错。比如上面的一行代码改为这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/assets&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">StripPrefix</span><span class="p">(</span><span class="s">&#34;/assets&#34;</span><span class="p">,</span> <span class="nx">hashfs</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">)))</span>
</code></pre></div><p>再次运行结果就不对（没有 “我是 JS 内容”）。（注意禁用浏览器缓存，否则看不到效果）</p>
<p>如果是 Echo 框架，则可以：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">Static</span><span class="p">(</span><span class="s">&#34;/assets&#34;</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">)</span>
</code></pre></div><p>Gin 框架，也可以：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">router</span><span class="p">.</span><span class="nf">Static</span><span class="p">(</span><span class="s">&#34;/assets&#34;</span><span class="p">,</span> <span class="s">&#34;.&#34;</span><span class="p">)</span>
</code></pre></div><p>关于其中的细节，大家有兴趣可以查阅相关源码。这里只要记住，服务目录，末尾加上 <code>/</code>，（目录嘛，应该有 <code>/</code>），即：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/assets/&#34;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</code></pre></div><h2 id="04-基于-echo-的使用">04 基于 Echo 的使用</h2>
<p>在 cmd 目录下创建 echo/main.go 文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;mime&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;net/url&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;path&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;text/template&#34;</span>

	<span class="s">&#34;github.com/benbjohnson/hashfs&#34;</span>
	<span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
	<span class="s">&#34;github.com/polaris1119/embed&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/assets/*&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">filename</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">PathUnescape</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;*&#34;</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="nx">isHashed</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">hashfs</span><span class="p">.</span><span class="nf">ParseName</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">hash</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">HashName</span><span class="p">(</span><span class="nx">base</span><span class="p">)</span> <span class="o">==</span> <span class="nx">filename</span> <span class="p">{</span>
				<span class="nx">filename</span> <span class="p">=</span> <span class="nx">base</span>
				<span class="nx">isHashed</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrNotFound</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrInternalServerError</span>
		<span class="p">}</span>
		<span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

		<span class="c1">// Fetch file info. Disallow directories from being displayed.
</span><span class="c1"></span>		<span class="nx">fi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Stat</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrInternalServerError</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">fi</span><span class="p">.</span><span class="nf">IsDir</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrForbidden</span>
		<span class="p">}</span>

		<span class="nx">contentType</span> <span class="o">:=</span> <span class="s">&#34;text/plain&#34;</span>
		<span class="c1">// Determine content type based on file extension.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ext</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Ext</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">ext</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">contentType</span> <span class="p">=</span> <span class="nx">mime</span><span class="p">.</span><span class="nf">TypeByExtension</span><span class="p">(</span><span class="nx">ext</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Cache the file aggressively if the file contains a hash.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">isHashed</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">Response</span><span class="p">().</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Cache-Control&#34;</span><span class="p">,</span> <span class="s">`public, max-age=31536000`</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Set content length.
</span><span class="c1"></span>		<span class="nx">ctx</span><span class="p">.</span><span class="nf">Response</span><span class="p">().</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Length&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">fi</span><span class="p">.</span><span class="nf">Size</span><span class="p">(),</span> <span class="mi">10</span><span class="p">))</span>

		<span class="c1">// Flush header and write content.
</span><span class="c1"></span>		<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">().</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;HEAD&#34;</span> <span class="p">{</span>
			<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Blob</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">contentType</span><span class="p">,</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">tpl</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;index.html&#34;</span><span class="p">).</span><span class="nf">ParseFiles</span><span class="p">(</span><span class="s">&#34;template/index.html&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="kd">var</span> <span class="nx">buf</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">tpl</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
			<span class="s">&#34;mainjs&#34;</span><span class="p">:</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">HashName</span><span class="p">(</span><span class="s">&#34;static/main.js&#34;</span><span class="p">),</span>
		<span class="p">})</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">HTML</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>服务静态文件的代码： <code>e.GET(&quot;/assets/*&quot;, func(ctx echo.Context) error {</code>，主要参照了 <a href="https://github.com/benbjohnson/hashfs/blob/main/hashfs.go#L162">https://github.com/benbjohnson/hashfs/blob/main/hashfs.go#L162</a> 的实现；</li>
<li>首页的路由和 net/http 基本一样，关注 mainjs 模板变量；</li>
</ul>
<p>简单解释下服务静态文件的实现原理：</p>
<ul>
<li>获取请求的路径（<code>*</code> 部分）;</li>
<li>通过 hashfs.ParseName 解析出文件的 base 和 hash 两部分；</li>
<li>使用 fs.FS 打开文件，判断文件类型、大小，并将内容返回给客户端，如果有缓存，设置 HTTP Cache；</li>
</ul>
<p>运行 go run ./cmd/echo/main.go，不出意外和 net/http 版本一样的效果。</p>
<h2 id="05-基于-gin-的使用">05 基于 Gin 的使用</h2>
<p>其实知道了如何基于 Echo 框架使用，其他框架参照着实现即可。因为 Gin 框架用户多，因此也实现下。</p>
<p>在 cmd 目录下创建文件：gin/main.go</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;mime&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;net/url&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;path&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;strings&#34;</span>

	<span class="s">&#34;github.com/benbjohnson/hashfs&#34;</span>
	<span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
	<span class="s">&#34;github.com/polaris1119/embed&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>

	<span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/assets/*filepath&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">filename</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">url</span><span class="p">.</span><span class="nf">PathUnescape</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Param</span><span class="p">(</span><span class="s">&#34;filepath&#34;</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">filename</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">TrimPrefix</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span> <span class="s">&#34;/&#34;</span><span class="p">)</span>

		<span class="nx">isHashed</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">if</span> <span class="nx">base</span><span class="p">,</span> <span class="nx">hash</span> <span class="o">:=</span> <span class="nx">hashfs</span><span class="p">.</span><span class="nf">ParseName</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">hash</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">HashName</span><span class="p">(</span><span class="nx">base</span><span class="p">)</span> <span class="o">==</span> <span class="nx">filename</span> <span class="p">{</span>
				<span class="nx">filename</span> <span class="p">=</span> <span class="nx">base</span>
				<span class="nx">isHashed</span> <span class="p">=</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsNotExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusNotFound</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

		<span class="c1">// Fetch file info. Disallow directories from being displayed.
</span><span class="c1"></span>		<span class="nx">fi</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Stat</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">fi</span><span class="p">.</span><span class="nf">IsDir</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nf">AbortWithError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusForbidden</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>

		<span class="nx">contentType</span> <span class="o">:=</span> <span class="s">&#34;text/plain&#34;</span>
		<span class="c1">// Determine content type based on file extension.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ext</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Ext</span><span class="p">(</span><span class="nx">filename</span><span class="p">);</span> <span class="nx">ext</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="nx">contentType</span> <span class="p">=</span> <span class="nx">mime</span><span class="p">.</span><span class="nf">TypeByExtension</span><span class="p">(</span><span class="nx">ext</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Cache the file aggressively if the file contains a hash.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">isHashed</span> <span class="p">{</span>
			<span class="nx">ctx</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Cache-Control&#34;</span><span class="p">,</span> <span class="s">`public, max-age=31536000`</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// Set content length.
</span><span class="c1"></span>		<span class="nx">ctx</span><span class="p">.</span><span class="nx">Writer</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Length&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">FormatInt</span><span class="p">(</span><span class="nx">fi</span><span class="p">.</span><span class="nf">Size</span><span class="p">(),</span> <span class="mi">10</span><span class="p">))</span>

		<span class="c1">// Flush header and write content.
</span><span class="c1"></span>		<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">Request</span><span class="p">.</span><span class="nx">Method</span> <span class="o">!=</span> <span class="s">&#34;HEAD&#34;</span> <span class="p">{</span>
			<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">ctx</span><span class="p">.</span><span class="nf">Data</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">contentType</span><span class="p">,</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
	<span class="p">})</span>

	<span class="nx">r</span><span class="p">.</span><span class="nf">LoadHTMLGlob</span><span class="p">(</span><span class="s">&#34;template/*&#34;</span><span class="p">)</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">ctx</span><span class="p">.</span><span class="nf">HTML</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;index.html&#34;</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span><span class="p">{</span>
			<span class="s">&#34;mainjs&#34;</span><span class="p">:</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">Fsys</span><span class="p">.</span><span class="nf">HashName</span><span class="p">(</span><span class="s">&#34;static/main.js&#34;</span><span class="p">),</span>
		<span class="p">})</span>
	<span class="p">})</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>服务静态文件的内容和 Echo 框架基本一样，除了各自框架特有的。</p>
<blockquote>
<p>因为 Gin 框架提供了 LoadHTMLGlob，首页路由的处理函数代码很简单。</p>
</blockquote>
<p>运行 go run ./cmd/gin/main.go，不出意外和 net/http 版本一样的效果。</p>
<h2 id="06-总结">06 总结</h2>
<p>举一反三，在学习过程中可以让你更好的掌握某个知识点。</p>
<p>之前有读者问到 module 如何使用 vendor（没网情况下使用）。今天试验这个就是用了 vendor。其实它的使用很简单，在项目下执行：go mod vendor 即可。不过需要注意的是，加入了新的依赖，就应该执行一次 go mod vendor。</p>
<p>今天介绍的这个库在这个时代用到的可能性不高，不过也有可能会用得到。更重要的是希望这篇文章可以作为一个小项目实践下。希望你能从头自己编码实现。</p>
<p>另外还留了一个问题给你：index.html 文件没有内嵌，请你自己完成。（提示：html/template 增加了对 io/fs.Fs 的支持）</p>
<p>本项目完整代码：<a href="https://github.com/polaris1119/embed">https://github.com/polaris1119/embed</a>。</p>
]]></content>
		</item>
		
		<item>
			<title>从一份 2020 年大厂加班榜说起</title>
			<link>https://polarisxu.studygolang.com/posts/talk/2020-996-rank/</link>
			<pubDate>Tue, 05 Jan 2021 18:25:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/2020-996-rank/</guid>
			<description>大家好，我是站长 polarisxu。 这几天圈内讨论最多的事非 pdd 事件莫属，于是再一次引出 996 问题的讨论，这似乎是国内码农永远的痛？！ 新华网都发声了：（https://finance.sina.cn/tech/2021-01-05/detail-iiznezxt0681211.d.html） 互联网内卷真是不要太严重。 今天不再讨论 pdd 的事情。谈一下互联网加班的问题，因</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这几天圈内讨论最多的事非 pdd 事件莫属，于是再一次引出 996 问题的讨论，这似乎是国内码农永远的痛？！</p>
<p>新华网都发声了：（https://finance.sina.cn/tech/2021-01-05/detail-iiznezxt0681211.d.html）</p>
<p><p class="md__image">
  <img src="../imgs/996-xinhuanet.png"
    alt=""  />
</p>
</p>
<p>互联网内卷真是不要太严重。</p>
<p>今天不再讨论 pdd 的事情。谈一下互联网加班的问题，因为在群里里看到这样一张图片：</p>
<p><p class="md__image">
  <img src="../imgs/2020-996-rank.png"
    alt=""  />
</p>
</p>
<p>这是一份 2020 年大厂加班榜，据说数据是广大网友提交的。</p>
<p>我读者中应该有不少在以上大厂的，这个数据还算真实吗？！</p>
<p>我想借这份榜单谈谈我职场这么多年的一些体会。先说我几个经历的事情。</p>
<h2 id="01">01</h2>
<p>我研究生毕业后去的开心网，经历过开心“最恐怖”的加班时刻。当时因为人人网上市，开心压力很大，员工都理解。但公司做了一个决定：做上市前的冲刺，开全员会议，宣布一周 7 天工作制。。。宣布完，就有一些人提离职！</p>
<p>我那时候应该刚毕业，心里想着就是好好工作，提升自己。我印象中加班最狠的一次：凌晨 2 点上线。因为是一个全新的、大项目上线，上线必然会有问题需要处理。我记得处理到 4、5 点。然后回去睡了一会（因为住公司附近，走路上下班）。8 点多起床接着上班，因为白天用户更多，需要对可能的问题及时处理。也许真的是因为年轻，那两天，整个人飘飘的感觉，很兴奋，一点睡意都没有，但吃饭也很少，感觉不到饿。现在想想，其实挺可怕的。。。</p>
<p>当然，最后开心网上市计划泡汤了。当初宣布 7 天工作制就是一个错误的决定，基本上没执行下去不说，弄得大家很不舒服。</p>
<h2 id="02">02</h2>
<p>创业这么多年，期间自己角色也在变。从 360 离开，加入一个创业公司，是想体验下创业的感觉。那时候，公司每个人都是创业的心态，每天 9 点到公司，晚上基本没有 10 点之前下班过，一周 6 天，远远超过 996 了。而且周日在家，我基本也是随时处理问题。那时，我并没有觉得累。（说明下：北京上下班单程平均时间近 1 个小时，我差不多在这个水平。也就是说，每天基本 7 点 50 左右出门，晚上到家一般 23 点之后）</p>
<p>我经常想，是什么让我可以那么多精力投入在工作上而不会觉得累？！我现在觉得是对创业的新鲜感，对做成后可能的回报的憧憬，而且那时人员少，大家很简单，工作时间虽然长，但心情比较愉快，不会有领导 PUA。</p>
<h2 id="03">03</h2>
<p>后来，我成为了负责人，心态有一些不一样了。</p>
<p>因为我属于很守时类型的人，讨厌迟到，无论是读书时代还是工作，很少迟到。</p>
<p>当我是普通员工时，我做好自己，不太会关心别人是什么情况，迟不迟到跟我没关系。但当我是负责人时，看到下属迟到，一两次还好，经常迟到的，心里会很不舒服。我知道有些人虽然迟到了，但晚上下班也会比较晚。因此我总是安慰自己，要看到大家的好。</p>
<p>但我不是公司老板，公司老板如果看到我的团队总是迟到等，他会怎么想？要知道，很多老板更多看到的是问题。他会发现总有人迟到，而不是发现总有人加班。我一直希望给技术团队一个相对自由的时间、环境。所以，很多事情老板并不管。但有一个前提是大家做的不错。</p>
<p>实话说，关于工作时长，我是要求过团队的。为了避免老板干预我的团队，我自然需要作出一些要求。不过现在看，时间的要求跟榜单上比还是少了很多。难道这就是我们创业不成功的原因？哈哈哈~</p>
<hr>
<p>每个人都会焦虑！现在这个时代更是如此，更何况各种内卷严重。。。</p>
<ul>
<li>开心网当时那个状态、压力，老板肯定特别焦虑，压力很大。但通过全员 7 天工作制就能解决压力吗？老板的焦虑就没了吗？如果最后上市成功了，老板你什么回报，普通员工什么回报？而且不少员工应该是没有期权，还有不少有期权跟没有也没太多区别。这样的情况下，凭什么老板的焦虑要用员工的时间来分担。</li>
<li>自发的行为和强制是有本质区别的。如何让员工更自发的去奋斗？这也许是 HR 要长期思考的问题吧。</li>
<li>作为管理者或老板，看到员工的问题也许是无法避免的。但应该有同理心。为什么大家都说外企很轻松？难道轻松的外企就不优秀吗？前段时间看了微软第三任 CEO 萨提亚-纳德拉的《刷新：重新发现商业与未来》，对萨提亚反复强调的“同理心是微软企业文化的重要内容”印象深刻，微软在他的带领下取得了辉煌的成绩。</li>
</ul>
<p>借用新华网的话，奋斗不能只靠激情。年轻人要奋斗，要快乐的奋斗，健康的奋斗！</p>
]]></content>
		</item>
		
		<item>
			<title>2021 年了，你可能没注意到的微信公众号的一些变化</title>
			<link>https://polarisxu.studygolang.com/posts/wechat/2021-01-wechat-changes/</link>
			<pubDate>Mon, 04 Jan 2021 18:25:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/wechat/2021-01-wechat-changes/</guid>
			<description>大家好，我是站长 polarisxu。 2021 年计划聊一些微信公众号的事情。今天先聊聊微信公众号（订阅号）的一些变化，作为这个系列的开篇。 01 基础知识 先简单普及一些基础知识：订阅号和服务号，主要介绍下它们关键的一些不同点，着重介绍下订阅号的一些知识。 订阅号 如果你开通自己的公众号，一定是选择订阅号。个人主体只能注册订阅号，目前一个身份证只能注册一个订阅号（以前是 5 个）。</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>2021 年计划聊一些微信公众号的事情。今天先聊聊微信公众号（订阅号）的一些变化，作为这个系列的开篇。</p>
<h2 id="01-基础知识">01 基础知识</h2>
<p>先简单普及一些基础知识：订阅号和服务号，主要介绍下它们关键的一些不同点，着重介绍下订阅号的一些知识。</p>
<h3 id="订阅号">订阅号</h3>
<p>如果你开通自己的公众号，一定是选择订阅号。个人主体只能注册订阅号，目前一个身份证只能注册一个订阅号（以前是 5 个）。</p>
<p><strong>关于认证</strong></p>
<p>个人订阅号无法进行微信认证。前段时间微信灰度了个人认证，也就是下面这样：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes01.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes02.png"
    alt=""  />
</p>
</p>
<p>不过目前这个认证没有任何额外的功能，只是一个标识。</p>
<p>而企业（包括个体户）订阅号是支持微信认证的（一次 300 元，一年要认证一次）。认证了的企业订阅号，支持更多的接口功能，进行一些额外开发对接。同时，服务号只能企业注册，认证费用 300/次，一年一次。服务号可以开通微信支付。当然，服务号还有更多其他的能力。</p>
<blockquote>
<p>因为新注册公众号没有留言功能，如果你想购买，个人订阅号是不行的，必须是注册的企业订阅号，因为被迁移主体必须是认证的企业订阅号。具体这方面有疑问可以和我沟通，我这个号就是迁移得来的。</p>
</blockquote>
<p><strong>关于群发消息</strong></p>
<p>订阅号每天可以发送一次，每次条数不限制。服务号一个月可以发送 4 次，每次条数也不限制，为什么服务号一个月才能发送 4 次？下面你就会知道。</p>
<hr>
<p>在微信聊天列表，有一个订阅号消息，所有的订阅号（个人和非个人）都会在这里面；而服务号是在外面的，和普通好友聊天同级。比如「西贝莜面村」就是服务号。</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes03.png"
    alt=""  />
</p>
</p>
<p>正因为直接在消息列表中，因此微信限制了服务号一个月只能群发 4 次消息，避免恶意打扰用户。毕竟服务号的定位是提供功能服务，不是群发消息，比如提供下单服务。</p>
<h2 id="02-列表页的变化">02 列表页的变化</h2>
<p>细心的读者会发现，订阅号消息列表页最近有一些变化。</p>
<blockquote>
<p>有些人可能没留意，一个公众号的一次群发消息（不管多少篇文章）在订阅号消息列表中最多只会显示头条和次条，之后的都是折叠的。</p>
</blockquote>
<h3 id="头条样式">头条样式</h3>
<p>普通用户可能不会注意。以前订阅号消息列表页，各个公众号的消息头条显示样式有两种：</p>
<ul>
<li>样式一：常读公众号的样式</li>
</ul>
<p><p class="md__image">
  <img src="../imgs/2101-changes04.png"
    alt="样式一"  />
</p>
</p>
<ul>
<li>样式二：非常读公众号的样式。即不管头条还是非头条，标题和封面都是一样的显示方式。</li>
</ul>
<p><p class="md__image">
  <img src="../imgs/2101-changes05.png"
    alt=""  />
</p>
</p>
<p>但现在所有的消息都是样式一。不过单篇文章分享出去，封面永远是那个正方形样式。</p>
<p>这样对所有的号公平展示。</p>
<h3 id="单条消息样式">单条消息样式</h3>
<p>有些公众号一次只发送一条消息。之前的样式是这样的：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes06.png"
    alt=""  />
</p>
</p>
<p>封面、标题和摘要，在标题上方显示多少朋友读过。</p>
<p>现在是这样的：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes07.png"
    alt=""  />
</p>
</p>
<p>没有了摘要，多少朋友读过放在了摘要那。不过文章分享出去以及进入某个公众号里面看到的，摘要还是有的。</p>
<p>另外，据说有些人被灰度到了这样的样式：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes08.png"
    alt=""  />
</p>
</p>
<p>会直接显示阅读数、赞数，也许不显示摘要就是为这个做准备的吧。</p>
<blockquote>
<p>直接显示阅读数和赞数，靠标题党吸引阅读的，可能效果会比较差了。比如阅读数高，赞少，多半是标题党，用户可能就不点了？！</p>
</blockquote>
<h2 id="03-公众号主页的变化">03 公众号主页的变化</h2>
<p>没有截以前的图，直接看现在的样子：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes09.png"
    alt=""  />
</p>
</p>
<ul>
<li>
<p>增加了视频 Tab。内容是公众号的视频消息（单独群发的视频）。有点鼓励发视频了。比如视频号的视频也发到公众号。（因为我的号没发过视频，所以没有这个 Tab）</p>
</li>
<li>
<p>新增了服务 Tab。将原来的自定义菜单整合到此处，不过 callback 的菜单项不会显示。</p>
</li>
<li>
<p>取消关注位置变了。</p>
</li>
</ul>
<p>另外还有一个，即可将话题标签配置在公众号主页显示，如下图：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes10.png"
    alt=""  />
</p>
</p>
<p>最多可以配置 10 个。具体配置方法：登录 mp.weixin.qq.com，点击左侧 话题标签 菜单进行配置：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes11.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>微信在话题这个事情上越来越“微博化了”：公众号话题功能、朋友圈和微信群对 <code>#</code> 的支持，以及通过话题进行相关查询、推荐等。</p>
</blockquote>
<h2 id="04-文章详情的变化">04 文章详情的变化</h2>
<p>平时点赞的朋友应该发现，在公众号文章详情末尾，默认是这样的：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes12.png"
    alt=""  />
</p>
</p>
<p>只要你点了“赞”或“在看”，就变成了这样：</p>
<p><p class="md__image">
  <img src="../imgs/2101-changes13.png"
    alt=""  />
</p>
</p>
<p>但我真的想说：这个喜欢的推荐我基本都不喜欢，好吗？！推荐给你的，你喜欢吗？</p>
<h2 id="05-总结">05 总结</h2>
<p>以上就是近期我发现的一些微信公众号的变化。有些已经存在不短时间了，有些刚上线，很多人还没用上，而有些可能还在灰度测试中。希望本文对你有帮助，特别是还没设置主页标签的，可以设置一波了。</p>
]]></content>
		</item>
		
		<item>
			<title>2020 年终总结：希望对你有所帮助</title>
			<link>https://polarisxu.studygolang.com/posts/talk/2020-summary/</link>
			<pubDate>Thu, 31 Dec 2020 16:40:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/2020-summary/</guid>
			<description>大家好，我是站长 polarisxu。 第一次正式写年终总结，也许是一个好的开始，希望以后年年写。 可能每个年终总结都会感慨，2020 年是不平凡的一年，疫情持续了一年，原以为好些了，最近似乎有变严重了。大家多保重。口罩戴了一年，不知道什么时候才能去掉，希望这天早点到来。 年终总结，是对我自己的一个回顾，但发出来，我希望能够对大家有点帮助或启发。 这份总结主要会聊五个方</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>第一次正式写年终总结，也许是一个好的开始，希望以后年年写。</p>
<p>可能每个年终总结都会感慨，2020 年是不平凡的一年，疫情持续了一年，原以为好些了，最近似乎有变严重了。大家多保重。口罩戴了一年，不知道什么时候才能去掉，希望这天早点到来。</p>
<p>年终总结，是对我自己的一个回顾，但发出来，我希望能够对大家有点帮助或启发。</p>
<p>这份总结主要会聊五个方面的内容：</p>
<ul>
<li>写作</li>
<li>读书</li>
<li>创业</li>
<li>家庭</li>
<li>收获</li>
</ul>
<h2 id="01-写作">01 写作</h2>
<p>先聊聊写书。</p>
<h3 id="写书">写书</h3>
<p>2020 年最大的成绩就是出版了一本书。因为疫情，这个春节比往年都长，而且在家办公了一段时间，省去了路上的时间。当然最关键的还是，那段时间只有我和爱人在北京，使得我可以安心地写书。</p>
<p>目前这本书在豆瓣上的评分是 8.4 分，感谢大家的支持：<a href="https://book.douban.com/subject/35130972/">https://book.douban.com/subject/35130972/</a>。</p>
<p><p class="md__image">
  <img src="../imgs/2020-mywritebook.png"
    alt=""  />
</p>
</p>
<p>关于写书，有些人可能想问点什么。比如：</p>
<ul>
<li>赚了不少钱吧？</li>
<li>写书一种什么体验？</li>
<li>写书性价比高吗？</li>
<li>。。。</li>
</ul>
<p>首先，对大部分人来说（畅销书作者除外），写书赚的钱是很少的。其实大家可以算一笔账：</p>
<blockquote>
<p>假如一本书定价 100 元，一般版税 7%~8%，卖一本你得到 7 块钱，1 万本也才 7 万块钱，而实际上卖 1 万本真的挺难的。</p>
</blockquote>
<p>既然赚不了多少钱，为什么还有那么多人出书呢？</p>
<p>我的理解，因为出书相当于给自己做了背书。之前还听说，某大厂职级晋升，如果出了书会有加分。一般来说，一件事情的回报不会是单一的，我们不能只盯着眼前的，不能只盯着金钱的回报。张一鸣总是强调延迟满足感，字节跳动的小伙伴因此也总提这个，我觉得大家要学会把眼光看远。</p>
<p>所以，如果你有机会出书，别犹豫，干就对了。如果你觉得自己有这个能力出书，想出书，但不清楚相关的事情，欢迎和我交流。</p>
<h3 id="写文章">写文章</h3>
<p>大家应该见到过不少类似这样的文章：技术人应不应该写博客？</p>
<p>写博客文章和写书还是不一样的，写文章会更灵活，写书限制、要求都会更多。我个人觉得，如果你想将来出一本书，但觉得水平不够，可以先试试写一些博文，提升提升写作水平。当你写的多了，很可能出版社会主动找你哦。</p>
<p>回顾 2020 年，我陆陆续续写了 60+ 篇文章。2020 年之前写的文章还是比较少，在 2020 年中旬，我决定开一个自己的公众号，并花钱买了留言功能，也就是现在的 「polarisxu」。之前写的文章如果要在「Go语言中文网」公众号发布，只能限于 Go 相关，但有了个人的公众号，主题可以很随意。在职场打拼这么多年，加上这几个月看了一些非技术类的文章、图书，我觉得写下来的，不应该只有技术。所以接下来，除了分享技术，我还会分享非技术的内容。</p>
<p>另外，如果你计划写作，我个人建议可以开通自己的公众号，搞一个自己的博客。为什么搞两个？</p>
<ul>
<li>公众号读者粘性好，关注你了，你可以更好地触达他。目前我觉得公众号的粉丝是所有平台里价值最高的。</li>
<li>但公众号有一个问题，就是时效性，历史的文章很少有人看了。而博客可以借助搜索引擎，不断有流量，同时历史文章也更利于读者阅读。</li>
</ul>
<p>对公众号运营感兴趣的可以一起交流。</p>
<h2 id="02-读书">02 读书</h2>
<blockquote>
<p>没有什么问题是一本书解决不了的，如果有那就再来一本。。。</p>
</blockquote>
<p>大家都是读书人。学生时代，教科书读了不少，工作后，你读了多少书呢？书买了相当于看了：很多人热衷于买书，其实是好事，但只是热衷于买，多少就有点浪费了。</p>
<p>我自己买书比较少，一方面喜欢随时阅读，纸质图书不方便；另一方面，买了经常不读，内心有罪恶感。</p>
<p>2020 年中下旬，我开始使用微信读书。这里我个人强烈推荐「微信读书」：</p>
<ul>
<li>数字化时代，应该充分利用数字化。下个十年，预计能被数字化的都会被数字化。</li>
<li>通过微信读书，可以把你的阅读进行数字化，让你很容易进行数据统计：读完了哪几本书？每本书阅读了多长时间？每周阅读多长时间？做了多少笔记等等。微信读书还为你生成了年度读书报告。</li>
<li>根据你的兴趣，为你推荐你喜欢的书，相当于帮你找书。</li>
<li>可以方便的看到大家对这本书的评价，书中还会有别人的笔记。</li>
<li>书中引用的其他图书，可以直接点击，看看是否自己喜欢，加入书架等。</li>
<li>还可以听书，非技术类的，听书的效果还不错。</li>
<li>。。。</li>
</ul>
<p>半年来，我在微信读书读了 12 本图书，有些书是略读，有些书是精读：做了读书笔记。有一些还没有读完，正在阅读中。</p>
<p><p class="md__image">
  <img src="../imgs/2020-myreadbooks.png"
    alt=""  />
</p>
</p>
<p>这里推荐大家读一下樊登的《读懂一本书》，里面提到的一些方法有一定借鉴作用。</p>
<blockquote>
<p>注意：技术类的图书，特别是代码比较多的，微信读书的阅读体验可能会差些。</p>
</blockquote>
<p>2021 年也许会考虑写写读书心得。</p>
<p>对了，用微信读书，不代表说让你别买书了，有些书该买还得买。而且我一直认为，有些书买了不一定是用来读的：家里书架上满满的图书，是不是有种书香门第的感觉？我相信这对培养孩子读书的兴趣也是有帮助的。</p>
<h2 id="03-创业">03 创业</h2>
<p>关于创业，前段时间写过一篇短文。虽然创业了很多年，但因为一直没有做出什么成绩，所以这块不想说太多。</p>
<p>在上面读过的书中，有一本创业记，作者将自己创业的过程完完整整记录了下来，没有过创业经历的人可能对其中的内容不会有太多体会。创业的苦、创业的难，个中滋味只有自己最清楚。</p>
<p>2020 年，因为疫情，虽然产生很多新机会，比如在线教育大火。但受影响的企业真的很多。很多人可能没有什么体会，因为你没有丢工作。前段时间，公司准备换办公室，去望京 SOHO 那块看了一些办公室，空的办公室不少。据中介介绍，疫情影响真的挺大，空出了很多办公室，房租价格也是比之前低不少。可见，很多小公司在疫情期间活不下去，关门了。</p>
<p>回顾 2020 年，创业对我来说，相比之前还是有更多的收获，虽然业务没起来，但比之前经历了更多，从技术、产品、运营等纯线上的管理到仓配、采购等线下的业务流程和管理，接触了很多之前不熟悉的领域，无形中学到了不少新知识。</p>
<p>不知道关注我的人中有多少是在校生。我个人特别不建议毕业后就去一个创业公司。当然自己创业或跟着认识的人觉得特别靠谱的除外，毕竟选择大于努力。如果你对一个创业公司不了解（除非是你的熟人，否则很难了解），风险挺大的。虽然似乎拿到的钱不少（实际上不多，因为加上福利，基本和大公司是有差距的），但随时都有可能丢工作，特别是今年，大环境不好，被动换工作，结果真的挺惨。如果你没得选，只能进一个小公司，建议你找一个注重员工个人成长的公司，因为环境挺重要的。当然个人积极主动学习更重要。</p>
<h2 id="04-家庭">04 家庭</h2>
<p>因为创业，欠家庭还是挺多的。</p>
<p>关于家庭方面，2020 年有两件大事。</p>
<ul>
<li>
<p>住进了自己的小家，再也不用每年为房租涨价心烦，更不用为搬家发愁。</p>
</li>
<li>
<p>大女儿上小学了。</p>
</li>
</ul>
<p>但家家有一本难念的经。有一天晚上，媳妇对我说：大女儿说想自己一个人睡，希望有一个自己的房间，因为她同学有。</p>
<p>随着孩子一天天长大，这个愿望会越来越强烈，而且也应该给她一个独立的空间。作为父亲需要承担这个责任，为孩子早日实现愿望。。。然而在北京真的好难！</p>
<p>如果愿望一时半会实现不了，希望自己在周末能够多花些时间陪陪她们。</p>
<p>如果你跟我一样，全靠自己奋斗，类似的问题、苦恼大概迟早也会到来吧。所以，趁年轻、趁单身，提升自己，多赚点钱，让将来过的更好些。</p>
<h2 id="05-收获">05 收获</h2>
<p>关于收获，主要聊两方面。</p>
<h3 id="公众号">公众号</h3>
<p>上文提到，2020 年中（6 月 17 日）启用个人微信公众号，开始记录、分享我个人的学习、生活、工作和感想。因为这个号是基于之前「火丁笔记」的，自带了近 3.5k 粉丝。经过这半年的努力，涨了近 1.5 万粉丝。感谢大家的支持。</p>
<p>除了粉丝，运营公众号另外的收获就是能获得一定的收入回报。关于公众号运营的一些事情，2021 年计划写一些相关文章聊聊。</p>
<p>另外，上次发文说过，知乎有人给打理，收获了近 9 万粉丝。感谢有你！</p>
<h3 id="社区">社区</h3>
<p>这一年，Go 语言中文网网站的开发工作很少，但 GCTT 一直在产出，无闻大佬一直在帮校对，感谢大家。</p>
<p>回顾这一年，社区主要做了如下事情：</p>
<ul>
<li>Go官网的镜像 <a href="https://docs.studygolang.com">https://docs.studygolang.com</a> 启用新版，同时提供 playground、blog 等访问；</li>
<li>组织了一次重庆 gopher 聚餐；一次北京 gopher dinner；</li>
<li>为大家定制了 gopher 卫衣；</li>
<li>组织 Go 语言官网的翻译；</li>
<li>Go 语言中文网公众号每天为大家推送 Go 相关文章；</li>
<li>每周一期的《Go 语言爱好者周刊》；</li>
<li>开发上线了一版 Go 语言中文网小程序；</li>
<li>。。。</li>
</ul>
<p>当然最重要的是认识了更多的朋友：一些新认识的，一些之前没见过面见上了，一些有了更多的交流。。。</p>
<p>2021 年，希望 Go 语言中文网网站能给大家带来一些惊喜。</p>
<hr>
<p>一年了，你可能觉得自己没做什么，但只要你静下心来回顾，会发现做了不少事情，而且肯定有值得记录的。也许等你老了，回过头来看看自己的过往记录，回忆起过去的你，也算是一种幸福吧！</p>
<p>冯大说，每个人都应该阶段性对自己做一次梳理、总结，工作也好、生活也罢。其实，我的这份总结是不够的，因为缺少复盘和反思。但毕竟是公开的，自己反思的内容就先不放上了。建议你元旦可以为自己的生活、学习或工作写一份总结，至少工作上应该写一份，然后看情况发给你的 Leader，也许年终奖或来年加薪有惊喜也未可知！</p>
]]></content>
		</item>
		
		<item>
			<title>Go 1.16 的这个新变化需要适应下：go get 和 go install 的变化</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go-get-install/</link>
			<pubDate>Sun, 27 Dec 2020 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go-get-install/</guid>
			<description>大家好，我是站长 polarisxu。 一直以来，我们通常都是通过 go get 来下载并安装包的。但从 Go 1.16 起，不推荐通过 go get 来安装包（主要是说安装可执行文件），也就是说，go get 应该只是用来下载包，而且将来版本可能会给该命令始终加上 -d 标志。 你可能会问，这对我使用有什么影响呢？ 让我们看一个实际的例子。 01 安装 Delve 的例子 我们在本地通过源码安装 Go 的调试器 Delve，可以这么做： $ go get</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>一直以来，我们通常都是通过 <code>go get</code> 来下载并安装包的。但从 Go 1.16 起，不推荐通过 go get 来安装包（主要是说安装可执行文件），也就是说，go get 应该只是用来下载包，而且将来版本可能会给该命令始终加上 <code>-d</code> 标志。 你可能会问，这对我使用有什么影响呢？</p>
<p>让我们看一个实际的例子。</p>
<h2 id="01-安装-delve-的例子">01 安装 Delve 的例子</h2>
<p>我们在本地通过源码安装 Go 的调试器 Delve，可以这么做：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ go get github.com/go-delve/delve/cmd/dlv
</code></pre></div><p>因为 go get 会下载、编译并安装包（如果有 main 包）。</p>
<p>Go 1.16 建议这么使用 go get：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ go get -d github.com/go-delve/delve/cmd/dlv
</code></pre></div><p>这只会下载 delve，并不会构建和安装，而且将来 go get 只会用来下载。因此，你还需要手动执行安装。</p>
<h2 id="02-go-install-的变化">02 go install 的变化</h2>
<h3 id="gopath-年代">GOPATH 年代</h3>
<p>早在 GOPATH 年代，go install 的作用如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Install compiles and installs the packages named by the import paths.

The -i flag installs the dependencies of the named packages as well.
</code></pre></div><p>也就是说，go install 会将包编译成 <code>.a</code> 文件并安装到 <code>$GOPATH/pkg/$GOOS_$GOARCH</code> 下；如果是 main 包，会编译并生成可执行文件安装到 <code>$GOPATH/bin</code> 目录下（如果设置了 <code>$GOBIN</code>，则会安装到 <code>$GOBIN</code> 下 ）。这也是和 go build 不同之处。</p>
<h3 id="go-module-年代">Go Module 年代</h3>
<p>到了 Go Module 年代，情况发生了变化。大家似乎完全忘记了 go install 的存在（也有可能在 GOPATH 年代，大家就从来不用 go install），因为 go get、go build 就解决问题了。</p>
<p>特别是，从 Go Module 开始，工作目录没有了 src/pkg/bin 这三个目录，使得 go build 比 go install 更受欢迎。（GOPATH 年代，我更喜欢 go install，因为它会在项目生成和 GOROOT 一样的 src/pkg/bin，保持一致）。</p>
<p>看看 Module 年代，go install 命令的作用：（基于 Go1.15.x）</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Install compiles and installs the packages named by the import paths.

Executables are installed in the directory named by the GOBIN environment
variable, which defaults to <span class="nv">$GOPATH</span>/bin or <span class="nv">$HOME</span>/go/bin <span class="k">if</span> the GOPATH
environment variable is not set. Executables in <span class="nv">$GOROOT</span>
are installed in <span class="nv">$GOROOT</span>/bin or <span class="nv">$GOTOOLDIR</span> instead of <span class="nv">$GOBIN</span>.

When module-aware mode is disabled, other packages are installed in the
directory <span class="nv">$GOPATH</span>/pkg/<span class="nv">$GOOS_$GOARCH</span>. When module-aware mode is enabled,
other packages are built and cached but not installed.

The -i flag installs the dependencies of the named packages as well.
</code></pre></div><p>Module 没启用时，和 GOPATH 年代的作用是一样的。当启用 Module 模式时，go install 对普通包（非 main 包）不再安装（即没有了 <code>pkg/$GOOS_$GOARCH</code>），这和 go build 一样了。而对于 main 包，会将生成的可执行文件安装到 <code>$GOBIN</code> 目录下（<code>$GOBIN</code> 的默认值是 <code>$GOPATH/bin</code>，如果 <code>$GOPATH</code> 没有设置，则是 <code>$HOME/go/bin</code>）。</p>
<p>那么，Module 模式下，什么情况下你可能会使用 go install 呢？</p>
<p>如果你有这样的习惯会使用 go install。</p>
<blockquote>
<p>$GOBIN 在 PATH 环境变量下，这样，GOBIN 下面的可执行文件可以方便的运行。比如你的工作 module 是：github.com/polaris1119/test ，可以通过 <code>go install github.com/polaris1119/test</code> 将 test 安装到 GOBIN 下，然后直接执行 test 运行。</p>
</blockquote>
<h3 id="go-116-及以后">Go 1.16 及以后</h3>
<p>从 Go 1.16 起，go install 可以接受带有版本后缀的参数（例如 go install <a href="mailto:example.com/cmd@v1.0.0">example.com/cmd@v1.0.0</a>）。这将导致 go install 以模块感知模式构建和安装包，而忽略当前目录或任何父目录（如果有）中的 go.mod 文件。这对于在不影响主模块依赖性的情况下安装可执行文件很有用。</p>
<p>如本文开头提到的，go get 不建议用来构建和安装包了。</p>
<p>所以，Go 1.16 及以后，go get 和 go install 应该什么时候使用呢？</p>
<ul>
<li>如果要安装第三方库的可执行文件，比如上面的 Delve，使用 go install，但需要带上版本后缀，比如 @latest；（不清楚为什么设计成必须带上版本号）</li>
<li>普通的库，继续使用 go get，建议加上 -d 标志；</li>
</ul>
<p>注意，虽然 go install 一个普通的第三方包（不过必须带上版本后缀）也会下载对应的包，但不会修改 go.mod，这和 go get 是不同的。</p>
<h2 id="03-总结">03 总结</h2>
<p>总结一下这个变化：（Go 1.16 还不会有影响，将来就会有影响，所以可以提前习惯下）</p>
<ul>
<li>日常的开发，还和之前一样使用 go get 即可；</li>
<li>但如果是要源码安装一些第三方可执行文件，比如 vscode-go 插件依赖的可执行文件，则应该使用 go install；</li>
<li>如果你本地编译习惯了我文中提到的方式，继续使用 go install 即可，虽然绝大部分人喜欢使用 go build。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>详解 Go 中的环境变量</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/environment-variables-in-golang/</link>
			<pubDate>Sat, 26 Dec 2020 10:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/environment-variables-in-golang/</guid>
			<description>了解环境变量以及在 Golang 应用程序中使用它们的不同方法。 开始之前 本教程假定你具有： 对 Go 语言的基本了解 系统上安装了最新 Golang 版本 几分钟的时间 在本文中，我们将了解环境变量以及为什么要使用它们。并且将使用内置和第三方包在 Go 应用程序中访问它们。 什么是环境变量？ 环境变量是系统级的键-值对，正在运行的进程可以访问它。这些通常用于使同一程序在不同的部署环境（例如 PROD， DEV 或 TES</description>
			<content type="html"><![CDATA[<p>了解环境变量以及在 Golang 应用程序中使用它们的不同方法。</p>
<h2 id="开始之前">开始之前</h2>
<p>本教程假定你具有：</p>
<ul>
<li>对 Go 语言的基本了解</li>
<li>系统上安装了最新 Golang 版本</li>
<li>几分钟的时间</li>
</ul>
<p>在本文中，我们将了解环境变量以及为什么要使用它们。并且将使用内置和第三方包在 Go 应用程序中访问它们。</p>
<h2 id="什么是环境变量">什么是环境变量？</h2>
<p>环境变量是系统级的键-值对，正在运行的进程可以访问它。这些通常用于使同一程序在不同的部署环境（例如 PROD， DEV 或 TEST）中表现不同。在环境中存储配置是 twelve-factor 应用程序的原理之一。它使应用程序具有可移植性。</p>
<h2 id="为什么要使用环境变量">为什么要使用环境变量</h2>
<ul>
<li>如果您在代码中使用敏感信息，那么所有有权访问该代码的未授权用户都将拥有敏感数据，您可能不希望如此。</li>
<li>如果您使用的代码版本控制工具如：<code>git</code>，那么可能将 DB 凭据与代码一起推送，它将公开。</li>
<li>如果要在一处管理变量，则可以进行任何更改，而不必在应用程序代码中的所有位置都进行更改。</li>
<li>您可以管理多个部署环境，例如 PROD，DEV 或 TEST。在部署之间可以轻松更改环境变量，而无需更改任何应用程序代码。</li>
</ul>
<blockquote>
<p>永远不要忘记在 .gitignore 中包含环境变量文件</p>
</blockquote>
<h2 id="内置操作系统包">内置操作系统包</h2>
<p>您不需要任何外部程序包即可访问 Golang 中的环境变量，并且可以使用标准库 <code>os</code> 包来实现。以下是与环境变量有关的函数及其用途的列表。</p>
<ul>
<li><code>os.Setenv()</code> 设置环境值的值。</li>
<li><code>os.Getenv()</code> 获取指定键对应的环境变量值。</li>
<li><code>os.Unsetenv()</code> 删除指定键命名对应的单个环境值，如果我们再尝试使用 <code>os.Getenv()</code> 来获取该环境值，将返回一个空值。</li>
<li><code>os.ExpandEnv</code> 根据环境变量的值替换字符串中的 <code>${var}</code> 或 <code>$var</code>。如果不存在任何环境变量，则将使用空字符串替换它。</li>
<li><code>os.LookupEnv()</code> 获取指定键对应的环境变量值。如果系统中不存在该变量，则返回值将为空，并且布尔值将为 false。否则，它将返回值（可以为空），并且布尔值为 true。</li>
</ul>
<blockquote>
<p>如果不存在环境变量，则 os.Getenv() 将返回一个空字符串，使用 LookupEnv 来区分空值和未设置值。</p>
</blockquote>
<p>现在，让我们在代码中使用上述所有函数。在一个空文件夹中创建一个 main.go 文件。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Set Environment Variables
</span><span class="c1"></span>  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;SITE_TITLE&#34;</span><span class="p">,</span> <span class="s">&#34;Test Site&#34;</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;DB_HOST&#34;</span><span class="p">,</span> <span class="s">&#34;localhost&#34;</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;DB_PORT&#34;</span><span class="p">,</span> <span class="s">&#34;27017&#34;</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;DB_USERNAME&#34;</span><span class="p">,</span> <span class="s">&#34;admin&#34;</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;DB_PASSWORD&#34;</span><span class="p">,</span> <span class="s">&#34;password&#34;</span><span class="p">)</span>
  <span class="nx">os</span><span class="p">.</span><span class="nf">Setenv</span><span class="p">(</span><span class="s">&#34;DB_NAME&#34;</span><span class="p">,</span> <span class="s">&#34;testdb&#34;</span><span class="p">)</span>

  <span class="c1">// Get the value of an Environment Variable
</span><span class="c1"></span>  <span class="nx">host</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;SITE_TITLE&#34;</span><span class="p">)</span>
  <span class="nx">port</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;DB_HOST&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Site Title: %s, Host: %s\n&#34;</span><span class="p">,</span> <span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>

  <span class="c1">// Unset an Environment Variable
</span><span class="c1"></span>  <span class="nx">os</span><span class="p">.</span><span class="nf">Unsetenv</span><span class="p">(</span><span class="s">&#34;SITE_TITLE&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;After unset, Site Title: %s\n&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;SITE_TITLE&#34;</span><span class="p">))</span>

  <span class="c1">//Checking that an environment variable is present or not.
</span><span class="c1"></span>  <span class="nx">redisHost</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">LookupEnv</span><span class="p">(</span><span class="s">&#34;REDIS_HOST&#34;</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;REDIS_HOST is not present&#34;</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Redis Host: %s\n&#34;</span><span class="p">,</span> <span class="nx">redisHost</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Expand a string containing environment variables in the form of $var or ${var}
</span><span class="c1"></span>  <span class="nx">dbURL</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">ExpandEnv</span><span class="p">(</span><span class="s">&#34;mongodb://${DB_USERNAME}:${DB_PASSWORD}@$DB_HOST:$DB_PORT/$DB_NAME&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;DB URL: &#34;</span><span class="p">,</span> <span class="nx">dbURL</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>下面是我们在终端中执行  <code>go run main.go</code>  的输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">go run main.go

// output
Site Title: Test Site, Host: localhost
After unset, Site Title: <span class="m">27017</span>
REDIS_HOST is not present
DB URL:  mongodb://admin:password@localhost:27017/testdb
</code></pre></div><p>还有两个函数 <code>os.Clearenv</code> 和 <code>os.Environ()</code>，让我们在单独的程序中使用它们。</p>
<ul>
<li><code>os.Clearenv</code>  删除所有环境变量，清理测试环境可能很有用</li>
<li><code>os.Environ()</code> 以 key = value 的形式返回包含所有环境变量的字符串的一部分。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;os&#34;</span>
  <span class="s">&#34;strings&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Environ returns a slice of string containing all the environment variables in the form of key=value.
</span><span class="c1"></span>  <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">env</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Environ</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// env is
</span><span class="c1"></span>    <span class="nx">envPair</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">SplitN</span><span class="p">(</span><span class="nx">env</span><span class="p">,</span> <span class="s">&#34;=&#34;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nx">key</span> <span class="o">:=</span> <span class="nx">envPair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nx">value</span> <span class="o">:=</span> <span class="nx">envPair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s : %s\n&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Delete all environment variables
</span><span class="c1"></span>  <span class="nx">os</span><span class="p">.</span><span class="nf">Clearenv</span><span class="p">()</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Number of environment variables: &#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nf">Environ</span><span class="p">()))</span>
<span class="p">}</span>
</code></pre></div><p>上面的函数将列出系统中所有可用的环境变量，包括 <code>NAME</code> 和 <code>DB_HOST</code>。一旦运行<code>os.Clearenv()</code>，它将清除正在运行的进程的所有环境变量。</p>
<h2 id="godotenv-包">GoDotEnv 包</h2>
<p>Ruby dotenv 项目启发了 <a href="https://github.com/joho/godotenv" target="_blank" rel="noopener">GoDotEnv</a>
 包，它从 <code>.env</code> 文件加载环境变量。</p>
<p>让我们创建一个 <code>.env</code> 文件，其中包含所有配置。</p>
<div class="highlight"><pre class="chroma"><code class="language-ini" data-lang="ini"><span class="c1"># .env file</span>
<span class="c1"># This is a sample config file</span>

<span class="na">SITE_TITLE</span><span class="o">=</span><span class="s">Test Site </span>

<span class="na">DB_HOST</span><span class="o">=</span><span class="s">localhost</span>
<span class="na">DB_PORT</span><span class="o">=</span><span class="s">27017</span>
<span class="na">DB_USERNAME</span><span class="o">=</span><span class="s">admin</span>
<span class="na">DB_PASSWORD</span><span class="o">=</span><span class="s">password</span>
<span class="na">DB_NAME</span><span class="o">=</span><span class="s">testdb</span>
</code></pre></div><p>然后在 main.go 文件中，我们将使用 godotenv 加载环境变量。</p>
<blockquote>
<p>我们也可以一次加载多个 env 文件。godotenv 还支持 YAML。</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// main.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;os&#34;</span>

  <span class="s">&#34;github.com/joho/godotenv&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// load .env file from given path
</span><span class="c1"></span>  <span class="c1">// we keep it empty it will load .env from current directory
</span><span class="c1"></span>  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">godotenv</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="s">&#34;.env&#34;</span><span class="p">)</span>

  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Error loading .env file&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// getting env variables SITE_TITLE and DB_HOST
</span><span class="c1"></span>  <span class="nx">siteTitle</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;SITE_TITLE&#34;</span><span class="p">)</span>
  <span class="nx">dbHost</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;DB_HOST&#34;</span><span class="p">)</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;godotenv : %s = %s \n&#34;</span><span class="p">,</span> <span class="s">&#34;Site Title&#34;</span><span class="p">,</span> <span class="nx">siteTitle</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;godotenv : %s = %s \n&#34;</span><span class="p">,</span> <span class="s">&#34;DB Host&#34;</span><span class="p">,</span> <span class="nx">dbHost</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>打开终端并运行  <code>main.go</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">go run main.go

// output
godotenv : Site <span class="nv">Title</span> <span class="o">=</span> Test Site
godotenv : DB <span class="nv">Host</span> <span class="o">=</span> localhost
</code></pre></div><h2 id="viper-包">Viper 包</h2>
<blockquote>
<p>Viper 是 Go 应用程序的配置的完整解决方案。它旨在在应用程序中工作，并且可以处理所有类型的配置需求和格式。</p>
</blockquote>
<p><a href="https://github.com/spf13/viper" target="_blank" rel="noopener">Viper</a>
 支持多种文件格式来加载环境变量，例如，从 JSON，TOML，YAML，HCL，envfile 和 Java 属性配置文件（properties）中读取。因此，在此示例中，我们将研究如何从 YAML 文件中加载环境变量。</p>
<blockquote>
<p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件和用于存储或传输数据的应用程序。</p>
</blockquote>
<p>让我们在一个空文件夹中创建 config.yaml 和 main.go。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="c"># config.yaml</span><span class="w">
</span><span class="w"></span><span class="nt">SITE</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">TITLE</span><span class="p">:</span><span class="w"> </span><span class="l">Test Site</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nt">DB</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">HOST</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;localhost&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">PORT</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;27017&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">USERNAME</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;admin&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">PASWORD</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;password&#34;</span><span class="w">
</span><span class="w">  </span><span class="nt">NAME</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;testdb&#34;</span><span class="w">
</span></code></pre></div><p>在下面的代码中，我们使用 Viper 从 config.yaml 中加载环境变量。我们可以从所需的任何路径加载配置文件。如果配置文件中没有任何环境变量，我们还可以为任何环境变量设置默认值。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// main.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;log&#34;</span>
  <span class="s">&#34;os&#34;</span>

  <span class="s">&#34;github.com/spf13/viper&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// Set the file name of the configurations file
</span><span class="c1"></span>  <span class="nx">viper</span><span class="p">.</span><span class="nf">SetConfigName</span><span class="p">(</span><span class="s">&#34;config&#34;</span><span class="p">)</span>

  <span class="c1">// Set the path to look for the configurations file
</span><span class="c1"></span>  <span class="nx">viper</span><span class="p">.</span><span class="nf">AddConfigPath</span><span class="p">(</span><span class="s">&#34;.&#34;</span><span class="p">)</span>

  <span class="c1">// Enable VIPER to read Environment Variables
</span><span class="c1"></span>  <span class="nx">viper</span><span class="p">.</span><span class="nf">AutomaticEnv</span><span class="p">()</span>

  <span class="nx">viper</span><span class="p">.</span><span class="nf">SetConfigType</span><span class="p">(</span><span class="s">&#34;yml&#34;</span><span class="p">)</span>

  <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">viper</span><span class="p">.</span><span class="nf">ReadInConfig</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Error reading config file, %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Set undefined variables
</span><span class="c1"></span>  <span class="nx">viper</span><span class="p">.</span><span class="nf">SetDefault</span><span class="p">(</span><span class="s">&#34;DB.HOST&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1&#34;</span><span class="p">)</span>

  <span class="c1">// getting env variables DB.PORT
</span><span class="c1"></span>  <span class="c1">// viper.Get() returns an empty interface{}
</span><span class="c1"></span>  <span class="c1">// so we have to do the type assertion, to get the value
</span><span class="c1"></span>  <span class="nx">DBPort</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">viper</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;DB.PORT&#34;</span><span class="p">).(</span><span class="kt">string</span><span class="p">)</span>

  <span class="c1">// if type assert is not valid it will throw an error
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;Invalid type assertion&#34;</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;viper : %s = %s \n&#34;</span><span class="p">,</span> <span class="s">&#34;Database Port&#34;</span><span class="p">,</span> <span class="nx">DBPort</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>打开终端并运行 <code>main.go</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">go run main.go

// output
viper : Database <span class="nv">Port</span> <span class="o">=</span> <span class="m">27017</span>
</code></pre></div><h2 id="结论">结论</h2>
<p>使用环境变量是在我们的应用程序中处理配置的绝佳方法。总体而言，它为您提供了轻松的配置，更好的安全性，多个部署环境以及更少的生产错误。</p>
<p>现在您可以在 go 应用程序中管理环境变量，并且可以在我们的 <a href="https://github.com/LoginRadius/engineering-blog-samples/tree/master/GoLang/EnvironmentVariables" target="_blank" rel="noopener">Github Repo</a>
 上找到本教程中使用的完整代码。</p>
<blockquote>
<p>原文链接：<a href="https://www.loginradius.com/engineering/blog/environment-variables-in-golang/">https://www.loginradius.com/engineering/blog/environment-variables-in-golang/</a></p>
<p>作者：Puneet Singh</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>这道题竟然只有 12% 的人答对。。。</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/weekly-question-embed-time/</link>
			<pubDate>Mon, 21 Dec 2020 16:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/weekly-question-embed-time/</guid>
			<description>这题是有点坑，但很多人对结果还是不知所以。</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>在 <a href="https://mp.weixin.qq.com/s/oDMSFjjzGbu7kkERM8ilGw" target="_blank" rel="noopener">《Go 语言爱好者周刊第 74 期》</a>
有一道题，以下代码输出什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
		<span class="nx">N</span> <span class="kt">int</span>
	<span class="p">}{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Date</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">UTC</span><span class="p">),</span>
		<span class="mi">5</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">m</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>A：<code>{&quot;Time&quot;: &quot;2020-12-20T00:00:00Z&quot;, &quot;N&quot;: 5}</code>；B：<code>&quot;2020-12-20T00:00:00Z&quot;</code>；C：<code>{&quot;N&quot;: 5}</code>；D：<code>&lt;nil&gt;</code></p>
<p>答题结果如下：</p>
<p><p class="md__image">
  <img src="../imgs/weekly-question-time.png"
    alt=""  />
</p>
</p>
<p>虽然参与投票的人不是很多，但从结果还是能反馈出来一些问题的，不少人知晓了答案是 B，但还是想不明白为什么。所以写篇文章对该题进行解析。大家不用在乎是不是刁钻的题目，通过题目能学到知识才是最重要的。</p>
<h2 id="01">01</h2>
<p>对一个结构体实例进行 json 系列化，直觉很容易选 A。但很显然，不可能这么简单，因此需要仔细看代码。至于选 C 和 D 的人，多半是瞎猜的吧，当然选 B 也不排除有瞎猜的。</p>
<p>为什么选 B 呢？我想借助一个例子讲解。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
  <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">name</span>  <span class="kt">string</span>
  <span class="nx">hobby</span> <span class="kt">string</span>
<span class="p">}</span>	

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">person</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&#34;polarisxu&#34;</span><span class="p">,</span> <span class="nx">hobby</span><span class="p">:</span> <span class="s">&#34;Golang&#34;</span><span class="p">}</span>
  <span class="nx">m</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>如果你认为输出 <code>{&quot;name&quot;:&quot;polarisxu&quot;,&quot;hobby&quot;:&quot;Golang&quot;}</code>，那你得去补补 encoding/json 包的知识了。要想输出  <code>{&quot;name&quot;:&quot;polarisxu&quot;,&quot;hobby&quot;:&quot;Golang”}</code>，一般我们会这么做：将 Person 的字段导出，同时设置上 tag。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
  <span class="nx">Hobby</span> <span class="kt">string</span> <span class="s">`json:&#34;hobby&#34;`</span>
<span class="p">}</span>
</code></pre></div><p>但如果我们不想导出 Person 的字段呢？可以通过实现 Marshaler 来做到。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="nf">MarshalJSON</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">`{&#34;name&#34;:&#34;`</span><span class="o">+</span><span class="nx">p</span><span class="p">.</span><span class="nx">name</span><span class="o">+</span><span class="s">`&#34;,&#34;hobby&#34;:&#34;`</span><span class="o">+</span><span class="nx">p</span><span class="p">.</span><span class="nx">hobby</span><span class="o">+</span><span class="s">`&#34;}`</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h2 id="02">02</h2>
<p>回到题目上，<a href="https://docs.studygolang.com/pkg/time/#Time" target="_blank" rel="noopener">time.Time</a>
 是什么类型？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Time</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// contains filtered or unexported fields
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这是一个没有导出任何字段的结构体类型，因此它肯定<a href="https://docs.studygolang.com/src/time/time.go?s=38148:38191#L1230" target="_blank" rel="noopener">实现了 Marshaler 接口</a>
。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// MarshalJSON implements the json.Marshaler interface.
</span><span class="c1">// The time is a quoted string in RFC 3339 format, with sub-second precision added if present.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">Time</span><span class="p">)</span> <span class="nf">MarshalJSON</span><span class="p">()</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Year</span><span class="p">();</span> <span class="nx">y</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">y</span> <span class="o">&gt;=</span> <span class="mi">10000</span> <span class="p">{</span>
		<span class="c1">// RFC 3339 is clear that years are 4 digits exactly.
</span><span class="c1"></span>		<span class="c1">// See golang.org/issue/4556#c15 for more discussion.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Time.MarshalJSON: year outside of range [0,9999]&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">RFC3339Nano</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="sc">&#39;&#34;&#39;</span><span class="p">)</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">AppendFormat</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">RFC3339Nano</span><span class="p">)</span>
	<span class="nx">b</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="sc">&#39;&#34;&#39;</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>这么说，答案不应该就是 A 吗？别急。</p>
<h2 id="03">03</h2>
<p>如果 t 是这么定义的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">t</span> <span class="o">:=</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Time</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
  <span class="nx">N</span> <span class="kt">int</span>
<span class="p">}{</span>
  <span class="nx">time</span><span class="p">.</span><span class="nf">Date</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">UTC</span><span class="p">),</span>
  <span class="mi">5</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>那结果就是 A。而题目中，time.Time 是内嵌的。你学习 Go 时，应该看过通过内嵌来模拟继承的功能吧！</p>
<p>正是因为内嵌，t 的方法集包括了 time.Time 的方法集，所以，t 自动实现了 Marshaler 接口。因此答案是 B。</p>
<p>其实这道题的情况，在日常工作中还真有可能遇到。所以，当你内嵌某个类型时，特别这个类型不是你自己定义的，需要留意这种情况。</p>
<p>一般解决这个问题的方法有两种：1）不内嵌；2）重新实现 MarshalJSON 方法。</p>
<p>然而这道题无法重新实现 MarshalJSON 方法，因为结构体类型是匿名的。只能通过不内嵌来得到正确的结果。</p>
<h2 id="04">04</h2>
<p>最后一起看下 json.Marshal 函数的文档，主要看下面这段：</p>
<blockquote>
<p>Marshal traverses the value v recursively. If an encountered value implements the Marshaler interface and is not a nil pointer, Marshal calls its MarshalJSON method to produce JSON. If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead, Marshal calls its MarshalText method and encodes the result as a JSON string. The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON.</p>
</blockquote>
<p>大意是说，如果值实现了 json.Marshaler 接口并且不是 nil 指针，则 Marshal 函数会调用其 MarshalJSON 方法以生成 JSON。如果不存在 MarshalJSON 方法，但该值实现 encoding.TextMarshaler 接口，则 Marshal 函数调用其 MarshalText 方法并将结果编码为 JSON 字符串。</p>
<p>可见，json.Marshal 函数优先调用 MarshalJSON，然后是 MarshalText，如果都没有，才会走正常的类型编码逻辑。</p>
]]></content>
		</item>
		
		<item>
			<title>感慨 Apple 的 强大</title>
			<link>https://polarisxu.studygolang.com/posts/apple/is-apple-m1-ready/</link>
			<pubDate>Sat, 19 Dec 2020 15:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/apple/is-apple-m1-ready/</guid>
			<description>大家好，我是站长 polarisxu。 这段时间关注 Apple M1 芯片挺多的，对 Apple 的强大由衷的感慨。市值 2.1 万亿美金，做的动作都成为行业引领者。 当年扁平化设计出来，被各种吐槽；结果大家都扁平化了； 出暗黑模式（很程序员？），有些人不喜欢，但现在各种都支持暗黑模式； iPhone 12 不带耳机和充电器，骂声一片，目测各个手机厂商都跟进，比如三星就宣布不带了； Mac 换成自己的 M1 芯片，很多软件厂商及时</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这段时间关注 Apple M1 芯片挺多的，对 Apple 的强大由衷的感慨。市值 2.1 万亿美金，做的动作都成为行业引领者。</p>
<ul>
<li>当年扁平化设计出来，被各种吐槽；结果大家都扁平化了；</li>
<li>出暗黑模式（很程序员？），有些人不喜欢，但现在各种都支持暗黑模式；</li>
<li>iPhone 12 不带耳机和充电器，骂声一片，目测各个手机厂商都跟进，比如三星就宣布不带了；</li>
<li>Mac 换成自己的 M1 芯片，很多软件厂商及时跟进支持；</li>
<li>。。。</li>
</ul>
<p>昨天 Go 1.16 Beta1 发布，原生支持 M1 芯片，今天无意中发现了一个 Twitter 账号：Is Apple Silicon Ready ?
@ism1ready，以及对应的网站：<a href="https://isapplesiliconready.com">https://isapplesiliconready.com</a>。刚换芯片，软件厂商们立马跟进，还有人做了这么个站点，不得不感叹：Apple 就是牛逼！</p>
<p><p class="md__image">
  <img src="../imgs/m1-01.png"
    alt=""  />
</p>
</p>
<p>如果你买了 M1 的 Mac，可以看看这个网站，它支持多国语言。对应用做了分类，同时就支持程度分为：原生支持 M1、只支持 Rosetta 2、不可用和还没测试。同时支持搜索某个软件。</p>
<p>有了这个网站，你可以很清晰的知晓软件对 M1 的支持程度。</p>
<h2 id="rosetta-2">Rosetta 2</h2>
<p>有些人可能不清楚 Rosetta 2 是啥，这里简单普及一下。</p>
<p>要说 Rosetta 2，先说说 Rosetta。</p>
<p>2006 年，苹果发布了 Rosetta，原因是它由原来的 PowerPC 芯片换成了 Intel 芯片，为了过渡，使许多 PowerPC 应用程序无需修改即可在基于 Intel 的 Mac 计算机上运行。因此可以简单的理解为，Rosetta 做了转换。</p>
<p>现在苹果又放弃了 Intel 芯片，采用 ARM 架构的 M1 芯片，同样会存在过渡问题，因此推出了 Rosetta 2，搭载苹果芯片的 Mac，可以运行专为 Intel 处理器 Mac 构建的 App。</p>
<p>苹果官方介绍在大多数情况下，需要 Rosetta 的 App 的性能不会出现任何差异。但实际上，性能和运行速度就无法保证和在 Intel 芯片的 Mac 上一样了。毕竟原生肯定优化的更好。</p>
<h2 id="软件原生支持情况">软件原生支持情况</h2>
<p>浏览器方面，Safari、Chrome、Edge、Firefox 都原生支持 M1 了。</p>
<p>编程语言方面，Go 1.16 支持，已经发布了 Beta1 版本；PHP 已经支持；Java 已经支持；Python 已经支持；Ruby 已经支持；Node 已经支持。其他一些语言，可以通过 Rosetta 2 来运行。</p>
<p>更多其他软件的支持情况可以通过该站的搜索查看。</p>
<p>所以，整体来说，因为有 Rosetta 2 的存在，新版 Mac 的使用完全不是问题，问题是有没有钱买~哈哈哈哈</p>
]]></content>
		</item>
		
		<item>
			<title>听说你还不知道如何查看 Go 历史文档？</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/view-go-history-std-version/</link>
			<pubDate>Thu, 17 Dec 2020 17:15:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/view-go-history-std-version/</guid>
			<description>大家好，我是站长 polarisxu。 这是一篇短文，写这篇文章主要是看到了两个信息： tonybai 写的《如何查看历史版本的 Go 文档？》 Go 官方发博文，2021 年初开始，godoc.org 默认将重定向到 pkg.go.dev ； tonybai 在文章中说了两种方法： 利用 go doc，可行，但非最优。比如 go doc http.Request。通过切换本地的 Go 版本实现查看不同版本的 Go 标准库文档； 使用 godoc 建立历史版本的 Web 化文档中心。</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>这是一篇短文，写这篇文章主要是看到了两个信息：</p>
<ul>
<li>tonybai 写的<a href="https://tonybai.com/2020/12/15/how-to-see-the-manual-of-go-history-version/" target="_blank" rel="noopener">《如何查看历史版本的 Go 文档？》</a>
</li>
<li>Go 官方发博文，2021 年初开始，<a href="https://docs.studygolang.com/blog/godoc.org-redirect" target="_blank" rel="noopener">godoc.org 默认将重定向到 pkg.go.dev</a>
；</li>
</ul>
<p>tonybai 在文章中说了两种方法：</p>
<ul>
<li>利用 go doc，可行，但非最优。比如 go doc http.Request。通过切换本地的 Go 版本实现查看不同版本的 Go 标准库文档；</li>
<li>使用 godoc 建立历史版本的 Web 化文档中心。这种方式需要额外安装 godoc：<code>go get golang.org/x/tools/cmd/godoc</code>。这种方法相当于本地启动一个旧版 Go 官网。godoc 支持一个参数 -goroot 来指定不同的 Go 版本目录树；</li>
</ul>
<p>但这两种方法都挺费劲的，因为需要你本地有各个版本的 Go 源码。以前没有更好的方法，但自从有了 pkg.go.dev，查看历史文档方便多了。因为 pkg.go.dev 更懂 Go module，通过它不仅可以查看标准库的历史版本文档，而且可以查看第三方库的历史版本。具体可以查看这里：<a href="https://pkg.go.dev/std?tab=versions">https://pkg.go.dev/std?tab=versions</a>。</p>
<p>虽然 godoc.org 也可以同时查看标准库文档和第三方库文档，但没有历史版本。pkg.go.dev 经过一年多的发展，经历了开源、重构等，官方终于决定正式弃用 godoc.org，将其重定向到 pkg.go.dev。</p>
<p>所以，是时候使用 pkg.go.dev 了，而且它可以直接访问，而不像 golang.org 不能访问。</p>
]]></content>
		</item>
		
		<item>
			<title>新买了 Apple M1 Mac，却不知道如何安装 Go？</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/apple-m1-install-go/</link>
			<pubDate>Wed, 16 Dec 2020 20:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/apple-m1-install-go/</guid>
			<description>大家好，我是站长 polarisxu。 前些天有一位朋友问我： 有些朋友可能会有点奇怪，M1 有什么特别的吗？为了照顾部分童鞋，这里简单介绍下。 01 为什么会出现这个问题 大家知道不同的操作系统是很不一样的，同时不同的 CPU 架构也是很不一样的。Go 号称是跨平台的，自然要支持这些操作系统和 CPU 架构。 在 Go 中，GOOS 表示操作系统，GOARCH 表示 CPU 架构。比如你的 Linux 服务器，一般是 GO</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>前些天有一位朋友问我：</p>
<p><p class="md__image">
  <img src="../imgs/apple-m1-install-go.png"
    alt=""  />
</p>
</p>
<p>有些朋友可能会有点奇怪，M1 有什么特别的吗？为了照顾部分童鞋，这里简单介绍下。</p>
<h2 id="01-为什么会出现这个问题">01 为什么会出现这个问题</h2>
<p>大家知道不同的操作系统是很不一样的，同时不同的 CPU 架构也是很不一样的。Go 号称是跨平台的，自然要支持这些操作系统和 CPU 架构。</p>
<p>在 Go 中，GOOS 表示操作系统，GOARCH 表示 CPU 架构。比如你的 Linux 服务器，一般是 GOOS=linux，GOARCH=amd64（即 x86-64）；你现在的 Mac 很可能是 GOOS=darwin，GOARCH=amd64 等。这里定义了 Go 支持的操作系统和 CPU 架构：<a href="https://docs.studygolang.com/pkg/runtime/internal/sys/#pkg-constants">https://docs.studygolang.com/pkg/runtime/internal/sys/#pkg-constants</a>。当然，这里的 GOOS 和 GOARCH 并非任意组合都支持。</p>
<p>一般地，很多人安装 Go，通过网上下载编译好的、对应系统的包，比如到 <a href="https://studygolang.com/dl">https://studygolang.com/dl</a> 可以下载你需要的文件，常见的系统是：Linux、Mac 和 Windows。</p>
<p><p class="md__image">
  <img src="../imgs/apple-m1-install-go-01.png"
    alt=""  />
</p>
</p>
<p>比如 Apple macOS，下载后双击打开，按提示操作即可。</p>
<p>然而，最新版 Mac 没有使用 Intel 芯片，而是使用了自研的 M1 芯片。之前 Intel 芯片是 amd64 架构，而 M1 芯片是 arm64 结构。前面说了，虽然 Go 是支持 arm64 架构的，但并非操作系统和 CPU 架构的任意组合都支持，也就是说 GOOS=darwin，GOARCH=arm64 的组合不支持（或者说没有针对这个用于 Mac 的组合做处理）。因此，现有预编译的版本都没法安装到 M1 Mac 上。</p>
<h2 id="02-探讨解决方案">02 探讨解决方案</h2>
<p>要解决这个问题，当然前提是 Go 团队支持 M1。虽然 Go 以往的版本都不支持，但对 M1 的支持，Go 已经开发完毕，而且网上已经有了 Intel 和 M1 的性能测试。</p>
<ul>
<li><a href="https://roland.zone/m1-go-benchmarks/" target="_blank" rel="noopener">Go 标准库性能测试，对比 Intel 和 苹果 M1 处理器</a>
</li>
<li><a href="https://gohugo.io/news/hugo-macos-intel-vs-arm/" target="_blank" rel="noopener">Hugo 在 Apple M1 的性能测试</a>
</li>
</ul>
<p>对 M1 的支持，需要等到 Go1.16 发布，也就是明年 2 月份。但我们可以通过 Go 代码仓库的 master 分支来编译安装 Go，因为它是支持 M1 的（注意，因为是开发版本，请勿用于生产环境）。</p>
<p>现在引出另一个问题：因为 Go 自 1.5 开始实现了自举，如果从源码安装 Go，需要本地有 Go 的编译器。。。陷入了死循环。</p>
<p>如果是非 M1 芯片，通常的做法是：下载一份 Go1.4 版本代码，编译一个 Go1.4（因为它是 C 语言实现的，不依赖 Go）。然后用这个 Go1.4 编译最新的 Go 源码。</p>
<p>实际上，官方告诉你有四种方法处理这种情况。</p>
<h3 id="源码安装的四种方法">源码安装的四种方法</h3>
<ul>
<li>下载 Go 的最新二进制版本（其实可以不是最新的）；</li>
<li>在一台安装有 Go 的电脑上执行交叉编译；</li>
<li>使用 gccgo；</li>
<li>即上面提到的方法，编译一个 Go1.4，然后用它编译其他 Go 版本；</li>
</ul>
<p>更多详细信息参考官方文档：<a href="https://docs.studygolang.com/doc/install/source#go14">https://docs.studygolang.com/doc/install/source#go14</a>。</p>
<p>所以，对于 M1 芯片安装 Go，方法 1 和方法 4 行不通（Go 1.4 很显然不支持 M1 芯片），而使用交叉编译是一个不错的选择，毕竟 gccgo，很多人并不熟悉。</p>
<h2 id="03-通过交叉编译在-m1-上安装-go">03 通过交叉编译在 M1 上安装 Go</h2>
<p>我认为支持交叉编译是 Go 的一大特色，不仅支持交叉编译 Go 程序，本身也支持交叉编译。</p>
<p>现在就讲解通过交叉编译解决 M1 安装 Go 的问题。</p>
<p>1）下载 Go 最新源码。</p>
<p>在一台非 M1 电脑上，下载 Go 最新源码，假设下载到用户目录：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~
$ git clone https://github.com/golang/go
</code></pre></div><p>2）进行交叉编译</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> go/src
$ <span class="nv">GOOS</span><span class="o">=</span>darwin <span class="nv">GOARCH</span><span class="o">=</span>arm64 ./bootstrap.bash
<span class="c1">#### Copying to ../../go-darwin-arm64-bootstrap</span>

<span class="c1">#### Cleaning ../../go-darwin-arm64-bootstrap</span>
Removing VERSION.cache
Removing bin/
Removing pkg/
Removing src/cmd/cgo/zdefaultcc.go
Removing src/cmd/go/internal/cfg/zdefaultcc.go
Removing src/cmd/go/internal/cfg/zosarch.go
Removing src/cmd/internal/objabi/zbootstrap.go
Removing src/go/build/zcgo.go
Removing src/runtime/internal/sys/zversion.go

<span class="c1">#### Building ../../go-darwin-arm64-bootstrap</span>

Building Go cmd/dist using /Users/xuxinhua/go1.4. <span class="o">(</span>go1.4-bootstrap-20170531 darwin/amd64<span class="o">)</span>
Building Go toolchain1 using /Users/xuxinhua/go1.4.
Building Go bootstrap cmd/go <span class="o">(</span>go_bootstrap<span class="o">)</span> using Go toolchain1.
Building Go toolchain2 using go_bootstrap and Go toolchain1.
Building Go toolchain3 using go_bootstrap and Go toolchain2.
Building packages and commands <span class="k">for</span> host, darwin/amd64.
Building packages and commands <span class="k">for</span> target, darwin/arm64.
----
Bootstrap toolchain <span class="k">for</span> darwin/arm64 installed in /Users/xuxinhua/go-darwin-arm64-bootstrap.
Building tbz.
-rw-r--r--  <span class="m">1</span> xuxinhua  staff  <span class="m">128102136</span> <span class="m">12</span> <span class="m">16</span> 17:15 /Users/xuxinhua/go-darwin-arm64-bootstrap.tbz
</code></pre></div><p>从上面的输出可以看到，在用户目录下会生成 go-darwin-arm64-bootstrap 文件夹和 go-darwin-arm64-bootstrap.tbz 压缩包，将其中之一发送给 M1 Mac，在 M1 电脑上可以以此作为 bootstrap，重新编译 Go，也可以直接将它作为 Go 编译器使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/go-darwin-arm64-bootstrap
$ bin/go env    
<span class="nv">GO111MODULE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOARCH</span><span class="o">=</span><span class="s2">&#34;arm64&#34;</span>
<span class="nv">GOBIN</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOCACHE</span><span class="o">=</span><span class="s2">&#34;~/Library/Caches/go-build&#34;</span>
<span class="nv">GOENV</span><span class="o">=</span><span class="s2">&#34;~/Library/Application Support/go/env&#34;</span>
<span class="nv">GOEXE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOFLAGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOHOSTARCH</span><span class="o">=</span><span class="s2">&#34;arm64&#34;</span>
<span class="nv">GOHOSTOS</span><span class="o">=</span><span class="s2">&#34;darwin&#34;</span>
<span class="nv">GOINSECURE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOMODCACHE</span><span class="o">=</span><span class="s2">&#34;~/go/pkg/mod&#34;</span>
<span class="nv">GONOPROXY</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GONOSUMDB</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOOS</span><span class="o">=</span><span class="s2">&#34;darwin&#34;</span>
<span class="nv">GOPATH</span><span class="o">=</span><span class="s2">&#34;~/go&#34;</span>
<span class="nv">GOPRIVATE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOPROXY</span><span class="o">=</span><span class="s2">&#34;https://proxy.golang.org,direct&#34;</span>
<span class="nv">GOROOT</span><span class="o">=</span><span class="s2">&#34;~/go-darwin-arm64-bootstrap&#34;</span>
<span class="nv">GOSUMDB</span><span class="o">=</span><span class="s2">&#34;sum.golang.org&#34;</span>
<span class="nv">GOTMPDIR</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOTOOLDIR</span><span class="o">=</span><span class="s2">&#34;~/Downloads/go-darwin-arm64-bootstrap/pkg/tool/darwin_arm64&#34;</span>
<span class="nv">GOVCS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOVERSION</span><span class="o">=</span><span class="s2">&#34;devel +5a25a3fd1d Tue Dec 15 02:35:59 2020 +0000&#34;</span>
<span class="nv">GCCGO</span><span class="o">=</span><span class="s2">&#34;gccgo&#34;</span>
<span class="nv">AR</span><span class="o">=</span><span class="s2">&#34;ar&#34;</span>
<span class="nv">CC</span><span class="o">=</span><span class="s2">&#34;clang&#34;</span>
<span class="nv">CXX</span><span class="o">=</span><span class="s2">&#34;clang++&#34;</span>
<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="s2">&#34;1&#34;</span>
<span class="nv">GOMOD</span><span class="o">=</span><span class="s2">&#34;/dev/null&#34;</span>
<span class="nv">CGO_CFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_CPPFLAGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">CGO_CXXFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_FFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_LDFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">PKG_CONFIG</span><span class="o">=</span><span class="s2">&#34;pkg-config&#34;</span>
<span class="nv">GOGCCFLAGS</span><span class="o">=</span><span class="s2">&#34;-fPIC -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/6r/nghqxtb92kv5136s7k67_cc00000gn/T/go-build4293620280=/tmp/go-build -gno-record-gcc-switches -fno-common&#34;</span>
</code></pre></div><h2 id="04-总结">04 总结</h2>
<p>吃螃蟹嘛，应该有一定的心里准备。但 Go 还是很给力。Bradfitz 发推文说，苹果在 6 月 22 日说，会给 Go 支持 Apple Silicon (arm64) 提交 patch，但到目前为止没看到，至少没有在邮件组中出现，他们没有在 <a href="https://tip.golang.org/CONTRIBUTORS">https://tip.golang.org/CONTRIBUTORS</a> 列表中。所有支持 Apple Silicon 的工作都是 Go 社区做的。</p>
<p>买了 M1 还没装 Go 的，可以试试了！</p>
]]></content>
		</item>
		
		<item>
			<title>你是不是没想过，结构体竟然可以内嵌一个接口？</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/weekly-question-analysis-embed-interface/</link>
			<pubDate>Mon, 14 Dec 2020 17:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/weekly-question-analysis-embed-interface/</guid>
			<description>大家好，我是站长 polarisxu。 时不时有人催问周刊题目的解析，那就先先解析下第 71 期 的题目。 01 题目是，以下代码能否通过编译： package main import ( &amp;#34;fmt&amp;#34; ) type worker interface { work() } type person struct { name string worker } func main() { var w worker = person{} fmt.Println(w) } 这是大家的投票结果： 只有 35% 的人答对了。 这里答错的原因在于 worker 是一个接口，如果是一个普通的类型，相信大家会答对。一个结构体竟然可以嵌入一个接口？！ 02 我们都知晓 Go 没有继承，但可以通</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>时不时有人催问周刊题目的解析，那就先先解析下<a href="https://mp.weixin.qq.com/s/QpG5oBlz9mcmBUV8gl7P7w" target="_blank" rel="noopener">第 71 期</a>
的题目。</p>
<h2 id="01">01</h2>
<p>题目是，以下代码能否通过编译：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">worker</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">work</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
	<span class="nx">worker</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">w</span> <span class="nx">worker</span> <span class="p">=</span> <span class="nx">person</span><span class="p">{}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这是大家的投票结果：</p>
<p><p class="md__image">
  <img src="../imgs/weekly71-73-01.png"
    alt=""  />
</p>
</p>
<p>只有 35% 的人答对了。</p>
<p>这里答错的原因在于 worker 是一个接口，如果是一个普通的类型，相信大家会答对。一个结构体竟然可以嵌入一个接口？！</p>
<h2 id="02">02</h2>
<p>我们都知晓 Go 没有继承，但可以通过内嵌类型模拟部分继承的功能。大家要记住，接口也是类型，自然也将它作为嵌入类型。如果题目的 person 接口体改为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">person</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">name</span> <span class="kt">string</span>
	<span class="nx">worker</span> <span class="nx">worker</span>
<span class="p">}</span>
</code></pre></div><p>相信会有更多人答对，这和嵌入类型唯一的区别在于是否显示指定了字段名，其他并无区别。</p>
<p>将接口作为嵌入类型可能让人感觉有些奇怪：那这个类型不是默认就实现了这个接口？！确实是这样的，所以才有了题目中这一句能编译通过：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">w</span> <span class="nx">worker</span> <span class="p">=</span> <span class="nx">person</span><span class="p">{}</span>
</code></pre></div><p>只不过，因为实例化 person 时，没有给 worker 指定值，因此 person 中的 worker 是 nil，调用它的话会报错，但编译是没问题的。</p>
<h2 id="03">03</h2>
<p>有人可能要问，嵌入接口有实际用途吗？我找一个标准库中的例子。</p>
<p>在 sort 包中，有一个接口：Interface</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Interface</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Len is the number of elements in the collection.
</span><span class="c1"></span>	<span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span>
	<span class="c1">// Less reports whether the element with
</span><span class="c1"></span>	<span class="c1">// index i should sort before the element with index j.
</span><span class="c1"></span>	<span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="c1">// Swap swaps the elements with indexes i and j.
</span><span class="c1"></span>	<span class="nf">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这是用于排序的。还有另外一个结构体：<a href="https://docs.studygolang.com/src/sort/sort.go?s=7078:7105#L239" target="_blank" rel="noopener">reverse</a>
</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">reverse</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// This embedded Interface permits Reverse to use the methods of
</span><span class="c1"></span>	<span class="c1">// another Interface implementation.
</span><span class="c1"></span>	<span class="nx">Interface</span>
<span class="p">}</span>
</code></pre></div><p>它就内嵌了一个 Interface，用于排序的反转。</p>
<p>而内嵌接口的关键在于如何给这个内嵌的接口赋值。sort 包有一个函数：Reverse</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Reverse</span><span class="p">(</span><span class="nx">data</span> <span class="nx">Interface</span><span class="p">)</span> <span class="nx">Interface</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">reverse</span><span class="p">{</span><span class="nx">data</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>其中实例化 reverse 时，直接通过传递的 Interface 实例赋值给 reverse 的内嵌接口，然后 reverse 类型可以有选择的重新实现内嵌的 Interface 的方法。比如 Less 方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="nx">reverse</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Interface</span><span class="p">.</span><span class="nf">Less</span><span class="p">(</span><span class="nx">j</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="04">04</h2>
<p>回到上面的题目，如果我们通过实例化的 w 调用 work 方法会报错：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">w</span> <span class="nx">worker</span> <span class="p">=</span> <span class="nx">person</span><span class="p">{}</span>
<span class="nx">w</span><span class="p">.</span><span class="nf">work</span><span class="p">()</span>	<span class="c1">// panic
</span></code></pre></div><p>和上面 reverse 类似，你需要给 person 中的 worker 实例化，也就是需要一个实现了 worker 接口的类型实例。比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">student</span> <span class="kd">struct</span><span class="p">{</span>
    <span class="nx">name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">student</span><span class="p">)</span> <span class="nf">work</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;I am &#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;, I am learning&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>然后这样实例化 person：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">w</span> <span class="nx">worker</span> <span class="p">=</span> <span class="nx">person</span><span class="p">{</span><span class="nx">worker</span><span class="p">:</span> <span class="nx">student</span><span class="p">{</span><span class="s">&#34;polarisxu&#34;</span><span class="p">}}</span>
</code></pre></div><p>你掌握了吗？</p>
]]></content>
		</item>
		
		<item>
			<title>体验下“世界上最好的语言”新版本的特性</title>
			<link>https://polarisxu.studygolang.com/posts/php/php8-intro/</link>
			<pubDate>Tue, 08 Dec 2020 11:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/php/php8-intro/</guid>
			<description>大家好，我是站长 polarisxu。 看到标题，大家应该知晓今天聊的主角是谁。是的，它就是 PHP。 PHP 曾经很辉煌，现在怎么样？不做过多评价，前几天好未来不刚组织了一届 PHP 大会吗？！正因为曾经很辉煌，很多现在的 Go 爱好者曾经都是 PHPer，应该还有不少还在用着 PHP。我觉得完全没必要非得贬低一门语言去抬高另外一门语言，自己喜欢就好。而且掌握多门语言是自己的优势。 为什么</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>看到标题，大家应该知晓今天聊的主角是谁。是的，它就是 PHP。</p>
<p>PHP 曾经很辉煌，现在怎么样？不做过多评价，前几天好未来不刚组织了一届 PHP 大会吗？！正因为曾经很辉煌，很多现在的 Go 爱好者曾经都是 PHPer，应该还有不少还在用着 PHP。我觉得完全没必要非得贬低一门语言去抬高另外一门语言，自己喜欢就好。而且掌握多门语言是自己的优势。</p>
<p>为什么聊 PHP，因为我也写了好几年 PHP，而且现在也会关注 PHP 的一些动态。PHP 8 发布差不多半个月了，有些人可能根本不知晓，还停留在 PHP 5.x。没想到吧，一眨眼，PHP 8 都发布了。</p>
<p>关于版本的那些事，这里不探讨，主要看看 PHP 8 有哪些新特性。另外，本文只会讲述新特性的一些关键点，因为官方文档对它们已经有更详细的介绍，你应该认真阅读官方文档。</p>
<h2 id="01-union-types联合类型">01 Union Types（联合类型）</h2>
<p>说明一点，从 PHP 7 开始，支持下面这样的语法：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="k">function</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">int</span> <span class="nv">$a</span><span class="p">,</span> <span class="nx">int</span> <span class="nv">$b</span><span class="p">)</span><span class="o">:</span> <span class="nx">int</span> 
<span class="p">{</span>
    <span class="k">return</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>是不是越来越强类型的感觉？虽然如此，但在非严格类型模式下（strict_types=0，这是默认值），你依然可以这么调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="nx">sum</span><span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div><p>但因为函数参数接收 int 类型（返回值也是 int 类型），因此上面结果是 4，而不是 4.2。如果是严格模式下，只允许传递 int 类型了。（<code>sum('1.2', 3.0)</code> 结果也是 4）</p>
<p>如果希望结果输出 4.2，同时又保持类型约束，怎么办？PHP 不支持方法重载。这就有了 PHP 8 的联合类型。</p>
<blockquote>
<p>联合类型接受多个不同的类型做为参数。声明联合类型的语法为 T1|T2|&hellip;。</p>
</blockquote>
<p>所以，上面代码可以改为：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="k">function</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">int</span><span class="o">|</span><span class="nx">float</span> <span class="nv">$a</span><span class="p">,</span> <span class="nx">int</span><span class="o">|</span><span class="nx">float</span> <span class="nv">$b</span><span class="p">)</span><span class="o">:</span> <span class="nx">int</span><span class="o">|</span><span class="nx">float</span>
<span class="p">{</span>
		<span class="k">return</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这样 <code>sum(1.2, 3)</code> 的结果就是 4.2 了。</p>
<p>一些注意事项：</p>
<ul>
<li>
<p>联合类型也可用于类成员变量；</p>
</li>
<li>
<p>null 可以用于联合类型中，但不能单独作为类型。比如 <code>int|null</code> 允许，但 null 作为类型不允许；</p>
</li>
<li>
<p>下面的函数是合法的：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="k">function</span> <span class="nf">index</span><span class="p">()</span><span class="o">:</span> <span class="nx">int</span><span class="o">|</span><span class="k">false</span>
<span class="p">{</span>
      <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>但返回值改为：<code>int|true</code> 却是非法的。这是出于历史原因，很多内部函数在失败时返回了 false 而不是 null。 这类函数的典型例子是 strpos()。因此允许联合类型中使用 false，但不允许使用 true。注意 false 并非是类型，这里看出是伪类型，不能单独使用。</p>
</li>
</ul>
<p>还有其他一些细节点，详情请访问官方文档查看：<a href="https://www.php.net/manual/zh/language.types.declarations.php">https://www.php.net/manual/zh/language.types.declarations.php</a>。</p>
<blockquote>
<p>不得不说，也许越来越意识到弱类型的问题，PHP 这是在做强类型的事情。然而，不少人要说了，搞这么费劲、这么复杂，还不如直接换强类型语言呢？！你觉得呢？</p>
</blockquote>
<p>当然，你完全可以忽略联合类型，继续使用 5.x 的方式写 PHP。</p>
<h2 id="03-named-arguments命名参数">03 Named Arguments（命名参数）</h2>
<p>这个特性还是很棒的。了解 Python 的朋友应该对这个特性很熟悉。这样一来，PHP 的函数支持不定参数、参数默认值、命名参数等。相对来说，Go 的函数还是弱很多。</p>
<p>比如 htmlspecialchars 函数签名如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="nx">htmlspecialchars</span> <span class="p">(</span> <span class="nx">string</span> <span class="nv">$string</span> <span class="p">[,</span> <span class="nx">int</span> <span class="nv">$flags</span> <span class="o">=</span> <span class="nx">ENT_COMPAT</span> <span class="o">|</span> <span class="nx">ENT_HTML401</span> <span class="p">[,</span> <span class="nx">string</span> <span class="nv">$encoding</span> <span class="o">=</span> <span class="nx">ini_get</span><span class="p">(</span><span class="s2">&#34;default_charset&#34;</span><span class="p">)</span> <span class="p">[,</span> <span class="nx">bool</span> <span class="nv">$double_encode</span> <span class="o">=</span> <span class="k">TRUE</span> <span class="p">]]]</span> <span class="p">)</span> <span class="o">:</span> <span class="nx">string</span>
</code></pre></div><p>PHP 8 之前，如果想要最后一个参数传递 false，需要这么调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="nx">htmlspecialchars</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nx">ENT_COMPAT</span> <span class="o">|</span> <span class="nx">ENT_HTML401</span><span class="p">,</span> <span class="s1">&#39;UTF-8&#39;</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
</code></pre></div><p>而有了命名参数后（PHP 8），可以这么调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="nx">htmlspecialchars</span><span class="p">(</span><span class="nv">$string</span><span class="p">,</span> <span class="nx">double_encode</span><span class="o">:</span> <span class="k">false</span><span class="p">);</span>
</code></pre></div><p>简单清晰。</p>
<p>总结一下就是：</p>
<ul>
<li>仅需指定必需的参数，可跳过可选的参数。</li>
<li>参数是与顺序无关的且具有自记录功能。</li>
</ul>
<p>命名参数确实带来了不少便利。不过我觉得也有一些要注意的点:</p>
<ul>
<li>函数参数可能会很多，Python 中很多函数一大堆参数，可维护性可能是一个问题；</li>
<li>原本函数参数名称是不重要的，但命名参数使得参数名称不能随便改，因为调用者可能依赖它了；</li>
</ul>
<h2 id="04-match-表达式">04 Match 表达式</h2>
<p>实际中我们经常通过 state 来表示各种状态，比如：0-待审核；1-上线；2-下线；3-删除。因为数据库中存的数字，但显示希望是文字说明。这时一般有两种做法：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="k">switch</span> <span class="p">(</span><span class="nv">$state</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
    <span class="nv">$stateDesc</span> <span class="o">=</span> <span class="s1">&#39;待审核&#39;</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
    <span class="nv">$stateDesc</span> <span class="o">=</span> <span class="s1">&#39;上线&#39;</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
    <span class="nv">$stateDesc</span> <span class="o">=</span> <span class="s1">&#39;下线&#39;</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
    <span class="nv">$stateDesc</span> <span class="o">=</span> <span class="s1">&#39;删除&#39;</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">echo</span> <span class="nv">$stateDesc</span><span class="p">;</span>
</code></pre></div><p>我个人喜欢通过 map 来实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="nv">$stateMap</span> <span class="o">=</span> <span class="p">[</span>
  <span class="mi">0</span> <span class="o">=&gt;</span> <span class="s1">&#39;待审核&#39;</span><span class="p">,</span>
  <span class="mi">1</span> <span class="o">=&gt;</span> <span class="s1">&#39;上线&#39;</span><span class="p">,</span>
  <span class="mi">2</span> <span class="o">=&gt;</span> <span class="s1">&#39;下线&#39;</span><span class="p">,</span>
  <span class="mi">3</span> <span class="o">=&gt;</span> <span class="s1">&#39;删除&#39;</span><span class="p">,</span>
<span class="p">];</span>

<span class="k">echo</span> <span class="nv">$stateMap</span><span class="p">[</span><span class="nv">$state</span><span class="p">];</span>
</code></pre></div><p>PHP 8 针对这样的场景提供了 match 表达式：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="k">echo</span> <span class="nx">match</span><span class="p">(</span><span class="nv">$state</span><span class="p">)</span> <span class="p">{</span>
  <span class="mi">0</span> <span class="o">=&gt;</span> <span class="s1">&#39;待审核&#39;</span><span class="p">,</span>
  <span class="mi">1</span> <span class="o">=&gt;</span> <span class="s1">&#39;上线&#39;</span><span class="p">,</span>
  <span class="mi">2</span> <span class="o">=&gt;</span> <span class="s1">&#39;下线&#39;</span><span class="p">,</span>
  <span class="mi">3</span> <span class="o">=&gt;</span> <span class="s1">&#39;删除&#39;</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div><p>可见 match 类似于 switch 语句，有如下特点：</p>
<ul>
<li>Match 是一个表达式，因此其结果可以存储在变量中或返回；</li>
<li>Match 分支仅支持单行表达式，不需要 break 语句；</li>
<li>switch 相当于使用 <code>==</code> 比较，而 Match 使用 <code>===</code> 比较；</li>
<li>如果没匹配到任何项，会抛 UnhandledMatchError 错误；</li>
<li>也支持 default；</li>
</ul>
<p>更多信息查看官方文档：<a href="https://www.php.net/manual/zh/control-structures.match.php">https://www.php.net/manual/zh/control-structures.match.php</a>。</p>
<h2 id="05-nullsafe-运算符nullsafe-operator">05 Nullsafe 运算符（Nullsafe operator）</h2>
<p>了解 Swift 之类的语言，应该知晓其中的可选型。PHP 8 新增的这个特性，我觉得多少有点可选型的意思。</p>
<p>在 PHP 7 中的如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="nv">$country</span> <span class="o">=</span>  <span class="k">null</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nv">$session</span> <span class="o">!==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
  <span class="nv">$user</span> <span class="o">=</span> <span class="nv">$session</span><span class="o">-&gt;</span><span class="na">user</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="nv">$user</span> <span class="o">!==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$address</span> <span class="o">=</span> <span class="nv">$user</span><span class="o">-&gt;</span><span class="na">getAddress</span><span class="p">();</span>
 
    <span class="k">if</span> <span class="p">(</span><span class="nv">$address</span> <span class="o">!==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="nv">$country</span> <span class="o">=</span> <span class="nv">$address</span><span class="o">-&gt;</span><span class="na">country</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在 PHP 8 中简化为：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="nv">$country</span> <span class="o">=</span> <span class="nv">$session</span><span class="o">?-&gt;</span><span class="na">user</span><span class="o">?-&gt;</span><span class="na">getAddress</span><span class="p">()</span><span class="o">?-&gt;</span><span class="na">country</span><span class="p">;</span>
</code></pre></div><h2 id="06-构造器属性提升">06 构造器属性提升</h2>
<p>PHP 8 起构造器的参数可以提升为类的属性。构造器的参数赋值给类属性的行为很普遍，否则无法操作。 而构造器提升的功能则为这种场景提供了便利。 例如下面的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="k">public</span> <span class="nx">float</span> <span class="nv">$x</span><span class="p">;</span>
  <span class="k">public</span> <span class="nx">float</span> <span class="nv">$y</span><span class="p">;</span>
  <span class="k">public</span> <span class="nx">float</span> <span class="nv">$z</span><span class="p">;</span>

  <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span>
    <span class="nx">float</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="nx">float</span> <span class="nv">$y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="nx">float</span> <span class="nv">$z</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">x</span> <span class="o">=</span> <span class="nv">$x</span><span class="p">;</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">y</span> <span class="o">=</span> <span class="nv">$y</span><span class="p">;</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">z</span> <span class="o">=</span> <span class="nv">$z</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>改为 PHP 8 的方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span>
    <span class="k">public</span> <span class="nx">float</span> <span class="nv">$x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="k">public</span> <span class="nx">float</span> <span class="nv">$y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="k">public</span> <span class="nx">float</span> <span class="nv">$z</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
  <span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><h2 id="07-字符串与数字的比较更符合逻辑">07 字符串与数字的比较更符合逻辑</h2>
<p>PHP 8 比较数字字符串（numeric string）时，会按数字进行比较。 不是数字字符串时，将数字转化为字符串，按字符串比较。</p>
<p>这一点要注意，之前这样的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="mi">0</span> <span class="o">==</span> <span class="s1">&#39;foobar&#39;</span> <span class="c1">// true
</span></code></pre></div><p>现在是 false：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="mi">0</span> <span class="o">==</span> <span class="s1">&#39;foobar&#39;</span> <span class="c1">// false
</span></code></pre></div><p>更多说明参见这里：<a href="https://wiki.php.net/rfc/string_to_number_comparison">https://wiki.php.net/rfc/string_to_number_comparison</a>。</p>
<h2 id="08-注解attributes">08 注解（attributes）</h2>
<p>现在可以用 PHP 原生语法来使用结构化的元数据，而非 PHPDoc 声明。</p>
<p>之前这么写：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="k">class</span> <span class="nc">PostsController</span>
<span class="p">{</span>
    <span class="sd">/**
</span><span class="sd">     * @Route(&#34;/api/posts/{id}&#34;, methods={&#34;GET&#34;})
</span><span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">get</span><span class="p">(</span><span class="nv">$id</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>现在这么写：</p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="k">class</span> <span class="nc">PostsController</span>
<span class="p">{</span>
    <span class="c1">#[Route(&#34;/api/posts/{id}&#34;, methods: [&#34;GET&#34;])]
</span><span class="c1"></span>    <span class="k">public</span> <span class="k">function</span> <span class="nf">get</span><span class="p">(</span><span class="nv">$id</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="09-即时编译">09 即时编译</h2>
<p>PHP 8 引入了两个即时编译引擎。 Tracing JIT 在两个中更有潜力，它在综合基准测试中显示了三倍的性能， 并在某些长时间运行的程序中显示了 1.5-2 倍的性能改进。 典型的应用性能则和 PHP 7.4 不相上下。</p>
<p>官方给了一个性能测试：</p>
<p><p class="md__image">
  <img src="../imgs/php8-jit.png"
    alt=""  />
</p>
</p>
<h2 id="10-总结">10 总结</h2>
<p>PHP 8 还有很多其他改动，在这里有详细的说明：<a href="https://www.php.net/releases/8.0/zh.php">https://www.php.net/releases/8.0/zh.php</a>。其中新增了 3 个函数实用的函数：str_contains()、str_starts_with() 和 str_ends_with()。（Go 表示第一天就有了）</p>
<p>这里面的新特性，命名参数我个人还是比较喜欢。你呢？</p>
]]></content>
		</item>
		
		<item>
			<title>推荐一个网站：其实是三个网站</title>
			<link>https://polarisxu.studygolang.com/posts/share/programming-idioms/</link>
			<pubDate>Mon, 07 Dec 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/share/programming-idioms/</guid>
			<description>大家好，我是站长 polarisxu。 现在这样的环境要求我们程序员掌握多门语言。然而，很多人在掌握了一门语言后，学习其他语言时，总会有前一门语言的影子；亦或有些人希望在学习新语言时能和之前的语言进行对比学习。 无意中发现一个网站，对有上述情况的人可能有些帮助，因此推荐给大家。网站地址：https://programming-idioms.org/。 从网站名称也能</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>现在这样的环境要求我们程序员掌握多门语言。然而，很多人在掌握了一门语言后，学习其他语言时，总会有前一门语言的影子；亦或有些人希望在学习新语言时能和之前的语言进行对比学习。</p>
<p>无意中发现一个网站，对有上述情况的人可能有些帮助，因此推荐给大家。网站地址：<a href="https://programming-idioms.org/">https://programming-idioms.org/</a>。</p>
<p><p class="md__image">
  <img src="../imgs/programming-idioms-home.png"
    alt=""  />
</p>
</p>
<p>从网站名称也能猜出作者的意图，希望让大家掌握每门语言自己的习语。</p>
<p>下面简单介绍下该网站。</p>
<h2 id="01">01</h2>
<p>首先这个网站的核心存储部分代码是开源的，使用 Go 语言实现。源码地址：<a href="https://github.com/Deleplace/programming-idioms">https://github.com/Deleplace/programming-idioms</a>。</p>
<p>这个网站看起来功能不少，看菜单：</p>
<p><p class="md__image">
  <img src="../imgs/programming-idioms-nav.png"
    alt=""  />
</p>
</p>
<p>实际上主要是 idioms （目前 241 个），以及 31 门语言。通过这两者的组合，形成了相关的内容。比如，你可以看看 Hello World 在各个语言都是如何实现的。</p>
<h2 id="02">02</h2>
<p>我认为该网站最有价值的一点在于它提供的 Cheatsheets 功能。</p>
<p><p class="md__image">
  <img src="../imgs/programming-idioms-cheatsheets.png"
    alt=""  />
</p>
</p>
<p>通过选择两门语言来对比学习，比如 Go 和 Rust，你可以在这里查看：<a href="https://programming-idioms.org/cheatsheet/Go/Rust">https://programming-idioms.org/cheatsheet/Go/Rust</a>。这样你可以快速的通过一门自己熟悉的语言了解另外一门陌生的语言。</p>
<p><p class="md__image">
  <img src="../imgs/programming-idioms-go-vs-rust.png"
    alt=""  />
</p>
</p>
<h2 id="03">03</h2>
<p>目前该站点的 Idioms 还不多，但每个人都可以贡献，通过该链接可以创建一个 idioms：<a href="https://programming-idioms.org/idiom-create">https://programming-idioms.org/idiom-create</a>。</p>
<p>此外，通过这个站点还发现了另外两个站点。</p>
<ul>
<li><a href="https://hyperpolyglot.org/">https://hyperpolyglot.org/</a>。这个站点通过并排的方式显示不同语言的对比，类似上面的 Cheatsheets。比如 C 语言与 Go 语言的对比就值得一看：<a href="https://hyperpolyglot.org/c">https://hyperpolyglot.org/c</a>；</li>
<li><a href="https://rosettacode.org/wiki/Rosetta_Code">https://rosettacode.org/wiki/Rosetta_Code</a>。这是一个编程主题网站。这个想法是要以尽可能多的不同语言提供针对同一任务的解决方案，以展示语言的相似性和差异性，并以一种解决方案为基础来帮助一个人学习另一门语言。 Rosetta Code 目前有 1,081 个任务，220 个草稿任务，有超过 810 种语言。当然没法为每种语言的每项任务提供解决方案，这需要大家一起努力，它已经形成了一个社区。实际上，这里有很多 LeetCode 上的题解。这个网站是刷算法的一个辅助网站。</li>
</ul>
<h2 id="04">04</h2>
<p>你发现了其他好的站点吗？欢迎留言分享给大家，好东西别私藏哦。</p>
]]></content>
		</item>
		
		<item>
			<title>GoLand 2020.3 正式发布了，有不少新功能，包括支持泛型</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/goland-2020-3-release/</link>
			<pubDate>Fri, 04 Dec 2020 22:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/goland-2020-3-release/</guid>
			<description>这是 2020 年第 3 个版本，也是最后一个版本。在 GoLand 2020.3 中，您可以探索 goroutines dumps，运行并导航到单个表测试（table tests），并从对 Testify 测试框架的扩展支持中获得更多信息。你还将发现许多新的代码编辑功能，包括对 time 包的支持，更智能的处理包方法，UI 改进，用于 Web 开发和使用数据库的各种新功能以及用于协作开发和结对编程的新服务。具体看看有哪些新特性。 01 调试器改进 Dump Goroutines 调试器中新</description>
			<content type="html"><![CDATA[<p>这是 2020 年第 3 个版本，也是最后一个版本。在 GoLand 2020.3 中，您可以探索 goroutines dumps，运行并导航到单个表测试（table tests），并从对 Testify 测试框架的扩展支持中获得更多信息。你还将发现许多新的代码编辑功能，包括对 time 包的支持，更智能的处理包方法，UI 改进，用于 Web 开发和使用数据库的各种新功能以及用于协作开发和结对编程的新服务。具体看看有哪些新特性。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020-3-release.png"
    alt=""  />
</p>
</p>
<h2 id="01-调试器改进">01 调试器改进</h2>
<h3 id="dump-goroutines">Dump Goroutines</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-dump-goroutines.gif"
    alt=""  />
</p>
</p>
<p>调试器中新的转储 Goroutines（Dump Goroutines） 图标使您可以在调试会话期间轻松地在堆栈中查找包含指定字符串的 goroutine。只需单击该图标即可在单独的窗口中打开转储。</p>
<p>为了帮助您始终关注重要信息，可以选择隐藏单个goroutine或具有相同堆栈的goroutine。右键单击goroutine，然后选择所需的操作，或按Delete键将其移至转储窗口中的特殊“隐藏”部分，这样不会分散您的注意力。</p>
<h3 id="go-remote-configuration">Go Remote configuration</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-remote-debug.gif"
    alt=""  />
</p>
</p>
<p>如果不需要重新连接，GoLand 2020.3可以通过 Go Remote 配置停止进程。</p>
<p>在配置设置中，您可以指定断开连接时调试器的默认行为，可以选择 “Stop remote Delve processes”，“使其保持运行状态”或让 GoLand 每次询问您如何继续。</p>
<h2 id="02-测试增强">02 测试增强</h2>
<h3 id="支持-table-tests">支持 table tests</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-table-tests-support.gif"
    alt=""  />
</p>
</p>
<p>您可以从 “Run” 工具窗口运行并导航到表测试。</p>
<p>有一些限制：</p>
<ul>
<li>测试数据变量必须是切片，数组或 map。它必须在与调用相同的函数中定义，并且在初始化后不得修改（for 循环中的 range 子句除外）。</li>
<li>各个测试数据条目必须是结构体字面值。调用前不得使用子测试名称表达式中使用的循环变量。</li>
<li>子测试名称表达式可以是测试数据中的字符串字段，测试数据字符串字段的连接以及带有 ％s 和 ％d 动词的fmt.Sprintf() 调用。</li>
</ul>
<h3 id="扩展了对-testify-的支持">扩展了对 Testify 的支持</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-testify-framework.gif"
    alt=""  />
</p>
</p>
<p>现在，IDE 可以识别启动测试套件的测试功能，并提供一种启动单个 suite.Run 和 suite.T().Run，只要子测试名称是字符串常量即可。另外，可以从“Run”工具窗口重新运行子测试，以避免重新运行整个顶级测试。</p>
<p>此外，GoLand 现在可以在一个测试用例中使用相同的方法名称分别运行 Testify 套件。</p>
<p>最后但并非最不重要的一点是，当您准备写测试函数时（testing.T 作为第一个参数），GoLand 会在可能的情况下自动传递该参数。这适用于 testify/assert，testify/require，testify/mock 和 testify/suite 包。</p>
<h2 id="03-代码检查">03 代码检查</h2>
<p><p class="md__image">
  <img src="../imgs/2020-3-incorrect-usage-println-printf.png"
    alt=""  />
</p>
</p>
<p>不正确使用类似 Println/Printf 的函数，GoLand 会有警告，之前只对标准库起作用，现在支持 github.com/pkg/errors, github.com/sirupsen/logrus 和 go.uber.org/zap 包。</p>
<p>最重要的是，我们添加了占位符突出显示和折叠，以及添加格式字符串参数的意图。</p>
<p><p class="md__image">
  <img src="../imgs/2020-3-code-inspection-cancel-function.png"
    alt=""  />
</p>
</p>
<p>context.CancelFunc（不称为代码检查）报告了 context 取消的潜在不安全使用。当 context 返回的 “cancel” 函数未在所有执行路径上调用时，此功能特别有用。</p>
<p>更多细节可以查看标准库文档：<a href="https://docs.studygolang.com/pkg/context">https://docs.studygolang.com/pkg/context</a>。</p>
<h2 id="04-代码编辑">04 代码编辑</h2>
<h3 id="time-包的支持">time 包的支持</h3>
<blockquote>
<p>Go 语言中文网注：Go 中的时间格式化和其他语言不一样，其他语言都是使用 YYYY、MM、dd 等，而 Go 使用魔法数字：2006-01-02 15:04:05 这样的固定时间。有些人可能记不住或习惯其他语言的格式。GoLand 2020.3 做了这样的转换，见下图。</p>
</blockquote>
<p><p class="md__image">
  <img src="../imgs/2020-3-go-time-support.gif"
    alt=""  />
</p>
</p>
<p>我们增加了对 time 包的支持，因此您可以更轻松地使用 time 和 duration。 GoLand 将通过代码补全（⌃Space）建议使用 ISO-8601 中 YYYY，MM，DD 占位符的预定义 Layout。</p>
<p>在某个 token 上按 ⌘P，IDE 将显示其含义。Layout 标记也有语法突出显示。代码完成还建议在字符串文字之外的标准时间 Layout。</p>
<h3 id="更智能的包处理">更智能的包处理</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-go-smarter-package-handling.gif"
    alt=""  />
</p>
</p>
<p>现在，IDE 可以更聪明地为您经常使用的包的提示项配置优先级，这些包是在项目的 go.mod 文件中明确声明的。</p>
<p>我们还添加了一个选项，可将包从项目导入路径和完成建议中完全排除。您可以通过 Alt + Enter 或在排除窗口中执行此操作。</p>
<h3 id="支持变量-shadowing">支持变量 shadowing</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-shadow-variables.png"
    alt=""  />
</p>
</p>
<p>GoLang 可以更轻松地发现变量 shadowing。</p>
<ul>
<li>IDE 显示的变量现在可以用不同的颜色区分 shadowing 变量。</li>
<li>导航到 shadowing 声明意图操作，使您可以立即切换到 shadowing 声明。</li>
</ul>
<h3 id="类型参数中的方括号">类型参数中的方括号</h3>
<p>我们跟踪了 Go 小组对 <a href="https://groups.google.com/g/golang-nuts/c/iAD0NBz3DYw?pli=1" target="_blank" rel="noopener">泛型</a>
 的更新，并增加了对泛型语法方括号的支持。</p>
<p>请注意，Settings | Go 中的 “<em>Enable generics (experimental support for type parameters)</em> ” 默认情况下处于关闭状态。您需要明确选择该复选框才能开始使用该功能。</p>
<p>更多关于该功能的信息可以<a href="https://blog.jetbrains.com/go/2020/11/24/experimenting-with-go-type-parameters-generics-in-goland/" target="_blank" rel="noopener">查看该文章</a>
。</p>
<h2 id="05-其他改进">05 其他改进</h2>
<p><p class="md__image">
  <img src="../imgs/2020-3-bench-test-live-templates.png"
    alt=""  />
</p>
</p>
<p>在测试文件中键入 func 时，默认情况下，GoLand 会提示出 bench 和 test 函数模板。</p>
<p><p class="md__image">
  <img src="../imgs/2020-3-for-loop-for-bench.png"
    alt=""  />
</p>
</p>
<p>当您在基准测试中输入 for 时，IDE 建议使用 b.N 的 for 循环来完成它。</p>
<h3 id="改进了拼写和语法检查器">改进了拼写和语法检查器</h3>
<p><p class="md__image">
  <img src="../imgs/2020-3-grammar-checkers.gif"
    alt=""  />
</p>
</p>
<p>现在，当您按 Alt + Enter 时，建议会立即显示在对话框中。此外，新版本的 LanguageTool 语法检查引擎还改进了英语检查功能，并增加了对 10 种其他语言的支持。</p>
<h2 id="06-和我编码结对编程">06 和我编码（结对编程）</h2>
<p><p class="md__image">
  <img src="../imgs/2020-3-code-with-me-marketplace.png"
    alt=""  />
</p>
</p>
<p>GoLand 2020.3 支持 Code With Me（EAP），这是 JetBrains 的一项新服务，用于协作开发和结对编程。与我一起编写代码使您可以与他人共享您当前在 IDE中 打开的项目，并实时进行协作。</p>
<p>关于该功能的更多信息请查看<a href="https://blog.jetbrains.com/tag/codewithme/" target="_blank" rel="noopener">这篇文章</a>
。</p>
<h2 id="07-其他">07 其他</h2>
<p>其他的改进有：</p>
<ul>
<li>UI 改进；</li>
<li>VSC 更新；</li>
<li>Web 开发增强；</li>
<li>对数据库支持增强；</li>
</ul>
<p>关于这块的详细信息可以到<a href="https://www.jetbrains.com/go/promo/whatsnew/" target="_blank" rel="noopener">这里查看</a>
。</p>
<h2 id="08-总结">08 总结</h2>
<p>GoLand 是一个收费软件，可以试用 30 天。如果觉得不错，欢迎支持！当然免费的 VSCode 也香，对吧！</p>
]]></content>
		</item>
		
		<item>
			<title>列举一些 Go1.16 中可能对大家有影响的变化</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go1.16-changes-2020/</link>
			<pubDate>Wed, 02 Dec 2020 19:20:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go1.16-changes-2020/</guid>
			<description>大家好，我是站长 polarisxu。 先说一下我一般怎么了解 Go 最新的一些动态。 01 从哪获取信息 主要通过以下方式： 逛推特，通过搜索功能，浏览 Go 信息，比如搜索：#golang since:2020-12-01 until:2020-12-02 看 Go 仓库的提交记录； 查看 https://tip.golang.org。这个一般在一个版本开发了一段时间看，比如现在可以看 Go1.16 的一些内容，主要可以看还未完成的 Release Notes：https://tip</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>先说一下我一般怎么了解 Go 最新的一些动态。</p>
<h2 id="01-从哪获取信息">01 从哪获取信息</h2>
<p>主要通过以下方式：</p>
<ul>
<li>
<p>逛推特，通过搜索功能，浏览 Go 信息，比如搜索：<code>#golang since:2020-12-01 until:2020-12-02</code></p>
</li>
<li>
<p>看 Go 仓库的提交记录；</p>
<p><p class="md__image">
  <img src="../imgs/go-commit-log.png"
    alt=""  />
</p>
</p>
</li>
<li>
<p>查看 <a href="https://tip.golang.org">https://tip.golang.org</a>。这个一般在一个版本开发了一段时间看，比如现在可以看 Go1.16 的一些内容，主要可以看还未完成的 Release Notes：<a href="https://tip.golang.org/doc/go1.16">https://tip.golang.org/doc/go1.16</a>。其实这个文件是 Go 代码仓库中的 doc/go1.16.html；</p>
</li>
</ul>
<p>此外，Reddit 的 r/golang 频道也会有很多信息。</p>
<h2 id="02-go-116-的一些改动">02 Go 1.16 的一些改动</h2>
<p>按计划，Go1.16 会在 2021 年 2 月份发布。目前 Release Notes 中已经有部分内容了。</p>
<h3 id="module-模式会默认开启">Module 模式会默认开启</h3>
<p>经过了这么多版本，终于默认开启了。默认开启是什么意思？即 GO111MODULE 环境变量的默认值将从 auto 改变为 on。这将解决一些目前使用 go 命令时的尴尬 。比如有些人可能说，明明我设置了 GOPROXY，但是 go get 依然没有经过它，下载依然失败。这是因为在非 modules 感知目录下运行 go get 时，自动选择了 GOPATH 模式而忽略了 GOPROXY 环境变量。如果你现在遇到这种情况，请手动将 GO111MODULE 环境变量更改为 on。</p>
<h3 id="内嵌静态资源">内嵌静态资源</h3>
<p>支持内嵌静态资源（文件或者文件夹）至生成的二进制文件中。这部分之前写文章介绍过，<a href="https://mp.weixin.qq.com/s/SiCTV7R2wA_I2nCQkC3GGQ" target="_blank" rel="noopener">见这里</a>
。</p>
<h3 id="支持最新版本-mac">支持最新版本 Mac</h3>
<p>最新版 Mac 使用了 ARM 架构，因此 Go 1.16 增加 <code>GOOS=darwin, GOARCH=arm64</code> 支持，而这之前是用于 iOS 的，以后 iOS port 改为 <code>GOOS=ios, GOARCH=arm64</code>。</p>
<h3 id="linux-系统下-rss-会更准确">Linux 系统下 RSS 会更准确</h3>
<p>在 Linux 上，runtime 现在默认会迅速地（使用 MADV_DONTNEED）向操作系统释放内存，而不是在操作系统面临内存压力时（使用 MADV_FREE）惰性地释放内存。</p>
<p>这意味着像 RSS 这样的进程级内存统计信息将更准确地反映 Go 进程所使用的物理内存数量。因此 Go1.16 中，不再需要配置 GODEBUG=madvdontneed=1 来改善内存监控行为。</p>
<h3 id="切片扩容策略改变">切片扩容策略改变</h3>
<p>如果一个 <code>append(x, values…)</code> 调用需要扩容，则基础切片 x 的容量将决定结果切片的容量（而不是原来的基础切片 x 的长度决定结果切片的容量）。</p>
<p>借用<a href="https://mp.weixin.qq.com/s/JAWKZeDSNYJlVc6GPNKqlg" target="_blank" rel="noopener">公众号 Go101</a>
 中的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">N</span> <span class="p">=</span> <span class="mi">1024</span>
  <span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="nx">N</span><span class="p">]</span><span class="kt">int</span>
  <span class="nx">x</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">[:</span><span class="nx">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="nx">N</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
  <span class="nx">y</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">[:</span><span class="nx">N</span><span class="p">:</span><span class="nx">N</span><span class="p">],</span> <span class="mi">9</span><span class="p">)</span>
  <span class="nb">println</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">y</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>Go 1.15 将输出 2048 1280，但是使用 Go 1.16 将输出 1280 1280。</p>
<p>具体提交见：<a href="https://github.com/golang/go/commit/2333c6299f340a5f76a73a4fec6db23ffa388e97?branch=2333c6299f340a5f76a73a4fec6db23ffa388e97&amp;diff=unified">https://github.com/golang/go/commit/2333c6299f340a5f76a73a4fec6db23ffa388e97?branch=2333c6299f340a5f76a73a4fec6db23ffa388e97&amp;diff=unified</a>。</p>
<h3 id="标准库">标准库</h3>
<p>1）增加了 io/fs、embed 等库。</p>
<p>2）template 允许跨行。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="p">{{</span><span class="s">&#34;hello&#34;</span> <span class="p">|</span>
   <span class="nx">printf</span><span class="p">}}</span>
</code></pre></div><p>3）strconv.ParseFloat 性能提升 2 倍。原因是它改为使用 <a href="https://nigeltao.github.io/blog/2020/eisel-lemire.html" target="_blank" rel="noopener">Eisel-Lemire 算法</a>
。这也会加速解码诸如 encoding/json 这样的文本格式。</p>
<h3 id="简化的结构体字段标签写法">简化的结构体字段标签写法</h3>
<p>在进行 Web 开发时，Model 类可能会有好几种标签，写起来很繁琐，因此还出现了不少这样辅助写标签的工具。Go 1.16 开始，结构体字段的标签中的值相同的键值对可以合并写成一个，方便很多，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">UserName</span> <span class="kt">string</span> <span class="s">`json bson gorm:&#34;user_name,omitempty&#34;`</span>
<span class="p">}</span>
</code></pre></div><h3 id="知晓-init-函数的执行时间和内存消耗">知晓 init 函数的执行时间和内存消耗</h3>
<p>关于该函数，大家都建议尽量别用，至少不能依赖它。同时不应该在其中处理耗时的事情。但之前没有很好地方法检测。Go 1.16 为 GODEBUG 环境变量增加了 inittrace=1 选项，可以输出 init 函数的执行时间和内存消耗。</p>
<p>再次借用 <a href="https://mp.weixin.qq.com/s/Lz1PwW0mzWMNxiuJBvdcXA" target="_blank" rel="noopener">Go101 的例子</a>
。</p>
<p>对于下面的程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;bye&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>使用下面的命令运行（Linux 系统，Go tip rev:7f688d18c0）:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nv">GODEBUG</span><span class="o">=</span><span class="nv">inittrace</span><span class="o">=</span><span class="m">1</span> go run main.go 
</code></pre></div><p>的输出为：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">init internal/bytealg @0.018 ms, <span class="m">0</span> ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
init runtime @0.15 ms, 0.56 ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
init errors @1.7 ms, 0.010 ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
init sync @1.8 ms, 0.001 ms clock, <span class="m">16</span> bytes, <span class="m">1</span> allocs
init internal/oserror @1.8 ms, 0.001 ms clock, <span class="m">80</span> bytes, <span class="m">5</span> allocs
init syscall @1.9 ms, 0.010 ms clock, <span class="m">944</span> bytes, <span class="m">2</span> allocs
init <span class="nb">time</span> @1.9 ms, 0.014 ms clock, <span class="m">400</span> bytes, <span class="m">8</span> allocs
init context @2.0 ms, 0.002 ms clock, <span class="m">128</span> bytes, <span class="m">4</span> allocs
init math @2.0 ms, <span class="m">0</span> ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
init strconv @2.1 ms, 0.006 ms clock, <span class="m">32</span> bytes, <span class="m">2</span> allocs
init unicode @2.1 ms, 0.086 ms clock, <span class="m">23944</span> bytes, <span class="m">27</span> allocs
...
init internal/bytealg @0 ms, <span class="m">0</span> ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
init runtime @0.048 ms, 0.042 ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
hello
init main @0.21 ms, 0.004 ms clock, <span class="m">0</span> bytes, <span class="m">0</span> allocs
bye
</code></pre></div><p>可见此 GODEBUG 环境变量选项对于查找 init 函数中的瓶颈很有帮助。</p>
<p>相关 issue: <a href="https://github.com/golang/go/issues/41378">https://github.com/golang/go/issues/41378</a>。</p>
<h2 id="03-总结">03 总结</h2>
<p>Go 1.16 相比 Go 1.15 改动多不少，更多内容等待明年 2 月份发布。</p>
<p>另外推荐 Go101 这本开源书，作者对 Go 的细节掌握的很深，而且他写了双语版，这里是中文版：<a href="https://github.com/golang101/golang101">https://github.com/golang101/golang101</a>。</p>
]]></content>
		</item>
		
		<item>
			<title>Hugo &#43; GitHub Pages 搭建自己的网站</title>
			<link>https://polarisxu.studygolang.com/posts/talk/myblog-with-hugo-github-pages/</link>
			<pubDate>Tue, 01 Dec 2020 11:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/myblog-with-hugo-github-pages/</guid>
			<description>大家好，我是站长 polarisxu。 很早之前，我使用 WordPress 搭建了个人博客：http://blog.studygolang.com，毕竟那时候 WordPress 是首选。现如今，大家似乎更喜欢静态博客，各种语言的静态博客生成器轮子不断，比如 Go 语言的 Hugo 就是一个静态博客生成器。我个人认为，静态博客生成器流行的一个很大原因，是 Markdown 的流行，开发人员习惯了使用 Markdown 进行写作。 对于我，有另外一个痛点</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>很早之前，我使用 WordPress 搭建了个人博客：<a href="http://blog.studygolang.com">http://blog.studygolang.com</a>，毕竟那时候 WordPress 是首选。现如今，大家似乎更喜欢静态博客，各种语言的静态博客生成器轮子不断，比如 Go 语言的 Hugo 就是一个静态博客生成器。我个人认为，静态博客生成器流行的一个很大原因，是 Markdown 的流行，开发人员习惯了使用 Markdown 进行写作。</p>
<p>对于我，有另外一个痛点。最近在公众号写了一些文章，希望同步到博客，只是文字还好处理些，如果涉及到图片，微信公众号上传了一次，博客还得再来一次，挺费劲的。同时，为了保留最原始的文字，原始博文放在 GitHub 是一个不错的选择（用 Git 保留你的修改，不要太棒好嘛！）。</p>
<p>既然博文都保存在了 GitHub 上，怎么方便快速的基于 GitHub 来搭建自己的博客呢？（有些人直接就让在 GitHub 阅读，虽然可以，但体验还是不太好，而且看起来没有那么高大上，是不是？）</p>
<p>我想过使用 GitBook 来搭建，安装时，发现官方已经不维护 gitbook-cli 了，而且每次新增加文章，都得维护目录等，也是挺费劲的。于是放弃了这种方式。</p>
<p>这时我想到了通过静态博客生成器来搞。最喜欢 Go，自然 Hugo 成为第一选择。</p>
<p>废话不多少，记录下我搭建的过程。</p>
<h2 id="01-安装-hugo">01 安装 Hugo</h2>
<p>你可以通过 <a href="https://github.com/gohugoio/hugo/releases">https://github.com/gohugoio/hugo/releases</a> 下载相应的安装包，我喜欢源码安装。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ go get -v github.com/gohugoio/hugo
</code></pre></div><p>如果你也想通过源码安装，请自行准备好 Go 环境。</p>
<p>查看版本同时验证是否安装成功：（查看该文时，最新版本可能变了）</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hugo version
Hugo Static Site Generator v0.76.5 darwin/amd64 BuildDate: unknown
</code></pre></div><h2 id="02-使用-hugo">02 使用 Hugo</h2>
<p>在你本机某个目录执行如下命令，创建一个网站，我使用 polarisxu 这个名字。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hugo new site polarisxu
Congratulations! Your new Hugo site is created in /Users/xuxinhua/project/testhugo/polarisxu.

Just a few more steps and you<span class="err">&#39;</span>re ready to go:

1. Download a theme into the same-named folder.
   Choose a theme from https://themes.gohugo.io/ or
   create your own with the <span class="s2">&#34;hugo new theme &lt;THEMENAME&gt;&#34;</span> command.
2. Perhaps you want to add some content. You can add single files
   with <span class="s2">&#34;hugo new &lt;SECTIONNAME&gt;/&lt;FILENAME&gt;.&lt;FORMAT&gt;&#34;</span>.
3. Start the built-in live server via <span class="s2">&#34;hugo server&#34;</span>.

Visit https://gohugo.io/ <span class="k">for</span> quickstart guide and full documentation.
</code></pre></div><p>进入 polarisxu 目录，查看目录结构如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ tree
.
├── archetypes
│   └── default.md
├── config.toml
├── content
├── data
├── layouts
├── static
└── themes

<span class="m">6</span> directories, <span class="m">2</span> files
</code></pre></div><p>接下来需要为我们的网站指定一个主题，这里我们选择 <a href="https://themes.gohugo.io/hermit/">https://themes.gohugo.io/hermit/</a> 这个主题。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git clone https://github.com/Track3/hermit.git themes/hermit
</code></pre></div><p>将该主题增加到网站的配置文件中，这样才能生效：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">echo</span> <span class="s1">&#39;theme = &#34;hermit&#34;&#39;</span> &gt;&gt; config.toml
</code></pre></div><p>测试下是否成功，运行：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hugo serve
</code></pre></div><p>打开浏览器访问：<a href="http://localhost:1313/">http://localhost:1313/</a>，看到如下内容：</p>
<p><p class="md__image">
  <img src="../imgs/hugo01.png"
    alt=""  />
</p>
</p>
<p>对该主题进行一些配置。一般的，主题会有例子，我们直接拷贝例子中的 config.toml 覆盖网站的 config.toml：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cp -rf themes/hermit/exampleSite/config.toml .
</code></pre></div><p>再次运行 <code>hugo serve</code>，页面如下：</p>
<p><p class="md__image">
  <img src="../imgs/hugo02.png"
    alt=""  />
</p>
</p>
<p>可见，这个页面内容可以通过 config.toml 配置，根据需要做一些修改，页面变成这样：（不同主题可能不一样）</p>
<p><p class="md__image">
  <img src="../imgs/hugo04.png"
    alt=""  />
</p>
</p>
<p>不过点击 「文章」 和 「关于」 都报 404。</p>
<h3 id="增加列表页">增加列表页</h3>
<p>在 content/posts 目录下新增一个文件：<code>_index.md</code>，内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">---
title: &#34;文章列表&#34;
---
</code></pre></div><p>这时（hugo serve 会自动编译）点击 Posts，页面如下：</p>
<p><p class="md__image">
  <img src="../imgs/hugo03.png"
    alt=""  />
</p>
</p>
<h3 id="增加-about-页面">增加 About 页面</h3>
<p>同样的，在 content/posts 目录下新增文件 <code>about.md</code>，正文内容随意，类似这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">---
title: &#34;关于&#34;
date: &#34;2020-12-01&#34;
---

这是关于页面，polarisxu。
</code></pre></div><h3 id="测试文章">测试文章</h3>
<p>接着，增加一篇测试文章：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hugo new posts/my-first-post.md
</code></pre></div><p>这会在 content/posts 目录下生成一个 my-first-post.md 文件，里面内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">---
title: &#34;My First Post&#34;
date: 2020-11-30T23:33:03+08:00
draft: true
toc: false
images:
tags:
  <span class="k">-</span> untagged
---
</code></pre></div><p>其中 <code>---</code> 之间的数据是文章的元数据，在 Hugo 中叫做 <a href="https://gohugo.io/content-management/front-matter/" target="_blank" rel="noopener">Front Matter</a>
。</p>
<p>随意增加一些内容，并做一些修改：（其中 isCJKLanguage: true 用于准确计算中文字数）</p>
<div class="highlight"><pre class="chroma"><code class="language-markdown" data-lang="markdown">---
title: &#34;第一篇文章&#34;
date: 2020-11-30T23:33:03+08:00
draft: false
toc: false
isCJKLanguage: true
images:
tags: 
  <span class="k">-</span> 文章
---

这是第一篇文章。。。
</code></pre></div><p>查看文章详情：<a href="http://localhost:1313/posts/my-first-post/">http://localhost:1313/posts/my-first-post/</a>。</p>
<p><p class="md__image">
  <img src="../imgs/hugo05.png"
    alt=""  />
</p>
</p>
<p>如果文章完成，可以执行 <code>hugo</code> 命令，生成静态页面。默认会将生成的静态页面放入 public 目录中。</p>
<p>关于 Hugo 更多的定制，比如 theme 的定制，这里不过多讲解，有兴趣的自己琢磨。比如虽然 <a href="https://polarisxu.studygolang.com/">https://polarisxu.studygolang.com/</a> 和这里的例子使用了同一个模板，但样子却有不少不同，你可以查看 <a href="https://github.com/polaris1119/polarisxu">https://github.com/polaris1119/polarisxu</a>，对比到底做了什么，折腾一番，基本会了。</p>
<h2 id="03-使用-github-pages-部署站点">03 使用 GitHub Pages 部署站点</h2>
<p>这是 GitHub 为你和你的项目准备网站的，GitHub Pages 官方站点：<a href="https://pages.github.com/">https://pages.github.com/</a>，大概就是通过将网站内容放到 GitHub，通过 GitHub Pages 可以弄出一个自己的站点。它最常使用的是通过 Jekyll 这个站点生成器生成静态页面，有兴趣的自行查阅资料了解。我们应该使用 Hugo 生成静态页面，因此直接将静态页面部署到 GitHub Pages。</p>
<h3 id="创建一个特殊的仓库">创建一个特殊的仓库</h3>
<p>在 GitHub 上创建一个仓库，不过仓库名有特殊要求。如果是个人账号，比如我的 GitHub ID 是 polaris1119，则仓库名是：polaris1119.github.io；如果是组织账号，比如 studygolang 这个组织，则仓库名是：studygolang.github.io。</p>
<h3 id="配置仓库">配置仓库</h3>
<p>进入仓库的 Settings 页面，有一个区块叫 GitHub Pages，可以配置站点信息，比如内容来源、自定义域名、是否启用 HTTPS 等。</p>
<p><p class="md__image">
  <img src="../imgs/hugo06.png"
    alt=""  />
</p>
</p>
<p>说明如下：</p>
<ul>
<li>数据源默认使用主分支下的根目录，我个人建议改为 docs 目录；</li>
<li>自定义域名如果留空，则默认仓库名就是你的域名，比如我这里的 polaris1119.github.io；</li>
<li>如果配置了自定义域名，则需要在你的域名配置上 CNAME 记录。我这里就是 polarisxu 这个子域名的 CNAME 值是 polaris1119.github.io；</li>
<li>如果配置了自定义域名，启用 HTTPS 需要等待一段时间才能生效；</li>
</ul>
<p>你可以在该仓库上正确的位置放置一个 index.html 文件，测试是否正常。</p>
<blockquote>
<p>小细节：避免 Jekyll 起作用，可以在仓库根目录放一个空文件，文件名： .nojekyll</p>
</blockquote>
<h3 id="部署我们的站点">部署我们的站点</h3>
<p>这里有两种做法。</p>
<p><strong>1）方法一</strong></p>
<p>上面 Hugo 项目的代码直接推送到 GitHub Pages 这个仓库中，在通过 Hugo 生成静态页面时，指定目标目录为 docs：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ hugo -d docs
</code></pre></div><p>这样 docs 下面的内容就是静态页面，是网站最终展示的内容。</p>
<p><strong>2）方法二</strong></p>
<p>Hugo 源网站内容单独放在一个仓，比如我放在了 <a href="https://github.com/polaris1119/polarisxu">https://github.com/polaris1119/polarisxu</a> 这个仓库。这样分两个仓库相对麻烦先。但也有一个好处：GitHub Pages 站点有内容大小限制：不能超过 1 GB，这样分开可以节省空间，而且 Hugo 内容和站点解耦。</p>
<p>因此每次在 Hugo 站点项目写完文章后，需要生成静态内容，拷贝到 GitHub Pages 仓库，提交代码等。把这些步骤写成一个脚本，瞬间变简单了。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="cp">#!/bin/sh
</span><span class="cp"></span>
hugo

cp -rf public/* ../polaris1119.github.io/docs/

<span class="nb">cd</span> ../polaris1119.github.io/

git add * <span class="o">&amp;&amp;</span> git commit -m <span class="s1">&#39;new article&#39;</span> <span class="o">&amp;&amp;</span> git push

<span class="nb">cd</span> ../polarisxu/
</code></pre></div><h2 id="04-总结">04 总结</h2>
<p>技术人员搞个自己的博客还是不错的，开始时花些时间折腾一个自己喜欢的站点，之后就是抽时间产出内容了。通过上面的介绍可知，现在搭建一个站点，完全不需要投入任何 money。</p>
<p>怎么样？有没有冲动自己搞一个。欢迎交流~</p>
]]></content>
		</item>
		
		<item>
			<title>Russ Cox 又有动态了：开源了一个 Go 工具</title>
			<link>https://polarisxu.studygolang.com/posts/talk/go-rsc-dynamic/</link>
			<pubDate>Sat, 21 Nov 2020 21:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/go-rsc-dynamic/</guid>
			<description>前天发了一篇文章，介绍了 Go 的名人，Go Team 现在的 Leader Russ Cox 。 01 这两天在大牛的 GitHub 上看到他开源了一个新的工具：一个实验性的，用于 Go 语言的重构工具。 项目地址：https://github.com/rsc/rf。 开源后，立马有人跟进：https://changelog.com/news/russ-coxs-experimental-new-refactoring-tool</description>
			<content type="html"><![CDATA[<p>前天发了一篇文章，介绍了 Go 的名人，<a href="https://mp.weixin.qq.com/s/kmcJRBahAl4gtPzZUvd5bg" target="_blank" rel="noopener">Go Team 现在的 Leader Russ Cox</a>
。</p>
<h2 id="01">01</h2>
<p>这两天在大牛的 GitHub 上看到他开源了一个新的工具：一个实验性的，用于 Go 语言的重构工具。</p>
<p>项目地址：<a href="https://github.com/rsc/rf">https://github.com/rsc/rf</a>。</p>
<p>开源后，立马有人跟进：<a href="https://changelog.com/news/russ-coxs-experimental-new-refactoring-tool-for-go-NoN0">https://changelog.com/news/russ-coxs-experimental-new-refactoring-tool-for-go-NoN0</a></p>
<blockquote>
<p>It’s just 18 commits deep at the time of logging, but when one of Go’s authors fires up a new project (and a refactoring tool at that), it’s worth following along to see what develops.</p>
</blockquote>
<p>目前该工具还不成熟。我初步猜测，如果成熟了，可能会被用于各大文本编辑器，辅助进行 Go 代码重构。</p>
<p>目前项目的 README.md 上没什么说明，但有一个 doc.go 文件。我尝试使用 pkg.go.dev 查看，发现 404：<a href="https://pkg.go.dev/github.com/rsc/rf">https://pkg.go.dev/github.com/rsc/rf</a></p>
<p><p class="md__image">
  <img src="../imgs/rf.png"
    alt=""  />
</p>
</p>
<p>这时点击下方的 Request “github.com/rsc/rf”，页面提示：</p>
<blockquote>
<p>“github.com/rsc/rf” is not a valid package or module. Were you looking for “rsc.io/rf”?</p>
</blockquote>
<p>因此改为 <a href="https://pkg.go.dev/rsc.io/rf">https://pkg.go.dev/rsc.io/rf</a> 即可正常访问。在该项目的 go.mod 文件中开头有这一行：</p>
<blockquote>
<p>module rsc.io/rf</p>
</blockquote>
<p>官方号称 pkg.go.dev 是更懂 go mod 的，我觉得访问 <a href="https://pkg.go.dev/github.com/rsc/rf">https://pkg.go.dev/github.com/rsc/rf</a> 应该能自动重定向到 <a href="https://pkg.go.dev/rsc.io/rf">https://pkg.go.dev/rsc.io/rf</a> 才对。有兴趣的可以看看 rf 的文档。</p>
<blockquote>
<p>知识点：上面 github.com/rsc/rf 之所以可以定义为 rsc.io/rf，是因为 rsc.io/rf 做了自定义包导入路径。你可以通过 <code>curl https://rsc.io/rf</code> 命令，查看输出结果，其中有这么一行代码：<code>&lt;meta name=&quot;go-import&quot; content=&quot;rsc.io/rf git https://github.com/rsc/rf&quot;&gt;</code> 这是关键。</p>
</blockquote>
<h2 id="02">02</h2>
<p>借此，介绍 Russ Cox 另外两个开源项目，当然是 Go 语言实现的。</p>
<ul>
<li>Two-factor 验证命令行工具，Star 数 1.1k+，项目地址：<a href="https://github.com/rsc/2fa">https://github.com/rsc/2fa</a>；</li>
<li>大型文件树上的快速索引正则表达式搜索工具，Star 数 2.5k+，项目地址：<a href="https://github.com/google/codesearch">https://github.com/google/codesearch</a>，他还专门写了文章介绍。Google 代码搜索是如何工作的？<a href="https://swtch.com/~rsc/regexp/regexp4.html">https://swtch.com/~rsc/regexp/regexp4.html</a></li>
</ul>
<h2 id="03">03</h2>
<p>借用曹大（Xargin）的话，你应该在 GitHub 上关注那些大神，通过他们的动态可以发现好玩的东西，更可以学习到新东西！</p>
<p>我不是大牛，但我会经常 Star 一些 Go 项目，欢迎大家去 GitHub 关注我：<a href="https://github.com/polaris1119">https://github.com/polaris1119</a>。</p>
]]></content>
		</item>
		
		<item>
			<title>Go 语言名人：除了 Rob Pike，很多人可能不知道他</title>
			<link>https://polarisxu.studygolang.com/posts/talk/go-celebrity-rsc/</link>
			<pubDate>Thu, 19 Nov 2020 19:20:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/go-celebrity-rsc/</guid>
			<description>大家好，我是站长 polarisxu。 今天和大家聊聊 Go 语言名人的那些事。 01 说起 Go 语言，很多人知晓有三个创始人。在 2007 年 09 月 25 日，Rob Pike 发了一封邮件： 所以一般认为 Rob Pike、Robert Griesemer 和 Ken Thompson 是 Go 的创始人，而很长一段时间，Rob Pike 在引领 Go 团队，同时在一些公众场合经常出现，因此大家对 Rob Piike 更熟悉。关于他们三个的情况，网上资料挺多的，这里不说了。 今天说的是另外一个人</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天和大家聊聊 Go 语言名人的那些事。</p>
<h2 id="01">01</h2>
<p>说起 Go 语言，很多人知晓有三个创始人。在 2007 年 09 月 25 日，Rob Pike 发了一封邮件：</p>
<p><p class="md__image">
  <img src="../imgs/rsc01.jpg"
    alt=""  />
</p>
</p>
<p>所以一般认为 Rob Pike、Robert Griesemer 和 Ken Thompson 是 Go 的创始人，而很长一段时间，Rob Pike 在引领 Go 团队，同时在一些公众场合经常出现，因此大家对 Rob Piike 更熟悉。关于他们三个的情况，网上资料挺多的，这里不说了。</p>
<p>今天说的是另外一个人。在 Go 项目启动后不久，Russ Cox 和 Lance Taylor 也加入了 Go 语言的设计团队。他们 5 人一起开发了两款编译器和一个标准库，为 2009 年 11 月 10 日 Go 语言以开源方式发布打下了基础。</p>
<p><p class="md__image">
  <img src="../imgs/rsc02.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>问题：为什么说开发了两款编译器？</p>
</blockquote>
<p>是的，今天要说的这个人就是 Russ Cox，他是现在 Go Team 的 Leader。</p>
<h2 id="02">02</h2>
<p>Russ Cox，网络上的昵称是 rsc，2008 年博士毕业于 MIT（麻省理工学院），毕业后就加入了 Go 核心设计开发团队，非常年轻。下面是毕业证信息，在 MIT 网站可以查到：<a href="https://pdos.csail.mit.edu/~rsc/">https://pdos.csail.mit.edu/~rsc/</a>。</p>
<p><p class="md__image">
  <img src="../imgs/rsc03.png"
    alt=""  />
</p>
</p>
<p>关于 Russ Cox 加入 Google 进入 Go Team 团队有一段小故事，这是 Russ Cox 本人在 2018 年 4 月份参加<a href="https://changelog.com/gotime/77" target="_blank" rel="noopener">第 77 期 GoTime</a>
 时讲述的。</p>
<blockquote>
<p>我上大学时就曾与 Rob Pike 合作参与 Plan 9 操作系统的开发，之后在 Google 研究院实习。当我读完研究生（博士）时，Rob 告诉我有关 Go 的内容，大概是说：“我们正在尝试吸收我们在 Plan 9 上开发软件时真正喜欢的所有东西，并使它们能够用于我们在 Google 的日常编程中。你想帮忙吗？”我当时想，“是的，当然。” 就这样我加入了 Go 团队。</p>
<p>有趣的是，我在想这件事（因为你可能会问这个&hellip;那是十年前的事了），我自己不敢相信这有多幸运，因为我完成博士研究生学业的时候，这份工作随之而来，就像是我过去十年所做的所有事情的完美结合。似乎过去做的事情是为做 Go 这件事做铺垫。 然后我和所有这些伟大的人一起工作，比如 Rob，Ken，Robert Griesemer，Ian Taylor。。。我们辛苦了两年，然后 Go 开源了。</p>
<p>然后真正令人惊讶的事情发生了，坦诚地说，我们没有人预料到，我们选择开源后，人们竟然想使用 Go。这对我们来说很震惊。 我在发布（开源发布）前几天对 Rob  说，我希望也许有几个人会注意到，理想的情况是，无论下一个大语言是什么，都会窃取 Go 的并发和接口思想。这将是我们使编程更好一点的微小贡献。</p>
</blockquote>
<p>大牛果然一开始就很厉害！</p>
<p>此外在这个 Go Time 中，Russ Cox 谈到了较多 Plan9 的事情以及大篇幅说道 vgo 的设计。当然还有很多其他内容，虽然过去 2 年了，感兴趣的可以去读一读。</p>
<p>实际上，几年前开始，Russ Cox 就已经是 Go Team 的技术负责人（Leader）。他会做一些领导工作，并帮助确定优先事项等。很多拿不定主意的决策都是 Russ Cox 最后拍板，很多时候他都是力排众议。相信大家印象最深的就是他设计的 vgo，即 Go Module 的前身，在这之前可是已经有了 dep 这个准官方解决方案。为此有一个 Go 的社区贡献者写文说 Go 是 Google 的而非社区的。Russ Cox 对此进行了<a href="https://groups.google.com/g/golang-nuts/c/6dKNSN0M_kg/m/Y1yDJRwQBgAJ" target="_blank" rel="noopener">回应</a>
，同时引用了他 2015 年发表在 <a href="https://docs.studygolang.com/blog/open-source" target="_blank" rel="noopener">Go 官方博客上的文章</a>
（那时候似乎就意识到会有这样的事情发生？）。这里我不做任何评价，相信每个人心里有自己的一杆秤。</p>
<p>在整个 Go 代码仓库中，Russ Cox 提交的代码量是最多的。</p>
<p><p class="md__image">
  <img src="../imgs/rsc04.png"
    alt=""  />
</p>
</p>
<h2 id="03">03</h2>
<p>推荐下 Russ Cox 的博客：<a href="https://research.swtch.com/">https://research.swtch.com/</a>，涉猎比较广。其中有一篇文章预测了<a href="https://research.swtch.com/gophercount" target="_blank" rel="noopener">世界上有多少 Go Developers</a>
。你觉得有多少？</p>
<p>Russ Cox 预测，截至 2019 年 11 月，估计是 115 万到 196 万。</p>
<p>他给了一个预测的方法：</p>
<blockquote>
<p>Number of Go Developers    =    Number of Software Developers   ×   Fraction using Go</p>
</blockquote>
<p>所以我们需要回答世界上有多少软件开发人员，以及他们使用 Go 的百分比。这些数据主要通过一些第三方发布的调查、统计得到。有兴趣的可以看看他的预测方法。</p>
<p>最后他得出：</p>
<ul>
<li>
<p>2017 年 7 月，在 1680 万-2100 万的开发者中，有 3%-4.6％  Go 开发者，即 50 万 — 90 万；</p>
</li>
<li>
<p>在 2018 年 7 月，在 1840 万-2300 万的开发者中，有 4.6%-7.1％ Go 开发者，即 85 万 - 163 万；</p>
</li>
<li>
<p>在 2019 年 11 月，在 1890 万-2390 万的开发者中，有 6.1%-8.2％ Go 开发者，即 115 万 - 196 万；</p>
</li>
</ul>
<p>你觉得中国有多少 Go 开发者？</p>
<h2 id="04">04</h2>
<p>Go 有这样的大牛主导开发，未来会越来越好！</p>
<p><p class="md__image">
  <img src="../imgs/rsc05.png"
    alt=""  />
</p>
</p>
<p>看看大牛的书房，除了各种书，我相信吸引你眼光的是那些 gopher 小玩偶吧！</p>
<p>关于 Russ Cox，你还知道哪些事情？欢迎留言交流。</p>
]]></content>
		</item>
		
		<item>
			<title>聊聊 Go 和创业</title>
			<link>https://polarisxu.studygolang.com/posts/talk/go-and-business/</link>
			<pubDate>Wed, 18 Nov 2020 18:40:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/go-and-business/</guid>
			<description>昨天 PingCAP 完成 D 轮 2.7 亿美元融资的消息，相信很多人看到了。PingCAP 今天的成就，对开源界真是极大的鼓舞。祝贺祝贺！ 01 PingCAP 成立于 2015 年，是一家企业级开源分布式数据库厂商，提供包括开源分布式数据库产品、解决方案与咨询、技术支持与培训认证服务，致力于为全球行业用户提供稳定高效、安全可靠、开放兼容的新型数据基础设施，解放企业生产力，加速企业数字化转型升级。 由 PingCAP 创立的分布式</description>
			<content type="html"><![CDATA[<p>昨天 PingCAP 完成 D 轮 2.7 亿美元融资的消息，相信很多人看到了。PingCAP 今天的成就，对开源界真是极大的鼓舞。祝贺祝贺！</p>
<h2 id="01">01</h2>
<p>PingCAP 成立于 2015 年，是一家企业级开源分布式数据库厂商，提供包括开源分布式数据库产品、解决方案与咨询、技术支持与培训认证服务，致力于为全球行业用户提供稳定高效、安全可靠、开放兼容的新型数据基础设施，解放企业生产力，加速企业数字化转型升级。</p>
<p>由 PingCAP 创立的分布式关系型数据库 TiDB，为企业关键业务打造，具备「分布式强一致性事务、在线弹性水平扩展、故障自恢复的高可用、跨数据中心多活」等企业级核心特性，帮助企业最大化发挥数据价值，充分释放企业增长空间。</p>
<p>对 TiDB 有所耳闻的都知道，它是使用 Go 语言实现的，它的创始人兼 CEO 刘奇早期就活跃在 Go 社区，早在豌豆荚，他就主导开源了 <a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener">Codis</a>
。</p>
<p>PingCAP 的员工，一直活跃在各大社区，包括频频出席各种技术交流、分享场所，他们创业早期，刘奇本人都经常分享 TiDB。5 年的时间，做出这样的成绩，真的是开源界特别值得骄傲的事情。这样纯技术驱动的公司，是不是每个技术人员向往的呢？！</p>
<h2 id="02">02</h2>
<p>另一个创业公司，也是和 Go 有关：七牛。相信 Go 圈内知道的更多。我个人的看法，七牛和 Go 是相互成就的。</p>
<p>七牛成立于 2011 年 6 月，那时候 Go1.0 还未发布（Go1.0 是 2012 年 3 月 28 日发布的）。七牛的创始人兼 CEO 许式伟离开盛大创新院创办七牛云时，面临技术选型。尽管 Go 正式版本都还未发布，但他很坚决地选择了 Go 语言。为此他还专门给团队发了一封邮件，邮件中有一段是这么说的：</p>
<blockquote>
<p>在创业过程中我们会面临很多选择，也会有很多选择后来会被证明是错的，但是今天我可以确定的是，选择 Go 将会成为我们最正确的选择。</p>
</blockquote>
<p>在选择了 Go 语言后，考虑到 Go 仍然是一门十分小众的语言，七牛开始有意识地培养 Go 中国社区。为了让更多人能够知道 Go，加入 Go 的行列，他们做了很多工作，比如启动了《Go 语言编程》一书的编写工作，并最终和 Go 1.0 版本同步发布。2012 年 2 月，许老板首次在公开场合说：Go 会超过 C、Java，成为最流行的语言。这一年他到处宣讲，做了不下十场的 Go 语言讲座，平均每个月有一场。讲得最多的一个 PPT 是《Go，Next C》这篇，它基本上算他对 Go 的革命性到底在哪里的一个总结。对于一个初创公司来说，为一个并不属于自己业务的技术这么花时间去宣传，有些人可能会觉得比较不可理解。但是实际上有三个理由支撑他们这么做：</p>
<ul>
<li>Go 真的是一门革命性的语言，它的流行将对产业发展具重大意义。</li>
<li>Go 仍然是一门小众语言，而我们不止要招 Go 程序员，更重要的是要说服他们相信 Go 语言是有远大前景的专业技能方向。</li>
<li>七牛的用户是程序员，我们需要建立在用户心目中的专家形象。</li>
</ul>
<p>大家看到了现在 Go 语言的发展势头，同时作为一个创业公司，七牛云今年 6 月份获得了 F 轮 10 亿人民币的融资。</p>
<p>七牛为 Go 的发展做了很大的贡献，另一方面，我认为，正是因为借助 Go，也让七牛发展的更好。</p>
<h2 id="03">03</h2>
<p>再聊一个和 Go 没啥关系的公司，但相信大家都知晓。</p>
<p>掘金社区，大家不陌生。号称是一个帮助开发者成长的社区，是给开发者用的 Hacker News，给设计师用的 Designer News，和给产品经理用的 Medium。</p>
<p>2015 年阴明（网名 kalasoo） 创办了稀土掘金公司（2014 年底获得天使轮融资），运营掘金社区网站，16 年初获得 Pre-A 轮融资，17 年中旬获得 A 轮融资。之后并没有获得融资，运营很艰难。我记得去年，阴明大佬还做了一次女装直播，还发了文章，据说公司没有开发人员了，自己得学全栈技术，维护网站的运营，感觉随时有倒闭的风险。</p>
<p>今年 8 月份，听字节跳动的朋友说，在公司内部发现了掘金这个部门，而且在内部可以搜到掘金创始人和站长。前段时间，也证实了字节跳动收购了掘金。具体见：<a href="https://xw.qq.com/cmsid/20201104A04LTM00">https://xw.qq.com/cmsid/20201104A04LTM00</a>。</p>
<p>被收购，对掘金来说，也许是一个不错的出路。</p>
<h2 id="04">04</h2>
<p>常说创业九死一生，而我自己也一直在创业中（并非 Go 语言中文网），个中滋味只有自己清楚。作为技术人员，PingCAP、七牛 这样技术驱动的公司是很向往的，但自己作为创始人是很难的。</p>
<p>掘金，外面看来，网站做的很不错，但一直却活得很辛苦。我个人也运营了一个网站，投入的时间和心血，只有我自己知晓，它一直还只是我的个人项目，也许一直会是我的个人爱好项目。当时听到掘金被并购的消息，同样作为网站创建者，感触颇多，如果有资本的进入，也许就不能只是爱好了。。。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://www.sohu.com/a/197332119_355140">https://www.sohu.com/a/197332119_355140</a></p>
]]></content>
		</item>
		
		<item>
			<title>通过这个 Runtime 统计信息可视化库学到了什么？</title>
			<link>https://polarisxu.studygolang.com/posts/go/pkg/statsview/</link>
			<pubDate>Tue, 17 Nov 2020 15:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/pkg/statsview/</guid>
			<description>大家好，我是站长 polarisxu。 掌握系统运行状态，知道系统哪些地方可能存在问题，方便进行优化，这是一个实际系统必备的。裸奔，对系统一无所知，迟早是要出大事的。 在 Go 语言中，官方标准库提供了方法，让我们能够获得内存分配、GC 和 Goroutine 等情况。比如内存、GC 等情况，可以通过 runtime.MemStats 获取：https://docs.studygolang.com/pkg/runtime/#M</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>掌握系统运行状态，知道系统哪些地方可能存在问题，方便进行优化，这是一个实际系统必备的。裸奔，对系统一无所知，迟早是要出大事的。</p>
<p>在 Go 语言中，官方标准库提供了方法，让我们能够获得内存分配、GC 和 Goroutine 等情况。比如内存、GC 等情况，可以通过 runtime.MemStats 获取：<a href="https://docs.studygolang.com/pkg/runtime/#MemStats">https://docs.studygolang.com/pkg/runtime/#MemStats</a>，Goroutine 数量可以通过 runtime.NumGoroutine() 函数获得。</p>
<p>一般我们我们需要自己解析 MemStats 信息、做展示，也可以做图表。</p>
<p>之前推荐过一个在浏览器中实时查看 Go 应用程序运行时统计信息（GC，MemStats 等）的库：<a href="https://polarisxu.studygolang.com/posts/go/pkg/statsviz/" target="_blank" rel="noopener">statsviz</a>
。今天给大家推荐另外一个库：<a href="https://github.com/go-echarts/statsview">https://github.com/go-echarts/statsview</a>，这是这两天刚出来的。</p>
<p>看长什么样：</p>
<p><p class="md__image">
  <img src="../imgs/statsview.png"
    alt=""  />
</p>
</p>
<p>我们可以运行下面这段代码得到类似上面的图：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/go-echarts/statsview&#34;</span>
    <span class="s">&#34;time&#34;</span>
    <span class="s">&#34;math/rand&#34;</span>
    <span class="s">&#34;strconv&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nf">work</span><span class="p">()</span>
    <span class="nx">mgr</span> <span class="o">:=</span> <span class="nx">statsview</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

    <span class="c1">// Start() runs a HTTP server at `localhost:18066` by default.
</span><span class="c1"></span>    <span class="nx">mgr</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>

    <span class="c1">// Stop() will shutdown the http server gracefully
</span><span class="c1"></span>    <span class="c1">// mgr.Stop()
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">work</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Generate some allocations
</span><span class="c1"></span>    <span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">byte</span><span class="p">{}</span>

    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">512</span><span class="o">+</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="p">))</span>
        <span class="nx">m</span><span class="p">[</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">100</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">b</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">byte</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="01-如何使用">01 如何使用</h2>
<blockquote>
<p>都 Go1.15.x 了，请使用 go module。</p>
</blockquote>
<p>statsview 的使用较简单。</p>
<ul>
<li>import &ldquo;github.com/go-echarts/statsview”</li>
<li>mgr := statsview.New()</li>
<li>mgr.Start()</li>
<li>打开浏览器访问：http://localhost:18066/debug/statsview</li>
<li>尽情享受吧~</li>
</ul>
<p>此外，可以通过 <code>viewer.SetConfiguration(opts …Option)</code>改变一些行为，包括：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// WithInterval sets the interval(in millisecond) of collecting and pulling metrics
</span><span class="c1">// default -&gt; 1500
</span><span class="c1"></span><span class="nf">WithInterval</span><span class="p">(</span><span class="nx">interval</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Option</span>

<span class="c1">// WithMaxPoints sets the maximum points of each chart series
</span><span class="c1">// default -&gt; 40
</span><span class="c1"></span><span class="nf">WithMaxPoints</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Option</span>

<span class="c1">// WithTemplate sets the rendered template which fetching stats from the server and
</span><span class="c1">// handling the metrics data
</span><span class="c1"></span><span class="nf">WithTemplate</span><span class="p">(</span><span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Option</span>

<span class="c1">// WithAddr sets the listen address
</span><span class="c1">// default -&gt; &#34;localhost:18066&#34;
</span><span class="c1"></span><span class="nf">WithAddr</span><span class="p">(</span><span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Option</span>

<span class="c1">// WithTimeFormat sets the time format for the line-chart Y-axis label
</span><span class="c1">// default -&gt; &#34;15:04:05&#34;
</span><span class="c1"></span><span class="nf">WithTimeFormat</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Option</span>

<span class="c1">// WithTheme sets the theme of the charts
</span><span class="c1">// default -&gt; Macarons
</span><span class="c1">//
</span><span class="c1">// Optional:
</span><span class="c1">// * ThemeWesteros
</span><span class="c1">// * ThemeMacarons
</span><span class="c1"></span><span class="nf">WithTheme</span><span class="p">(</span><span class="nx">theme</span> <span class="nx">Theme</span><span class="p">)</span> <span class="nx">Option</span>
</code></pre></div><p>例如修改默认端口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">viewer</span><span class="p">.</span><span class="nf">SetConfiguration</span><span class="p">(</span><span class="nx">view</span><span class="p">.</span><span class="nf">WithAddr</span><span class="p">(</span><span class="s">&#34;localhost:8087&#34;</span><span class="p">)</span>
</code></pre></div><p>不像之前介绍的 statsviz，statsview 固定使用 net/http，所以集成到项目中只需要让它在单独的一个 goroutine 中运行，单独的端口即可。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">mgr</span> <span class="o">:=</span> <span class="nx">statsview</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">mgr</span><span class="p">.</span><span class="nf">Start</span><span class="p">()</span>
<span class="p">}()</span>
</code></pre></div><p>其实这也是在介绍 statsviz 时的最佳实践。毕竟 runtime 信息属于系统内部信息，不适合暴露给公网用户。</p>
<h2 id="02-学习相关实现">02 学习相关实现</h2>
<p>和 <a href="https://polarisxu.studygolang.com/posts/go/pkg/statsviz/" target="_blank" rel="noopener">statsviz</a>
 不同，该库没有使用 WebSocket 协议，直接通过轮询的方式不断获取数据。另外，因为 statsview 是 go-echarts 出的，因此画图也使用的是 <a href="https://github.com/go-echarts/go-echarts" target="_blank" rel="noopener">go-echarts</a>
 库。</p>
<h3 id="多参数控制">多参数控制</h3>
<p>关于 statsview，有一个知识点想跟大家讲一下，那就是多参数控制。</p>
<p>上文提到库可以通过 <code>viewer.SetConfiguration(opts …Option)</code> 函数定制一些行为，其中 Option 是一个函数类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Option</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">config</span><span class="p">)</span>
</code></pre></div><p>其中 config 的定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">config</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Interval</span>   <span class="kt">int</span>
	<span class="nx">MaxPoints</span>  <span class="kt">int</span>
	<span class="nx">Template</span>   <span class="kt">string</span>
	<span class="nx">Addr</span>       <span class="kt">string</span>
	<span class="nx">TimeFormat</span> <span class="kt">string</span>
	<span class="nx">Theme</span>      <span class="nx">Theme</span>
<span class="p">}</span>
</code></pre></div><p>该类型的字段用于控制该库的一些行为。它有一个默认的实例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">defaultCfg</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">config</span><span class="p">{</span>
	<span class="nx">Interval</span><span class="p">:</span>   <span class="nx">DefaultInterval</span><span class="p">,</span>
	<span class="nx">MaxPoints</span><span class="p">:</span>  <span class="nx">DefaultMaxPoints</span><span class="p">,</span>
	<span class="nx">Template</span><span class="p">:</span>   <span class="nx">DefaultTemplate</span><span class="p">,</span>
	<span class="nx">Addr</span><span class="p">:</span>       <span class="nx">DefaultAddr</span><span class="p">,</span>
	<span class="nx">TimeFormat</span><span class="p">:</span> <span class="nx">DefaultTimeFormat</span><span class="p">,</span>
	<span class="nx">Theme</span><span class="p">:</span>      <span class="nx">DefaultTheme</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div><p>面对这样的需求，通常的解决方案是：</p>
<ul>
<li>将 config 默认实例导出，使用方直接修改对应字段的值；</li>
<li>通过提供一系列函数实现修改，比如 SetInterval(int)</li>
</ul>
<p>方案一封装性不好，暴露太多细节；而方案二的问题在于，config 的字段类型不一致，通常方案不够优雅。该库的实现方式是定义一个 Option 类型，然后提供一系列具有相似签名的函数来控制这些配置，即上文列出来的 WithXXX 类函数，看其中的一个实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// WithAddr sets the listening address
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WithAddr</span><span class="p">(</span><span class="nx">addr</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Option</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">config</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">Addr</span> <span class="p">=</span> <span class="nx">addr</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这样通过 WithXXX 函数得到一系列 Option 实例，而 viewer.SetConfiguration 接收一系列 Option 实例，所以使用是就这样了：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">viewer</span><span class="p">.</span><span class="nf">SetConfiguration</span><span class="p">(</span><span class="nx">viewer</span><span class="p">.</span><span class="nf">WithTheme</span><span class="p">(</span><span class="nx">viewer</span><span class="p">.</span><span class="nx">ThemeWalden</span><span class="p">),</span> <span class="nx">view</span><span class="p">.</span><span class="nf">WithAddr</span><span class="p">(</span><span class="s">&#34;localhost:8087&#34;</span><span class="p">))</span>
</code></pre></div><p>还有其他案例吗？</p>
<h3 id="colly-中的案例">colly 中的案例</h3>
<p><a href="https://github.com/gocolly/colly" target="_blank" rel="noopener">Colly</a>
 是一个 Go 语言实现的，快速的、优雅的 Scraper 和 Crawler 框架。它的实例化函数比较“独特”：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCollector</span><span class="p">(</span><span class="nx">options</span> <span class="o">...</span><span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Collector</span><span class="p">))</span> <span class="o">*</span><span class="nx">Collector</span>
</code></pre></div><p>实例化一个类型，一般有以下几种方式：</p>
<ol>
<li>new(T)</li>
<li>T{} 或 &amp;T{}</li>
<li>自定义的工厂函数</li>
</ol>
<p>对于类型中的成员，我们可以在实例化时传递，如第 2、3 种方式；也可以在生成实例后，通过 <code>t.Field</code> 的形式赋值（前提是导出的成员）。</p>
<p>一般地，我们在定义工厂函数时，要为类型成员初始化，会给工厂函数定义相应的参数。而 Collector 类型的工厂函数参数，却是一个或多个函数。这样设计有以下方面的原因：</p>
<ol>
<li>Collector 类型的成员较多；</li>
<li>成员的类型多样；</li>
<li>不要求所有的成员必须指定值；</li>
</ol>
<p>针对这些问题，Collector 工厂类 NewCollector() 巧妙的使用不定参数，而且类型是 <code>func(*Collector)</code>，这样可以有选择的配置一个或多个选项，很好地解决了上面的三个问题。它的源码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewCollector</span><span class="p">(</span><span class="nx">options</span> <span class="o">...</span><span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Collector</span><span class="p">))</span> <span class="o">*</span><span class="nx">Collector</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Collector</span><span class="p">{}</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">Init</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">options</span> <span class="p">{</span>
        <span class="nf">f</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">parseSettingsFromEnv</span><span class="p">()</span>

    <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></div><p>同时，通过函数的方式来配置选项，就好比很多面向对象语言中的 Set 方法，可以在里面有其他的一些逻辑判断，而不仅仅是设置一个值。比如以下配置函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Debugger</span><span class="p">(</span><span class="nx">d</span> <span class="nx">debug</span><span class="p">.</span><span class="nx">Debugger</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Collector</span><span class="p">)</span>
</code></pre></div><h3 id="bigcache-中的案例">BigCache 中的案例</h3>
<p><a href="https://github.com/allegro/bigcache" target="_blank" rel="noopener">BigCache</a>
 是一个高性能缓存库。获得它的一个实例是这样的形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">bigcache</span><span class="p">.</span><span class="nf">NewBigCache</span><span class="p">(</span><span class="nx">bigcache</span><span class="p">.</span><span class="nf">DefaultConfig</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">))</span>
</code></pre></div><p>即它的构造函数（New 函数）接收一个 Config 对象，这也是要控制多个配置。</p>
<p>因为 Go 不是完全的面向对象语言。当类型中有较多成员，且可以通过外部控制时，根据封装的原则，一般不建议将这些字段导出（公开），但这样一来构造函数就需要能接收很多参数。在 Go 中有两种较常见的设计方法。</p>
<p>1）通过另外一个结构体来控制</p>
<p>比如 bigcache 包中的 Config 结构体。这么做有什么好处？</p>
<p>一方面控制了 BigCache 类型的行为，避免实例化后可以随意更改，起到了封装的作用。另一方面，让构造函数更简洁，只需要接收一个 Config 即可（注意最好使用 Config 值类型，而不是指针）。而且可以通过提供一些 Config 的默认值来做到更易用，比如 bigcache.DefaultConfig() 函数就是这样的例子。</p>
<p>2）通过一个函数类型来控制</p>
<p>比如我们通过这种方式替换 bigcache 包的 Config 结构体。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BigCacheOption</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">BigCache</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">ShardsNum</span><span class="p">(</span><span class="nx">shards</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">BigCacheOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">BigCache</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">shards</span> <span class="p">=</span> <span class="nx">shards</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">LifeWindow</span><span class="p">(</span><span class="nx">eviction</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="nx">BigCacheOption</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">BigCache</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">lifeWindow</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">eviction</span><span class="p">.</span><span class="nf">Seconds</span><span class="p">())</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 提供更多的配置选项函数
</span><span class="c1"></span><span class="o">...</span>
</code></pre></div><p>通过定义一个函数类型 BigCacheOption 来控制。对 BigCache 类型中非导出的字段，提供相应的函数，该函数返回 BigCacheOption 类型。</p>
<p>针对这种方式，BigCache 的构造函数需要改为如下的形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">NewBigCache</span><span class="p">(</span><span class="nx">options</span> <span class="o">...</span><span class="nx">BigCacheOption</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">BigCache</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">BigCache</span><span class="p">{}</span>
	<span class="c1">// 省略其他，主要处理 options 部分
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">options</span> <span class="p">{</span>
		<span class="nf">f</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">c</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h2 id="03-总结">03 总结</h2>
<p>如果你需要实时图表的方式查看系统运行时的一些数据，可能之前介绍的 statsviz 更合适。</p>
<p>该文介绍的通过参数灵活控制系统的方法，希望你能够掌握。</p>
]]></content>
		</item>
		
		<item>
			<title>字节跳动面试真的也会问这样的问题？！</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/bytedance-interview-201112/</link>
			<pubDate>Thu, 12 Nov 2020 18:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/bytedance-interview-201112/</guid>
			<description>大家好，我是站长 polarisxu。 网上看到有人分享去字节跳动的面试 Go 的经验 ，从面试题来看，应该是比较初级的职位。 这份面试经验总结中（其实谈不上总结，只是面试题的记录，并没有总结分析答案），有一道 Go 相关的题，也是一个老生常谈的问题：以下代码有什么问题，怎么解决？ total, sum := 0, 0 for i := 1; i &amp;lt;= 10; i++ { sum += i go func() { total += i }() } fmt.Printf(&amp;#34;total:%d sum %d&amp;#34;, total, sum) 01 考点一 我相信很多人应该一眼看出了其中</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>网上看到有人分享去字节跳动的<a href="https://zhuanlan.zhihu.com/p/132813717" target="_blank" rel="noopener">面试 Go 的经验</a>
，从面试题来看，应该是比较初级的职位。</p>
<p>这份面试经验总结中（其实谈不上总结，只是面试题的记录，并没有总结分析答案），有一道 Go 相关的题，也是一个老生常谈的问题：以下代码有什么问题，怎么解决？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">total</span><span class="p">,</span> <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">total</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="p">}()</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;total:%d sum %d&#34;</span><span class="p">,</span> <span class="nx">total</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
</code></pre></div><h2 id="01-考点一">01 考点一</h2>
<p>我相信很多人应该一眼看出了其中的一个问题，那就是 i 使用的问题。常见的题目是这样的：以下代码，输出什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">}()</span>
<span class="p">}</span>
<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
</code></pre></div><p>相信很多人知道，会输出一堆 11（可能还有其他的数字），而不是期望的输出 1 到 10。</p>
<p>怎么改进？你应该也知晓。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
</code></pre></div><p>（当然这里的输出顺序是乱的，大家应该清楚）</p>
<h2 id="02-考点二">02 考点二</h2>
<p>该题的第二个考点：data race。因为存在多 goroutine 同时写 total 变量的问题，所以有数据竞争。可以加上 -race 参数验证：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ go run -race main.go
<span class="o">==================</span>
WARNING: DATA RACE
Read at 0x00c0001b4020 by goroutine 8:
  main.main.func1<span class="o">()</span>
      /Users/xuxinhua/main.go:12 +0x57

Previous write at 0x00c0001b4020 by main goroutine:
  main.main<span class="o">()</span>
      /Users/xuxinhua/main.go:9 +0x10b

Goroutine <span class="m">8</span> <span class="o">(</span>running<span class="o">)</span> created at:
  main.main<span class="o">()</span>
      /Users/xuxinhua/main.go:11 +0xe7
<span class="o">==================</span>
</code></pre></div><p>这可以通过加锁的方式解决：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">mutex</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="nx">total</span><span class="p">,</span> <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="nx">mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>此外，也可以通过 atomic 包解决：（注意 total 的类型，因为 atomic.AddInt64 需要）</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">total</span> <span class="kt">int64</span>
<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
  <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">total</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
  <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>通过 -race 你验证，发现 data race 没了。</p>
<p>细心的你不知道发现没有，以上代码我故意把最后的 fmt 输出那一行去掉了，因为它用了 total 变量，避免它导致 data race。这引出考点三。</p>
<h2 id="03-考点三">03 考点三</h2>
<p>我上面都没有给完整的代码，因为经过上面两步，最终的结果还是不对的。从上面说的 fmt 输出代码去掉就说明还有问题。</p>
<p>初学 Go 应该遇到类似这样的问题，下面代码一般没有输出。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
	<span class="p">}()</span>
<span class="p">}</span>
</code></pre></div><p>原因是 main 函数先退出了，开启的 goroutine 根本没有机会执行。所以，常见的解决办法是在最后加一个 Sleep：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
	<span class="p">}()</span>
  
  <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Sleep 会让 main goroutine 休眠，调度器调度其他 goroutine 运行。</p>
<p>回到开头的题目其实也存在这个问题，通过在 fmt 语句之前加上 Sleep，基本能得到正确的结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">total</span> <span class="kt">int64</span>
<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">total</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
    <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;total:%d sum %d&#34;</span><span class="p">,</span> <span class="nx">total</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
</code></pre></div><p>但如果加上 -race 发现还是有问题：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ go run -race main.go
<span class="o">==================</span>
WARNING: DATA RACE
Read at 0x00c00001c0b0 by main goroutine:
  main.main<span class="o">()</span>
      /Users/xuxinhua/main.go:20 +0xe4

Previous write at 0x00c00001c0b0 by goroutine 7:
  sync/atomic.AddInt64<span class="o">()</span>
      /Users/xuxinhua/.go/current/src/runtime/race_amd64.s:276 +0xb
  main.main.func1<span class="o">()</span>
      /Users/xuxinhua/main.go:15 +0x44

Goroutine <span class="m">7</span> <span class="o">(</span>finished<span class="o">)</span> created at:
  main.main<span class="o">()</span>
      /Users/xuxinhua/main.go:14 +0xa4
<span class="o">==================</span>
total:55 sum 55Found <span class="m">1</span> data race<span class="o">(</span>s<span class="o">)</span>
</code></pre></div><p>所以，这种方式是不靠谱的，这时正确的方式是使用 sync.WaitGroup。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;sync/atomic&#34;</span>
    <span class="s">&#34;sync&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="kd">var</span> <span class="nx">total</span> <span class="kt">int64</span>
    <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
            <span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">total</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
        <span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;total:%d sum %d&#34;</span><span class="p">,</span> <span class="nx">total</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="04-总结">04 总结</h2>
<p>通过上面的分析，发现看起来是一个简单的题目，其实考点好几个。这个题目还是挺好的，字节跳动面试官出的这道题还是有点水平。你觉得呢？</p>
]]></content>
		</item>
		
		<item>
			<title>GitHub 出的这个功能，让开源项目有了自己的社区</title>
			<link>https://polarisxu.studygolang.com/posts/talk/view-github-discussions/</link>
			<pubDate>Thu, 12 Nov 2020 10:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/view-github-discussions/</guid>
			<description>大家好，我是站长 polarisxu。 为了更有利于开源项目的发展，形成自己的社区很重要，作者们可以更好地和使用者交流互动，了解他们需求、问题。虽然 GitHub 有 issue，但毕竟它主要还是用于反馈 bug、提新特性，不是一个社区的感觉。所以一般项目都会有其他的社区，比如会开通 google groups 邮件组、使用 Gitter、Discord、Slack 等。当然，国内的项目通常会使用 QQ 群、微信群</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>为了更有利于开源项目的发展，形成自己的社区很重要，作者们可以更好地和使用者交流互动，了解他们需求、问题。虽然 GitHub 有 issue，但毕竟它主要还是用于反馈 bug、提新特性，不是一个社区的感觉。所以一般项目都会有其他的社区，比如会开通 google groups 邮件组、使用 Gitter、Discord、Slack 等。当然，国内的项目通常会使用 QQ 群、微信群。（我个人认为，QQ 群、微信群对社区沉淀是很不好的，知识输出、讨论没法重用，虽然对提问者友好，可以快速得到回应）</p>
<p>今年年初，GitHub 开始测试一个新功能：Discussions，它想为开源项目打造一个自己的社区，将之前分散的社区聚合在一起。比如一般开源社区是这样的：用 Gitter 作为开源社区聊天的地方，StackOverflow 用于寻求问题的答案，而论坛用于讨论等。有了 Discussions，我们可以在上面开展很多活动。GitHub 官方对 Discussions 的描述是这样的：</p>
<blockquote>
<p>This is a community we build together. Please be welcoming and open minded.</p>
</blockquote>
<p>不过目前该功能还在公测中，具体正式发布时间还未知。如果你想自己的项目试用该功能，可以到 <a href="https://github.com/github/feedback/discussions">https://github.com/github/feedback/discussions</a> 提出申请，请求 GitHub 将你的项目加入 Beta 列表中。这里有别人请求加入的交流：<a href="https://github.com/github/feedback/discussions/24">https://github.com/github/feedback/discussions/24</a>。</p>
<h2 id="01-一睹-discussions">01 一睹 Discussions</h2>
<p>我们通过一个开通了该功能的 <a href="https://github.com/asim/nitro" target="_blank" rel="noopener">Go 项目：Nitro</a>
（之前的 go-micro，<a href="https://polarisxu.studygolang.com/posts/go/micro/micro-3.0.0-m3o/" target="_blank" rel="noopener">具体详见该文</a>
）来看看 Discussions。</p>
<p>在启用了 Discussions 的项目上，在顶部会有这个 Tab：</p>
<p><p class="md__image">
  <img src="../imgs/nitro-home.png"
    alt=""  />
</p>
</p>
<p>这个功能应该可以通过 Settings 控制是否启用（在有该功能测试资格的情况下）。</p>
<p>进入该 Tab，页面如下：</p>
<p><p class="md__image">
  <img src="../imgs/nitro-discussions.png"
    alt=""  />
</p>
</p>
<p>左侧可以有分类，中间是主题列表，右侧可以有其他一些提示信息。顶部还可以通过 New、Top、Answered、Unanswered 快速筛选，当然也支持搜索。</p>
<h2 id="02-discussions-vs-issues">02 Discussions V.S Issues</h2>
<p>以前，Issues 也常常被用来讨论一些与当前 GitHub 项目相关的问题，但实际上可能 Issues 不太适合作为一个问答的地方，更多应该是反馈 bug 等？！现在有了 Discussions，可以对二者的定位做一个划分：Issues 用来反馈 bug，提出新特性；Discussions 用来讨论其他与项目相关的，当然，它也可以用来讨论新特性。在新特性这一点上，我个人认为 Discussions 适合于新特性不成熟的讨论阶段，基本确认后，通过 issue 提交该新特性，实现后 PR 关闭该 issue。</p>
<h2 id="03-你看好该功能吗">03 你看好该功能吗？</h2>
<p>从该功能看，GitHub 希望为开源项目提供全套的服务？将相关信息聚合在一起，更有利于形成开源项目自己的社区，我个人挺看好它的。你觉得该功能怎么样？</p>
<p>在 2020 年 3 月 28 日，Offer 365 CLI 就在 Twitter 上宣布，他们将关闭公共 Gitter 频道，开始使用 GitHub Discussions 发布相关信息。</p>
<p><p class="md__image">
  <img src="../imgs/office365-twitter.png"
    alt=""  />
</p>
</p>
<p>现在看看它的 Discussions 页面，维护的还不错：<a href="https://github.com/pnp/cli-microsoft365/discussions">https://github.com/pnp/cli-microsoft365/discussions</a>。</p>
]]></content>
		</item>
		
		<item>
			<title>祝贺 Go 开源 11 周年</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go-opensource-11-years/</link>
			<pubDate>Tue, 10 Nov 2020 09:30:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go-opensource-11-years/</guid>
			<description>题图来自《了不起的程序员》 今天是 Go 语言开源 11 周年。有些人可能不太知道，简单回顾下 Go 的历史。 2007 年 Rob Pike, Robert Griesemer 和 Ken Thompson 一起创建了 Go 语言。从代码提交记录看，2008 年 3 月 3 日有了 Go 最初的规范 。 2009 年 11 月 10 日，Go 语言以开放源代码的方式向全球发布，当年获得了 TIOBE 年度编程语言称号； 2011 年 3 月 16 日，Go 语言的第一个稳定版本 r56 发布； 2012 年 3 月 28 日，Go 语言的第一个正式版本 Go1 发布，并承诺</description>
			<content type="html"><![CDATA[<p><p class="md__image">
  <img src="../imgs/go-opensource-11.png"
    alt="了不起的程序员"  />
</p>
</p>
<p>题图来自《了不起的程序员》</p>
<p>今天是 Go 语言开源 11 周年。有些人可能不太知道，简单回顾下 Go 的历史。</p>
<p>2007 年 Rob Pike, Robert Griesemer 和 Ken Thompson 一起创建了 Go 语言。从代码提交记录看，2008 年 3 月 3 日有了 <a href="https://github.com/golang/go/blob/18c5b488a3b2e218c0e0cf2a7d4820d9da93a554/doc/go_spec" target="_blank" rel="noopener">Go 最初的规范</a>
。</p>
<ul>
<li>2009 年 11 月 10 日，Go 语言以开放源代码的方式向全球发布，当年获得了 TIOBE 年度编程语言称号；</li>
<li>2011 年 3 月 16 日，Go 语言的第一个稳定版本 r56 发布；</li>
<li>2012 年 3 月  28 日，Go 语言的第一个正式版本 Go1 发布，并承诺 1.x 的 兼容性；</li>
<li>直到 2013 年  5 月 13 日，Go1.1 正式版才发布，距离 1.0 过去了一年多。正式因为经历了这么久，Go 官方团队正式考虑发布周期的问题，并整理成文档：<a href="https://github.com/golang/go/wiki/Go-Release-Cycle">https://github.com/golang/go/wiki/Go-Release-Cycle</a>；总的目标是 6 个月发布一个版本，细分为 3 个月的常规开发，然后是 3 个月的测试和优化，即所谓的版本冻结。通过发行小版本来纠正诸如崩溃或安全性等关键问题。同时明确发布周期定于每年的 2 月 1 日和 8 月 1 日；</li>
<li>2013 年 12 月 1 日，Go1.2 正式发布；</li>
<li>2014 年 6 月 18 日，Go1.3 正式发布；</li>
<li>2014 年 12 月 10 日，Go1.4 正式发布；</li>
<li>2015 年 8 月 19 日，Go1.5 正式发布。该版本实现了自举，即移除了 C 代码，使用 Go 开发 Go 语言；开始按发布节奏走了（该版本故意推迟 2 个月发布）；</li>
<li>2016 年 2 月 17 日，Go1.6 正式发布；</li>
<li>2016 年 8 月 15 日，Go1.7 正式发布；引入 context 包；</li>
<li>2017 年 2 月 17 日，Go1.8 正式发布；</li>
<li>2017 年 8 月 24 日，Go1.9 正式发布；引入别名；</li>
<li>2018 年 2 月 16 日，Go1.10 正式发布；</li>
<li>2018 年 8 月 25 日，Go1.11 正式发布。开始支持 Module；</li>
<li>2019 年 3 月 1 日，Go1.12 正式发布；</li>
<li>2019 年 9 月 3 日，Go1.13 正式发布；</li>
<li>2020 年 2 月 25 日，Go1.14 正式发布；goroutine 支持异步抢占调度；</li>
<li>2020 年 8 月 11 日，Go1.15 正式发布；</li>
</ul>
<p>关于以上版本的一些关键改动，可以查看 <a href="https://mp.weixin.qq.com/s/Tzqn5kzdfzcQPUD5NtN2mg" target="_blank" rel="noopener">《你必须了解的 Go 历史：帮助理解 Go 的设计思想和每个版本的优势或弱点》</a>
。</p>
<p>今天是 11 月 10 日，11 年前的今天，Go 语言开源了。在此祝愿 Go 语言越来越好！</p>
<p>Go 语言这两年出版了不少图书，这里分享几本 Go 语言英文图书。</p>
<h3 id="01mastering-go-2nd-edition">01《Mastering Go 2nd Edition》</h3>
<p>使用网络库，并发，机器学习和高级数据结构创建 Golang 生产级应用程序。这本书试用于已经了解语言基础知识并希望成为专家级 Go 实践者的 Go 程序员。</p>
<p><p class="md__image">
  <img src="../imgs/mastering-go.jpg"
    alt=""  />
</p>
</p>
<p>该书目录：</p>
<ol>
<li>Go 和操作系统</li>
<li>了解 Go 内部</li>
<li>使用基本 Go 数据类型</li>
<li>复合类型的用途</li>
<li>如何使用数据结构增强 Go 代码</li>
<li>你可能不了解的 Go 包和功能</li>
<li>反射和接口</li>
<li>告诉 Unix 系统该怎么做</li>
<li>Go 中的并发性：Goroutines，通道和管道</li>
<li>Go 中的并发：高级主题</li>
<li>代码测试，优化和分析</li>
<li>Go中网络编程的基础</li>
<li>网络编程：构建自己的服务器和客户端</li>
<li>Go 中的机器学习</li>
</ol>
<h3 id="02hands-on-system-programming-with-go">02《Hands-On System Programming with Go》</h3>
<p>使用 Golang 为 Unix 和 Linux 系统构建现代和并发应用程序。探索系统编程的基础知识，从内核 API 和文件系统开始，再到网络编程和过程通信。</p>
<p><p class="md__image">
  <img src="../imgs/system-programming-with-go.jpg"
    alt=""  />
</p>
</p>
<p>该书目录：</p>
<ol>
<li>系统编程简介</li>
<li>Unix OS 组件</li>
<li>Go 概述</li>
<li>使用文件系统</li>
<li>处理流</li>
<li>构建伪终端</li>
<li>处理进程和守护程序</li>
<li>退出代码，信号和管道</li>
<li>网络编程</li>
<li>使用 Go 进行数据编码</li>
<li>处理 Channel 和 Goroutines</li>
<li>使用 sync 和 atomic 进行同步</li>
<li>使用 Context 进行协调</li>
<li>实现并发模式</li>
<li>使用反射</li>
<li>使用 CGO</li>
</ol>
<h3 id="03hands-on-high-performance-with-go">03《Hands-On High Performance with Go》</h3>
<p>通过弹性大规模扩展和优化 Golang 应用程序的性能。成熟的方法和并发技术将帮助您使用 Go 编程编写更快更好的代码。</p>
<p><p class="md__image">
  <img src="../imgs/system-programming-with-go.jpg"
    alt=""  />
</p>
</p>
<p>该书目录：</p>
<ol>
<li>Go 性能介绍</li>
<li>数据结构与算法</li>
<li>了解并发</li>
<li>Go 中的 STL 算法等效项</li>
<li>Go 中的矩阵和向量计算</li>
<li>编写可读的 Go 代码</li>
<li>Go 中的模板编程</li>
<li>Go 中的内存管理</li>
<li>Go 中的 GPU 并行化</li>
<li>Go 中的编译时间评估</li>
<li>构建和部署 Go 代码</li>
<li>Profiling Go 代码</li>
<li>Tracing Go 代码</li>
<li>集群和作业队列</li>
<li>跨版本比较代码质量</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>客观、全面的比较 Rust 与 Go</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/rust-vs-go/</link>
			<pubDate>Tue, 10 Nov 2020 00:07:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/rust-vs-go/</guid>
			<description>最近一年，将 Rust 和 Go 进行比较的不少，但不少都不公正，带感情色彩。而这篇文章客观、全面的分析对比了 Rust 和 Go，让你具体项目时选择最合适的。 Rust 还是 Go，哪个更好？你应该为下一个项目选择哪种语言，为什么？两者在性能，简单性，安全性，功能，规模和并发性等方面如何比较？它们有什么共同点，并且在根本上有何不同？来自 For the Go of Love 系列图书的作者，友好而公正的比较 Rust 和 Golang。</description>
			<content type="html"><![CDATA[<blockquote>
<p>最近一年，将 Rust 和 Go 进行比较的不少，但不少都不公正，带感情色彩。而这篇文章客观、全面的分析对比了 Rust 和 Go，让你具体项目时选择最合适的。</p>
</blockquote>
<p>Rust 还是 Go，哪个更好？你应该为下一个项目选择哪种语言，为什么？两者在性能，简单性，安全性，功能，规模和并发性等方面如何比较？它们有什么共同点，并且在根本上有何不同？来自 <a href="https://bitfieldconsulting.com/books/" target="_blank" rel="noopener">For the Go of Love</a>
 系列图书的作者，友好而公正的比较 Rust 和 Golang。</p>
<h2 id="rust-和-go-都很棒">Rust 和 Go 都很棒</h2>
<p>首先，非常重要的一点是，Go 和 Rust 都是绝对优秀的编程语言。它们是现代的，强大的，被广泛采用的，并且具有出色的性能。你可能已经阅读了一些文章和博客文章，目的是说服 Go 比 Rust 更好，反之亦然。但这确实没有道理；每种编程语言都代表一组权衡。每种语言针对不同的事物进行了优化，因此，应根据适合你的语言以及你要解决的问题来确定语言的选择。</p>
<p>在本文中，我将简要概述我认为 Go 是理想的选择，以及我认为 Rust 是更好的选择的地方。不过，理想情况下，你应该对这两种语言都有一定的了解。尽管它们的语法和样式差异很大，但 Rust 和 Go 都是用于构建软件的一流工具。话虽如此，让我们仔细看看这两种语言。</p>
<h2 id="相似之处">相似之处</h2>
<p>Rust 和 Go 有很多共同点，这是你经常听到他们一起被提及的原因之一。两种语言的共同目标是什么？</p>
<blockquote>
<p>Rust 是一种专注于安全性和性能的低级静态类型多范式编程语言。<em>—</em><a href="https://serokell.io/blog/rust-guide" target="_blank" rel="noopener">Gints Dreimanis</a>
</p>
</blockquote>
<blockquote>
<p>Go 是一种开放源代码编程语言，可轻松构建简单，可靠和高效的软件。—<a href="https://golang.org/" target="_blank" rel="noopener">Golang.org</a>
</p>
</blockquote>
<h3 id="内存安全">内存安全</h3>
<p>Go 和 Rust 都属于优先考虑内存安全性的现代编程语言。数十年来，使用 C 和 C++ 等较旧的语言已经很清楚，导致错误和安全漏洞的最大原因之一是不安全或不正确地访问内存。 Rust 和 Go 以不同的方式处理此问题，但是两者的目的都是要比其他有关内存管理的语言更聪明，更安全，并帮助你编写正确且性能良好的程序。</p>
<h3 id="快速紧凑的可执行文件">快速，紧凑的可执行文件</h3>
<p>它们都是编译语言，这意味着你的程序直接转换为可执行的机器代码，因此你可以将程序作为单个二进制文件进行部署；与 Python 和 Ruby 等解释型语言不同，你无需随程序一起分发解释器，大量库和依赖项，这是一大优势。与解释型语言相比，这也使 Rust 和 Go 程序都非常快。</p>
<h3 id="通用语言">通用语言</h3>
<p>Rust 和 Go 都是功能强大，可扩展的通用编程语言，你可以使用它们来开发各种现代软件，从Web应用程序到分布式微服务，或者从嵌入式微控制器到移动应用程序。两者都具有出色的标准库和蓬勃发展的第三方生态系统，以及强大的商业支持和庞大的用户群。它们都已经存在了很多年，并将在未来几年继续被广泛使用。今天学习 Go 或 Rust 将是你的时间和精力的明智投资。</p>
<h3 id="务实pragmatic的编程风格">务实（Pragmatic）的编程风格</h3>
<p>两种语言都不是纯函数式语言（例如 Scala 或 Elixir），也不是全面面向对象的语言（例如 Java 和 C#）。相反，尽管 Go 和 Rust 都具有与函数和面向对象的编程相关的功能，但它们都是务实的语言，旨在以最合适的方式解决问题，而不是强迫你采用特定的处理方式。 （不过，如果你喜欢函数式编程风格，则在 Rust 中会发现更多的函数式特性，因为 Rust 的函数式功能比 Go 多得多。）</p>
<blockquote>
<p>我们可以讨论什么是“面向对象”语言，但是公平地说，Go 或 Rust 中都没有 C++，Java 或 C# 用户期望的面向对象编程风格。—Jack Mott</p>
</blockquote>
<h3 id="大规模发展">大规模发展</h3>
<p>Rust 和 Go 都具有一些有用的特性，这使其适合于大型编程，包括大型团队，大型代码库，或两者兼而有之。</p>
<p>例如，尽管 C 程序员多年来一直在争论括号的位置，以及是否应使用制表符或空格使代码缩进，但 Rust 和 Go 都通过使用标准格式工具（gofmt 用于 Go，rustfmt 用于 Rust）完全消除了此类问题。 它使用规范样式自动格式化你的代码。并不是说这种特殊的样式本身如此出色：而是 Rust 和 Go 程序员所欣赏的标准化。</p>
<blockquote>
<p>gofmt 的风格不是每个人的最爱，但 gofmt 是每个人的最爱。<em>—</em><a href="https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=8m43s" target="_blank" rel="noopener">Rob Pike</a>
</p>
</blockquote>
<p>两种语言得分很高的另一个领域是构建管道（build pipeline）。两者都具有出色的内置高性能标准构建和依赖管理工具。不再需要为复杂的第三方构建系统而费力，也不必每两年学习一次新的。</p>
<blockquote>
<p>在我早期的职业生涯中，具有 Java 和 Ruby 背景的 Go 和 Rust 代码构建工作似乎使我无法承受。当我在 Google 时，遇到用 Go 编写的服务感到很欣慰，因为我知道它易于构建和运行。 Rust 的情况也是如此，尽管我只是在较小的规模上进行了研究。我希望无限可配置的构建系统的日子已经一去不复返了，所有语言都附带了它们自己专用的构建工具，这些工具可以直接使用。<em>—</em><a href="https://samwho.dev/" target="_blank" rel="noopener">Sam Rose</a>
</p>
</blockquote>
<h2 id="那有什么大惊小怪的">那有什么大惊小怪的？</h2>
<p>考虑到所有这些，并且看到这两种语言的设计和功能如此强大，你可能想知道所有的圣战是关于什么的（我也是）。人们为什么对 “Go vs Rust” 如此大惊小怪，陷入愤怒的社交媒体争吵中，并写了很长的博客文章，内容涉及只有白痴才会使用Rust，或者 Go 不是真正的编程语言等等。它可能会让他们感觉更好，但对于试图决定要为项目使用哪种语言的人，或者应该学习哪种语言来促进编程事业的人，这并不能完全为你提供帮助。明智的人不会根据谁喊得最多而做出重要的选择。</p>
<p>现在，让我们继续探讨一些成年人在某些方面可能会比较喜欢一种语言而不是另一种语言的问题。</p>
<h2 id="性能">性能</h2>
<p>我们已经说过，Go 和 Rust 都能生成非常快的程序，因为它们被编译为本机代码，而无需通过解释器或虚拟机。但是，Rust 的性能特别出色，它可与 C 和 C++ 相媲美（C/C++ 通常被认为是性能最高的编译语言），但与这些较旧的语言不同，它还提供了内存安全性和并发安全性，而执行速度却基本没有任何成本。 Rust 还允许你创建复杂的抽象，而无需在运行时付出性能损失。</p>
<p>相比之下，尽管 Go 程序的性能也非常好，但是 Go 的主要目的是提高开发速度（包括编译），而不是提高执行速度。 Go 编译器不会花费很多时间来尝试生成尽可能高效的机器代码；它更关心快速编译大量代码。因此，Rust 通常会在运行时基准测试中击败 Go。</p>
<p>Rust 的运行时性能也始终如一且可预测，因为它不使用垃圾回收。 Go 的垃圾收集器非常高效，并且经过优化，可以使其 STW 的时间尽可能短（并且在每个新的 Go 版本中都变得更短）。但是垃圾回收不可避免地在程序的行为方式中引入了一些不可预测性，这在某些应用程序（例如嵌入式系统）中可能是一个严重的问题。</p>
<p>由于 Rust 旨在使程序员能够完全控制底层硬件，因此有可能将 Rust 程序优化为非常接近机器的最大理论性能。对于执行速度超过所有其他考虑因素的领域（例如游戏编程，操作系统内核，Web 浏览器组件和实时控制系统），Rust 使其成为绝佳的选择。</p>
<h2 id="简单">简单</h2>
<p>如果没有人能弄清楚如何使用它，那么编程语言有多快也没关系。 Go 被故意认为是对 C++ 等语言不断增长的复杂性的一种反应。它的语法很少，关键字也不多，而且功能也很少。这意味着学习 Go 语言并不需要很长时间，你可以在其中编写有用的程序。</p>
<blockquote>
<p>Go 非常容易学习。我知道这是一个经常被吹捧的好处，但是我对能够这么快地提高生产力感到非常惊讶。多亏了语言，文档和工具，我实际上在两天之后就编写了有趣的，可提交的代码。— <a href="https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410" target="_blank" rel="noopener">Rust 程序员对 Go 的早期印象</a>
</p>
</blockquote>
<p>这里的关键词是简单。当然，简单（simple）与容易（easy）并不相同，但是简单的小型语言比复杂的大型语言更容易学习。要做的事情没有太多不同的方式，因此所有编写良好的 Go 代码看起来都一样。深入研究不熟悉的服务并了解其功能很容易。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Gopher&#39;s Diner Breakfast Menu&#34;</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">dish</span><span class="p">,</span> <span class="nx">price</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">menu</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">dish</span><span class="p">,</span> <span class="nx">price</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>尽管核心语言很小，但 Go 的标准库功能非常强大。这意味着你的学习曲线还需要包括所需的标准库部分，而不仅仅是Go语法。另一方面，将功能从语言中移出并移入标准库意味着你现在可以专注于仅学习与你相关的库。</p>
<p>Go 还被设计用于具有大型代码库和大型团队的大规模软件开发。在这种情况下，重要的是，新开发人员必须尽快上手。</p>
<blockquote>
<p>使用 Go，你可以快速完成工作。 Go 是我使用过的最具生产力的语言之一。口头禅是：解决今天的实际问题。<em>—</em><a href="https://endler.dev/2017/go-vs-rust/" target="_blank" rel="noopener">Matthias Endler</a>
</p>
</blockquote>
<h2 id="特性">特性</h2>
<blockquote>
<p>与其他几种编程语言相比，Rust 支持更多的复杂特性，因此，你可以用它实现更多的功能。例如，它支持泛型。<em>—</em><a href="https://devathon.com/blog/rust-vs-go-which-programming-language-to-choose/" target="_blank" rel="noopener">Devathon</a>
</p>
</blockquote>
<p>Rust 专门设计为包含许多强大而有用的功能，以帮助程序员以最少的代码完成最多的工作。例如，Rust 的 match 功能使你可以非常简洁地编写灵活的表达逻辑：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span>: <span class="kt">u64</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">bool</span> <span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="mi">0</span><span class="p">...</span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
</span><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="mi">2</span><span class="p">..</span><span class="n">n</span><span class="p">).</span><span class="n">any</span><span class="p">(</span><span class="o">|</span><span class="n">d</span><span class="o">|</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>由于 Rust 的功能很多，这意味着有很多东西要学习，尤其是在一开始的时候。但这没关系：在 C++ 或 Java 中也有很多东西要学习，而且你没有获得 Rust 附带的高级功能，例如内存安全性。批评 Rust 是一种复杂的语言，没有抓住重点：它被设计成具有表现力，这意味着具有许多功能，并且在许多情况下，这是编程语言所需要的。当然，这是一条学习曲线，但是一旦你开始使用它，就可以了。</p>
<blockquote>
<p>Rust 为准备接受更复杂的语法和语义（可能会带来更高的可读性成本）以换取最大可能的性能的程序员，与 C++ 和 D 竞争思想共享。<em>—</em><a href="https://dave.cheney.net/2015/07/02/why-go-and-rust-are-not-competitors" target="_blank" rel="noopener">Dave Cheney</a>
</p>
</blockquote>
<h2 id="并发">并发</h2>
<p>大多数语言都对并发编程提供某种形式的支持（一次执行多项操作），但是 Go 是专为这项工作而设计的。 Go 不使用操作系统线程，而是提供了一种轻量级的替代方案：goroutines。每个 goroutine 是一个独立执行的 Go 函数，Go 调度程序会将其映射到其控制下的 OS 线程之一。这意味着调度程序仅使用有限数量的 OS 线程即可非常有效地管理大量并发的goroutine。</p>
<p>因此，你可以在一个程序中运行数百万个并发 goroutine，而不会造成严重的性能问题。这使 Go 成为 Web 服务器和微服务等大规模并发应用程序的理想选择。</p>
<p>Go 还提供了快速，安全，有效的方式，goroutine 使用 channel 进行通信和共享数据。 Go 的并发支持设计良好，使用起来很愉快。通常很难对并发程序进行推理，而构建可靠，正确的并发程序对任何语言都是一个挑战。但是，由于它是从一开始就内置在语言中的，而不是事后才想到的，Go 中的并发编程简单、合理、良好的集成进语言中。</p>
<blockquote>
<p>Go 使构建易于分解的应用程序变得非常容易，该应用程序在作为一组微服务部署时充分利用了并发性。 Rust 也可以做这些事情，但是可以说有点困难。从某些方面来说，Rust 对防止与内存相关的安全漏洞的痴迷意味着程序员必须竭尽全力来执行使用其他语言（包括 Go）更简单的任务。<em>—</em><a href="https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/" target="_blank" rel="noopener">Sonya Koptyev</a>
</p>
</blockquote>
<p>相比之下，Rust 中的并发是一个很新的特性，并且还有待稳定中，但是它的发展非常活跃，因此请留意这块。例如，Rust 的 <a href="https://github.com/rayon-rs/rayon" target="_blank" rel="noopener">rayon</a>
 提供了一种非常优雅且轻巧的方法，可以将顺序计算转换为并行计算。</p>
<blockquote>
<p>具有轻量级 Goroutine 和 Channel 语法确实很棒。它确实显示出语法的威力，即如此小的细节使并发编程比其他语言感觉更好。— <a href="https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410" target="_blank" rel="noopener">Rust 程序员对 Go 的早期印象</a>
</p>
</blockquote>
<p>虽然在 Rust 中实现并发程序可能会不太直接，但仍然可以实现，并且这些程序可以利用 Rust 的安全保证。标准库的 Mutex 类就是一个很好的例子：在 Go 中，你可以忘记在访问某些东西之前先获得一个互斥锁，但是 Rust 不允许你这样做。</p>
<blockquote>
<p>Go 将并发作为第一类概念。这并不是说你无法在 Rust 中找到类似 Go 的并发方式，而是留给程序员练习。<em>—</em><a href="https://dave.cheney.net/2015/07/02/why-go-and-rust-are-not-competitors" target="_blank" rel="noopener">Dave Cheney</a>
</p>
</blockquote>
<h2 id="安全性">安全性</h2>
<p>前面我们已经看到，Go 和 Rust 都以不同的方式来防止与内存管理有关的大量常见编程错误。但是，尤其是 Rust 会竭尽全力确保你不会做本不该做的不安全的事情。</p>
<blockquote>
<p>Rust 的程序编辑器非常严格且学究（pedantic），它会检查你使用的每个变量以及引用的每个内存地址。它避免了可能的数据争用情况，并通知你有关未定义行为的信息。从根本上讲，并发和内存安全问题根本不可能进入Rust的安全子集。<em>—</em><a href="https://bitbucket.org/blog/why-rust" target="_blank" rel="noopener">Why Rust?</a>
</p>
</blockquote>
<p>这会使 Rust 中的编程成为几乎所有其他语言的不同体验，而且一开始可能具有挑战性。但对很多人来说，努力工作是值得的。</p>
<blockquote>
<p>对我来说，Rust 的主要优点是感觉编译器成为我的靠山，不会让任何错误漏出（有时感觉像魔术）。<em>—Grzegorz Nosek</em></p>
</blockquote>
<p>包括 Go 在内的许多语言都具有帮助程序员避免错误的功能，但是 Rust 将其提升到了一个新的高度，因此潜在的错误程序甚至无法编译。</p>
<blockquote>
<p>使用 Rust，库程序员可以使用很多工具来防止用户犯错误。 Rust 使我们能够说我们拥有特定的数据。其他任何人都不可能拥有所有权，因此我们知道其他任何人都无法对其进行修改。我想不到曾经有过这么多工具来防止意外滥用。真是太好了。<em>—</em><a href="https://samwho.dev/" target="_blank" rel="noopener">Sam Rose</a>
</p>
</blockquote>
<p>对于新手 Rust 程序员来说，“与借阅检查器（borrow checker）打架”是一个常见的症状，但是在大多数情况下，它发现的问题是代码中的真正错误（或至少是潜在的错误）。这可能会迫使你从根本上重新架构程序，以避免遇到这些问题。当正确性和可靠性是你的重中之重时，这是一件好事。语言不会改变编程方式的重点是什么？当你使用其他语言工作时，Rust 讲授的有关安全性的课程也会很有用。</p>
<blockquote>
<p>如果选择 Rust，通常需要该语言提供的保证：防止空指针和数据竞争的安全性，可预测的运行时行为以及对硬件的完全控制。如果你不需要这些功能，Rust 对于你的下一个项目可能不是一个好的选择。这是因为这些保证要付出一定的代价：学习坡度，时间问题。你将需要学习不良习惯并学习新概念。很有可能，刚开始时，你将与借阅检查器进行很多斗争。<em>—</em><a href="https://endler.dev/2017/go-vs-rust/" target="_blank" rel="noopener">Matthias Endler</a>
</p>
</blockquote>
<p>你发现 Rust 的编程模型的挑战性可能取决于你以前在其他语言中所拥有的经验。 Python 或 Ruby 程序员可能会发现它有限制；而其他人可能很高兴。</p>
<blockquote>
<p>如果你是一位花了数周时间寻找这些语言的内存安全性错误的 C 或 C++ 程序员，那么你将非常感谢 Rust。 “对抗借阅检查器”变为“编译器可以检测到吗？凉！”—Grzegorz Nosek</p>
</blockquote>
<h2 id="规模">规模</h2>
<blockquote>
<p>当今的服务器程序包含数千万行代码，由成百上千的程序员进行处理，并且每天都会更新。 Go 的设计和开发旨在提高在这种环境下的工作效率。 Go 的设计考虑因素包括严格的依赖关系管理，随着系统增长的软件体系结构的适应性以及跨组件边界的鲁棒性。<em>—</em><a href="https://talks.golang.org/2012/splash.article" target="_blank" rel="noopener">Rob Pike</a>
</p>
</blockquote>
<p>当你自己或以小组形式处理问题时，选择简单语言还是丰富语言是你的偏爱。但是随着软件变得越来越大，越来越复杂，以及团队越来越大，这种差异真正开始显现出来。对于大型应用程序和分布式系统，执行速度不如开发速度重要：像 Go 这样的故意最小化的语言减少了新开发人员的启动时间，并使他们更容易使用大型代码库。</p>
<blockquote>
<p>使用 Go，初级开发人员更容易提高工作效率，而中级开发人员更难引入脆弱的抽象，而抽象将导致问题。由于这些原因，Rust 在企业软件开发方面不如 Go 引人注目。<em>—</em><a href="https://kristoff.it/blog/why-go-and-not-rust" target="_blank" rel="noopener">Loris Cro</a>
</p>
</blockquote>
<p>当涉及到大型软件开发时，清晰胜于灵活。 Go 的限制性实际上使它比 Rust 等更复杂、功能更强大的语言更适合企业和大型组织。</p>
<h2 id="差异">差异</h2>
<p>尽管 Rust 和 Go 都是流行的，现代的，广泛使用的语言，但从故意针对完全不同的用例的意义上来说，它们并不是真正的竞争对手。 Go 的整个编程方法与 Rust 的方法完全不同，每种语言都适合某些人，同时又会激怒其他人。绝对很好，而且如果 Rust 和 Go 都以或多或少相同的方式或多或少地完成了相同的事情，那么我们实际上就不需要两种不同的语言。</p>
<p>那么，通过发现它们采取截然不同的方法的问题，我们是否能够了解 Rust 和 Go 的各自性质？让我们找出答案。</p>
<h3 id="垃圾回收">垃圾回收</h3>
<p>“进行垃圾收集或不进行垃圾收集”是没有正确答案的问题之一。垃圾回收和自动内存管理通常使开发可靠，高效的程序变得快速简便，对于某些人来说，这是必不可少的。但是其他人说，垃圾回收的性能开销和停顿，使程序在运行时无法正常运行，并引入了无法接受的延迟。争论不休。</p>
<blockquote>
<p>Go 与 Rust 完全不同。尽管两者都可以模糊地描述为系统语言或 C 语言的替代品，但它们具有不同的目标和应用，语言设计风格以及优先级。垃圾收集确实是一个巨大的区别。在 Go 中使用 GC 可使该语言变得更加简单和小巧。</p>
<p>在 Rust 中不使用 GC 可以使它真正更快（特别是如果你需要保证的等待时间，而不仅仅是高吞吐量），并启用 Go 中无法实现的特性和编程模式（或者至少在不牺牲性能的情况下）。<em>—</em><a href="https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410" target="_blank" rel="noopener">PingCAP</a>
</p>
</blockquote>
<h2 id="更接近金属close-to-the-metal">更接近金属（Close to the metal）</h2>
<p>计算机编程的历史一直是一个越来越复杂的抽象的故事，它使程序员能够解决问题而不必担心底层机器的实际工作原理。这使程序更易于编写，并且可能更具移植性。但是对于许多程序而言，访问硬件以及精确控制程序执行方式更为重要。 Rust 的目标是让程序员拥有更多的控制权，使其“更接近金属”，但是 Go 提取了体系结构的详细信息，以使程序员更加接近问题。</p>
<blockquote>
<p>两种语言有不同的使用范围。 Golang 对于编写微服务和典型的 “DevOps” 任务很有用，但它不是系统编程语言。对于并发性，安全性和/或性能很重要的任务，Rust 更强。但是它的学习曲线比 Go 更陡。<em>—</em><a href="https://endler.dev/2017/go-vs-rust/" target="_blank" rel="noopener">Matthias Endler</a>
</p>
</blockquote>
<h3 id="go-发展更快">Go 发展更快</h3>
<p>我在其他地方写过，对于大多数程序而言，<a href="https://bitfieldconsulting.com/golang/slower" target="_blank" rel="noopener">性能并不如可读性重要</a>
。但是，当性能确实很重要时，它真的很重要。 Rust 进行了许多设计折衷，以实现最佳的执行速度。相比之下，Go 更加关注简单性，并且愿意为此牺牲一些（运行时）性能。但是 Go 的构建速度是无与伦比的，这对于大型代码库而言非常重要。</p>
<blockquote>
<p>Rust 比 Go 快。在上述基准测试中，Rust 速度更快，在某些情况下还快一个数量级。但是在选择使用 Rust 编写所有内容之前，请考虑一下 Go 在许多基准测试中并没有落后很多，并且它仍然比 Java，C#，JavaScript，Python 等同类工具快得多。</p>
<p>如果你需要一流的性能，那么你可以选择这两种语言中的任一种。如果你要构建一个处理高负载的 Web 服务，并且希望能够在垂直和水平方向上进行伸缩，则两种语言都将非常适合你。<em>—</em><a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9" target="_blank" rel="noopener">Andrew Lader</a>
</p>
</blockquote>
<h3 id="正确性">正确性</h3>
<p>另一方面，如果程序没有正常运行，则可以任意快。大多数代码不是长期编写的，但通常令人惊讶的是某些程序可以在生产环境中运行多长时间：在某些情况下需要数十年。在这种情况下，需要花一些额外的时间来开发程序，以确保程序正确，可靠并且将来不需要进行大量维护。</p>
<blockquote>
<p>我的看法：明天将要发布的代码选择 Go，在未来五年内保持不变的代码选择 Rust。<em>—Grzegorz Nosek</em></p>
</blockquote>
<p>尽管 Go 和 Rust 对于任何严肃的项目都是不错的选择，但最好使自己对每种语言及其特征都尽可能了解。最终，其他人的想法无关紧要：只有你可以决定哪种对你和你的团队是合适的。</p>
<blockquote>
<p>如果你想加快开发速度，也许是因为你要编写许多不同的服务，或者你有庞大的开发团队，那么 Go 是你选择的语言。 Go 为你提供了一流的并发性，并且不容许不安全的内存访问（Rust 也不容忍），但不会强迫你管理每个最后的细节。 Go 是快速而强大的工具，但是它避免了使开发人员陷入困境，而专注于简单性和统一性。另一方面，如果需要拧紧块性能，那么 Rust 应该是你的选择。<em>—</em><a href="https://codeburst.io/should-i-rust-or-should-i-go-59a298e00ea9" target="_blank" rel="noopener">Andrew Lader</a>
</p>
</blockquote>
<h2 id="结论">结论</h2>
<p>我希望本文使你相信，Rust 和 Go 都值得你认真考虑。如果可能的话，你应该力求获得至少两种语言的某种程度的经验，因为它们对你在任何技术职业中都是非常有用的，即使你喜欢将编程作为业余爱好也是如此。如果你只有时间投入精力来学习一种语言，那么请在将 Go 和 Rust 都用于各种大小不同的程序之前，不要做出最终决定。</p>
<p>而且，对编程语言的了解实际上只是成为一名成功的软件工程师的一小部分。到目前为止，您将需要的最重要的技能是设计，工程，体系结构，沟通和协作。如果您擅长这些，那么无论您选择哪种语言，您都将是一名出色的软件工程师。学习愉快！</p>
<blockquote>
<p>原文链接：<a href="https://bitfieldconsulting.com/golang/rust-vs-go">https://bitfieldconsulting.com/golang/rust-vs-go</a></p>
<p>原文作者：John Arundel</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>关于 Go 语言微服务框架 Micro 的一些情况说明</title>
			<link>https://polarisxu.studygolang.com/posts/go/micro/micro-3.0.0-m3o/</link>
			<pubDate>Mon, 09 Nov 2020 15:50:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/micro/micro-3.0.0-m3o/</guid>
			<description>用过或了解过 Micro 这个框架的人，可能有所耳闻，大家对其抱怨比较多，典型的抱怨是升级后不兼容。比如网上有教程是基于 1.x，但新版本是 2.x，完全不一样了，而且似乎官方文档也没有及时更新，使用了它的人“痛苦不堪”。 前些天，有人问我有无其他 Go 微服务框架推荐，说 Micro 3.0.0 开始不能用了！！ 我听了一惊：我只听说它不稳定，总是变来变去，兼容性不好，但没听说不能用。后来了解了下，原来</description>
			<content type="html"><![CDATA[<p>用过或了解过 Micro 这个框架的人，可能有所耳闻，大家对其抱怨比较多，典型的抱怨是升级后不兼容。比如网上有教程是基于 1.x，但新版本是 2.x，完全不一样了，而且似乎官方文档也没有及时更新，使用了它的人“痛苦不堪”。</p>
<p>前些天，有人问我有无其他 Go 微服务框架推荐，说 Micro 3.0.0 开始不能用了！！</p>
<p>我听了一惊：我只听说它不稳定，总是变来变去，兼容性不好，但没听说不能用。后来了解了下，原来 3.0 做了巨大的改变。主要有：</p>
<ul>
<li>Micro 3.0 推荐叫做 M3O，微服务框架成为了云原生开发平台</li>
<li>废弃了 Go-Micro</li>
<li>开源 License 由 Apache 2.0 改为 <a href="https://polyformproject.org/licenses/shield/1.0.0/" target="_blank" rel="noopener">Polyform Shield</a>
</li>
</ul>
<p>说明一点，Micro 是一个公司：Micro Services, Inc。</p>
<h2 id="01-micro-30-叫做-m3o一个云原生开发平台">01 Micro 3.0 叫做 M3O，一个云原生开发平台</h2>
<p>在 11 月 05 日，官方宣布 Micro 3.0.0 发布。这不再是一个微服务框架，而是一个云原生平台。有什么不一样呢？</p>
<p>官方在 3.0 版本对主要工具进行了重大重构，并将其整合到可以从开发人员的角度解决构建、运行、管理和使用这整个工作流的问题。</p>
<h3 id="为什么做这样的改变">为什么做这样的改变</h3>
<p>Micro 最初是作为微服务开发的工具包，它结合了 api 网关，Web dashboard 和 cli 与使用 Go RPC 框架构建的服务进行交互。因为考虑到那时让所有人重新购买 PaaS 感觉就像是一场失败的战斗。因此，官方选择围绕 RPC 框架编写单一用途的工具，以为它可以使人们逐步采用它，直到他们看到对平台的需求为止。</p>
<p>虽然有一个简单的 Go 框架以及一些用于查询和与之交互的周围组件，但是就像任何长期存在的项目一样，随着试图解决瑞士军刀无法做到的那种平台体验，其复杂性也在增加，开发了许多独立的库。这对于用户而言，增加了认知上的负担。</p>
<p>在 2019 年，官方对所有这些库进行了合并，这提供了极大的帮助，但始终仍然存在一个悬而未决的问题。 micro 和 go-micro 有什么区别？一般我们将 go-micro 视为框架，将 micro 视为工具箱，但这样的划分似乎没有意义。</p>
<p>过去 5 年，随着容器和容器编排成为焦点，“云原生”工具激增，世界爆炸了。更具体地说，Docker 和 Kubernetes 重新定义了技术领域，并更加有意识地转向在云中构建软件。</p>
<p>Micro 甚至可以追溯到 2015 年，都具有前瞻性的观点。很明显，分布式系统和云原生将在未来几年内成为后端服务开发的主导模型，但是不清楚要花多长时间花折腾各种工具，例如 docker，kubernetes，grpc，istio 等。这感觉就像重新构建技术栈。Micro 希望解决整个工作流上的事情，而只是在微服务开发上。</p>
<p>M3O 官方认为 PaaS 3.0 不仅是在运行容器甚至是源代码，而且还囊括了整个开发人员的经验，包括用于编写云代码的模型。因此它们打造了 Micro 3.0，或叫 M3O，这是用于云原生开发的平台。</p>
<p>更多信息可以看 <a href="https://micro.mu/blog/2020/11/05/micro-v3-aka-m3o.html" target="_blank" rel="noopener">Micro 3.0.0 的发布公告</a>
。</p>
<h2 id="02-废弃-go-micro">02 废弃 Go-Micro</h2>
<p>这个点上面已经做了一定说明。</p>
<p>官方终止对 go-micro 的支持。这个项目自 2014 年创建至今，已经拥有 14.7k+ Star。作者认为尽管它为许多人解决了一些问题，但它并没有完成它的初衷。</p>
<p>现在这个项目并没有直接放弃，而是转交到个人名下（Micro 公司的 CEO Asim），为了避免混淆，项目名也改了，叫 <a href="https://github.com/asim/nitro" target="_blank" rel="noopener">Nitro</a>
。现在它是一个快速的分布式应用程序开发框架。</p>
<p>虽然 go-micro 2.0 依然可以使用，但已经不维护。更多相信信息可以查看 Nitro 项目的 FAQ。</p>
<h2 id="03-licence-改为-polyform-shield">03 Licence 改为 Polyform Shield</h2>
<p>Polyform Shield 这个 Licence 我是第一次见 ，相信很多人也是。官方的说法是：</p>
<blockquote>
<p>Micro 继续保持开源状态，但使用 Polyform Shield 进行了许可，这可以防止该软件被提取并作为服务运行。这是为了与 AWS 和其他运行开放源代码以谋取利益而不回馈的人抗衡。</p>
</blockquote>
<p>这个 Licence 是为了防止 AWS 这样的云服务部署 Micro 服务，和 Micro 公司进行直接竞争，其他情况下可以免费使用。因此不存在开头网友说的不让用的情况。</p>
<p>值得一提的是，Nitro 项目的 Licence 也改为了 Polyform Shield。</p>
<h2 id="04-总结">04 总结</h2>
<p>Micro 3.0 的出现，可能是顺应时代的产物。但从另一个角度，包括 Licence 的变更，一个靠开源项目活下去的公司不容易。M3O 是一个云原生（m3o.com）托管平台，有兴趣可以了解它的收费模式，这是开源项目公司进行商业化的一种方式。</p>
<p>就像 Micro 的创始人 Asim 在 Nitro 项目的 FAQ 中说的：</p>
<blockquote>
<p>Go Micro 的维护，需要花费很多的时间精力，它属于 Micro Services，Inc. 公司，该公司现在专注于 Micro as a Service，并将此处的所有接口合并到该项目的服务库中。在大多数情况下，Go Micro 都没有资金支持，虽然得到过好评。因此，在坚持了 6 年后，在 3.0 版中，这个项目属于我个人（Asim），我做出了艰难的决定，要重新许可为非商业项目。对于任何商业应用程序，我正在寻找  <a href="https://github.com/sponsors/asim" target="_blank" rel="noopener">github sponsorship</a>
，以便我可以将这些资金用于维护和支持工作。</p>
</blockquote>
<p>所以，如果你曾经喜欢 Micro 这个项目，建议你可以继续喜欢。当然也希望这次之后，版本能够更稳定。而我看了这些后，作为一个开源爱好者，我准备花时间研究研究 Micro，顺便写写笔记，希望为它的推广做一点贡献。</p>
]]></content>
		</item>
		
		<item>
			<title>除了 fmt.Errorf() 之外—Go 中的日常错误对象：CockroachDB errors 库（第4篇）</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/cockroachdb-errors-everyday/</link>
			<pubDate>Wed, 04 Nov 2020 21:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/cockroachdb-errors-everyday/</guid>
			<description>在 Go 中传递错误的惯用方式是使用预定义的类型错误。但是 Go 的标准库仅提供了非常简单的错误对象，errors.New() 和 fmt.Errorf()。 本文介绍了 CockroachDB 的 error 库（它是 Go 标准库库 errors 的直接替代品），Go 程序员如何用它来描述和传播其代码中的错误和错误代号（code）。 Go 标准库 errors 太简单 由 fmt.Errorf() 构造的 Go 中最常见的“简单”错误对象类似于带有错误接口的包含在结构中的字符串：其</description>
			<content type="html"><![CDATA[<p>在 Go 中传递错误的惯用方式是使用预定义的类型错误。但是 Go 的标准库仅提供了非常简单的错误对象，errors.New() 和 fmt.Errorf()。</p>
<p>本文介绍了 CockroachDB 的 error 库（它是 Go 标准库库 errors 的直接替代品），Go 程序员如何用它来描述和传播其代码中的错误和错误代号（code）。</p>
<h2 id="go-标准库-errors-太简单">Go 标准库 errors 太简单</h2>
<p>由 fmt.Errorf() 构造的 Go 中最常见的“简单”错误对象类似于带有错误接口的包含在结构中的字符串：其 Error() 方法返回构造错误时设置的字符串。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// prints &#34;hello&#34;
</span></code></pre></div><p>什么都没有，仅此而已。打印错误对象也会显示该字符串。顺便说一句，使用 Go 的错误包 errors 的构造函数构建错误 errors.New() 结果一样。</p>
<h2 id="日常代码的简单错误">日常代码的简单错误</h2>
<p>如果使用 <a href="https://github.com/pkg/errors" target="_blank" rel="noopener">Dave Cheney 的错误库</a>
，或者甚至更好的 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">CockroachDB 错误库</a>
（通过导入 <code>github.com/cockroachdb/errors</code>），则简单错误也会在构造错误时自动捕获堆栈跟踪。</p>
<p>仅当详细打印错误时才显示堆栈跟踪。这样可以更轻松地排除错误的来源：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;github.com/cockroachdb/errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// still prints just &#34;hello&#34;
</span><span class="c1"></span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// verbose mode
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这会打印：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hello
<span class="o">(</span>1<span class="o">)</span> attached stack trace
  -- stack trace:
  <span class="p">|</span> main.main
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:10
  <span class="p">|</span> runtime.main
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/proc.go:203
  <span class="p">|</span> runtime.goexit
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/asm_amd64.s:1373
Wraps: <span class="o">(</span>2<span class="o">)</span> hello
Error types: <span class="o">(</span>1<span class="o">)</span> *withstack.withStack <span class="o">(</span>2<span class="o">)</span> *errutil.leafError
</code></pre></div><p>此详细输出包括第一行的 <code>.Error()</code> 结果，后跟堆栈跟踪内容。</p>
<p>经验一次又一次地表明，在程序中出现意外情况的确切点提取堆栈跟踪的能力对于查明确切原因并成功解决问题至关重要。没有这种能力，程序员会毫无线索，麻木排查，浪费大量时间。</p>
<p>仅出于这个原因，我不鼓励任何人使用 Go 自己的 fmt.Errorf() 或 errors.New()。相反，请导入 github.com/cockroachdb/errors 并仔细阅读以下内容：</p>
<ul>
<li>errors.New()：直接替换 Go 标准库的 errors.New()，但它会带有堆栈跟踪；</li>
<li>errors.Errorf() 或 errors.Newf()：用堆栈跟踪的方式替换 Go 标准库的 fmt.Errorf()；</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">cockroachdb</span><span class="o">/</span><span class="nx">errors</span>

<span class="c1">// New constructs a simple error and attaches a stack trace.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>

<span class="c1">// Newf constructs a simple error whose message is composed using printf-like formatting.
</span><span class="c1">// It also attaches a stack trace.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Newf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>

<span class="c1">// Errorf is an alias for Newf for convenience
</span><span class="c1">// and drop-in compatibility with github.com/pkg/errors.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Errorf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></div><h2 id="在错误中添加消息前缀以识别上下文">在错误中添加消息前缀以识别上下文</h2>
<p>当从多个位置调用相同的逻辑，并且可能因错误而失败时，则希望将消息前缀添加到任何返回的错误对象。</p>
<p>这有助于提供有关“错误发生的位置”的更多上下文，以便在运行时出现错误时（何时出现错误），可以清楚地了解哪个代码路径产生了错误。</p>
<p>例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;github.com/cockroachdb/errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;boo&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;bar&#34;</span><span class="p">)</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">baz</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;baz&#34;</span><span class="p">)</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="nx">r</span> <span class="o">:=</span> <span class="nf">rollDice</span><span class="p">()</span>
     <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
     <span class="k">if</span> <span class="p">(</span><span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nf">bar</span><span class="p">()</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nf">baz</span><span class="p">()</span>
     <span class="p">}</span>
     <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>多亏了 errors.Wrap()，它为消息添加了前缀，main 函数可能报告 bar:boo 或 baz:boo，并且人可以很方便的知晓是调用了哪个函数导致的错误。如果没有 errors.Wrap()，则导致错误的调用路径将是无法发现的。</p>
<p>为方便起见，当提供 nil 错误作为输入时，errors.Wrap() 返回nil。在许多情况下，这使我们可以消除 if err != nil 条件。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nf">foo</span><span class="p">(),</span> <span class="s">&#34;bar&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">baz</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nf">foo</span><span class="p">(),</span> <span class="s">&#34;baz&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>最后，errors.Wrap() 还将辅助堆栈跟踪附加到错误对象，从而在对错误的来源进行故障排除时提供了额外的上下文。在 channel 的场景出现错误是特别有用。</p>
<p>对于 errors.New()，此堆栈跟踪仅在显示详细错误时可见。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;github.com/cockroachdb/errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;world&#34;</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">bar</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;hello&#34;</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">baz</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">bar</span><span class="p">(</span><span class="nf">foo</span><span class="p">())</span> <span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nf">baz</span><span class="p">()</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// still prints just &#34;hello: world&#34;
</span><span class="c1"></span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// verbose mode
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>将打印：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hello: world
<span class="o">(</span>1<span class="o">)</span> attached stack trace
  -- stack trace:
  <span class="p">|</span> main.bar
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:10
  <span class="p">|</span> <span class="o">[</span>...repeated from below...<span class="o">]</span>
Wraps: <span class="o">(</span>2<span class="o">)</span> hello
Wraps: <span class="o">(</span>3<span class="o">)</span> attached stack trace
  -- stack trace:
  <span class="p">|</span> main.foo
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:9
  <span class="p">|</span> main.baz
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:11
  <span class="p">|</span> main.main
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:14
  <span class="p">|</span> runtime.main
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/proc.go:203
  <span class="p">|</span> runtime.goexit
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/asm_amd64.s:1373
Wraps: <span class="o">(</span>4<span class="o">)</span> world
Error types: <span class="o">(</span>1<span class="o">)</span> *withstack.withStack <span class="o">(</span>2<span class="o">)</span> *errutil.withPrefix <span class="o">(</span>3<span class="o">)</span> *withstack.withStack <span class="o">(</span>4<span class="o">)</span> *errutil.leafError
</code></pre></div><p>和以前一样，<code>.Error()</code> 的结果显示在第一行。然后，打印出最外层的堆栈跟踪（errors.Wrap() 的结果）。这表明错误被包裹在第 10 行，但调用跟踪与下面显示的一样。</p>
<p>然后，详细显示将显示内部错误，并显示消息 <code>world</code> 及其自身的堆栈跟踪。此内部堆栈跟踪显示内部错误是在第 9 行生成的。</p>
<p>错误包装工具用途广泛：可以使用类似于 printf 的格式来编写消息前缀。这是完整的 API：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">cockroachdb</span><span class="o">/</span><span class="nx">errors</span>

<span class="c1">// Wrap adds a message prefix and also attaches an additional stack trace.
</span><span class="c1">// If the first argument is nil, it returns nil.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Wrap</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>

<span class="c1">// Wrap adds a message prefix composed using printf-like formatting,
</span><span class="c1">// and also attaches an additional stack trace.
</span><span class="c1">// If the first argument is nil, it returns nil.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></div><p>此外，为了兼容 Go 1.13 的 fmt.Errorf()，上面看到的 errors.Newf() 和 errors.Errorf() 函数，它们还能识别出格式化动词 ％w，从而触发 wrap 逻辑。</p>
<p>例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The following is similar to errors.Wrapf(err, &#34;hello&#34;).
</span><span class="c1">// However, it does not return nil if err is nil!
</span><span class="c1"></span><span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Newf</span><span class="p">(</span><span class="s">&#34;hello: %w&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</code></pre></div><p>请注意，只有 Newf()/Errorf() 可以识别 ％w：errors.Wrap() 无法识别。</p>
<blockquote>
<p>提示：应该优先使用 errors.Wrap() 代替特殊动词 ％w：因为它会正确忽略作为输入给出的 nil 错误。</p>
</blockquote>
<h2 id="次要错误注解">次要错误注解</h2>
<p>每个中级 Go 程序员都会迅速陷入这一痛苦的境地：如果在处理错误时遇到错误，该怎么办？</p>
<p>一个常见的示例是在处理文件时遇到错误后清理文件系统：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">writeConfig</span><span class="p">(</span><span class="nx">out</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">cfgA</span><span class="p">,</span> <span class="nx">cfgB</span> <span class="nx">Config</span><span class="p">)</span> <span class="p">(</span><span class="nx">resErr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Create the destination directory.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">MkDir</span><span class="p">(</span><span class="nx">out</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
       <span class="c1">// If an error is encountered below, remove
</span><span class="c1"></span>       <span class="c1">// the destination directory upon exit.
</span><span class="c1"></span>       <span class="k">if</span> <span class="nx">resErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
          <span class="k">if</span> <span class="nx">dirErr</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">RemoveAll</span><span class="p">(</span><span class="nx">out</span><span class="p">);</span> <span class="nx">dirErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
             <span class="c1">// now... what?
</span><span class="c1"></span>             <span class="o">...</span>
         <span class="p">}</span>
       <span class="p">}</span>
    <span class="p">}()</span>

    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">writeCfg</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">cfgA</span><span class="p">,</span> <span class="s">&#34;a.json&#34;</span><span class="p">,</span> <span class="s">&#34;config A&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">writeCfg</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">cfgB</span><span class="p">,</span> <span class="s">&#34;b.json&#34;</span><span class="p">,</span> <span class="s">&#34;config B&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">writeCfg</span><span class="p">(</span><span class="nx">outDir</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">cfg</span> <span class="nx">Config</span><span class="p">,</span> <span class="nx">filename</span><span class="p">,</span> <span class="nx">desc</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">j</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">cfg</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrapf</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="s">&#34;marshaling %s&#34;</span><span class="p">,</span> <span class="nx">desc</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">WriteFile</span><span class="p">(</span><span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">filename</span><span class="p">),</span> <span class="nx">j</span><span class="p">,</span> <span class="mo">0777</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>本示例中的函数创建一个输出目录，以将两个配置对象写入其中。但是，在写入某些配置对象时可能会发生错误。在这种情况下，该函数希望通过删除刚刚创建的目录来对其进行清理。</p>
<p>如果在目录删除过程中发生错误，该怎么办？应该返回哪个错误？</p>
<ul>
<li>如果返回原始错误，我们将看不到目录删除错误。</li>
<li>如果返回目录删除错误，我们将看不到文件生成错误。</li>
</ul>
<p>我们希望以某种方式返回有关这两个错误的详细信息，以帮助进行故障排除。同时，出于原因分析的目的，我们要谨慎地将遇到的第一个错误保留为“主要”错误。</p>
<p>我们可以通过如下调整代码来实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
   <span class="c1">// If an error is encountered below, remove
</span><span class="c1"></span>   <span class="c1">// the destination directory upon exit.
</span><span class="c1"></span>   <span class="k">if</span> <span class="nx">resErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">dirErr</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">RemoveAll</span><span class="p">(</span><span class="nx">out</span><span class="p">);</span> <span class="nx">dirErr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="c1">// This attaches dirErr as an ancillary error
</span><span class="c1"></span>         <span class="c1">// to the error object that was already stored in resErr.
</span><span class="c1"></span>         <span class="nx">resErr</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">WithSecondaryError</span><span class="p">(</span><span class="nx">resErr</span><span class="p">,</span> <span class="nx">dirErr</span><span class="p">)</span>
     <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}()</span>
</code></pre></div><p>通过这种编程模式，我们可以确信，在处理另一个错误时，我们可以保留遇到错误时所发生事件的全部情况。</p>
<p>次要错误注解不会影响主要错误上 <code>.Error()</code> 返回的文本。从相关代码以及标准 API error.Is() 的角度来看，代码的行为就像仅发生了主要错误一样。</p>
<p>但是，在详细打印过程中会发现第二个错误。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;github.com/cockroachdb/errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
  <span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">WithSecondaryError</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;friend&#34;</span><span class="p">))</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// prints just &#34;hello&#34;
</span><span class="c1"></span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// verbose mode
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>打印：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">hello
<span class="o">(</span>1<span class="o">)</span> secondary error attachment
  <span class="p">|</span> friend
  <span class="p">|</span> <span class="o">(</span>1<span class="o">)</span> attached stack trace
  <span class="p">|</span>   -- stack trace:
  <span class="p">|</span>   <span class="p">|</span> main.main
  <span class="p">|</span>   <span class="p">|</span>         /home/kena/src/errors-tests/test.go:11
  <span class="p">|</span>   <span class="p">|</span> runtime.main
  <span class="p">|</span>   <span class="p">|</span>         /usr/lib/go-1.14/src/runtime/proc.go:203
  <span class="p">|</span>   <span class="p">|</span> runtime.goexit
  <span class="p">|</span>   <span class="p">|</span>         /usr/lib/go-1.14/src/runtime/asm_amd64.s:1373
  <span class="p">|</span> Wraps: <span class="o">(</span>2<span class="o">)</span> friend
  <span class="p">|</span> Error types: <span class="o">(</span>1<span class="o">)</span> *withstack.withStack <span class="o">(</span>2<span class="o">)</span> *errutil.leafError
Wraps: <span class="o">(</span>2<span class="o">)</span> attached stack trace
  -- stack trace:
  <span class="p">|</span> main.main
  <span class="p">|</span>     /home/kena/src/errors-tests/test.go:10
  <span class="p">|</span> runtime.main
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/proc.go:203
  <span class="p">|</span> runtime.goexit
  <span class="p">|</span>     /usr/lib/go-1.14/src/runtime/asm_amd64.s:1373
Wraps: <span class="o">(</span>3<span class="o">)</span> hello
Error types: <span class="o">(</span>1<span class="o">)</span> *secondary.withSecondaryError <span class="o">(</span>2<span class="o">)</span> *withstack.withStack <span class="o">(</span>3<span class="o">)</span> *errutil.leafError
</code></pre></div><p>像以前一样，我们在第一行看到 <code>.Error()</code> 的文本。然后，我们看到附加的次要错误的详细打印输出，相对于主要错误向右缩进。次要错误自己的 <code>.Error()</code> 是 <code>friend</code>，首先打印它，然后打印次要错误的嵌入式堆栈跟踪。</p>
<p>然后，打印输出继续，不缩进地显示主要错误的堆栈跟踪。</p>
<p>API 概览：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">cockroachdb</span><span class="o">/</span><span class="nx">errors</span>

<span class="c1">// WithSecondaryError attaches secondary as an annotation
</span><span class="c1">// to the primary error. If primary is nil, nil is returned.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WithSecondaryError</span><span class="p">(</span><span class="nx">primary</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">secondary</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span>

<span class="c1">// CombineErrors attaches err2 to err1 as secondary error
</span><span class="c1">// if both err1 and err2 are not nil. If err1 is nil, err2
</span><span class="c1">// is returned instead.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">CombineErrors</span><span class="p">(</span><span class="nx">err1</span><span class="p">,</span> <span class="nx">err2</span> <span class="kt">error</span><span class="p">)</span> <span class="nx">errors</span>
</code></pre></div><h2 id="子任务更智能的错误处理">子任务更智能的错误处理</h2>
<p>扩展包 <a href="https://godoc.org/golang.org/x/sync/errgroup" target="_blank" rel="noopener">errgroup</a>
 提供了一个可重复使用的库，用于“为处理共同任务的子任务的 goroutine 组进行同步，错误传播和上下文取消”。</p>
<p>它的实现可以在这里找到：<a href="https://github.com/golang/sync/blob/master/errgroup/errgroup.go">https://github.com/golang/sync/blob/master/errgroup/errgroup.go</a>。</p>
<p>在较高的级别上，它使用 sync.WaitGroup 运行多个 goroutine，并在末尾添加一个屏障。此外，一旦它们中的任何一个因错误终止，它将取消该组中的所有其他 goroutine。</p>
<p>逻辑问题在于，如果两个或多个 goroutine 因错误而失败，则仅报告第一个错误。其他错误是“被遗忘的”：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">g</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

     <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
             <span class="k">defer</span> <span class="nx">g</span><span class="p">.</span><span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>

             <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">f</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                     <span class="c1">// errOnce.Do executes its argument just once. The second time an
</span><span class="c1"></span>                     <span class="c1">// error is encountered, it is simply forgotten altogether! Not nice.
</span><span class="c1"></span>                     <span class="nx">g</span><span class="p">.</span><span class="nx">errOnce</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
                             <span class="nx">g</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">err</span>
                             <span class="k">if</span> <span class="nx">g</span><span class="p">.</span><span class="nx">cancel</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                                     <span class="nx">g</span><span class="p">.</span><span class="nf">cancel</span><span class="p">()</span>
                             <span class="p">}</span>
                     <span class="p">})</span>
             <span class="p">}</span>
     <span class="p">}()</span>
<span class="p">}</span>
</code></pre></div><p>我们可以按以下方式解决此问题：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Group</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="o">...</span>
     <span class="nx">errOnce</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
     <span class="nx">mu</span> <span class="p">{</span>
        <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span> <span class="c1">// makes .err race-free.
</span><span class="c1"></span>        <span class="nx">err</span>     <span class="kt">error</span>
     <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
   <span class="o">...</span>
   <span class="k">return</span> <span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">err</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
     <span class="o">...</span>
     <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
             <span class="o">...</span>
             <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">f</span><span class="p">();</span> <span class="p">!</span><span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Canceled</span><span class="p">)</span> <span class="p">{</span>
                   <span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
                   <span class="k">defer</span> <span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
                   <span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">err</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">CombineErrors</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nx">err</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
             <span class="p">}</span>
     <span class="p">}()</span>
<span class="p">}</span>
</code></pre></div><p>使用 errgroup.Group 的此备用版本，如果子任务中有两个或多个错误，则第一个将成为“主要”错误，而第一个之后的所有其他错误将作为辅助错误注解附加。</p>
<p>该代码还使用 errors.Is(err, context.Canceled) 来排除由组调用共享上下文的 cancel() 函数而产生的错误对象，这些对象只是噪音，可能在故障排除期间没有用。</p>
<h2 id="检查错误的身份">检查错误的身份</h2>
<p>在最常见的情况下，错误会传播，最终通过网络连接返回，或打印到日志文件。</p>
<p>但是，有时代码需要检查错误对象以决定其他行为。</p>
<p>为此，库可以定义一些特定的函数来处理这种情况。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">os</span>

<span class="c1">// IsExist returns a boolean indicating whether the error is known to report
</span><span class="c1">// that a file or directory already exists. It is satisfied by ErrExist as
</span><span class="c1">// well as some syscall errors.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">IsExist</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">bool</span>
</code></pre></div><p>可以这样使用：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ensureDirectoryExists</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Mkdir</span><span class="p">(</span><span class="nx">path</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="k">if</span> <span class="nx">os</span><span class="p">.</span><span class="nf">IsExist</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// The directory already exists. This is OK,
</span><span class="c1"></span>         <span class="c1">// no need to report an error.
</span><span class="c1"></span>         <span class="nx">err</span> <span class="p">=</span> <span class="kc">nil</span>
       <span class="p">}</span>
       <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;directory created&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>此函数尝试创建目录。如果已经存在，它将不执行任何操作。如果遇到另一个错误（例如磁盘损坏等），则会报告该错误。</p>
<p>另一种技术是使用“前哨”错误，并将返回的错误对象与那些标记进行比较以检测特定情况。</p>
<p>我们看到了上面带有 error.Is(err, context.Canceled) 的示例。这是来自 SQL 客户端程序的另一个示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">sqlConn</span><span class="p">)</span> <span class="nf">Query</span><span class="p">(</span><span class="nx">query</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">driver</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">sqlRows</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ensureConn</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
             <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
     <span class="p">}</span>
     <span class="nx">rows</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Query</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>
     <span class="k">if</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Is</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">driver</span><span class="p">.</span><span class="nx">ErrBadConn</span><span class="p">)</span> <span class="p">{</span>
             <span class="c1">// If the connection has been closed by the server or
</span><span class="c1"></span>             <span class="c1">// there was some other kind of network error, close
</span><span class="c1"></span>             <span class="c1">// the connection on our side so that the call to
</span><span class="c1"></span>             <span class="c1">// ensureConn() above establishes a new connection
</span><span class="c1"></span>             <span class="c1">// during the next query.
</span><span class="c1"></span>             <span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
             <span class="nx">c</span><span class="p">.</span><span class="nx">reconnecting</span> <span class="p">=</span> <span class="kc">true</span>
     <span class="p">}</span>
     <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
             <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="o">&amp;</span><span class="nx">sqlRows</span><span class="p">{</span><span class="nx">rows</span><span class="p">:</span> <span class="nx">rows</span><span class="p">.(</span><span class="nx">sqlRowsI</span><span class="p">),</span> <span class="nx">conn</span><span class="p">:</span> <span class="nx">c</span><span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>此代码检测 SQL 驱动程序何时返回 driver.ErrBadConn 并在这种情况下选择特殊行为。任何其他错误均按原样返回，并导致程序在此函数的调用程序中的某处停止。</p>
<blockquote>
<p>errors.is() 可以通过重复调用  Unwrap() 方法来检测整个错误的直接因果链中的前哨错误。因此，将忽略“在途中”发现的任何次要错误注解。这种行为是有意设计的：类似树的行为将使人们难以推理出错误是另一个“原因”的含义。还会在其他 API errors.As() 错误中引发有关遍历顺序的难题。就个人而言，经验还没有向我表明，除线性因果链之外，其他任何东西在实践中有用。</p>
</blockquote>
<h2 id="和-pkgerrors-的不同">和 pkg/errors 的不同</h2>
<p>自 2016 年以来，事实上是 Go 的错误包的标准替代品是 Dave Cheney 的 pkg/errors 库，该库位于 <a href="https://github.com/pkg/errors">https://github.com/pkg/errors</a>。</p>
<p>该包最初引入了链接列表错误对象的概念，自动包装错误并添加堆栈跟踪以在故障排除期间提供更多上下文。</p>
<p>不幸的是，Go 1.13 的发布使 pkg/errors 过时了：Dave Cheney 定义了自己的库，使用一种名为 Cause() 的方法来提取错误链的线性原因。当 Go 1.13 采纳用链接列表出错的想法时，它定义了另一个方法 Unwrap() 来提取原因。因此，Go 的errors.Is()和其他 API 无法理解源自 pkg/errors 的错误。</p>
<p>此外，来自 pkg/errors 的对象将严重遭受 Go Error 打印灾难，因此该库使自定义错误类型的实现非常困难。</p>
<p>CockroachDB 错误库接管了 pkg/errors：它采用 Go 1.13 约定，提供了 Go 1.13 标准 API 的直接替代品，并避免了 Go 错误打印灾难。它还实现了大多数 pkg/errors 接口，因此可以用作以前使用 Dave Cheney 库的程序的直接替代。</p>
<h2 id="总结">总结</h2>
<p>Go 库通过 Go 自己的错误包中的 fmt.Errorf() 和 errors.New() 提供了错误接口的简化实现。</p>
<p>改用 CockroachDB 错误库，代替 Go 的错误包和 Dave Cheney的 pkg/errors，可以获得更好的体验。</p>
<p>它的错误构造函数 errors.New()/errors.Newf()（别名为 errors.Errorf()）自动在错误对象中包含堆栈跟踪，可以使用 <code>fmt.Printf(&quot;％+v&quot; ,err)</code> 打印堆栈追踪。</p>
<p>它还提供了错误包装器的词汇表。最常见的是带有 errors.Wrap()/errors.Wrapf() 的消息前缀注释，用于注释从多个位置调用的函数的调用路径。这还包括幕后的堆栈跟踪。</p>
<p>另一个常见的包装器解决了在处理另一个错误时遇到错误时如何在 Go 中执行的令人困惑的问题：使用辅助原因注解，并使用 errors.WithSecondaryCause() 或 errors.CombineErrors() 附加，Go 代码可以保留两个错误，因此程序员在故障排除期间可以同时看到两者。</p>
<p>CockroachDB 错误库中的错误还提供了一致的行为，并且在详细格式化错误时提供了有用的显示结构，从而避免了巨大的 Go 错误打印灾难。我们将在本系列的后续文章中专门探讨实现自定义错误，以进一步探讨该主题。</p>
]]></content>
		</item>
		
		<item>
			<title>从来没有这么强烈想推荐一个工具</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/cheat-sh/</link>
			<pubDate>Tue, 03 Nov 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/cheat-sh/</guid>
			<description>大家好，我是站长 polarisxu。 在逛 GitHub Trending 时看到了这个项目：https://github.com/chubin/cheat.sh，因为之前我整理过一系列 cheatsheet，因此好奇的打开了这个项目。于是被它吸引了。。。 01 是什么 该项目的描述是： the only cheat sheet you need 简单一句话却很吸引人：这么强大，这一个 cheatsheet 就够了？ 因为在这一份清单中，包含了几乎所有开发者常见的东西，不</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>在逛 GitHub Trending 时看到了这个项目：<a href="https://github.com/chubin/cheat.sh">https://github.com/chubin/cheat.sh</a>，因为之前我整理过一系列 cheatsheet，因此好奇的打开了这个项目。于是被它吸引了。。。</p>
<h2 id="01-是什么">01 是什么</h2>
<p>该项目的描述是：</p>
<blockquote>
<p>the only cheat sheet you need</p>
</blockquote>
<p>简单一句话却很吸引人：这么强大，这一个 cheatsheet 就够了？</p>
<p>因为在这一份清单中，包含了几乎所有开发者常见的东西，不仅如此，它还提供了很好的获取接口，让你轻松的找到你想要的。它是一个统一访问世界上最好的、社区驱动的备忘单（cheat sheet）存储库。</p>
<h2 id="02-有什么">02 有什么</h2>
<p>让我们想象一下，有一种理想的备忘单。看起来像什么？它应该具有什么功能？</p>
<ul>
<li><strong>简洁</strong>—它只应包含你需要的东西，而不能包含其他任何东西；</li>
<li><strong>快速</strong>—想使用时就能立马使用；</li>
<li><strong>全面</strong>—它应该包含每个可能问题的答案；</li>
<li><strong>通用</strong>—它应该随处可用，无需任何准备；</li>
<li><strong>不打扰</strong>—它不应分散你的主要任务；</li>
<li><strong>辅导</strong>—它应该可以帮助你学习该主题；</li>
<li><strong>不起眼</strong>—完全可以忽略使用它；</li>
</ul>
<p>作者认为 cheat.sh 做到了。我也认为做到了。</p>
<p><strong>那它具体有哪些特性呢？</strong></p>
<ul>
<li>具有简单的 curl/browser 界面；</li>
<li>涵盖 56 种编程语言，若干 DBMS 和 1000 多种最重要的 UNIX/Linux 命令；</li>
<li>与 StackOverflow 一样，提供对世界上最好的社区驱动的备忘单存储库的访问；</li>
<li>随处可用，无需安装；</li>
<li>超快，通常会在 100 毫秒内返回答案；</li>
<li>有一个方便的命令行客户端 cht.sh，虽然不是必须的，但它非常有用且很有帮助；</li>
<li>可以直接从代码编辑器中使用，而无需打开浏览器并且不切换您的思维环境；</li>
<li>支持特殊的隐形模式，在这种模式下，无需触摸按键和发出声音即可完全隐身使用；</li>
</ul>
<h2 id="03-如何使用">03 如何使用</h2>
<p>使用 cheat.sh 有以下几种方式：（可以是 HTTP 或 HTTPS，也可以是 cheat.sh 或 cht.sh）</p>
<ul>
<li>在终端使用 curl 工具；</li>
<li>使用其他 HTTP/HTTPS 客户端；</li>
<li>浏览器访问 cheat.sh；</li>
<li>终端使用 cht.sh 客户端；</li>
<li>在你的编辑器中集成；</li>
</ul>
<p>一般建议通过 curl 工具、cht.sh 客户端或编辑器插件来使用。使用示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl cheat.sh/tar
$ curl cht.sh/go
$ curl https://cheat.sh/php
$ curl https://cht.sh/redis
</code></pre></div><p>上面例子中，tar、go、php、redis 等可以是 Linux 命令，也可以是语言的命令等。</p>
<p>如果你记不起来命令准确名称，则可以使用 〜KEYWORD 表示法进行搜索。例如，查看如何制作文件系统/卷/其他内容的快照：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl cht.sh/~snapshot
</code></pre></div><p>官方的一张图看看相关说明：</p>
<p><p class="md__image">
  <img src="../imgs/cheat01.png"
    alt=""  />
</p>
</p>
<p>关于选项（options），可以通过 <code>/:help</code> 查看。对于开发来说，经常会加上 Q 选项，比如上面命令加上 Q 选项后的结果：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl <span class="s2">&#34;http://cheat.sh/go/execute+external+program?Q&#34;</span>
cmd :<span class="o">=</span> exec.Command<span class="o">(</span><span class="s2">&#34;yourcommand&#34;</span>, <span class="s2">&#34;some&#34;</span>, <span class="s2">&#34;args&#34;</span><span class="o">)</span>
<span class="k">if</span> err :<span class="o">=</span> cmd.Run<span class="o">()</span><span class="p">;</span> err !<span class="o">=</span> nil <span class="o">{</span>
    fmt.Println<span class="o">(</span><span class="s2">&#34;Error: &#34;</span>, err<span class="o">)</span>
<span class="o">}</span>
</code></pre></div><p>关于更多使用在客户端工具 cht.sh 中介绍。</p>
<h2 id="04-客户端工具-chtsh">04 客户端工具 cht.sh</h2>
<p>cheat.sh 服务有自己的命令行客户端（cht.sh），与使用 curl 直接查询该服务相比，它具有几个有用的功能：</p>
<ul>
<li>特殊的 shell 模式，具有持久查询上下文和 readline 支持；</li>
<li>查询历史；</li>
<li>粘贴板整合；</li>
<li>shell 的 tab 完成支持（bash、zsh、fish）；</li>
<li>stealth 模式；</li>
</ul>
<h3 id="安装">安装</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">mkdir -p ~/bin/
curl https://cht.sh/:cht.sh &gt; ~/bin/cht.sh
chmod +x ~/bin/cht.sh
</code></pre></div><p>确保 cht.sh 在 PATH 中，方便使用。</p>
<p>shell 模式需要 rlwrap，这是 readline 的包装。Mac 下可以通过 brew install rlwrap 安装。</p>
<h3 id="使用">使用</h3>
<p>有了 cht.sh，之前 curl 的方式可以用更自然的方式。比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cht.sh go execute external program
</code></pre></div><p>个人更推荐采用交互式 shell 模式：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ cht.sh --shell <span class="o">[</span>LANG<span class="o">]</span>
</code></pre></div><p>其中 [LANG] 可以指定具体的编程语言，比如 go。</p>
<p>因此 cheat.sh 命令有两种上下文：特定语言和非特定语言（全局）。<code>:help</code> 在这两种上下文下显示的内容是不一样的。</p>
<ul>
<li>在特定语言下，有 hello、<code>:list</code> 和 <code>:learn</code>，其中 <code>:learn</code> 是该语言的一个简短教程；</li>
<li>通过 <code>/</code> 可以切换上下文。比如：/go  表示在 go 这个语言上下文查找；/tar 表示在全局上下文查找 tar 命令；</li>
<li>查找当前所在语言的内容，直接查询即可，比如当前如果是 Go 上下文，直接输入 int，可以查看 int 类型的信息；</li>
</ul>
<p>在交互式 shell 下通过 help 命令可以查看帮助：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">cht.sh&gt; <span class="nb">help</span>
<span class="nb">help</span>    - show this <span class="nb">help</span>
hush    - <span class="k">do</span> not show the <span class="s1">&#39;help&#39;</span> string at start anymore
<span class="nb">cd</span> LANG - change the language context
copy    - copy the last answer in the clipboard <span class="o">(</span>aliases: yank, y, c<span class="o">)</span>
ccopy   - copy the last answer w/o comments <span class="o">(</span>cut comments<span class="p">;</span> aliases: cc, Y, C<span class="o">)</span>
<span class="nb">exit</span>    - <span class="nb">exit</span> the cheat shell <span class="o">(</span>aliases: quit, ^D<span class="o">)</span>
id <span class="o">[</span>ID<span class="o">]</span> - set/show an unique session id <span class="o">(</span><span class="s2">&#34;reset&#34;</span> to reset, <span class="s2">&#34;remove&#34;</span> to remove<span class="o">)</span>
stealth - stealth mode <span class="o">(</span>automatic queries <span class="k">for</span> selected text<span class="o">)</span>
update  - self update <span class="o">(</span>only <span class="k">if</span> the scriptfile is writeable<span class="o">)</span>
version - show current cht.sh version
/:help  - service <span class="nb">help</span>
QUERY   - space separated query staring <span class="o">(</span>examples are below<span class="o">)</span>
              cht.sh&gt; python zip list
              cht.sh/python&gt; zip list
              cht.sh/go&gt; /python zip list
</code></pre></div><p>其中 cd 用来切换语言上下文；copy 和 ccopy 用来复制内容。</p>
<h3 id="定制">定制</h3>
<p>如果你想要定制 cht.sh，可以编辑文件：<code>~/.cht.sh/cht.sh.conf</code>。我觉得用默认即可。</p>
<h2 id="05-编辑器集成">05 编辑器集成</h2>
<p>这方面对 Vim 的支持是最好的。见下图：</p>
<p><p class="md__image">
  <img src="../imgs/cheat02.png"
    alt=""  />
</p>
</p>
<p>项目首页提供了这些编辑器对应的插件和配置、使用方法。请自行根据需要按照、配置。</p>
<h2 id="06-搜索">06 搜索</h2>
<p>cheat.sh 包含内容众多，方便的搜索是必不可少的。除了上文介绍的 ~KEYWORD 方式，还支持其他一些选项（辅助功能）。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">i   <span class="k">case</span> insensitive search
b   word boundaries
r   recursive search
</code></pre></div><p>比如：</p>
<pre><code>/~shot/bi
</code></pre><h2 id="07-实际用途">07 实际用途</h2>
<p>比如我想查询某们语言 MD5 怎么用？</p>
<p><strong>Go 语言</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">cht</span><span class="p">.</span><span class="nx">sh</span><span class="p">&gt;</span><span class="o">/</span><span class="k">go</span> <span class="nx">md5</span>

<span class="cm">/*
</span><span class="cm"> * cryptography - How to get a MD5 hash from a string in Golang ...
</span><span class="cm"> *
</span><span class="cm"> * From crypto/md5 doc (http:golang.org/pkg/crypto/md5/#New):
</span><span class="cm"> */</span>

<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;crypto/md5&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;io&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">md5</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="s">&#34;The fog is getting thicker!&#34;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%x&#34;</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// [Stephen Hsu] [so/q/2377881] [cc by-sa 3.0]
</span></code></pre></div><p><strong>PHP 语言</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-php" data-lang="php"><span class="nx">cht</span><span class="o">.</span><span class="nx">sh</span><span class="o">&gt;/</span><span class="nx">php</span> <span class="nx">md5</span>

<span class="cm">/*
</span><span class="cm"> * php - Using MD5 on login page
</span><span class="cm"> *
</span><span class="cm"> * Simply wrap $_POST[&#39;password&#39;] into md5() like so:
</span><span class="cm"> */</span>

<span class="nv">$mypassword</span> <span class="o">=</span> <span class="nx">md5</span> <span class="p">(</span><span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;password&#39;</span><span class="p">]);</span>
</code></pre></div><p><strong>Java 语言</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">cht</span><span class="o">.</span><span class="na">sh</span><span class="o">&gt;/</span><span class="n">java</span> <span class="n">md5</span>

<span class="cm">/*
</span><span class="cm"> * java - How can I generate an MD5 hash?
</span><span class="cm"> *
</span><span class="cm"> * The MessageDigest class can provide you with an instance of the MD5
</span><span class="cm"> * digest.
</span><span class="cm"> *
</span><span class="cm"> * When working with strings and the crypto classes be sure to always
</span><span class="cm"> * specify the encoding you want the byte representation in. If you just
</span><span class="cm"> * use string.getBytes() it will use the platform default. (Not all
</span><span class="cm"> * platforms use the same defaults)
</span><span class="cm"> */</span>

<span class="kn">import</span> <span class="nn">java.security.*</span><span class="o">;</span>

<span class="o">..</span>

<span class="kt">byte</span><span class="o">[]</span> <span class="n">bytesOfMessage</span> <span class="o">=</span> <span class="n">yourString</span><span class="o">.</span><span class="na">getBytes</span><span class="o">(</span><span class="s">&#34;UTF-8&#34;</span><span class="o">);</span>

<span class="n">MessageDigest</span> <span class="n">md</span> <span class="o">=</span> <span class="n">MessageDigest</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="s">&#34;MD5&#34;</span><span class="o">);</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">thedigest</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="na">digest</span><span class="o">(</span><span class="n">bytesOfMessage</span><span class="o">);</span>

<span class="o">/*</span>
 <span class="o">*</span> <span class="n">If</span> <span class="n">you</span> <span class="n">have</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span> <span class="n">take</span> <span class="n">a</span> <span class="n">look</span> <span class="n">at</span> <span class="n">the</span> <span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="kt">byte</span><span class="o">[])</span> <span class="n">method</span>
 <span class="o">*</span> <span class="n">which</span> <span class="n">can</span> <span class="n">be</span> <span class="n">called</span> <span class="n">repeatedly</span><span class="o">.</span> <span class="n">Then</span> <span class="n">call</span> <span class="o">.</span><span class="na">digest</span><span class="o">()</span> <span class="n">to</span> <span class="n">obtain</span> <span class="n">the</span>
 <span class="o">*</span> <span class="n">resulting</span> <span class="n">hash</span><span class="o">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="o">[</span><span class="n">koregan</span><span class="o">]</span> <span class="o">[</span><span class="n">so</span><span class="o">/</span><span class="n">q</span><span class="o">/</span><span class="n">415953</span><span class="o">]</span> <span class="o">[</span><span class="n">cc</span> <span class="n">by</span><span class="o">-</span><span class="n">sa</span> <span class="n">3</span><span class="o">.</span><span class="na">0</span><span class="o">]</span>
</code></pre></div><p>再比如你需要反转一个数组，不知道怎么写，可以找 cheat.sh 帮忙：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">cht</span><span class="p">.</span><span class="nx">sh</span><span class="p">&gt;</span> <span class="o">/</span><span class="k">go</span> <span class="nx">reverse</span> <span class="nx">list</span>

<span class="cm">/*
</span><span class="cm"> * How do I reverse an array in Go?
</span><span class="cm"> *
</span><span class="cm"> * Honestly this one is simple enough that I&#39;d just write it out like
</span><span class="cm"> * this:
</span><span class="cm"> */</span>

<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>

    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
        <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="08-数据来源">08 数据来源</h2>
<p>目前 cheat.sh 的数据来源如下：</p>
<p><p class="md__image">
  <img src="../imgs/cheat03.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/cheat04.png"
    alt=""  />
</p>
</p>
<p>你也可以为 cheat.sh 做贡献，输入 <code>:post</code> 看看。</p>
<h2 id="09-总结">09 总结</h2>
<p>这个项目在 GitHub 近 21k Star，觉得不错可以点个 Star，让更多人知晓这个优秀的项目。希望它能够为你的工作带来便利，通过查这个手册，能够提升你的效率，同时增强你的能力。</p>
]]></content>
		</item>
		
		<item>
			<title>提前试用将在 Go1.16 中发布的内嵌静态资源功能</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/go-embed-try/</link>
			<pubDate>Sun, 01 Nov 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/go-embed-try/</guid>
			<description>大家好，我是站长 polarisxu。 喜欢 Go 语言有很多理由，其中有一点“因为编译为一个二进制文件，直接运行，没有其他依赖，使得部署特别容易。”我想是很多人喜欢的。 然而一个项目，很可能会包含一些静态资源文件，这样一来，一个 Go 二进制文件就不能解决了，需要将静态资源文件一起带上。于是有了很多第三方解决方案，将静态资源文件“嵌入”最终的 Go 二进制文件中。最知名的应该是 go-bindata</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>喜欢 Go 语言有很多理由，其中有一点“因为编译为一个二进制文件，直接运行，没有其他依赖，使得部署特别容易。”我想是很多人喜欢的。</p>
<p>然而一个项目，很可能会包含一些静态资源文件，这样一来，一个 Go 二进制文件就不能解决了，需要将静态资源文件一起带上。于是有了很多第三方解决方案，将静态资源文件“嵌入”最终的 Go 二进制文件中。最知名的应该是 <a href="https://pkg.go.dev/github.com/jteeuwen/go-bindata" target="_blank" rel="noopener">go-bindata</a>
，此外还有很多其他的：</p>
<ul>
<li><a href="https://pkg.go.dev/github.com/alecthomas/gobundle" target="_blank" rel="noopener">github.com/alecthomas/gobundle</a>
</li>
<li><a href="https://pkg.go.dev/github.com/GeertJohan/go.rice" target="_blank" rel="noopener">github.com/GeertJohan/go.rice</a>
</li>
<li><a href="https://pkg.go.dev/github.com/go-playground/statics" target="_blank" rel="noopener">github.com/go-playground/statics</a>
</li>
<li><a href="https://pkg.go.dev/github.com/gobuffalo/packr" target="_blank" rel="noopener">github.com/gobuffalo/packr</a>
</li>
<li><a href="https://pkg.go.dev/github.com/knadh/stuffbin" target="_blank" rel="noopener">github.com/knadh/stuffbin</a>
</li>
<li><a href="https://pkg.go.dev/github.com/mjibson/esc" target="_blank" rel="noopener">github.com/mjibson/esc</a>
</li>
<li><a href="https://pkg.go.dev/github.com/omeid/go-resources" target="_blank" rel="noopener">github.com/omeid/go-resources</a>
</li>
<li><a href="https://pkg.go.dev/github.com/phogolabs/parcello" target="_blank" rel="noopener">github.com/phogolabs/parcello</a>
</li>
<li><a href="https://pkg.go.dev/github.com/pyros2097/go-embed" target="_blank" rel="noopener">github.com/pyros2097/go-embed</a>
</li>
<li><a href="https://pkg.go.dev/github.com/rakyll/statik" target="_blank" rel="noopener">github.com/rakyll/statik</a>
</li>
<li><a href="https://pkg.go.dev/github.com/shurcooL/vfsgen" target="_blank" rel="noopener">github.com/shurcooL/vfsgen</a>
</li>
<li><a href="https://pkg.go.dev/github.com/UnnoTed/fileb0x" target="_blank" rel="noopener">github.com/UnnoTed/fileb0x</a>
</li>
<li><a href="https://pkg.go.dev/github.com/wlbr/templify" target="_blank" rel="noopener">github.com/wlbr/templify</a>
</li>
<li><a href="https://pkg.go.dev/perkeep.org/pkg/fileembed" target="_blank" rel="noopener">perkeep.org/pkg/fileembed</a>
</li>
</ul>
<p>从这个列表足以看出需求的广泛性。于是官方决定提供实现，在 go 命令中实现该功能。因为在 Go 命令中添加对嵌入基本功能的直接支持将消除对某些工具的需求，至少可以简化其他工具的实现。</p>
<p>2020 年 10 月 30 日，Russ Cox 提交了最终的实现：<a href="https://github.com/golang/go/commit/25d28ec55aded46e0be9c2298f24287d296a9e47" target="_blank" rel="noopener">cmd/go: add //go:embed support</a>
，意味着你在 tip 版本可以试用该功能了。Go1.16 版本会包含该功能。欢迎大家试用，反馈建议。</p>
<h2 id="01-试用-go-embed">01 试用 go embed</h2>
<p>通过几个示例快速了解 go embed 的用法。</p>
<h3 id="例-1内嵌文件--web-应用">例 1：内嵌文件 — Web 应用</h3>
<p>基于 Echo 框架：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">_</span> <span class="s">&#34;embed&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/labstack/echo&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static/logo.png
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">content</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Blob</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;image/png&#34;</span><span class="p">,</span> <span class="nx">content</span><span class="p">)</span>
	<span class="p">})</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>目录结构如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">.
├── main.go
└── static
    └── logo.png
</code></pre></div><p>编译运行后，可以将二进制文件移到任何地方运行，浏览器访问 http://localhost:8989，能够正确显示 logo 图片表示成功了。</p>
<p>基于 Gin 框架，代码类似：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="nx">_</span> <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;net/http&#34;</span>

    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static/logo.png
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">content</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">router</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
    <span class="nx">router</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ctx</span><span class="p">.</span><span class="nf">Data</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;image/png&#34;</span><span class="p">,</span> <span class="nx">content</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">router</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>直接使用 net/http 库，代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="nx">_</span> <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static/logo.png
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">content</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;image/png&#34;</span><span class="p">)</span>
        <span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">content</span><span class="p">)</span>
    <span class="p">})</span>

    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h3 id="例-2内嵌文件--命令行应用">例 2：内嵌文件 — 命令行应用</h3>
<p>简单的 Hello World：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="nx">_</span> <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed message.txt
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">message</span> <span class="kt">string</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>其中 messaeg.txt 中的内容是 Hello World。目录结构如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">.
├── main.go
└── message.txt
</code></pre></div><p>编译后，可以将二进制移到任何地方，运行输出 Hello World（即 messaeg.txt 中的内容）。</p>
<h3 id="例-3内嵌目录---命令行应用">例 3：内嵌目录 - 命令行应用</h3>
<p>以下程序将 static 目录内嵌到二进制程序中，然后在当前目录创建 static 目录中的所有文件。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;embed&#34;</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;path&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">local</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fis</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">local</span><span class="p">.</span><span class="nf">ReadDir</span><span class="p">(</span><span class="s">&#34;static&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fi</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">fis</span> <span class="p">{</span>
		<span class="nx">in</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">local</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">&#34;static&#34;</span><span class="p">,</span> <span class="nx">fi</span><span class="p">.</span><span class="nf">Name</span><span class="p">()))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">out</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="s">&#34;embed-&#34;</span> <span class="o">+</span> <span class="nx">path</span><span class="p">.</span><span class="nf">Base</span><span class="p">(</span><span class="nx">fi</span><span class="p">.</span><span class="nf">Name</span><span class="p">()))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">out</span><span class="p">,</span> <span class="nx">in</span><span class="p">)</span>
		<span class="nx">out</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="nx">in</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;exported&#34;</span><span class="p">,</span> <span class="s">&#34;embed-&#34;</span><span class="o">+</span><span class="nx">path</span><span class="p">.</span><span class="nf">Base</span><span class="p">(</span><span class="nx">fi</span><span class="p">.</span><span class="nf">Name</span><span class="p">()))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>该示例的目录结构和例 1 一样。编译后，可以将二进制文件移到任何地方，运行后，会在当前目录输出以 embed- 开头的文件。</p>
<h3 id="例-4内嵌目录--web-应用">例 4：内嵌目录 — Web 应用</h3>
<p>基于 Echo 框架：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;net/http&#34;</span>

    <span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">local</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/*&#34;</span><span class="p">,</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FS</span><span class="p">(</span><span class="nx">local</span><span class="p">))))</span>
    <span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>同样，目录结构和 example1 一致。编译后运行，访问 http://localhost:8989，看到如下界面：</p>
<p><p class="md__image">
  <img src="../imgs/try-embed01.png"
    alt=""  />
</p>
</p>
<p>注意上面使用的是 <code>/*</code>，如果直接使用 <code>/</code>，点击链接会是 404。</p>
<p>换成 Gin，代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;net/http&#34;</span>

    <span class="s">&#34;github.com/gin-gonic/gin&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static/*
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">local</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">router</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">Default</span><span class="p">()</span>
    <span class="nx">router</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/*filepath&#34;</span><span class="p">,</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">WrapH</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FS</span><span class="p">(</span><span class="nx">local</span><span class="p">))))</span>

    <span class="nx">router</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果和 Echo 框架一样。同样要注意是 <code>/*filepath</code>，不能是 <code>/</code>。</p>
<p>换成标准库 net/http 试试？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;embed&#34;</span>
    <span class="s">&#34;log&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">local</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">http</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FS</span><span class="p">(</span><span class="nx">local</span><span class="p">)))</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8989&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>标准库中 <code>/</code> 会自动处理所有的请求。</p>
<h2 id="02-goembed-指令">02 //go:embed 指令</h2>
<p>之前第三方的现实，基本是基于 go generate，将静态资源文件生成 go 源文件，最后编译进二进制文件中。官方的实现，通过 <code>//go:embed</code> 指令，在编译时将静态资源嵌入二进制文件中。然后，Go 通过标准库，让用户能够访问这些内嵌的资源。因此，先介绍下 <code>//go:embed</code> 指令的用法。</p>
<h3 id="相关规则">相关规则</h3>
<p>在变量声明上方，通过 <code>//go:embed</code> 指令指定一个或多个符合 path.Match 模式的要嵌入的文件或目录。相关规则或使用注意如下：</p>
<p>1）跟其他指令一样，// 和 go:embed 之间不能有空格。（不会报错，但该指令会被编译器忽略）</p>
<p>2）指令和变量声明之间可以有空行或普通注释，不能有其他语句；</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:embed message.txt
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">message</span> <span class="kt">string</span>
</code></pre></div><p>以上代码是允许的，不过建议紧挨着，而且建议变量声明和指令之间也别加注释，注释应该放在指令上方。</p>
<p>3）变量的类型只能是 string、[]byte 或 embed.FS，即使是这三个类型的别名也不行；</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">mystring</span> <span class="p">=</span> <span class="kt">string</span>

<span class="c1">//go:embed hello.txt
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">message</span> <span class="nx">mystring</span>	<span class="c1">// 编译不通过：go:embed cannot apply to var of type mystring
</span></code></pre></div><p>4）允许有多个 <code>//go:embed</code> 指令。多个文件或目录可以通过空格分隔，也可以写多个指令。比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:embed image template
</span><span class="c1">//go:embed html/index.html
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">content</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>
</code></pre></div><p>5）文件或目录使用的是相对路径，相对于指令所在 Go 源文件所在的目录，路径分隔符永远使用 <code>/</code>；当文件或目录名包含空格时，可以使用双引号或反引号括起来。</p>
<p>6）对于目录，会以该目录为根，递归的方式嵌入所有文件和子目录；</p>
<p>7）变量的声明可以是导出或非导出的；可以是全局也可以在函数内部；但只能是声明，不能给初始化值；</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//go:embed message.txt
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">message</span> <span class="kt">string</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>	<span class="c1">// 编译不通过：go:embed cannot apply to var with initializer
</span></code></pre></div><p>8）只能内嵌模块内的文件，比如 <code>.git/*</code> 或软链接文件无法匹配；空目录会被忽略；</p>
<p>9）模式不能包含 <code>.</code> 或 <code>..</code>，也不能以 <code>/</code> 开始，如果要匹配当前目录所有文件，应该使用 <code>*</code> 而不是 <code>.</code>；</p>
<h2 id="03-标准库">03 标准库</h2>
<p>和 embed 相关的标准库有 5 个，其中 2 个是新增的：embed 和 io/fs；net/http，text/template 和 html/template 包依赖 io/fs 包，而 embed.FS 类型实现了 io/fs 包的 FS 接口，因此这 3 个包可以使用 embed.FS。（Go1.16 发布时可能还会增加其他包或修改一些包的内容）</p>
<h3 id="iofs-包">io/fs 包</h3>
<p>该包定义了文件系统的基本接口。文件系统既可以由主机操作系统提供，也可以由其他包提供。本文我们主要介绍和 embed 密切相关的内容。</p>
<p>先看 <strong>FS 接口</strong>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FS</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Open opens the named file.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// When Open returns an error, it should be of type *PathError
</span><span class="c1"></span>    <span class="c1">// with the Op field set to &#34;open&#34;, the Path field set to name,
</span><span class="c1"></span>    <span class="c1">// and the Err field describing the problem.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Open should reject attempts to open names that do not satisfy
</span><span class="c1"></span>    <span class="c1">// ValidPath(name), returning a *PathError with Err set to
</span><span class="c1"></span>    <span class="c1">// ErrInvalid or ErrNotExist.
</span><span class="c1"></span>    <span class="nf">Open</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>FS 提供对分层文件系统的访问。像操作系统使用的文件系统就是一种分层文件系统。</p>
<p>FS 接口是文件系统所需的最小实现。文件系统可以实现其他接口，比如 fs.ReadFileFS，以提供其他或优化的功能。</p>
<p><strong>File 接口</strong>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">File</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Stat</span><span class="p">()</span> <span class="p">(</span><span class="nx">FileInfo</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nf">Read</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>该接口定义对单个文件的访问。这是文件的最小实现要求。文件可以实现其他接口，例如 fs.ReadDirFile，io.ReaderAt 或 io.Seeker，以提供其他或优化的功能。</p>
<p>因为有了 FS、File 等的接口抽象，之前在 os 包中的一些内容移到了 io/fs 包中，比如 fs.FileInfo 接口、fs.FileMode 类型，os 中原有的定义改成了它们的别名。</p>
<p><strong>DirEntry 接口</strong>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">DirEntry</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="c1">// Name returns the name of the file (or subdirectory) described by the entry.
</span><span class="c1"></span>    <span class="c1">// This name is only the final element of the path (the base name), not the entire path.
</span><span class="c1"></span>    <span class="c1">// For example, Name would return &#34;hello.go&#34; not &#34;/home/gopher/hello.go&#34;.
</span><span class="c1"></span>    <span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span>

    <span class="c1">// IsDir reports whether the entry describes a directory.
</span><span class="c1"></span>    <span class="nf">IsDir</span><span class="p">()</span> <span class="kt">bool</span>

    <span class="c1">// Type returns the type bits for the entry.
</span><span class="c1"></span>    <span class="c1">// The type bits are a subset of the usual FileMode bits, those returned by the FileMode.Type method.
</span><span class="c1"></span>    <span class="nf">Type</span><span class="p">()</span> <span class="nx">FileMode</span>

    <span class="c1">// Info returns the FileInfo for the file or subdirectory described by the entry.
</span><span class="c1"></span>    <span class="c1">// The returned FileInfo may be from the time of the original directory read
</span><span class="c1"></span>    <span class="c1">// or from the time of the call to Info. If the file has been removed or renamed
</span><span class="c1"></span>    <span class="c1">// since the directory read, Info may return an error satisfying errors.Is(err, ErrNotExist).
</span><span class="c1"></span>    <span class="c1">// If the entry denotes a symbolic link, Info reports the information about the link itself,
</span><span class="c1"></span>    <span class="c1">// not the link&#39;s target.
</span><span class="c1"></span>    <span class="nf">Info</span><span class="p">()</span> <span class="p">(</span><span class="nx">FileInfo</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>DirEntry 是从目录读取的条目（使用 ReadDir 函数或 ReadDirFile 的 ReadDir方法）。比如下面 embed 包中的 embed.FS 有一个方法 ReadDir 就返回了 DirEntry 类型的切片。这样可以遍历 embed.FS 这个文件系统。</p>
<h3 id="embed-包">embed 包</h3>
<p>资源文件嵌入 Go 二进制程序后，我们通过 embed 包可以访问它们。</p>
<h4 id="string-和-byte">string 和 []byte</h4>
<p>当指令用于 string 或 []byte 时，只能有一个模式，匹配一个文件，字符串或 []byte 的内容是该文件的内容。这时虽然不需要使用 embed 包，但必须导入，因此采用空导入：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">_</span> <span class="s">&#34;embed&#34;</span> 
</code></pre></div><h4 id="fsfile-system">FS（File System）</h4>
<p>一般内嵌单个文件，采用 string 或 []byte 是最好的选择；但内嵌很多文件或目录树，应该使用 embed.FS 类型，这也是该包目前唯一的类型。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FS</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// The compiler knows the layout of this struct.
</span><span class="c1"></span>	<span class="c1">// See cmd/compile/internal/gc&#39;s initEmbed.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The files list is sorted by name but not by simple string comparison.
</span><span class="c1"></span>	<span class="c1">// Instead, each file&#39;s name takes the form &#34;dir/elem&#34; or &#34;dir/elem/&#34;.
</span><span class="c1"></span>	<span class="c1">// The optional trailing slash indicates that the file is itself a directory.
</span><span class="c1"></span>	<span class="c1">// The files list is sorted first by dir (if dir is missing, it is taken to be &#34;.&#34;)
</span><span class="c1"></span>	<span class="c1">// and then by base, so this list of files:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//	p
</span><span class="c1"></span>	<span class="c1">//	q/
</span><span class="c1"></span>	<span class="c1">//	q/r
</span><span class="c1"></span>	<span class="c1">//	q/s/
</span><span class="c1"></span>	<span class="c1">//	q/s/t
</span><span class="c1"></span>	<span class="c1">//	q/s/u
</span><span class="c1"></span>	<span class="c1">//	q/v
</span><span class="c1"></span>	<span class="c1">//	w
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// is actually sorted as:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">//	p       # dir=.    elem=p
</span><span class="c1"></span>	<span class="c1">//	q/      # dir=.    elem=q
</span><span class="c1"></span>	<span class="c1">//	w/      # dir=.    elem=w
</span><span class="c1"></span>	<span class="c1">//	q/r     # dir=q    elem=r
</span><span class="c1"></span>	<span class="c1">//	q/s/    # dir=q    elem=s
</span><span class="c1"></span>	<span class="c1">//	q/v     # dir=q    elem=v
</span><span class="c1"></span>	<span class="c1">//	q/s/t   # dir=q/s  elem=t
</span><span class="c1"></span>	<span class="c1">//	q/s/u   # dir=q/s  elem=u
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This order brings directory contents together in contiguous sections
</span><span class="c1"></span>	<span class="c1">// of the list, allowing a directory read to use binary search to find
</span><span class="c1"></span>	<span class="c1">// the relevant sequence of entries.
</span><span class="c1"></span>	<span class="nx">files</span> <span class="o">*</span><span class="p">[]</span><span class="nx">file</span>
<span class="p">}</span>
</code></pre></div><p>FS 是文件的只读集合，通常使用 <code>//go:embed</code> 指令进行初始化。如果不使用 <code>//go:embed</code> 指令声明 FS，则它是一个空文件系统。</p>
<p>FS 是只读值，因此可以安全地同时使用多个 goroutine，也可以将 FS 类型的值相互赋值。</p>
<p>FS 实现了 fs.FS，因此它可以与任何使用文件系统接口（fs.FS）的包一起使用，包括 net/http，text/template 和 html/template。</p>
<p>此外，FS 还是实现了 fs.ReadDirFS 和 fs.ReadFileFS 这两个接口。</p>
<p>所以，FS 实现了 3 个接口，一共 3 个方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">FS</span><span class="p">)</span> <span class="nf">Open</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">FS</span><span class="p">)</span> <span class="nf">ReadDir</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="nx">fs</span><span class="p">.</span><span class="nx">DirEntry</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">FS</span><span class="p">)</span> <span class="nf">ReadFile</span><span class="p">(</span><span class="nx">name</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>关于它们的用法，在上文例子中有所涉及。</p>
<h2 id="04-实际项目使用">04 实际项目使用</h2>
<p>本节模拟一个实际项目，看怎么使用 embed，主要两个方面：嵌入静态资源；嵌入模板文件。本节示例代码地址：<a href="https://github.com/polaris1119/embed-example">https://github.com/polaris1119/embed-example</a>，采用 Echo 框架。</p>
<p>因为是演示 embed 的实际用法，因此项目做了尽可能简化，目录结构如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">.
├── LICENSE
├── README.md
├── cmd
│   └── blog
│       └── main.go
├── embed.go
├── go.mod
├── go.sum
├── static
│   └── css
│       └── style.min.css
└── template
    └── index.html
</code></pre></div><p>做个说明：</p>
<ul>
<li>因为 <code>go:embed</code> 指令只能从相对源码所在目录的位置引用资源，这里特意采用了 main.go 放在 cmd/blog 中这种方式，看这样如何处理资源嵌入；</li>
<li>static 和 template 目录是需要嵌入的目录；</li>
</ul>
<p>因为 main.go 和 static/template 不在同一个目录，因此 main.go 中没法直接使用 <code>go:embed</code> 指令。我们在 static 的同级目录下创建一个文件：embed.go，专门用来写该指令。代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">embedexample</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;embed&#34;</span>
<span class="p">)</span>

<span class="c1">//go:embed static
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">StaticAsset</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>

<span class="c1">//go:embed template
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">TemplateFS</span> <span class="nx">embed</span><span class="p">.</span><span class="nx">FS</span>
</code></pre></div><p>这样，项目中所有其他的地方都可以通过引用该包来使用内嵌的资源。</p>
<p>接着看 main.go 的代码如何使用它的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;html/template&#34;</span>
	<span class="s">&#34;io&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
	<span class="s">&#34;github.com/labstack/echo/v4/middleware&#34;</span>
	<span class="s">&#34;github.com/polaris1119/embedexample&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Recover</span><span class="p">())</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Logger</span><span class="p">())</span>

	<span class="nx">tpl</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Template</span><span class="p">{</span>
		<span class="nx">templates</span><span class="p">:</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;index&#34;</span><span class="p">).</span><span class="nf">ParseFS</span><span class="p">(</span><span class="nx">embedexample</span><span class="p">.</span><span class="nx">TemplateFS</span><span class="p">,</span> <span class="s">&#34;template/*.html&#34;</span><span class="p">)),</span>
	<span class="p">}</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Renderer</span> <span class="p">=</span> <span class="nx">tpl</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/static/*&#34;</span><span class="p">,</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FS</span><span class="p">(</span><span class="nx">embedexample</span><span class="p">.</span><span class="nx">StaticAsset</span><span class="p">))))</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;index.html&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Template</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">templates</span> <span class="o">*</span><span class="nx">template</span><span class="p">.</span><span class="nx">Template</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">templates</span><span class="p">.</span><span class="nf">ExecuteTemplate</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>模板的引用：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tpl</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Template</span><span class="p">{</span>
  <span class="nx">templates</span><span class="p">:</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;index&#34;</span><span class="p">).</span><span class="nf">ParseFS</span><span class="p">(</span><span class="nx">embedexample</span><span class="p">.</span><span class="nx">TemplateFS</span><span class="p">,</span> <span class="s">&#34;template/*.html&#34;</span><span class="p">)),</span>
<span class="p">}</span>
</code></pre></div><p>通过 ParseFS 方法来实现，支持 path.Match 格式。</p>
<p>而静态资源这样引用：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/static/*&#34;</span><span class="p">,</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">WrapHandler</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FileServer</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">FS</span><span class="p">(</span><span class="nx">embedexample</span><span class="p">.</span><span class="nx">StaticAsset</span><span class="p">))))</span>
</code></pre></div><p>这样，在模板文件 index.html 中就可以访问到样式文件了：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/static/css/style.min.css&#34;</span><span class="p">&gt;</span>
</code></pre></div><p>可以将编译后的二进制文件移到任何地方，然后运行，访问 http://localhost:2020 看到如下界面表示成功了。</p>
<p><p class="md__image">
  <img src="../imgs/try-embed02.png"
    alt=""  />
</p>
</p>
<h2 id="05-总结">05 总结</h2>
<p>本文通过几个例子快速了解官方内嵌静态资源的用法，然后讲解一些关键的标准库，最后是一个实际项目中使用的例子。</p>
<p>纵观官方的实现，使用起来很方便，通过一个 <code>go:embed</code> 指令，让很多细节都不需要关注。当然，如果你对它的实现感兴趣，可以阅读设计提案和源码。</p>
<h2 id="06-参考资料">06 参考资料</h2>
<ol>
<li>Embed 设计提案：<a href="https://github.com/golang/proposal/blob/master/design/draft-embed.md">https://github.com/golang/proposal/blob/master/design/draft-embed.md</a></li>
<li>示例参考：<a href="https://github.com/mattn/go-embed-example">https://github.com/mattn/go-embed-example</a></li>
<li>tip 相关文档：<a href="https://tip.golang.org">https://tip.golang.org</a></li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>这个调查显示 Go 竟然是 2020 年最受欢迎的编程语言</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/hackerearth-developer-survey/</link>
			<pubDate>Fri, 30 Oct 2020 15:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/hackerearth-developer-survey/</guid>
			<description>大家好，我是站长 polarisxu。 今天看到一个 2020 年开发者调查报告，看到了 Go 的前景，忍不住想跟大家分享一下。 01 这份调查报告来自 HackerEarth 。简单介绍下它。 HackerEarth 的口号是：远程雇用最优秀的技术人才。拥有 400 万+ 开发人员（注册用户），上千家企业信赖，他们帮助公司准确评估，面试和雇用顶尖技术人才。 他们提供编程练习、黑客挑战，号称能够进行准确的编码评估并远程聘用最好的技术人才。根据</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>今天看到一个 2020 年开发者调查报告，看到了 Go 的前景，忍不住想跟大家分享一下。</p>
<h2 id="01">01</h2>
<p>这份调查报告来自 <a href="https://www.hackerearth.com/" target="_blank" rel="noopener">HackerEarth</a>
。简单介绍下它。</p>
<p>HackerEarth 的口号是：远程雇用最优秀的技术人才。拥有 400 万+ 开发人员（注册用户），上千家企业信赖，他们帮助公司准确评估，面试和雇用顶尖技术人才。</p>
<p>他们提供编程练习、黑客挑战，号称能够进行准确的编码评估并远程聘用最好的技术人才。根据官网介绍，创始人是大学时候的两个朋友。</p>
<h2 id="02">02</h2>
<p>为什么要做开发者调查？HackerEarth 是这么认为的：</p>
<p>过去十年来技术的飞速发展改变了一切。它改变了我们的生活方式，工作方式以及彼此之间的互动方式—实际上，很难找到没有被技术改变的事物。</p>
<p>然而，全球的组织都感觉到技术人才短缺。但是这种短缺可能比您预期的还要严重。根据最近的一项调查，今天的技术人才短缺是自 2008 年以来的最高水平。因此，招聘人员和招聘经理必须了解开发人员的状况并了解当今技术人员的心态，这样才能更好地满足开发人员的要求、需求。</p>
<p>组织要想更好地招聘，需要做的关键改变之一就是将重点从传统的招聘方法转移到基于技能的招聘过程。如果我们超越目前对简历或学位的关注，将所有中学后课程都包括在内，那么将会出现更多的选择。基于技能的招聘实践可以帮助您降低招聘成本和雇用时间，提高多样性，更快地填补空缺职位，并在紧张的劳动力市场中找到组织所需的合适技术人才。</p>
<p>在 HackerEarth，我们拥有 400 万强大的开发者社区，我们的使命是为他们提供合适的机会。为继续支持我们的使命，我们很高兴为您带来 2020 HackerEarth 开发人员调查。 HackerEarth 有史以来第一次分享了对来自 76 个国家/地区的 16,000 多名开发人员（其中女性占受访者的 20％ 以上）的调查所收集的反馈。</p>
<p>我们认为，调查中提供的数据和见解将帮助招聘者更好地了解开发人员生态系统，采用基于技能的招聘方法。此外，这项调查将为开发人员提供一个机会，使他们能够了解当今市场的情况，了解趋势以及如何提高自己的技能。</p>
<p>希望这份调查能够对你的技术招聘有帮助，对你的职业发展能有一点帮助。</p>
<h2 id="03">03</h2>
<p>调查结果的一些关键结论。</p>
<h3 id="到了-2020-年数据科学仍然占据统治地位">到了 2020 年，数据科学仍然占据统治地位</h3>
<p>数据科学无止境！从学生开发人员（63％）到在职专业人员（61％），每个人都想占有一席之地。学生开发人员感兴趣的其他领域包括网络安全和物联网，而在职专业人员对物联网和区块链感兴趣。</p>
<p><p class="md__image">
  <img src="../imgs/hackerearth-survey01.png"
    alt=""  />
</p>
</p>
<h3 id="go-是今年最受欢迎的编程语言">Go 是今年最受欢迎的编程语言</h3>
<p>在学生（29％）和经验丰富的开发人员（32％）中，Go 已成为最受欢迎的编程语言的明显赢家。</p>
<p><p class="md__image">
  <img src="../imgs/hackerearth-survey02.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/hackerearth-survey03.png"
    alt=""  />
</p>
</p>
<h3 id="开发人员在全栈开发方面经验最丰富而在机器学习方面经验最少">开发人员在全栈开发方面经验最丰富，而在机器学习方面经验最少</h3>
<p>大多数开发人员（无论是初学者还是经验丰富的人员）都具有全栈开发以及前端和后端开发的专业知识。</p>
<p>尽管大多数开发人员都表示希望从事数据科学项目，但在机器学习方面经验不足。</p>
<p>可见机器学习方面还有很大的潜力。</p>
<p><p class="md__image">
  <img src="../imgs/hackerearth-survey04.png"
    alt=""  />
</p>
</p>
<h3 id="您要让开发人员挂了吗">您要让开发人员挂了吗？</h3>
<p>技术面试可能会让人感到压力，招聘人员有责任使求职者的面试过程变得更加轻松。可悲的是，大多数开发人员在面试后都没有收到建设性的反馈。</p>
<p>使他们对技术招聘过程感到不满意的其他原因包括：面试次数过多（14％），误导性的职位描述（14％），面试之间的等待时间（12％）和缺乏相关的技术问题（10％）。（不能同意更多，很多企业面试完全不考虑候选人的面试体验）</p>
<h3 id="你对开会怎么看">你对开会怎么看？</h3>
<p>当问及要实现 100％ 的工作效率需要什么时，70％的开发人员选择了更少的会议。</p>
<p>此外，大多数开发人员还选择了多显示器（61％），无杂物的工作空间（59％）以及戴耳机时不打扰的方式（59％）。</p>
<h3 id="开发人员的幸福感与工作时间不成比例">开发人员的幸福感与工作时间不成比例</h3>
<p>所有的工作，没有乐趣，会削弱开发人员的幸福感吗？我们认为不是！在接受调查的所有开发人员中，有 70％ 对当前工作不满意的开发人员每周工作 40 至 50 个小时。大家还是希望能够按时上下班~</p>
<p>考虑到大多数员工每周工作 40 小时是标准的工作，因此可以肯定地说，开发人员正在寻找有意义的工作，而坐在办公桌前并不能增加他们的幸福感。</p>
<p>这一点国内似乎谈不上？</p>
<p><p class="md__image">
  <img src="../imgs/hackerearth-survey05.png"
    alt=""  />
</p>
</p>
<p>其他更多内容，包括程序员业余都喜欢做什么？喜欢从哪获取知识等，可以访问这里查看：<a href="https://www.hackerearth.com/recruit/developer-survey/">https://www.hackerearth.com/recruit/developer-survey/</a>。</p>
<h2 id="04">04</h2>
<p>虽然这份报告不能完全反馈出国内的情况，但有一点，那就是 Go 在国外也收到越来越多的关注，很多人都希望学习 Go 语言。是的，你别犹豫了~</p>
]]></content>
		</item>
		
		<item>
			<title>AI 和 数据科学领域，Go 语言可能很快会取代 Python。最后的原因有点迷</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/golang-ai-programming-language/</link>
			<pubDate>Thu, 29 Oct 2020 21:40:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/golang-ai-programming-language/</guid>
			<description>30 年前，Python 首次出现。但是花了 20 年时间才能获得开发人员的赏识。快进到 2019 年，它成为开发人员中第二受欢迎的语言。（来自 Stackoverflow 开发人员 2019 调查结果 ） 过去，尤其是在过去的 5 年中，它的增长是巨大的。Python 成为机器学习和数据科学开发人员的首选语言。 在接下来的几年中，Python 在这些领域的主导地位无疑会持续。但是与更新的语言相比，它具有一些严重的缺点。对于 21 实际</description>
			<content type="html"><![CDATA[<p>30 年前，Python 首次出现。但是花了 20 年时间才能获得开发人员的赏识。快进到 2019 年，它成为开发人员中第二受欢迎的语言。（来自 <a href="https://insights.stackoverflow.com/survey/2019#most-loved-dreaded-and-wanted" target="_blank" rel="noopener">Stackoverflow 开发人员 2019 调查结果</a>
）</p>
<p>过去，尤其是在过去的 5 年中，它的增长是巨大的。Python 成为机器学习和数据科学开发人员的首选语言。</p>
<p>在接下来的几年中，Python 在这些领域的主导地位无疑会持续。但是与更新的语言相比，它具有一些严重的缺点。对于 21 实际 20 年代的开发者来说，这可能是一个障碍。</p>
<p>现在是检查 Python 问题并将其替换为更好的替代方法的正确时机。就 AI 开发和数据科学而言，我们的下一个入门语言可能是 Golang。</p>
<h2 id="python-受欢迎的原因">Python 受欢迎的原因</h2>
<p>Python 受欢迎的主要原因是：它易于学习。与其他语言相比，它的语法很简单，任何人都可以在几小时或几天内学习 Python 的基础知识。</p>
<p>即使在学习了其他语言（例如 C++ 或 Java）之后，开发人员通常还是更喜欢使用 Python。那是因为有一个 Python 库，几乎可以满足所有人的要求。</p>
<p>库和简单的语法使使用 Python 开发软件既简单又高效。这些优势使 Python 成为了初学者的语言。</p>
<h2 id="python-问题">Python 问题</h2>
<h3 id="速度">速度</h3>
<p>Python 是一种解释型语言，这会引起 Python 的最大问题：执行缓慢。与其他编译语言（例如 C++ 和 Go）相比，Python 的执行速度很慢，非常慢。</p>
<p>Python 是一种动态类型的语言。在运行期间会自动分配变量的数据类型。这使执行速度大大降低。</p>
<h3 id="使用-cc">使用 C/C++</h3>
<p>为了克服 Python 运行慢的缺点，Tensorflow，Numpy 和 Pandas 之类的库部分用 C 或 C++ 编写。它们有助于显著提高执行速度。</p>
<p>基本上，Python 需要其他语言的帮助才能克服其问题。</p>
<h3 id="全局解释器锁global-interpreter-lock">全局解释器锁（Global Interpreter Lock）</h3>
<p>Python 的<a href="https://wiki.python.org/moin/GlobalInterpreterLock" target="_blank" rel="noopener">全局解释器锁</a>
（GIL）一次只能执行一个线程，同时提高了单线程性能。Python 的多线程并没有真正让多个线程同时运行。</p>
<p>实际上，Python 无法执行真正的多线程。</p>
<p>（注意：Python 的非 CPython 实现（例如 Jython 和 IronPython 没有 GIL））</p>
<h2 id="为什么要使用-go-语言">为什么要使用 Go 语言？</h2>
<blockquote>
<p>Go 是一种开放源代码编程语言，可轻松构建，简单，可靠和高效。</p>
</blockquote>
<p>“ Go” 在 10 年前首次亮相。它是 Google 开发的通用性编程语言。</p>
<p>与 Python 和其他编程语言相比，它具有多个优势，这就是我们感兴趣的原因。</p>
<h3 id="快速">快速</h3>
<p>Go 是静态类型化和编译的语言。这意味着执行速度将比 Python 快几倍。与 Python 不同，Go 不需要其他语言的帮助就可以更快。</p>
<p>这是 Go 和 Python 之间的一个<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/go-python3.html" target="_blank" rel="noopener">小型基准测试游戏比较</a>
。Go 几乎与 C++ 和 Java 一样快。而且，Go 的代码编译速度比 C/C++ 和 Java 快得多。</p>
<h3 id="简单易学">简单易学</h3>
<p>Go 的语法很简单，类似于 C。它是一种易于学习的编程语言，特别是已经了解 C 或 Java 语言的基础知识。</p>
<p>要了解 Go 的基础知识，请访问 <a href="http://tour.studygolang.com/welcome/1" target="_blank" rel="noopener">Go 指南</a>
 进行交互式之旅或访问<a href="https://docs.studygolang.com/doc/" target="_blank" rel="noopener">官方文档</a>
。</p>
<h3 id="越来越受欢迎">越来越受欢迎</h3>
<p>根据此次 Hackearth 对来自 76 个国家/地区的 16,000 多名开发人员的<a href="https://www.hackerearth.com/recruit/developer-survey/" target="_blank" rel="noopener">调查</a>
，Go 是 2020 年最受欢迎的编程语言。</p>
<p>32％ 的经验丰富的开发人员和 29％ 的学生说他们想学习 Go 不足为奇。</p>
<p><p class="md__image">
  <img src="../imgs/go-for-ai-ds.png"
    alt=""  />
</p>
</p>
<h3 id="并发">并发</h3>
<p>并发是 Go 的主要优势之一。Go 具有 <a href="http://tour.studygolang.com/concurrency/1" target="_blank" rel="noopener">Goroutines</a>
 以实现并发。Goroutines 是可以同时独立运行的函数。</p>
<p>Goroutine 重量轻，仅占用 2KB（依赖于不同实现，目前 Go1.15 是 2KB） 的内存。由于 Goroutine 轻巧，因此可以同时运行成千上万个。</p>
<p>Goroutine 还有很多其他优点，比如：</p>
<ul>
<li>Goroutine 具有可增长的分段堆栈。这意味着它们仅在需要时才使用更多的内存。</li>
<li>Goroutine 具有比线程更快的启动时间。</li>
<li>Goroutine 带有内置原语，以在它们自己（通道）之间安全地通信。</li>
<li>使用 Goroutines 可以避免共享数据结构时不得不使用互斥锁。</li>
<li>此外，goroutine 和 OS 线程没有 1:1 映射。一个 goroutine 可以在多个线程上运行。 Goroutines 被多路复用到少量的 OS 线程中。</li>
</ul>
<p>参考文章：<a href="https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65" target="_blank" rel="noopener">为什么要学习 Go？</a>
。</p>
<h2 id="是什么使-go-适用于-ai-研究">是什么使 Go 适用于 AI 研究</h2>
<p>将 Go 专门用于 AI 研究或数据科学并没有什么特别的。为什么应将 Go 用于 AI 和数据科学？我会告诉你的&hellip;但是等一下。</p>
<p>30 年前，尚未开发 Python 来构建机器学习或深度学习算法或进行数据可视化。</p>
<p>之所以是今天，是因为开发人员和学生们喜欢用 Python 进行代码编写，并且支持<em>开发该开发人员意图</em>的语言。</p>
<p>Go 旨在提高程序员的生产力。与 Python 相比，它具有多个优点。它很可能会在未来几年中成功取代 Python，成为最受欢迎的语言。</p>
<p>因此，它可以归结为 1 行：</p>
<p><strong>Go 可以支持 “21 世纪 20 年代的开发人员”发展他们的思想，这比任何其他语言都要好得多。</strong></p>
<blockquote>
<p>原文链接：<a href="https://towardsdatascience.com/golang-ai-programming-language-for-the-20s-71890baa8c47">https://towardsdatascience.com/golang-ai-programming-language-for-the-20s-71890baa8c47</a></p>
<p>本文作者：Dasaradh Saran</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>闲聊昨晚极客时间的直播</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/talk-geek-time-live/</link>
			<pubDate>Mon, 26 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/talk-geek-time-live/</guid>
			<description>昨天晚上（10 月 25 日）极客时间进行了一场直播，主题是：《未来 5 年将是 Go 语言的天下》。 客观说，这个主题还是挺唬人的，而直播的内容跟这个主题关系不大。有三个嘉宾，只有左耳朵耗子谈了 Go 的未来，他的判断，Go 会成为主流，只会 PHP 肯定行不通。 在提问环节，有人问到耗子哥关于 Python 的看法，他直言：Python 会成为新手语言。不管你认不认同，耗子哥的一些观点还是有一定道理的。 耗子</description>
			<content type="html"><![CDATA[<p>昨天晚上（10 月 25 日）极客时间进行了一场直播，主题是：《未来 5 年将是 Go 语言的天下》。</p>
<p>客观说，这个主题还是挺唬人的，而直播的内容跟这个主题关系不大。有三个嘉宾，只有左耳朵耗子谈了 Go 的未来，他的判断，Go 会成为主流，只会 PHP 肯定行不通。</p>
<p>在提问环节，有人问到耗子哥关于 Python 的看法，他直言：Python 会成为新手语言。不管你认不认同，耗子哥的一些观点还是有一定道理的。</p>
<p>耗子哥的部分，我只听了结尾一点。另外两位的分享，我都听完了。简单聊聊。</p>
<h2 id="01-go-在字节跳动的地位">01 Go 在字节跳动的地位</h2>
<p>秦岩老师 PPT 第一页：</p>
<p><p class="md__image">
  <img src="../imgs/geektime01.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>提到的文章地址：<a href="https://www.infoq.cn/article/fEa7CHf9MOohbxbTYReS">https://www.infoq.cn/article/fEa7CHf9MOohbxbTYReS</a></p>
</blockquote>
<p>据我了解，字节当前后端服务超过 80% 的流量是跑在 Go 构建的服务上。高峰 QPS 超过 700 万，日处理请求量超过3000 亿，是业内最大规模的 Go 应用。</p>
<p>对于 Go 爱好者来说，如果能够进入字节跳动，在项目中进行历练，自己上进，相信 Go 水平会有一个质的提升；而应届生，我个人也强烈建议努力朝着进入字节跳动努力。</p>
<p><p class="md__image">
  <img src="../imgs/geektime02.png"
    alt=""  />
</p>
</p>
<p>如上图，Go 在这样量级的公司占据第一使用率，无论从哪方面讲，对 Go 来说都是巨大的成功，也证明了 Go 的可靠性。</p>
<h2 id="02-直播的故障">02 直播的故障</h2>
<p>抖音的老师刚开个头，突然直播故障了，持续了几分钟。</p>
<p>大家的吐槽来了：</p>
<p><p class="md__image">
  <img src="../imgs/geektime03.png"
    alt=""  />
</p>
</p>
<p><p class="md__image">
  <img src="../imgs/geektime04.png"
    alt=""  />
</p>
</p>
<p>秦岩老师是负责抖音、直播稳定性的，他一来不稳定了？！</p>
<p>对于这个突发的故障，不用太较真，各种系统应该常遇到。正式因为这样那样的故障，催生出各种应对办法，各种高可用、稳定性架构。</p>
<p>对此，我想说的是，如果你一直在一个小公司，没有大流量，很多问题你是没法遇到的，这些问题只学理论是不够的。你写的代码，你的架构，可能在你的公司运行的很好，但只要流量一大，他们可能就崩溃了。一定阶段，技术的提升，需要环境、需要大项目、大流量的历练。又回到那句话：趁年轻，能进大厂，一定要到大厂去历练，现在能力不够，恶补下，朝着大厂的目标去努力。</p>
<h2 id="03-毛剑老师的分享">03 毛剑老师的分享</h2>
<p>毛剑老师这次主要站在面试官的角度分享大厂面试 Go 工程师更看重哪些能力。他提到了软实力、硬实力，以及他喜欢问候选人哪些题。</p>
<p>这方面，每个人的喜好不一样，有些面试官喜欢问这个，有些喜欢问那个。就技术能力来说，大厂一般会有规范的流程，有些可能有面试考察能力的要求。所以，除了 Go 语言本身使用掌握外，还需要对核心的一些设计有所了解。比如调度、内存、并发等，此外服务端相关的其他技能，也是必须掌握的。</p>
<p>对此，我个人的看法：</p>
<ul>
<li>根据职位不同，可能侧重点不一样；不同公司、不同部门，面试的喜好也会有所区别，需要有针对性的准备；</li>
<li>Go 语言本身的基本功，底层的一些实现，作为一个 Gopher，你应该不断探索；</li>
<li>操作系统、网络、数据库、缓存等服务端相关的技能得不断加深；</li>
<li>适当刷刷题，比如 LeetCode；手写代码也可以练练。比如字节面试都会让手写代码；</li>
</ul>
<h2 id="04-未来-5-年将是-go-语言的天下">04 未来 5 年将是 Go 语言的天下？</h2>
<p>这个定义有点夸张，但 Go 确实受到越来越多的关注。别的不说，很多 PHPer 都在学习 Go。从我的网站：https://studygolang.com 流量看，这些年上升还是挺厉害的。</p>
<p>一直以来，国内的技术和国外是不太一样的。Go 语言也很明显，在国内的热度明显高于国外。因为有字节跳动、腾讯（据说 Go 在腾讯今年有望成为第二大编程语言，去年是第三大）、滴滴、B 站等大厂的大规模使用（圈内人应该发现，曾经 PHP 一统天下的好未来，这段时间也是各种 Go），Go 必然会受到越来越多的关注。从目前在线教育对 Go 的投入来看，他们也看到了 Go 的潜力。所以，我看好 Go，你呢？！</p>
]]></content>
		</item>
		
		<item>
			<title>Go error 打印灾难 —  CockroachDB errors 库（第3篇）</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-error-printing-catastrophe/</link>
			<pubDate>Mon, 26 Oct 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-error-printing-catastrophe/</guid>
			<description>这篇文章是关于 “CockroachDB errors 库” 的系列文章的第 3 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。 Go 1.13 的标准库采用了 Dave Cheney 自 2015 年以来对错误处理的主要贡献：将 Go 错误对象构造为链表的想法。 唉，这种方式给 Go 开发人员造成了巨大的障碍：使打印错误对象变得困难、几乎不可能。 这就是我所说的 “Go error 打印灾难&amp;quot;，下面我们将准确</description>
			<content type="html"><![CDATA[<p>这篇文章是关于 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">“CockroachDB errors 库”</a>
的系列文章的第 3 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</p>
<p>Go 1.13 的标准库采用了 Dave Cheney 自 2015 年以来对错误处理的主要贡献：将 Go 错误对象构造为链表的想法。 唉，这种方式给 Go 开发人员造成了巨大的障碍：使打印错误对象变得困难、几乎不可能。</p>
<p>这就是我所说的 “Go error 打印灾难&quot;，下面我们将准确地看到它是什么。</p>
<h2 id="提醒go-错误为什么是链表怎么做的">提醒：Go 错误为什么是链表，怎么做的</h2>
<p>Go 的错误 API，从 v1.13 开始，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// error is a pre-defined type.
</span><span class="c1"></span><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
   <span class="c1">// Error returns an error&#39;s short message string.
</span><span class="c1"></span>   <span class="c1">// This is used e.g. when formatting an error with %s/%v.
</span><span class="c1"></span>   <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// wrapper can be implemented by additional error
</span><span class="c1">// “layers”, to decorate an error. This interface
</span><span class="c1">// is not pre-defined in the language but should be
</span><span class="c1">// implemented by API-conformant error decorators.
</span><span class="c1">//
</span><span class="c1">// This is the interface that powers the error identification
</span><span class="c1">// facilities errors.Is() and errors.As().
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">wrapper</span> <span class="kd">interface</span> <span class="p">{</span>
   <span class="c1">// Unwrap accesses the next layer in the error object.
</span><span class="c1"></span>   <span class="c1">// This used to be called “Cause” in Dave Cheney&#39;s
</span><span class="c1"></span>   <span class="c1">// pkg/errors library.
</span><span class="c1"></span>   <span class="nf">Unwrap</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>使用此 API，Go 生态系统中的代码可以通过两种方式构造 error 对象：</p>
<ul>
<li>使用类似 fmt.Errorf() 或 errors.New() 构造&quot;叶”错误；</li>
<li>使用修饰层 &ldquo;包装&rdquo; 错误，例如使用 errors.Wrap() 为错误增加前缀信息，errors.WithStack() 附加堆栈跟踪或使用 %w 动词的 fmt.Errorf() ，这是 1.13 新增的：<code>err = fmt.Errorf(&quot;some context: %w&quot;, err)</code></li>
<li>包装类型通过实现 Unwrap() 方法来声明其&quot;剥离&quot;的能力。这是由 Go 的标准库检查和使用的，特别是 errors.Is()，它可以通过查看所有中间层来识别错误是否为特定类型的错误。</li>
</ul>
<p>抽象的链表使得使用来自不相关的 Go 包的修饰类型将修饰附加到任何错误对象成为可能。通过将层之间的关系定义为”只是 error&quot;，没有包依赖项，也不会有循环导入的问题。它还使得可以跨不同的项目分离装饰器/包装器的开发，同时保持互操作性。</p>
<p>有关这个主题的详细信息，请阅读本系列中的上一篇文章：<a href="https://dr-knz.net/cockroachdb-errors-std-api.html" target="_blank" rel="noopener">Go 标准错误 API</a>
。</p>
<h2 id="提醒go-的格式化设施">提醒：Go 的格式化设施</h2>
<p>Go 库中最常用的、功能最全的打印设施是标准 fmt 包。它包含格式化各种 Go 为字符串，或输出到文件、buffer、终端。</p>
<p>例如 fmt.Println(v) 将 v 的值打印到终端。</p>
<p>fmt 中的大多数打印函数共享基础逻辑，为更强大的 Printf() API 提供支持。Printf() 使用格式字符串和变量参数列表，并显示根据格式的参数。这直接派生自 C 中类似的<a href="https://en.wikipedia.org/wiki/C_file_input/output" target="_blank" rel="noopener">标准 API</a>
。</p>
<p>Go 的 fmt 可以打印任意数据类型，但 C 的 stdio 不能。</p>
<p>这是使用预定义逻辑的组合来处理 Go 自己的基本类型，能智能递归地打印结构类型、指针和数组类型，以及自定义类型：fmt 尝试在传递给 Print 样式函数的值上使用四个接口。</p>
<ul>
<li>fmt .Formatter 接口定义了 Format(…) 方法，可以通过实现该方法以完全覆盖格式。</li>
<li>如果 fmt.Formatter 不存在，然后 fmt 会识别预定义的 error 接口。在这种情况下，它调用 Error() 方法并打印该方法。</li>
<li>如果 fmt.Formatter 或 error 都不可用，则根据使用的格式动词，自定义类型可以实现 fmt.Stringer（一个 String() 方法）或 fmt.GoStringer（一个 GoString() 方法）用于驱动更简单、不太灵活的格式输出。</li>
</ul>
<p>只有当这些接口都未实现时，fmt 才回退到使用其预定义逻辑。</p>
<p>有关本主题的详细信息，请阅读本系列中的上一篇文章：<a href="https://dr-knz.net/go-formatting-apis.html" target="_blank" rel="noopener">Go 的格式化 API。</a>
</p>
<h2 id="提醒error-的简单打印">提醒：error 的简单打印</h2>
<p>fmt 检测 error 参数并自动调用 Error() 方法。这工作得很好，即使对于包装错误：Error() 在最外层的包装器（链接列表的头部）上调用。因此，该包装器的 Error() 实现可以覆盖其尾部图层的错误。</p>
<p>例如：</p>
<ul>
<li><code>errors.New(&quot;world&quot;).Error()</code> 返回 <code>world</code>。</li>
<li><code>errors.Wrap(errors.New(&quot;world&quot;), &quot;hello&quot;)</code> 返回 <code>hello: world</code>。</li>
<li>同上，<code>fmt.Errorf(&quot;hello %w&quot;, errors.New(&quot;world&quot;))</code> 也构造了一个包装错误。</li>
</ul>
<p>这样，当将错误传递到 fmt 时，我们会自动获得自然的&quot;更长&quot;，&ldquo;更完整”的 Error() 结果。</p>
<p>一切似乎都很好，而且自从 Go v1.0 以来一直很好，但是详细的打印又如何呢？</p>
<h2 id="提醒详细的打印模式">提醒：详细的打印模式</h2>
<p>当使用 %+v 格式参数时，fmt 内部逻辑将采用&quot;详细&quot;模式，以显示参数列表中的相应值。默认情况下，详细模式会触发例如在结构类型中显示字段名称。</p>
<p>例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">a</span> <span class="kt">int</span> <span class="p">}{</span><span class="mi">123</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>  <span class="c1">// prints {123}
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="c1">// verbose mode: prints {a:123}
</span></code></pre></div><p>&ldquo;详细模式”的定义有一个新的抽象：某些数据在常见情况下不可见，但可根据请求变为可见。</p>
<p>这在进行 “printf debugging” 或事件日志记录时非常有用，因为查看调试或日志记录输出是给专业用户查看的，可以查看比程序常规输出中显示更多的信息。</p>
<p>自定义类型只能通过实现 fmt.Formatter 接口来自定义详细模式的输出。formatter 接口。只有该接口的 Format() 方法能获取有关是否请求详细模式的信息。fmt 包的其他接口不够强大。</p>
<p>特别是，error 接口和隐式 wrapper 接口都没有为错误类型提供一种自定义 fmt 中显示方式的方法。</p>
<h2 id="详细打印-go-错误的可取之处">详细打印 Go 错误的可取之处</h2>
<p>除了调用 Error() 方法提供的简单模式外，Go 生态系统还构建了单独的详细模式来打印错误对象的需求。</p>
<p>例如，Dave Cheney 的 pkg/errors 包和 CockroachDB 的 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">errors</a>
 库都会自动在错误对象中嵌入堆栈跟踪。此堆栈跟踪不会出现在 Error() 的输出中，因此在简单模式下打印错误对象时不包括此堆栈跟踪。当程序遇到错误，发现自己无法令人满意地处理它时，程序员可以使用 %+v 进入详细模式以查看堆栈跟踪。这有助于了解错误的来源和在程序中的位置。</p>
<p>此外，程序可以选择使用错误包装器将不是错误消息的控制信息嵌入到程序中，例如，指示调用方函数中错误处理期间应执行操作的特殊数字代码。调用方函数可以使用标准 API errors.As() 从错误链接链表中提取此数据。</p>
<p>如果程序员在排除的疑难 Bug 时想要可视化此信息，该信息不包括在 Error() 的输出中，怎么办？同样，将此信息输出为&quot;详细模式”的一部分，似乎这是一种自然的选择。</p>
<p>不幸的是，实现这个目标是相当困难的。</p>
<h2 id="基本缺陷-1在包装器中无法自定义">基本缺陷 1：在包装器中无法自定义</h2>
<p>我们试验和设计自己的错误类型，其中一些隐藏的信息只在详细模式下显示。我们可以这样做，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myError</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">msg</span> <span class="kt">string</span> <span class="c1">// public message
</span><span class="c1"></span>   <span class="nx">code</span> <span class="kt">int</span> <span class="c1">// hidden code
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Error implements the error interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>

<span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myError</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">verb</span> <span class="o">==</span> <span class="sc">&#39;v&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Verbose mode.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;(code: %d) %s&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">code</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>说明：当我们用 %v 打印 <code>*myError</code> 的实例时，我们得到 msg 的值；使用 %+v 时，我们得到相同的内容，但有前缀 (code: NNN)  和字段 code 的值。</p>
<p>精明的读者可能会注意到此代码看起来不完整，因为它不处理 %q 等格式动词。这在本节中不直接相关，因此我们暂时忽略它。</p>
<p>除了最后一点， 代码似乎工作正常？</p>
<p>唉！</p>
<p>尝试以下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">myError</span><span class="p">{</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="mi">123</span><span class="p">}</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;wazaa: %w&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>         <span class="c1">// simple mode: prints just &#34;wazaa: hello&#34;
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span> <span class="c1">// verbose: prints... what?
</span></code></pre></div><p>我们希望本示例中的代码打印 <code>zawaa: (code: 213) hello</code>。不幸的是，它不是：由 fmt.Errorf 返回的错误类型，fmt.Formatter 接口不起作用。因此，使用 fmt.Errorf 时，myError 中的自定义信息丢失了！</p>
<p>换句话说，在 “标准 Go” 中，通过 <code>Unwrap()</code> 方法创建良好的包装错误类型还不够；因此，在&quot;标准 Go&quot;中创建成形良好的错误包装类型是不够的。还必须实现适当的 Format() 方法，在包装错误中，通过 fmt.Formatter  处理任何可能的自定义格式。</p>
<p>这样有两个主要问题：</p>
<ul>
<li>有一点很明确：必须实现 Format() 方法，即使自定义包装不需要自定义格式，以免 fmt.Formatter 接口对于所有参与者都毫无用处。</li>
<li>Go 库中没有文档说明此问题。所以大家根本不了解也不知道。实际上，粗略的检查显示，Go 生态系统中的许多自定义错误包装器类型均未实现 Format()，因此会在其 “尾巴” 中破坏格式自定义。</li>
</ul>
<h2 id="基本缺陷-2转发forwarding-fmtformatter-的困难">基本缺陷 2：转发（forwarding） fmt.Formatter 的困难</h2>
<p>如果我们愿意支付抽象税，并同意所有包装错误类型也将实现 fmt.Formatter，那又会这样？怎么会这样呢？</p>
<p>作为支持示例，让我们尝试一个非常简单的包装，它没有任何特殊功能：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">myWrapper</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">cause</span> <span class="kt">error</span> <span class="c1">// tail of linked list
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Error implements the error interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span> <span class="p">}</span>

<span class="c1">// Unwrap implements the unwrap interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Unwrap</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span> <span class="p">}</span>
</code></pre></div><p>然后，我们可以开始实现 fmt.Formatter。至少，它应该区分冗长和非冗长模式。</p>
<p>但是，如果我们不确定错误原因（error cause）是否实际实现 fmt.Formatter？也许没有。因此，为了减少的惊讶，我们需要做&quot;与 fmt 相同的一些事&rdquo;。实现此目的的最佳方法是调用 fmt 本身逻辑：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">verb</span> <span class="o">==</span> <span class="sc">&#39;v&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Verbose mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself verbosely.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;%+v&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Simple mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself simply.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这是一个繁琐的模式，只是为了确保 e. cause 得到打印。</p>
<p>此外，如果 e.cause 想要了解有关原始格式的信息，那该内容会如何呢？如果与 %#v 一起使用时，使用 #v？还是 %#+v？还是 %q？</p>
<p>遗憾的是，fmt 中没有标准 API 来正确将所有状态转发到递归调用。自 Go 1.15 起，将所有格式状态（formatting state）完全转发到错误原因而不打印任何其他内容的代码量最低如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">f</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Builder</span>
    <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;%&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;#&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;0&#39;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">wp</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Width</span><span class="p">();</span> <span class="nx">wp</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">w</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">pp</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Precision</span><span class="p">();</span> <span class="nx">pp</span> <span class="p">{</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteByte</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">)</span>
        <span class="nx">f</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="nx">f</span><span class="p">.</span><span class="nf">WriteRune</span><span class="p">(</span><span class="nx">verb</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这看起来非常不方便，容易出错。</p>
<p>即使是 Dave Cheney 的 pkg/errors 包也没有做到这一点，它仅在包装器中按如下方式实现 Format()，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">withMessage</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">verb</span> <span class="p">{</span>
    <span class="k">case</span> <span class="sc">&#39;v&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Cause</span><span class="p">())</span>
            <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="k">fallthrough</span>
    <span class="k">case</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="sc">&#39;q&#39;</span><span class="p">:</span>
        <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>此代码对于谓词 %q 不正确，同时完全省略其他格式标记（如 %#v 等），并且无法识别除 v、s 或 q 以外的任何谓词。</p>
<p>在 Go 生态系统中探索发现，很少有自定义错误包装类型实现 Format()。</p>
<p>实现适当的自定义 Format()， 以及没有预定义 （也不建议） 机制在 fmt 中转发 Format() 调用这一事实是如此困难，这是 Go 标准库的基本限制。</p>
<p>（安利：上面的正确代码的副本可作为可重用的 fmtfwd.MakeFormat() 函数，在 <a href="https://github.com/knz/go-fmtfwd" target="_blank" rel="noopener">go-mtfwd</a>
 包中。然而，这不是万能药。）</p>
<h2 id="基本缺陷-3不更改-api-无法修复的问题">基本缺陷 3：不更改 API 无法修复的问题</h2>
<p>Go 的团队称自己构建的语言可以最大限度地保持向后兼容性。标准库的添加是通过引入或替换功能，但不会影响现有代码的语义。</p>
<p>在这种情况下，Go 开发人员可以做什么来&quot;修复&quot;上面确定的问题，而不破坏现有的 error 代码，也不需要现有包添加&quot;缺失&quot;的粘附代码，如缺少的 Format() 转发器？</p>
<p>事实证明，在 fmt 包中可以直接做的工作不多。</p>
<p>在高级别上，不可能的任务是确保错误链中的所有细节以详细模式打印，同时考虑 Format() 方法中的自定义行为。</p>
<p>由于不是链中的每一个错误都提供 Format() 方法，因此 fmt 代码需要使用 Unwrap() 方法迭代自身。然后在每个层上都需要打印&hellip;东西。但究竟是什么？</p>
<ul>
<li>它无法调用 Error()，因为包装器上的 Error() 本身将递归，并获取链中其他层的字符串片段；</li>
<li>它无法调用 Format()，因为包装器上的 Format() 已经（根据当前生态系统）对错误原因递归递处理。</li>
</ul>
<p>因为 fmt.Formatter 接口 Format() 方法的第一个参数 fmt.State，是一个接口类型，因此实际在 fmt 中会是一个特定的 State 实例，可以&quot;分离&quot;当前错误层内的直接打印，从进一步递归执行打印。</p>
<p>例如，如下 Format() 实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Format implements the fmt.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">verb</span> <span class="o">==</span> <span class="sc">&#39;v&#39;</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Verbose mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself verbosely.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;(code %d) %+v&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">code</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Simple mode. Make fmt ask the cause
</span><span class="c1"></span>      <span class="c1">// to print itself simply.
</span><span class="c1"></span>      <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>通过此代码可见，在 Format 内部调用的 fmt.Fprintf 或 fmt.Fprint 的第一参数是 fmt.State 的实例，这是 fmt 包负责注入的。简单字符串和非错误值可以传递，每次看到错误值时，它都会被”忽略”，以便外部 fmt 循环可以转到下一层，而不会重复输出。</p>
<p>这个想法的问题， 要知晓 Format() 方法中是怎么使用 fmt.State 的。它不适用于实现以下函数的软件包：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">withMessage</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">verb</span> <span class="p">{</span>
        <span class="c1">// ...
</span><span class="c1"></span>    <span class="k">case</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="sc">&#39;q&#39;</span><span class="p">:</span>
        <span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">w</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>（这个例子来自 pkg/errors）。</p>
<p>请注意，与 Go 生态系统中的许多其他实现一样，此实现也挫败了我们的想法：某些打印使用 fmt.State 的 io.Writer 子接口并将 <code>.Error()</code> 字符串直接传递给它。当包装器的 Format() 正在打印下一层错误时，无法可靠地从 fmt.State 中进行检测，从而捕获该错误以执行其他操作。</p>
<p>因此，Go 生态系统中“将错误作为链接列表”的集成与 fmt.Formatter 抽象发生冲突，并创建了一个坑，社区中的每个人都陷入困境，而 Go 标准库无法帮助任何人在 fmt 中使用魔术。</p>
<h2 id="也许是救星pre-113-xerrors">也许是救星：pre-1.13 xerrors</h2>
<p>在进行 Go 1.13 的工作中，2017 年成立了一个工作组，研究采用“错误作为链接列表”的方法，并基本上接管了 Dave Cheney 在 pkg/errors 中的工作。</p>
<p>这就是由 Jonathan Amsterdam，Russ Cox，Marcel van Lohuizen 和 Damien Neil 组成的小组开始开发 <a href="https://github.com/golang/xerrors" target="_blank" rel="noopener">xerrors</a>
 包，以作为新抽象的原型和研究依据。</p>
<p>这项工作指导作者提出了一些建议：</p>
<ul>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/go2draft-error-printing.md" target="_blank" rel="noopener">Marcel van Lohuizen: Error Printing — Draft Design</a>
 (August 2018)</li>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/29934-error-values.md" target="_blank" rel="noopener">Jonathan Amsterdam, Russ Cox, Marcel van Lohuizen, Damien Neil: Proposal: Go 2 Error Inspection</a>
 (January 2019)</li>
</ul>
<p>他们的工作主要集中在 Unwrap() 的语义以及新 API error.Is() 和 errors.As() 的创建上，以可靠地从错误对象中识别和提取信息。</p>
<p>Marcel van Lohuizen 更加关注错误处理的打印方面，并设计了以下提案：</p>
<ul>
<li>
<p>除了 fmt.Formatter，error，fmt.Stringer 和 fmt.GoStringer 外，fmt 包支持一个新接口：errors.Formatter。</p>
</li>
<li>
<p>新接口将通过错误包装和叶类型实现。</p>
</li>
<li>
<p>提议的接口如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">errors</span>
  
<span class="kd">type</span> <span class="nx">Formatter</span> <span class="p">{</span>
     <span class="kt">error</span>
  
     <span class="c1">// FormatError can be implemented to customize the formatting
</span><span class="c1"></span>     <span class="c1">// of errors, instead of fmt.Formatter&#39;s Format.
</span><span class="c1"></span>     <span class="c1">//
</span><span class="c1"></span>     <span class="c1">// It has access to an errors.Printer (see below)
</span><span class="c1"></span>     <span class="c1">// to actually produce output.
</span><span class="c1"></span>     <span class="c1">//
</span><span class="c1"></span>     <span class="c1">// In the common case, the code in FormatError details
</span><span class="c1"></span>     <span class="c1">// the current layer and returns the next error layer
</span><span class="c1"></span>     <span class="c1">// to print, or `nil` to indicate the tail of the
</span><span class="c1"></span>     <span class="c1">// linked list has been reached.
</span><span class="c1"></span>     <span class="c1">//
</span><span class="c1"></span>     <span class="c1">// Optionally, the code for a wrapper&#39;s FormatError
</span><span class="c1"></span>     <span class="c1">// can take over formatting of both itself *and all
</span><span class="c1"></span>     <span class="c1">// subsequent layers* by producing its custom
</span><span class="c1"></span>     <span class="c1">// representation for all and then returning `nil`,
</span><span class="c1"></span>     <span class="c1">// even though its Unwrap() method is still used
</span><span class="c1"></span>     <span class="c1">// by errors.Is() to iterate through the tail.
</span><span class="c1"></span>     <span class="nf">FormatError</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Printer</span><span class="p">)</span> <span class="p">(</span><span class="nx">next</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
  
<span class="kd">type</span> <span class="nx">Printer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Print</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>  <span class="c1">// can be used to output stuff
</span><span class="c1"></span>    <span class="nf">Printf</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1">// can be used to output stuff
</span><span class="c1"></span>  
    <span class="c1">// Detail is a “magic” predicate which both indicates whether
</span><span class="c1"></span>    <span class="c1">// verbose mode is requested via %+v, and also starts indenting
</span><span class="c1"></span>    <span class="c1">// the output performed by subsequent Print()/Printf() calls in
</span><span class="c1"></span>    <span class="c1">// the interface, so that the details are visually “pushed to
</span><span class="c1"></span>    <span class="c1">// the right”.
</span><span class="c1"></span>    <span class="nf">Detail</span><span class="p">()</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<p>一个示例用法如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// FormatError implements the errors.Formatter interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">myWrapper</span><span class="p">)</span> <span class="nf">FormatError</span><span class="p">(</span><span class="nx">p</span> <span class="nx">errors</span><span class="p">.</span><span class="nx">Printer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;always&#34;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Detail</span><span class="p">()</span> <span class="p">{</span>
       <span class="nx">p</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;hidden: &#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">code</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span>
<span class="p">}</span>
</code></pre></div><p>使用此代码，我们将得到以下行为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">myWrapper</span><span class="p">{</span><span class="nx">cause</span><span class="p">:</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">code</span><span class="p">:</span> <span class="mi">123</span><span class="p">}</span>
<span class="nx">err</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">myWrapper</span><span class="p">{</span><span class="nx">cause</span><span class="p">:</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">code</span><span class="p">:</span> <span class="mi">456</span><span class="p">}</span>

<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// simple mode: prints &#34;always: always: hello&#34;
</span><span class="c1"></span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%+v\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="c1">// prints:
</span><span class="c1">//
</span><span class="c1">//   always:
</span><span class="c1">//      hidden: 456
</span><span class="c1">//   always:
</span><span class="c1">//      hidden: 123
</span><span class="c1">//   hello
</span></code></pre></div><p>（请注意一些特性：错误是从最外层/头部到最内层/尾部打印的，并且在每个前缀之后，细节之前插入了冒号）。</p>
<p>因此，将 fmt 代码修改为使用新接口的方式是：</p>
<ol>
<li>检测 Format() 方法是否可用。如果是这样，它被调用，结束。</li>
<li>否则，如果要打印的对象是错误，它将对其进行迭代：调用 FormatError()（如果存在）并使用其返回值作为下一次迭代的输入进行迭代。</li>
<li>当错误对象上不存在 FormatError() 或返回 nil 时，迭代将停止。</li>
<li>如果在迭代结束时仍有 Format() 或 Error() 方法可供调用，则将调用该方法以“完成”格式化。</li>
</ol>
<p>xerror 原型能够集中精力仅格式化一层包装器，而又不知道如何正确地将 Format() 调用转发给其他层。</p>
<p>因此，这是解决上述第二个基本限制的尝试。</p>
<p>哎，它根本无法解决第一个基本限制：如果包装层未实现 FormatError()，则 fmt 代码将仅停止在该级别尝试，并且在错误中进一步进行任何 FormatError() 或 Format() 定制链会被丢弃。</p>
<p>此外，许多人不喜欢“从前到后”打印错误的方式：在对错误详细信息进行故障排除时，开发人员发现重要是首先显示链接列表的“最内层”（尾部），然后才是“最外层”（头）。 xerrors 实现不允许这样做。</p>
<p>最后，无论如何，所有讨论都是没有争议的：没有选择将 xerror 打印抽象（包括 errors.Formatter，errors.Printer 和相应的 fmt 更改）包含在 Go 1.13 中。从 Go 1.16 开始，<a href="https://github.com/golang/go/issues/29934#issuecomment-591488854" target="_blank" rel="noopener">朝着这个方向进行的任何进一步工作都被推迟</a>
，具体另行通知。</p>
<h2 id="战略失误打破与pkgerrors-的兼容性">战略失误：打破与pkg/errors 的兼容性</h2>
<p>依赖于 Dave Cheney 的 pkg/errors 的社区项目超过 50,000 个，该软件包已成为事实上的扩展，能够提供错误包装程序的基本库，并作为错误打印自定义示例，尽管不完善。</p>
<p>甚至有一个扩展的生态系统，它依靠基本的链表抽象，使用一种名为 Cause() 的方法来接受链中的下一个层次。</p>
<p>Go 团队可能已经接受了这种方法，并且可以在“所有错误包装程序都必须以类似于 pkg/errors 的方式实现 Format”的方式进行区分。然后，errors.Is()/errors.As() 可能选择了 pkg/errors 的 Cause() 抽象。</p>
<p>遗憾的是，Go 团队选择了不同的方法名称：Unwrap()。因此，Go 1.13 发布后开发的新一代错误包已无法重用 pkg/errors。</p>
<p>因此，1.13 不仅引入了基本限制；这也阻止了 Go 社区继续可靠地使用 pkg/errors。</p>
<h2 id="总结go-error-打印灾难">总结：Go error 打印灾难</h2>
<p>在 2019 年，Go 1.13 采纳了 Dave Cheney 的 2015 年建议，将错误对象视为链表。因此，对 Unwrap() 方法进行了标准化，并使用 Is() 和 As() 函数增强了错误包，这些函数可以从以这种方式构造的错误中可靠地提取信息。</p>
<p>不幸的是，fmt 软件包没有学习如何打印这种错误的新形状，并且可靠地自定义错误对象的显示已变得不可能。</p>
<p>这是因为与以前的版本一样，fmt 仅了解 Format()，Error() 和 String()，并且仅在错误链的顶端或“头”考虑这些方法。</p>
<p>如果一个包定义了自定义包装错误类型，但忘记定义了自定义 Format() 方法，则 fmt 将忽略链接列表“尾部”中的任何其他 Format() 方法，并且自定义项将丢失。</p>
<p>此外，只有 Format() 方法可以为“详细”和“简单”格式（％v /％+v）提供不同的实现。在实践中，以递归方式在错误链尾部调用进一步的自定义方式，几乎不可能实现包装错误的 Format()。</p>
<p>简而言之，错误打印的自定义变得容易出错，并且在 Go 1.13 中基本上不可靠。Go 1.13 中放弃了的关键 Cause() 接口，导致与另一个具有某些人们可以达成共识的逻辑的程序包 Dave Cheney 的 pkg/errors 不兼容。 Go 团队通过 xerrors 包来尝试修复 Go 标准库中的这种情况，实际上并没有成功解决这些问题，存在重大的新缺陷，最终不令人满意。</p>
<p>这就是我们程序员无所适从的方式。</p>
<p>这是 Go error 打印灾难，它的悬念留在 Go 1.16 中。</p>
<h2 id="接下来">接下来</h2>
<p>CockroachDB error 库在错误打印方面花费了大量精力。尽管它不能填补所有空白，但确实可以减轻很多的痛苦。</p>
<p>本系列的下一篇文章进一步说明。</p>
<h2 id="参考文献">参考文献</h2>
<ul>
<li><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">Dave Cheney: Don’t just check errors, handle them gracefully</a>
.</li>
<li><a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">The Go Blog: Working with errors in Go 1.13</a>
.</li>
<li><a href="https://github.com/golang/go/issues/29934" target="_blank" rel="noopener">Jonathan Amsterdam, et al: Go 2 error values</a>
.</li>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/go2draft-error-printing.md" target="_blank" rel="noopener">Marcel van Lohuizen: Error Printing — Draft Design</a>
.</li>
<li><a href="https://go.googlesource.com/proposal/&#43;/master/design/29934-error-values.md" target="_blank" rel="noopener">Jonathan Amsterdam, Russ Cox, Marcel van Lohuizen, Damien Neil: Proposal: Go 2 Error Inspection</a>
.</li>
</ul>
<blockquote>
<p>原文链接：https://dr-knz.net/go-error-printing-catastrophe.html</p>
<p>本文作者：Raphael ‘kena’ Poss</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Go 格式化 API —  CockroachDB errors 库（第2篇）</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-formatting-apis/</link>
			<pubDate>Sat, 24 Oct 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-formatting-apis/</guid>
			<description>这篇文章是关于 “CockroachDB errors 库” 的系列文章的第 2 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。 以下面的代码为例： import &amp;#34;fmt&amp;#34; type T struct { x int } func main() { v := T{123} fmt.Println(v) } 这个程序打印 {123}，尽管我们没有教 Go 如何打印我们的 T 类型。它是如何做到这一点的？ printer 的等效性 fmt 包中的逻辑在所有 printer 之间共享，因此以下调用都保证等效： fmt.Print(x) fmt.Printf(&amp;quot;%v&amp;quot;, x) os.Stdout.Write([]byte(fmt.Sprint(x))) os.Stdout.Write([]byte(fmt.Sprintf(&amp;quot;%v&amp;quot;, x))) 换句话说</description>
			<content type="html"><![CDATA[<p>这篇文章是关于 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">“CockroachDB errors 库”</a>
的系列文章的第 2 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</p>
<p>以下面的代码为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">x</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">v</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="mi">123</span><span class="p">}</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这个程序打印 {123}，尽管我们没有教 Go 如何打印我们的 T 类型。它是如何做到这一点的？</p>
<h2 id="printer-的等效性">printer 的等效性</h2>
<p>fmt 包中的逻辑在所有 printer 之间共享，因此以下调用都保证等效：</p>
<ul>
<li><code>fmt.Print(x)</code></li>
<li><code>fmt.Printf(&quot;%v&quot;, x)</code></li>
<li><code>os.Stdout.Write([]byte(fmt.Sprint(x)))</code></li>
<li><code>os.Stdout.Write([]byte(fmt.Sprintf(&quot;%v&quot;, x)))</code></li>
</ul>
<p>换句话说，fmt.Print 的逻辑始终与将 Printf 与动词 %v 一起使用相同，前者实际使用后者作为实现。</p>
<p>同样，fmt.Println 使用 fmt.Print，外加 %v 动词，<code>fmt.Sprintln</code> 和 <code>fmt.Sprint</code> 是同样的道理。</p>
<h2 id="fmtstringer-和-fmtformatter">fmt.Stringer 和 fmt.Formatter</h2>
<p>现在，在上面的代码底部添加以下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
</code></pre></div><p>再次运行程序。会发生什么？它打印 <code>boo</code>。值 123 没有了。</p>
<p>这里发生的情况是，方法 String() 返回字符串实现了标准接口 fmt.Stringer，fmt 中的函数如果发现有它就会使用它。另外，尝试删除上面的 String() 函数定义，并将其替换为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>现在会发生什么？程序打印 <code>baa</code>。值 123 依然没有了。</p>
<p>如果这两个方法都可用怎么办？程序会打印 baa： fmt.Formatter 优先 fmt.Stringer。</p>
<p>当两个方法都不可用时，fmt 的逻辑会&quot;回&quot;在它自己的内部显示代码上，从而在表示值方面尽最大努力。</p>
<h2 id="fmt-对-error-知道多少">fmt 对 error 知道多少？</h2>
<p>Go 的标准 error 接口只提供返回字符串的 Error() 方法，而没有别的。</p>
<p>fmt 的逻辑知道 error，并知道如何使用其 Error() 方法，扩展上面解释的偏好规则：</p>
<ul>
<li>fmt.Formatter 优先级最高；</li>
<li>如果 fmt.Formatter 不存在，但是 error，则会使用 Error() 方法；</li>
<li>否则如果存在 fmt.Stringer，则使用它。</li>
</ul>
<h2 id="svq-和-xx-的关系">%s、%v、%q 和 %x/%X 的关系</h2>
<p>到目前为止，我们已经看到了，针对 %v 动词，fmt 的逻辑是如何可选地使用 fmt.Formatter、error 和 fmt.Stringer。</p>
<p>然而，在 Go 代码中使用的更常见的动词可能是 %s。%s 与 %v 的关系如何？</p>
<p>通常，%s 使用的逻辑与 %v 大致相同：如果 fmt.Stringer、error 或 fmt.Formatter 存在，将使用相同的偏好使用它。</p>
<p>当对象既不实现 String()，Error() 也不实现 Format() 时，就会出现区别。在这种情况下，％v 具有一些预定义的表示形式（例如，上例中的{123}），而 ％s 会提示“参数的类型错误”并且无法表示任何内容。</p>
<p>这就是为什么除非代码使用特定类型的字符串操作值，否则 Go 习惯用法通常是使用 ％v 而不是 ％s。</p>
<p>附加动词 ％q 和 ％x/％X 是 ％s 的变体（当 String()，Error() 和 Format() 都不可用时具有相同的限制）：</p>
<ul>
<li>%q 用引号引起来字符串，所以 fmt.Printf(&quot;%q&quot;, <code>he said &quot;hi&quot;</code>) 打印出 <code>he said &quot;hi&quot;</code>。</li>
<li>％x/％X 显示字符串中字节的十六进制表示形式。在实践中很少使用该方法（该方法更多用于整数）。</li>
</ul>
<h2 id="打印值指针方法集">打印值，指针方法集</h2>
<p>现在考虑上面的程序，以及以下实现的组合（注意接收器的类型）：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>现在打印的是 boo。为什么是这样？上面的代码按值传递 T 实例。根据方法集的概念，只实现了 fmt.Stringer 接口，因此输出 boo。如果现在改为这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>输出什么？这次再次输出：{123}，因为 fmt 的逻辑“看不到”上面的方法。</p>
<p>因此有如下规则：如果对象按值打印，则只考虑其按值方法。（其实就是方法集问题）</p>
<h2 id="打印引用值方法集">打印引用，值方法集</h2>
<p>现在，让我们用以下主程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">v</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">T</span><span class="p">{</span><span class="mi">123</span><span class="p">}</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>现在考虑以下程序变体：</p>
<ul>
<li>
<p>变体 A：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
<li>
<p>变体 B：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
<li>
<p>变体 C：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
<li>
<p>变体 D：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="s">&#34;boo&#34;</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;baa&#34;</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></li>
</ul>
<p>针对这些情况，上面的程序输出什么？都是 &ldquo;baa&rdquo;。</p>
<p>指针接收器 <code>*T</code> 的方法集包含 T 和 <code>*T</code> 的方法集。（原文作者写的不对，说变体 C 输出 &ldquo;boo&rdquo;）。</p>
<h2 id="使用-v-动词打印">使用 %+v 动词打印</h2>
<p>数字类型的 + 标志强制显示正值的加号，以便始终显示符号位。</p>
<p>然而，与 v 结合，它会触发&quot;详细打印&quot;。</p>
<p>根据 fmt 的默认逻辑，这会将字段的名称添加到结构中。</p>
<p>如果实现了 <code>fmt.Stringer</code> 接口，+ 不会对结果有任何改变， 如果实现了 fmt.Formatter 接口，根据约定，Format() 方法输出的信息比未指定 + 时的信息更详细。</p>
<p>Go 库没有规定应如何实现：不同的包往往以不同的方式实现。然而，缺乏规范不是问题；在这两种情况下，输出都供人眼使用，因此小显示不一致并不被视为问题。</p>
<h2 id="go-语法表示和-v-动词">Go 语法表示和 %#v 动词</h2>
<p>最后，将原来的主程序改为使用 %#v 动词：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">v</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="mi">123</span><span class="p">}</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%#v\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这会打印什么？</p>
<ul>
<li>如果 String() 方法可用，会忽略它；</li>
<li>如果 Format() 方法可用，则使用它；</li>
<li>如果 GoString() 方法可用（fmt.GoStringer 接口），则使用它；</li>
<li>否则，将使用 Go 语法结构的打印输出。</li>
</ul>
<p>这里发生的情况是，%#v 说明符打算打印值的 “Go表示”，而不是它的“人类可读表示”。fmt 逻辑知道如何这样做，但是自定义类型可以用 fmt 自定义这种行为：即实现 fmt.Formatter 或 GoStringer 接口。</p>
<p>注意，出于完整性考虑，上面解释了 GoStringer，但在实践中，发现它很少被使用。</p>
<p>我个人推荐 <a href="https://github.com/kr/pretty">https://github.com/kr/pretty</a> 这个工具，它比 Go 的标准库更清晰地打印 Go 语法表示。例如：<code>fmt.Printf(&quot;%# v&quot;, pretty.Formatter(x))</code>。</p>
<h2 id="格式化动词标识和修改器">格式化动词、标识和修改器</h2>
<p>到目前为止，我们已经看到 %v 与 %s 在意图和目的上的不同，以及例 %v 与 %+v 的不同。</p>
<p>如果我们想用不同的结果来定义我们自己的定制呢？</p>
<p>对于上面三种情况，可靠的定制机制是 fmt.Formatter 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">fmt</span>

<span class="c1">// Formatter can be implemented by your custom types.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Formatter</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// An object of type State is provided by the fmt
</span><span class="c1">// logic to your custom Format() method.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">State</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span> <span class="c1">// inherits the Write() method
</span><span class="c1"></span>
     <span class="nf">Flag</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span>

     <span class="nf">Width</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
     <span class="nf">Precision</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>最让我感兴趣的是：</p>
<ul>
<li>参数 verb 直接传递给我们自定义的 Format() 方法。这表示主“格式化动词”：对于 %v，verb == ‘v’。对于 %#v，依然是 verb == ‘v’。对于 %s，verb 是 s，以此类推。</li>
<li>有 Flag() 方法的 fmt.State 作为参数传递给 Format() 方法。如果设置了相应的格式化标志，Flag() 返回 true。例如，对于 %v，<code>Flag('#') == false</code>，而对于 %#v，<code>Flag('#') == true</code>。</li>
<li>此外，fmt.State 也实现了 io.Writer 接口。这样就可以直接将状态变量作为第一个参数传递给另一个对 fmt.Fprint 的调用，进一步简化了自定义 Format() 方法的实现。</li>
</ul>
<p>fmt.State 上的 Width() 和 Precision() 方法也很有趣，因为它们允许访问格式化字符串中的附加数值参数或修饰符。例如，在 %3.2f 中，我们有宽度 3 和精度 2。然而，这些在实践中很少被使用。</p>
<p>下面是一个符合 Go 习惯的例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Response</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">code</span> <span class="kt">int</span>
     <span class="nx">msg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Response</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">verb</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="nx">verb</span> <span class="p">{</span>
   <span class="k">case</span> <span class="sc">&#39;v&#39;</span><span class="p">:</span>
       <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nf">Flag</span><span class="p">(</span><span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// With %+v, we print both the message and the code.
</span><span class="c1"></span>          <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;%s (%d)&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">code</span><span class="p">)</span>
       <span class="p">}</span>
       <span class="k">fallthrough</span>
   <span class="k">case</span> <span class="sc">&#39;s&#39;</span><span class="p">:</span>
       <span class="c1">// For %s, or %v without +, we just print the message.
</span><span class="c1"></span>       <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// String is provided for convenience.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Response</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>简单解释下：</p>
<ul>
<li>以上实现中，对于 %+v，它将同时输出 msg 和 code。当只有 %v/%s，它只打印 msg。</li>
<li>为了让类型兼容 fmt.Stringer 接口，以便用于其他需要 String() 方法的地方，通过调用 fmt.Sprint 实现 String()。</li>
</ul>
<p>下面会进一步讨论。</p>
<p>上面代码一个有趣的点是，它不处理 %q/%x/%x。对于这些动词，它不输出任何内容。</p>
<p>它也不支持除了 + 之外的其他标志，例如，它对待 %#v 和 %v 是相同的。</p>
<p>事实上，Go API 并没有使实现与自身内部逻辑一样通用和强大的自定义 Format() 变得容易，而且“野生的” Go 包常常包含像上面那样的不完整实现。</p>
<h2 id="实践中自定义-formatter">实践中自定义 Formatter</h2>
<p>我在实践中发现，在整个生态系统的包经常按如下方式处理：</p>
<ul>
<li>自定义 Format() 方法总是为 v 动词做一些有效和有用的事情，而不考虑提供的标志。</li>
<li>带有动词 v 但没有标志的 Format() 的行为（即一个简单的 %v），通常与 String() 的行为保持一致。</li>
<li>如果自定义格式化程序同时具有“简单”和“详细”模式，那么它通常将 + 识别为访问详细模式的标志。</li>
<li>如果 %s 和 %v（没有标志）都被识别，它们通常输出相同的内容。</li>
<li>在自定义 Format() 方法中正确处理 %q、%x 和 %X 的情况并不常见。</li>
<li>非数值类型的自定义格式化程序几乎从不处理宽度和精度修饰符。</li>
</ul>
<p>最后一点特别说明了为什么关心固定宽度字符串格式的代码应该在以下两个步骤中拼写输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%30s&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>  <span class="c1">// instead of printing v directly
</span></code></pre></div><h2 id="在-fmtstringerfmtformatter-和-error-之间重用代码">在 fmt.Stringer、fmt.Formatter 和 error 之间重用代码</h2>
<p>上面的一个例子是通过调用 fmt.Sprint 实现 String()。它又在同一类型上使用 Format() 方法。简化为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
   <span class="c1">// This causes fmt to call Format() above and ultimately
</span><span class="c1"></span>   <span class="c1">// print r.msg.
</span><span class="c1"></span>   <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在这种情况下，为什么人们会选择通过返回 fmt.Sprint(r) 而不是返回 r.msg 来实现 String() 呢?</p>
<p>这是遵循 DRY 原则的实例：如果以后逻辑需要更改为&quot;打印更多内容&quot;，则只需修改 Format() 方法；String() 方法会自动从中受益。</p>
<p>这种模式比较常见。以下是另一种形式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
   <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span> <span class="c1">// or: s.Write([]byte(r.String()))
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>同样，一个方法实现&quot;使用另一个&quot;，因此一个方法只需要更改其中任何一个，在两者中获得相同的行为。</p>
<p>同样，如果涉及 error 接口，我们会在实践中看到所有重用组合：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">U</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">U</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">U</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nf">String</span><span class="p">()</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">U</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nf">String</span><span class="p">())</span> <span class="p">}</span>

<span class="kd">type</span> <span class="nx">V</span> <span class="kd">struct</span> <span class="p">{</span> <span class="nx">msg</span> <span class="kt">string</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">V</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">V</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">V</span><span class="p">)</span> <span class="nf">Format</span><span class="p">(</span><span class="nx">s</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">rune</span><span class="p">)</span> <span class="p">{</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprint</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">msg</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div><p>Q：为什么我们看到如此多样性？</p>
<p>A：我不太确定，但我责怪 Go 库文档中缺乏方案。另请参阅下面的两个答案。</p>
<p>Q：既然我们在每个情况下都得到相同的结果，这有关系吗？</p>
<p>A：从功能的角度来看，这些示例都是等效的。从性能角度来看，应考虑在程序中更经常使用哪些变体。如果常用 String() 方法，比打印出对象更是如此，那么让 String() 包含最简单的实现可能会产生更好的性能。这是因为 fmt 包中的逻辑有点重量级。然而请注意，在实践中，我并没有发现这种情况经常发生，所以我要说，这并不重要。</p>
<p>Q：我正在实现自己的自定义类型。我应该瞄准什么模式？</p>
<p>A：如果您的类型只有一个表示形式，直接使用 String() 即可；如果您实现错误类型，自然使用 Error() 更合适，一般都不需要实现 Format()。但如果需要区分&quot;简单&quot;和&quot;详细&quot;显示，则首先实现 Format() 然后从中派生 String() 或 Error()。</p>
<h2 id="总结">总结</h2>
<p>Go 在其标准 fmt 包中提供了通用格式 API。</p>
<p>该 API 中的所有函数都由通用逻辑提供支持，这是 Print/Sprintf 在引擎下使用的逻辑：每个对象都显示在某种格式&quot;动词&quot;的上下文中。</p>
<p>最常见和可靠的动词是 v（提示：它是 &ldquo;v&rdquo;，如&quot;value&quot;），也被 Print() 和 Println() 使用。它可以打印几乎任何东西，并不挑剔的值是零或实现一个特定的接口。</p>
<p>同时，在实现自己的类型时，可以通过实现某些接口自定义 fmt 的行为：</p>
<ul>
<li>fmt.Stringer，一个简单的 String() string 方法；</li>
<li>error，一个简单的 Error() string 方法；</li>
<li>fmt.Formatter，一个 Format() 方法。当通过 %v 与 %+v 以及其他动词和标志组合使用时，这可用于显示不同的东西。</li>
</ul>
<p>在实践中，我们看到同时提供 String() 和 Format() 方法或 Error() 和 Format() 方法的包。一个通常是通过调用另一个来实现的，以避免代码重复。Go 的标准库允许所有的组合重用，实际上我们可以在生态系统中找到所有变体。</p>
<blockquote>
<p>原文链接：https://dr-knz.net/go-formatting-apis.html</p>
<p>本文作者：Raphael ‘kena’ Poss</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Go 标准错误 API — CockroachDB errors 库（第1篇）</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/cockroachdb-errors-std-api/</link>
			<pubDate>Fri, 23 Oct 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/cockroachdb-errors-std-api/</guid>
			<description>这篇文章是关于 “CockroachDB errors 库” 的系列文章的第 1 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。 那本篇文章主要谈论什么呢？ 基本的 Go 错误：error 是值 Go 生态有一些非常流行、也非常基本的学习资源（文档）： A Tour of Go: Errors 。这是 Go 的官方教程。 Go By Example: errors 。Go By Example 是一些系列文章，推荐给那些希望通过示例学习 Go 的朋友们。 Goland Docs: Errors and Exception handling</description>
			<content type="html"><![CDATA[<p>这篇文章是关于 <a href="https://github.com/cockroachdb/errors" target="_blank" rel="noopener">“CockroachDB errors 库”</a>
的系列文章的第 1 篇，“CockroachDB errors 库”实际上是 Go 的标准 errors 包的通用、开放源码的替代品。</p>
<p>那本篇文章主要谈论什么呢？</p>
<h2 id="基本的-go-错误error-是值">基本的 Go 错误：error 是值</h2>
<p>Go 生态有一些非常流行、也非常基本的学习资源（文档）：</p>
<ul>
<li><a href="http://tour.studygolang.com/methods/19" target="_blank" rel="noopener">A Tour of Go: Errors</a>
。这是 Go 的官方教程。</li>
<li><a href="http://books.studygolang.com/gobyexample/errors/" target="_blank" rel="noopener">Go By Example: errors</a>
。Go By Example 是一些系列文章，推荐给那些希望通过示例学习 Go 的朋友们。</li>
<li><a href="https://golangdocs.com/errors-exception-handling-in-golang" target="_blank" rel="noopener">Goland Docs: Errors and Exception handling in GoLang</a>
。“Golang Docs” 是一系列文章，它涵盖了 Go 中的常见软件模式。</li>
</ul>
<p>我们可以从这些文章中学到什么？</p>
<ul>
<li>
<p>Go 提供了一个预定义的接口类型 error，定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// an &#34;error&#34; is an object with an `Error()` method
</span><span class="c1">// which describes the situation that occurred.
</span><span class="c1"></span><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>编写 Go 函数/方法的惯用方法是让它们在常规返回值之外，再返回一个 error 类型值，并在每个调用点上进行测试</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">div</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">y</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
       <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;boo&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">/</span> <span class="nx">y</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
  
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">div</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
       <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;woops: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
       <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;result:&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>如上面的示例所示，fmt.Printf 会知道如何调用 error 的 Error() 方法来显示错误文本。如果错误是通过%s、%q、%x/%X 打印的，它也会这样做。</p>
</li>
</ul>
<h2 id="error-也是链表">error 也是链表</h2>
<p>如果你还不知道 <a href="https://dave.cheney.net/" target="_blank" rel="noopener">Dave Cheney</a>
 是谁，现在是时候去了解下这位及其高产的 Go 大师程序员。</p>
<p>2015 年，Dave 创建了 pkg/errors 包（<a href="https://github.com/pkg/errors" target="_blank" rel="noopener">源代码</a>
，<a href="https://pkg.go.dev/github.com/pkg/errors" target="_blank" rel="noopener">文档</a>
），随后在 2016 年东京举行的 GoCon 春季会议上展示了它。下面这篇文章用散文的形式解释了这个故事：</p>
<p><a href="https://studygolang.com/articles/12484" target="_blank" rel="noopener">Dave Cheney：优雅的处理错误，而不仅仅只是检查错误</a>
</p>
<p>以下是 Dave 提到的主要创新：</p>
<ul>
<li>Go error 对象像链表一样构建，而且是不可变的。</li>
<li>err 在任何时候都会指向列表的头部。</li>
<li>在首次发生错误时，将构造一个原子或&quot;叶&quot;错误对象，该对象将在列表的尾部。</li>
<li>当错误通过调用堆栈和软件组件返回时，通过向错误添加更多&quot;层&quot;、在现有错误列表的头部 push 更多列表元素或&quot;包装器&quot;来增加错误。</li>
</ul>
<p>这在实践中给我们什么启发呢？主要用途是向错误对象添加消息前缀，以给出有关&quot;错误发生在哪&quot;的更多上下文。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
   <span class="s">&#34;fmt&#34;</span>
   <span class="s">&#34;github.com/pkg/errors&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;boo&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bar</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nf">foo</span><span class="p">(),</span> <span class="s">&#34;bar&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">baz</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">Wrap</span><span class="p">(</span><span class="nf">foo</span><span class="p">(),</span> <span class="s">&#34;baz&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="nx">r</span> <span class="o">:=</span> <span class="nf">rollDice</span><span class="p">()</span>
     <span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
     <span class="k">if</span> <span class="p">(</span><span class="nx">r</span> <span class="p">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nf">bar</span><span class="p">()</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">err</span> <span class="p">=</span> <span class="nf">baz</span><span class="p">()</span>
     <span class="p">}</span>
     <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>使用 <code>errors.Wrap()</code>，添加一个前缀到错误消息，main 函数能报告：<code>bar: boo</code> 或 <code>baz:boo</code> 这样人类可读错误消息，方便知晓哪个函数被调用。如果没有 <code>errors.Wrap()</code>，哪个调用路径导致错误将不容易知晓。</p>
<p>在实践中，这是如何工作的，看起来有点像这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// errorString represents a leaf error. This
</span><span class="c1">// is what gets constructed by e.g. fmt.Errorf().
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">errorString</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">msg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// Error implements the error interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">errorString</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span> <span class="p">}</span>

<span class="c1">// msgWrap represents a wrapper which adds a prefix
</span><span class="c1">// to an error. This is what gets constructed
</span><span class="c1">// by e.g. pkg/errors.Wrap().
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">msgWrap</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">cause</span> <span class="kt">error</span>
     <span class="nx">msg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="c1">// instances of msgWrap are also instances of the error
</span><span class="c1">// interface, by implementing the Error() method.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">msgWrap</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
     <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s: %v&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">msg</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cause</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="错误消息包装注释和-cause-发现">错误消息、包装注释和 cause 发现</h2>
<p>Dave Cheney 的基础逻辑是：</p>
<blockquote>
<p>The <code>Error</code> method on the <code>error</code> interface exists for humans, not code.</p>
</blockquote>
<p>换句话说，程序代码不应检查或比较 Error() 方法的结果。</p>
<p>Dave 继续谴责两种 Go 编程模式，他认为令人厌恶，现在仍然不赞成：</p>
<ul>
<li>“哨兵错误（sentinel errors）&ldquo;的概念，这是在代码中通过 error 实例进行比较。例如，<code>if err == ErrNotExists</code>。这种方式的主要问题是，如果错误是链表，也许是在列表的尾部找到哨兵，而头部有其他内容（例如，消息前缀）。Sentinel 的另一个更实际的问题是，为了能够执行比较，发生比较的包必须导入定义 sentinel 所在的包。这将导致依赖项。这种类型的硬依赖性使软件组合更加困难。</li>
<li>引用 &ldquo;error types&rdquo;（或错误包装类型）的概念，进行错误类型断言，例如，<code>if e, ok := err.(SomeType); ok</code>。此处的问题与上述问题相同：如果错误是链表，则它可能不起作用，并且还导致了包依赖。</li>
</ul>
<p>Dave 建议应该采用这两种方式：</p>
<ul>
<li>为调用者感兴趣的错误对象的属性定义接口。例如，错误是否可恢复可以通过 IsRecoverable() 方法来定义。然后，在任何包都可以断言此接口的实现，没有依赖关系：在 Go 中，接口断言基于结构相等，而不是命名相等。</li>
<li>注意错误链接列表结构，并在检查错误对象时正确遍及链表层级。</li>
</ul>
<p>为了实现后一点，Dave Cheney 在 pkg/errors 中引入了 causer 接口，从而有了以下可重用的代码模式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NB: causer is not exported by pkg/errors; instead
</span><span class="c1">// any package can re-defined it as needed
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">causer</span> <span class="kd">interface</span> <span class="p">{</span> <span class="nf">Cause</span><span class="p">()</span> <span class="kt">error</span> <span class="p">}</span>

<span class="o">...</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">{</span>
       <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">SomeInterfaceWithProperty</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
          <span class="c1">// ... do something ...
</span><span class="c1"></span>       <span class="p">}</span>

       <span class="c1">// Peel one layer, if wrapped.
</span><span class="c1"></span>       <span class="k">if</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.(</span><span class="nx">causer</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
          <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Cause</span><span class="p">()</span>
          <span class="k">continue</span>
       <span class="p">}</span>
       <span class="k">break</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>此模式会将错误展开，根据错误链访问，直到叶子节点或链表尾部。</p>
<h2 id="在-errors-中内嵌堆栈追踪">在 errors 中内嵌堆栈追踪</h2>
<p>包 pkg/errors 的一个被低估的特性是，每次构造错误或包装错误时，它都会自动保留堆栈跟踪的副本。</p>
<p>这一点很重要，因为它使得在排除问题时能够分析”错误发生在哪里&rdquo;：通常情况下，该错误仅对开发人员可见，或在实例化后很长一段时间，在调用者中的某个地方出现问题。各种 Go 并发模式使这种困难更加复杂，其中错误对象通过通道将错误对象从一个 goroutine 传输到下一个 goroutine。因此，仅仅查看源代码中的&quot;一行&quot;来查找错误的来源是不够的。</p>
<p>为此，pkg/error 使用极其轻量级且相当聪明的机制来在每个错误构造时保留调用堆栈的副本。</p>
<p>此堆栈跟踪不出现在 Error() 方法的结果中；相反，当通过 Printf 中的 %+v 谓词（这是最常见的情况，例如在调试期间）或通过检查错误链接列表某些层（例如与 <a href="https://sentry.io/" target="_blank" rel="noopener">Sentry.io</a>
 集成）上是否存在 StackTrace() 方法时，将显示错误对象。</p>
<p>这种机制特别巧妙的是，堆栈跟踪的所有详细信息（包括函数/包名称）不会直接存储在错误对象中，而是在打印堆栈跟踪时检索它们。通常情况下，错误发生，但可能是无害的，这样可以节省时间和内存。</p>
<h2 id="go-113-中的提升和-api-分裂">Go 1.13 中的提升和 API 分裂</h2>
<p>很难说 pkg/errors 包多么基础和重要。但目前直接依赖它的公开 Go 项目超过 5 万个，还有无法统计的私有 Go 存储库。</p>
<p>Go 语言的设计者认识到了这一点，并<a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">在 2019 年将其语义集成到 Go 标准库</a>
中，从 Go 1.13 开始：</p>
<ul>
<li>Go 1.13 的错误也是链表。</li>
<li>Go 1.13 没有提供 <code>errors.Wrap()</code>，但是为 fmt.Errorf 做了扩充：使用格式化动词 %w，构造一个包装错误，并保持原来的错误对象放在链表尾部供检测；
<ul>
<li>在 <code>pkg/errors</code>: <code>errors.Wrapf(err, &quot;hello %s&quot;, &quot;world&quot;)</code></li>
<li>在 Go 1.13: <code>fmt.Errorf(&quot;hello %s: %w&quot;, &quot;world&quot;, err)</code></li>
</ul>
</li>
<li>Go 1.13 简化了在错误链表的每个中间级别上测试属性的任务，使用以下 api：
<ul>
<li>errors.Is(err1, err2) 检查 err1 中的任何层是否等于 err2（会递归地测试哨兵）。这可以用来识别许多标准库的哨兵，例如 errors.Is(err, os.ErrNotExist) 检查是否由于找不到某个文件/目录而导致错误。</li>
<li><code>errors.As(err1, &lt;type&gt;)</code> 检查 err1 中的任何层是否可以被转换为 <code>&lt;type&gt;</code>（接口或具体类型），并返回转换的结果。这可以用来断言错误属性，就 Dave Cheney 在 2015 年建议的那样。</li>
</ul>
</li>
</ul>
<p>然而存在一些争议，因为 Go 1.13 在社区中引发了 API 的分裂：</p>
<ul>
<li>error 对象上的展开方法称为 Unwrap()，而不是 Cause()。我个人很讨厌 Go 团队选择一个单独的方法名，因为这直接破坏了与所有基于 pkg/errors 构建的包的兼容性，而且没有很好这么做的原因。</li>
<li>Go 1.13 没有提供像 pkg/errors 中的 error.Cause() 那样的 “unwrap 一切”的函数。</li>
<li>另外，遗憾的是，因为 Go 1.13 没有定义 Cause() 方法，所以不可能使用 pkg/errors 中的 error.Cause() 来解包装来自 Go 1.13 项目和为 pkg/errors API 设计的项目的混合错误对象。</li>
<li>非常遗憾的是，Go 1.13 没有像 pkg/errors 那样提供捕获堆栈跟踪的工具。由于上述 API 的不兼容性，不可能将 pkg/errors 与特定于 Go 1.13 的代码混合匹配来获得这种行为。</li>
</ul>
<p>总结为如下表格：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Feature</th>
<th style="text-align:left">Go’s &lt;1.13 <code>errors</code></th>
<th style="text-align:left"><code>github.com/pkg/errors</code></th>
<th style="text-align:left">Go 1.13 <code>errors</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">leaf error constructors (<code>New</code>, <code>Errorf</code> etc)</td>
<td style="text-align:left">✔</td>
<td style="text-align:left">✔</td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">abstraction: errors are linked lists</td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">error causes via <code>Cause()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">error causes via <code>Unwrap()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">best practice: test interfaces, not values/types</td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left">(partial)</td>
</tr>
<tr>
<td style="text-align:left"><code>errors.As()</code>, <code>errors.Is()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left"><code>errors.Wrap()</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">automatic error wrap when format ends with : %w</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
</tr>
<tr>
<td style="text-align:left">standard wrappers with efficient stack trace capture</td>
<td style="text-align:left"></td>
<td style="text-align:left">✔</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>这种分裂是真实而悲哀的。发生这种情况的原因（也许令人惊讶）是 Go 团队无法确定一种好的方法来标准化打印错误。我们将在本系列的后续文章中了解其中的原因。</p>
<p>然而，pkg/error 社区的用户不能简单地加入到 Go 1.13 的潮流中去。这里有一个缺口，需要一些交叉兼容的库来弥补这个缺口。</p>
<p>这就是为什么 <a href="https://github.com/cockroachdb/errors/" target="_blank" rel="noopener">CockroachDB 错误库</a>
能够做到这一点。您可以使用它作为 pkg/errors 和 Go 1.13 自己的 errors 包的临时替代。</p>
<blockquote>
<p>原文链接：https://dr-knz.net/cockroachdb-errors-std-api.html</p>
<p>本文作者：Raphael ‘kena’ Poss</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>一道关于 json 和 slice 的题难倒了 80% 的人</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/interview-slice-json/</link>
			<pubDate>Sun, 18 Oct 2020 14:18:50 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/interview-slice-json/</guid>
			<description>昨天在 Go语言爱好者周刊：第 65 期 刊首语发了一道题，以下代码输出什么？ package main import ( &amp;#34;encoding/json&amp;#34; &amp;#34;fmt&amp;#34; ) type AutoGenerated struct { Age int `json:&amp;#34;age&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` Child []int `json:&amp;#34;child&amp;#34;` } func main() { jsonStr1 := `{&amp;#34;age&amp;#34;: 14,&amp;#34;name&amp;#34;: &amp;#34;potter&amp;#34;, &amp;#34;child&amp;#34;:[1,2,3]}` a := AutoGenerated{} json.Unmarshal([]byte(jsonStr1), &amp;amp;a) aa := a.Child fmt.Println(aa) jsonStr2 := `{&amp;#34;age&amp;#34;: 12,&amp;#34;name&amp;#34;: &amp;#34;potter&amp;#34;, &amp;#34;child&amp;#34;:[3,4,5,7,8,9]}` json.Unmarshal([]byte(jsonStr2), &amp;amp;a) fmt.Println(aa) } 结果 80% 的人都答错了。 结果为什么是 [1 2 3] [3 4 5] 呢？ 这道题涉及到两个知识点： json 解析； slice； 1、json 解析 关于 json.Unmarshal 的文档，不少人可能没认真看。借此机会正好一起看下。https://docs.st</description>
			<content type="html"><![CDATA[<p>昨天在 <a href="https://mp.weixin.qq.com/s/CqcOPluw5RFMYRzrnWCoHA" target="_blank" rel="noopener">Go语言爱好者周刊：第 65 期</a>
 刊首语发了一道题，以下代码输出什么？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;encoding/json&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">AutoGenerated</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Age</span>   <span class="kt">int</span>    <span class="s">`json:&#34;age&#34;`</span>
	<span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
	<span class="nx">Child</span> <span class="p">[]</span><span class="kt">int</span>  <span class="s">`json:&#34;child&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">jsonStr1</span> <span class="o">:=</span> <span class="s">`{&#34;age&#34;: 14,&#34;name&#34;: &#34;potter&#34;, &#34;child&#34;:[1,2,3]}`</span>
	<span class="nx">a</span> <span class="o">:=</span> <span class="nx">AutoGenerated</span><span class="p">{}</span>
	<span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">jsonStr1</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">aa</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Child</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">aa</span><span class="p">)</span>
	<span class="nx">jsonStr2</span> <span class="o">:=</span> <span class="s">`{&#34;age&#34;: 12,&#34;name&#34;: &#34;potter&#34;, &#34;child&#34;:[3,4,5,7,8,9]}`</span>
	<span class="nx">json</span><span class="p">.</span><span class="nf">Unmarshal</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">jsonStr2</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">aa</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果 80% 的人都答错了。</p>
<p><p class="md__image">
  <img src="../imgs/json01.png"
    alt=""  />
</p>
</p>
<p>结果为什么是 [1 2 3] [3 4 5] 呢？</p>
<p>这道题涉及到两个知识点：</p>
<ul>
<li>json 解析；</li>
<li>slice；</li>
</ul>
<h2 id="1json-解析">1、json 解析</h2>
<p>关于 json.Unmarshal 的文档，不少人可能没认真看。借此机会正好一起看下。<a href="https://docs.studygolang.com/pkg/encoding/json/#Unmarshal">https://docs.studygolang.com/pkg/encoding/json/#Unmarshal</a>。</p>
<blockquote>
<p>Unmarshal 解析 JSON 编码的数据，并将结果存入 v 指向的值。如果 v 为 nil 或不是指针，则 Unmarshal 返回 InvalidUnmarshalError。</p>
<p>Unmarshal 和 Marshal 做相反的操作，必要时申请 map、slice 或指针，有如下的附加规则：</p>
<ul>
<li>
<p>为了将 JSON 数据解码写入一个指针，Unmarshal 首先处理 JSON 数据为 JSON 字面值 null 的情况。此时，Unmarshal 会将指针设置为 nil。否则，Unmarshal 会将 JSON 数据解码为指针所指向的值。如果指针为 nil，则 Unmarshal 为其分配一个新值并使指针指向它。</p>
</li>
<li>
<p>为了将 JSON 数据解码为实现 Unmarshaler 接口的值，Unmarshal 调用该值的 UnmarshalJSON 方法，包括当输入为 JSON  null 时。否则，如果该值实现 encoding.TextUnmarshaler 且输入是带引号的 JSON 字符串，则 Unmarshal 会使用该字符串的未加引号形式来调用该值的 UnmarshalText 方法。</p>
</li>
<li>
<p>要将 json 数据解码写入一个结构体，函数会匹配输入对象的键和 Marshal 使用的键（结构体字段名或者它的标签指定的键名），优先选择精确的匹配，但也接受大小写不敏感的匹配；</p>
</li>
<li>
<p>为了将 JSON 数据解码到结构中，Unmarshal 将传入的对象键与 Marshal 使用的键（结构字段名称或其 Tag）进行匹配，希望使用精确匹配，但还接受不区分大小写的匹配。默认情况下，没有相应结构字段的对象键将被忽略（有关替代方法，请参见 Decoder.DisallowUnknownFields）。</p>
</li>
<li>
<p>要将 JSON 数据解码写入一个接口类型值，Unmarshal 将其中之一存储在接口值中：</p>
<pre><code>Bool                   对应JSON布尔类型
float64                对应JSON数字类型
string                 对应JSON字符串类型
[]interface{}          对应JSON数组
map[string]interface{} 对应JSON对象
nil                    对应JSON的null
</code></pre></li>
<li>
<p>要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。</p>
</li>
<li>
<p>为了将 JSON 数组解码为 Go 数组，Unmarshal 将 JSON 数组元素解码为对应的 Go 数组元素。如果 Go 数组长度小于 JSON 数组，则其他 JSON 数组元素将被丢弃。如果 JSON 数组长度小于 Go 数组，则将其他 Go 数组元素会设置为零值。</p>
</li>
<li>
<p>要将 JSON 对象解码到 map 中，Unmarshal 首先要建立将使用的 map。如果 map 为零，Unmarshal 会分配一个新 map。否则，Unmarshal 会重用现有 map，保留现有条目（item）。然后，Unmarshal 将来自 JSON 对象的键/值对存储到 map 中。map 的键类型必须是任意字符串类型、整数或实现了 json.Unmarshaler 或 encoding.TextUnmarshaler 接口的类型。</p>
</li>
<li>
<p>如果 JSON 值不适用于给定的目标类型，或者 JSON 数字写入目标类型时溢出，则 Unmarshal 会跳过该字段并尽最大可能完成解析。如果没有遇到更多的严重错误，则 Unmarshal 返回一个 UnmarshalTypeError 来描述最早的此类错误。但无法确保有问题的字段之后的所有其余字段都将被解析到目标对象中。</p>
</li>
<li>
<p>JSON 的 null 值解码为 Go 的接口、指针、切片时会将它们设为 nil，因为 null 在 JSON 里一般表示“不存在”。 因此将 JSON null 解码到任何其他 Go 类型中不会影响该值，并且不会产生任何错误。</p>
</li>
<li>
<p>解析带引号的字符串时，无效的 UTF-8 或无效的 UTF-16 不会被视为错误。而是将它们替换为 Unicode 字符 U+FFFD。</p>
</li>
</ul>
</blockquote>
<p>跟此题相关的是下面这点：</p>
<blockquote>
<p>要将一个 JSON 数组解码到切片（slice）中，Unmarshal 将切片长度重置为零，然后将每个元素 append 到切片中。特殊情况，如果将一个空的 JSON 数组解码到一个切片中，Unmarshal 会用一个新的空切片替换该切片。</p>
</blockquote>
<p>因此第一次解析时，a.Child 是 [1 2 3]，aa 自然也是 [1 2 3]。第二次解析时，a.Child 的长度会被重置为 0，也就说里面的值会被重置（比如 a.Child = a.Child[:0]），然后将 3,4,5,7,8,9 一个个 append 到 a.Child 中。</p>
<p>而 append 操作可能会涉及到底层数组的扩容：当原来的容量不足时，会进行扩容。怎么扩容的呢？目前的版本（Go1.15.x）按照如下规则扩容：（扩容规则依赖具体实现，不同版本可能不一样）</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Get element of array, growing if necessary.
</span><span class="c1"></span><span class="k">if</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Kind</span><span class="p">()</span> <span class="o">==</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span> <span class="p">{</span>
  <span class="c1">// Grow slice if necessary
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Cap</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Cap</span><span class="p">()</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Cap</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="mi">4</span> <span class="p">{</span>
      <span class="nx">newcap</span> <span class="p">=</span> <span class="mi">4</span>
    <span class="p">}</span>
    <span class="nx">newv</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">MakeSlice</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Type</span><span class="p">(),</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Len</span><span class="p">(),</span> <span class="nx">newcap</span><span class="p">)</span>
    <span class="nx">reflect</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">newv</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="nx">v</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">newv</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">v</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v</span><span class="p">.</span><span class="nf">SetLen</span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>初始容量最小为 4；</li>
<li>之后按照容量的一半扩容，所以容量是 4、6、9、13、19&hellip;</li>
</ul>
<p>有人问上题为什么 aa 的容量是 4，这里正好解释了。</p>
<p>因此，第一次解析，aa.Child 是：[1 2 3]，cap = 4。第二次解析，aa.Child 先被重置，之后将 3,4,5,7,8,9 一个个 append，最后 aa.Child 是：[3 4 5 6 7 8 9], cap = 6。</p>
<h2 id="2slice">2、slice</h2>
<p>以上就是能从 json Unmarshal 文档能学到的相关知识。接下来关键在于 slice。关于 slice 的知识，网上很多教程，这里只讲解和该题相关的内容。</p>
<p>1）aa := a.Child 意味着什么？</p>
<p>先看 a.Child 的内部结构。</p>
<p><p class="md__image">
  <img src="../imgs/json02.png"
    alt=""  />
</p>
</p>
<p>赋值给 aa 后呢？aa 和 a.Child 共用底层数组。</p>
<p><p class="md__image">
  <img src="../imgs/json03.png"
    alt=""  />
</p>
</p>
<p>这里有引入一个小知识点，aa := a.Child 后，以下代码输出的两个地址是一样的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p,%p\n&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Child</span><span class="p">,</span> <span class="nx">aa</span><span class="p">)</span>
</code></pre></div><p>它们输出的都是底层数组的地址，这里一定要注意。通过它们，你可以验证底层数组扩容了（地址变了，表明扩容了）。</p>
<p>如果要输出 slice 本身的地址，应该这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%p,%p\n&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">.</span><span class="nx">Child</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">aa</span><span class="p">)</span>
</code></pre></div><p>2）执行第二次 json 解析后</p>
<p>根据上文的讲解，底层数组从索引 0 位置开始依次被 3、4、5、7 填充。因为 aa 的 len 是 3，所以即使底层数组变成了 3、4、5、7，aa 看到却是 3、4、5。</p>
<p>当再继续解析时，底层数组容量不够，因此进行扩容，cap 变成 6，将原底层数组的元素拷贝一份到新的数组中。所以最后 a.Child 的底层数组是这个新的底层数组：[3 4 5 7 8 9]，cap = 6。而 aa 的底层数组还是原来的。最后的内部表示是这样的。</p>
<p><p class="md__image">
  <img src="../imgs/json04.png"
    alt=""  />
</p>
</p>
<h2 id="3小结">3、小结</h2>
<p>总结起来两点：</p>
<ul>
<li>json 解析的规则，文档上明确说明了；（有人评论说跟 json 没关系，但我觉得很多人根本不知道 json 对这块是怎么处理的，正因为有这样的处理，才引出了 slice 扩容的问题）</li>
<li>slice 内部表示和 append 导致扩容。</li>
</ul>
<p>希望你已经彻底掌握了以上知识点。</p>
]]></content>
		</item>
		
		<item>
			<title>你喜欢的 Go 第三方库：一步为系统集成可视化实时运行时统计</title>
			<link>https://polarisxu.studygolang.com/posts/go/pkg/statsviz/</link>
			<pubDate>Thu, 15 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/pkg/statsviz/</guid>
			<description>大家好，我是站长 polarisxu。 掌握系统运行状态，知道系统哪些地方可能存在问题，方便进行优化，这是一个实际系统必备的。裸奔，对系统一无所知，迟早是要出大事的。 在 Go 语言中，官方标准库提供了方法，让我们能够获得内存分配、GC 和 Goroutine 等情况。比如内存、GC 等情况，可以通过 runtime.MemStats 获取：https://docs.studygolang.com/pkg/runtime/#M</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>掌握系统运行状态，知道系统哪些地方可能存在问题，方便进行优化，这是一个实际系统必备的。裸奔，对系统一无所知，迟早是要出大事的。</p>
<p>在 Go 语言中，官方标准库提供了方法，让我们能够获得内存分配、GC 和 Goroutine 等情况。比如内存、GC 等情况，可以通过 runtime.MemStats 获取：<a href="https://docs.studygolang.com/pkg/runtime/#MemStats">https://docs.studygolang.com/pkg/runtime/#MemStats</a>，Goroutine 数量可以通过 runtime.NumGoroutine() 函数获得。</p>
<p>一般我们我们需要自己解析 MemStats 信息、做展示，也可以做图表。</p>
<p>今天我给大家推荐一个库：<a href="https://github.com/arl/statsviz">https://github.com/arl/statsviz</a>，它是一个在浏览器中实时查看 Go 应用程序运行时统计信息（GC，MemStats 等）的库。</p>
<p>它能展示的信息如下图：</p>
<p><p class="md__image">
  <img src="../imgs/statsviz01.png"
    alt=""  />
</p>
</p>
<p>再看其中 Heap 的实时动图：</p>
<p><p class="md__image">
  <img src="../imgs/statsviz02.gif"
    alt=""  />
</p>
</p>
<p>上面这些通过运行下面这段代码就可以了：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math/rand&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;strconv&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/arl/statsviz&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Force the GC to work to make the plots &#34;move&#34;.
</span><span class="c1"></span>	<span class="k">go</span> <span class="nf">work</span><span class="p">()</span>

	<span class="c1">// Register statsviz handlers on the default serve mux.
</span><span class="c1"></span>	<span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">work</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Generate some allocations
</span><span class="c1"></span>	<span class="nx">m</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">byte</span><span class="p">{}</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">512</span><span class="o">+</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">1024</span><span class="p">))</span>
		<span class="nx">m</span><span class="p">[</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">100</span><span class="p">))]</span> <span class="p">=</span> <span class="nx">b</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">byte</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="1如何使用">1、如何使用</h2>
<blockquote>
<p>都 Go1.15.x 了，请使用 go module。</p>
</blockquote>
<p>statsviz 的使用很简单。假设基于 net/http 使用。</p>
<ul>
<li>import &ldquo;github.com/arl/statsviz”</li>
<li>注册 statsviz HTTP handlers</li>
<li>启动程序</li>
<li>打开浏览器访问：http://host:port/debug/statsviz</li>
<li>尽情享受吧~</li>
</ul>
<p>具体看看实际中怎么集成到项目中，根据可能的情况分别介绍。</p>
<h3 id="基于-nethttp">基于 net/http</h3>
<p>如果你的项目没有使用框架，直接基于 net/http；或者你的项目并没有提供 HTTP 服务。集成 statsviz 可以按照下面的方式。</p>
<p><strong>1）一个使用 net/http 的 Web 项目</strong></p>
<p>只需要 import statsviz 包后，在注册路由的地方加上如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
</code></pre></div><p>这是使用默认的 http.DefaultServeMux，如果你使用的是自定义 Mux，则加上如下类似如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">mux</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewServeMux</span><span class="p">()</span>
<span class="nx">statsviz</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nx">mux</span><span class="p">)</span>
</code></pre></div><p>其中，mux 使用你定义好的。</p>
<p>实际上，statsviz.RegisterDefault() 内部是这么实现的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RegisterDefault</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">Register</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">DefaultServeMux</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><strong>2）没有提供 HTTP 服务的项目</strong></p>
<p>这时最简单的方式就是使用 statsviz.RegisterDefault() ，同时需要启动一个 HTTP 服务：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div><h3 id="基于兼容-nethttp-的框架">基于兼容 net/http 的框架</h3>
<p>因为兼容 net/http 框架，因此可以直接将 statsviz 的 Handler 集成进去。比如对于 gorilla/mux 库，可以这么做：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">r</span> <span class="o">:=</span> <span class="nx">mux</span><span class="p">.</span><span class="nf">NewRouter</span><span class="p">()</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">Path</span><span class="p">(</span><span class="s">&#34;/debug/statsviz/ws&#34;</span><span class="p">).</span><span class="nf">Name</span><span class="p">(</span><span class="s">&#34;GET /debug/statsviz/ws&#34;</span><span class="p">).</span><span class="nf">HandlerFunc</span><span class="p">(</span><span class="nx">statsviz</span><span class="p">.</span><span class="nx">Ws</span><span class="p">)</span>
<span class="nx">r</span><span class="p">.</span><span class="nf">Methods</span><span class="p">(</span><span class="s">&#34;GET&#34;</span><span class="p">).</span><span class="nf">PathPrefix</span><span class="p">(</span><span class="s">&#34;/debug/statsviz/&#34;</span><span class="p">).</span><span class="nf">Name</span><span class="p">(</span><span class="s">&#34;GET /debug/statsviz/&#34;</span><span class="p">).</span><span class="nf">Handler</span><span class="p">(</span><span class="nx">statsviz</span><span class="p">.</span><span class="nx">Index</span><span class="p">)</span>

<span class="nx">mux</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewServeMux</span><span class="p">()</span>
<span class="nx">mux</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
<span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">,</span> <span class="nx">mux</span><span class="p">)</span>
</code></pre></div><p>这里主要是 statsviz.Ws 和 statsviz.Index，因为 gorilla/mux 库兼容 net/http，所以可以这么做。</p>
<h3 id="不兼容-nethttp-的框架">不兼容 net/http 的框架</h3>
<p>比如集成进 Gin 框架。做法就是和“没有提供 HTTP 服务的项目”一样，另开一个 HTTP 端口。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div><p>因此这里实际上和具体框架没关系。</p>
<h3 id="最佳实践">最佳实践</h3>
<p>因为 runtime 信息属于系统内部信息，不适合暴露给公网用户。因此，实际上中，最佳实践是，不管什么情况下，都单独开一个 HTTP 端口，类似下面这样，对公网不可访问。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div><h2 id="原理简单说明">原理简单说明</h2>
<p>该库使用 WebSocket 协议，定时将系统的 runtime 数据发送给浏览器，浏览器接收到之后，利用 JS 绘制图表，展示出来。Go 核心代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sendStats indefinitely send runtime statistics on the websocket connection.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">sendStats</span><span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">defaultSendPeriod</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">tick</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

	<span class="kd">var</span> <span class="nx">stats</span> <span class="nx">stats</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
			<span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">stats</span><span class="p">.</span><span class="nx">Mem</span><span class="p">)</span>
			<span class="nx">stats</span><span class="p">.</span><span class="nx">NumGoroutine</span> <span class="p">=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">NumGoroutine</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">WriteJSON</span><span class="p">(</span><span class="nx">stats</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>对客户端代码感兴趣的请自行阅读源码。</p>
<h2 id="总结">总结</h2>
<p>如果你需要实时图表的方式查看系统运行时的一些数据，可以尝试下它。用类似这样几行代码一步将它集成进你的系统：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">statsviz</span><span class="p">.</span><span class="nf">RegisterDefault</span><span class="p">()</span>
  <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;localhost:8080&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}()</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Go Playground 还能这么玩？</title>
			<link>https://polarisxu.studygolang.com/posts/go/project/usingg-gpgsync/</link>
			<pubDate>Fri, 09 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/project/usingg-gpgsync/</guid>
			<description>大家好，我是 polarisxu。 之前我为大家推荐过 Playground，对比了三款 Go Playground 。今天发现了另外一款 Playground，它最核心的特点是，可以多人协同编辑。 协同编辑，目前是很流行的一种多人协作模式。GitHub 的编辑器 Atom 就有这方面的支持。 简介 先简单看看这款 Playground：gpgsync。这是 syumai 开发的一款多人协同编辑的 Go Playground，他是</description>
			<content type="html"><![CDATA[<p>大家好，我是 polarisxu。</p>
<p>之前我为大家推荐过 Playground，<a href="https://mp.weixin.qq.com/s/SYngjiM8M2T6KS0OQNonCQ" target="_blank" rel="noopener">对比了三款 Go Playground</a>
。今天发现了另外一款 Playground，它最核心的特点是，可以多人协同编辑。</p>
<p>协同编辑，目前是很流行的一种多人协作模式。GitHub 的编辑器 Atom 就有这方面的支持。</p>
<h2 id="简介">简介</h2>
<p>先简单看看这款 Playground：gpgsync。这是 <a href="https://github.com/syumai" target="_blank" rel="noopener">syumai</a>
 开发的一款多人协同编辑的 Go Playground，他是一个 TypeScript 和 Go 爱好者。</p>
<p>项目地址：<a href="https://github.com/syumai/gpgsync">https://github.com/syumai/gpgsync</a>，这是一个 Node 项目，你可以本地搭建，也可以直接试用作者提供的 Demo：<a href="https://gpgsync.herokuapp.com/">https://gpgsync.herokuapp.com/</a>。</p>
<h2 id="如何使用">如何使用</h2>
<p>打开 <a href="https://gpgsync.herokuapp.com/">https://gpgsync.herokuapp.com/</a>，会让你提供一个 Room ID，可以使用随机生成的，也可以自定义。</p>
<p><p class="md__image">
  <img src="../imgs/gpgsync01.png"
    alt=""  />
</p>
</p>
<p>点击 Join 后，进入编辑界面。</p>
<p><p class="md__image">
  <img src="../imgs/gpgsync02.png"
    alt=""  />
</p>
</p>
<p>这个界面和官方的 Playground 基本类似，但多了一个 Options。这个功能来自作者的另一个项目：<a href="https://github.com/syumai/go-playground-custom">https://github.com/syumai/go-playground-custom</a>，好吧，又一个 Playground。这个项目的目标是为 Playground 提供一些额外的特性，包括：</p>
<ul>
<li>基于 CodeMirror 的丰富编辑器；
<ul>
<li>语法高亮（官方 Playground 是不支持语法高亮的）；</li>
<li>Vim 模式（我太喜欢这点了）；</li>
</ul>
</li>
<li>go2go 支持。这是对 Go 泛型的支持；</li>
</ul>
<p>点击 Options 后，在底部有相关配置：</p>
<p><p class="md__image">
  <img src="../imgs/gpgsync03.png"
    alt=""  />
</p>
</p>
<p>回到主题。</p>
<p>当你进入后，你可以将你的 Room ID 告诉你的协作者，或者直接复制链接发给 TA，你们就可以协同了。你或 TA 的改动，另一方能实时看到。</p>
<p>我的 Room：<a href="https://gpgsync.herokuapp.com/rooms/polarisxu">https://gpgsync.herokuapp.com/rooms/polarisxu</a>，大家可以试试，看看一堆人是啥效果，会不会崩溃~</p>
<p>你自己想单独试验，可以开两个浏览器看看效果。</p>
<p><strong>特别说明</strong>：最终的运行是交给 play.golang.org 的，因此要实际运行，请自备梯子。</p>
<h2 id="有啥用">有啥用</h2>
<p>我想到的有两点：</p>
<ul>
<li>请教大牛问题，实时看 TA 怎么写代码的；</li>
<li>面试，特别远程面试时，可以让对方通过这个写代码，你实时看到对方的整个 coding 过程；</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>终于找到了一款我喜欢的安装和管理 Go 版本的工具</title>
			<link>https://polarisxu.studygolang.com/posts/go/project/go-version-manager/</link>
			<pubDate>Fri, 09 Oct 2020 18:12:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/project/go-version-manager/</guid>
			<description>一直以来，我都习惯通过源码安装 Go。我是这么做的： 1）Git clone Go 源码 $ git clone https://github.com/golang/go 2）需要安装什么版本就切换到对应的分支，比如安装 1.15.x $ git checkout -b release-branch.go1.15 origin/release-branch.go1.15 如果本地之前已经存在该分支，直接 git checkout release-branch.go1.15 即可。 3）将 go 整个目录复制到 /usr/local/go1.15，编译安装 4）创建软链： ln -s go1.15 go 之后加上环境变量等。 如果想要切换版本，只需要做类似上面的步骤，最后将 go 这个软链指向要切换的</description>
			<content type="html"><![CDATA[<p>一直以来，我都习惯通过源码安装 Go。我是这么做的：</p>
<p>1）Git clone Go 源码</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git clone https://github.com/golang/go
</code></pre></div><p>2）需要安装什么版本就切换到对应的分支，比如安装 1.15.x</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git checkout -b release-branch.go1.15 origin/release-branch.go1.15
</code></pre></div><p>如果本地之前已经存在该分支，直接 git checkout release-branch.go1.15 即可。</p>
<p>3）将 go 整个目录复制到 /usr/local/go1.15，编译安装</p>
<p>4）创建软链：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">ln -s go1.15 go
</code></pre></div><p>之后加上环境变量等。</p>
<p>如果想要切换版本，只需要做类似上面的步骤，最后将 go 这个软链指向要切换的版本。</p>
<p>我这种方式存在两个问题：</p>
<ul>
<li>因为 Go1.5 实现了自举，对于没有安装 Go 的系统，需要先安装 Go1.4；</li>
<li>每次都编译，还是没那么方便，而且如果是 Windows 系统，可能会有一些问题（现在的 Windows 也可能没问题了？好久没使用 Windows 了，使用 Windows 的朋友可以留言告知下）；</li>
</ul>
<p>之后看到 <a href="https://github.com/moovweb/gvm" target="_blank" rel="noopener">gvm</a>
 这个工具，我试用了，可能是国内网络的原因，根本没法安装 Go，基本卡着不动。此外还有一些其他的解决方案，比如 <a href="https://github.com/syndbg/goenv" target="_blank" rel="noopener">goenv</a>
，这是仿照 pyenv 和 rbenv 实现的，安装配置感觉略微有点复杂，直接没尝试。</p>
<p>今天发现另外一个工具，和我手动管理多版本的思路类似，所以爱上了！</p>
<h2 id="1开发-goup-的初衷">1、开发 goup 的初衷</h2>
<p>发音：Go Up。作者介绍，他开发了这个工具的原因：</p>
<p>1）操作系统发行版的包管理工具一般不会那么及时的升级 Go 到最新版本，特别是 Linux 发行版；</p>
<p>2）虽然安装和管理 Go 版本的工具不少，但作者认为要么存在一些问题，要么体验不好或缺失一些功能；（哈哈哈，很有道理是不是？造一个轮子，总是觉得别人的不够圆，自己的又大又圆，有木有？）</p>
<p>作者想要一个这样的工具：</p>
<ul>
<li>不需要先安装了 Go 的某个版本；（我上面的管理方案就是需要先安装某个版本）</li>
<li>这个工具本身安装足够简单，最好一行命令搞定；</li>
<li>跨平台，在所有操作系统运行良好，至少在类 Unix 系统运行良好；</li>
<li>能方便的安装最新的 Go 版本；</li>
<li>能方便的安装 Go 的任意版本，包括 tip；</li>
<li>不会污染你的 Shell；</li>
<li>使用 Go 语言实现；</li>
</ul>
<h2 id="2安装-goup">2、安装 goup</h2>
<p>因为 goup 本身是 Go 语言实现的，因此他通过一个脚本下载对应系统的预编译 goup 程序。当前最新版本 0.0.7 （这个工具是 9 月底开发的），当然你也可以自己手动下载这些编译好 goup 程序。（如果你本地安装了 Go 版本，直接 go get -u -v github.com/owenthereal/goup/&hellip; 安装也是可以的）</p>
<p><p class="md__image">
  <img src="../imgs/goup01.png"
    alt=""  />
</p>
</p>
<p>一行代码安装 goup（推荐的方式）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl -sSf https://raw.githubusercontent.com/owenthereal/goup/master/install.sh <span class="p">|</span> sh
</code></pre></div><h2 id="3使用介绍">3、使用介绍</h2>
<p>看看 goup 的帮助文档：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ goup <span class="nb">help</span>
The Go installer

Usage:
  goup <span class="o">[</span>command<span class="o">]</span>

Available Commands:
  <span class="nb">help</span>        Help about any <span class="nb">command</span>
  init        Initialize the goup environment file.
  install     Install Go by providing a version <span class="o">(</span>e.g. <span class="s2">&#34;1.15.2&#34;</span>, or <span class="s2">&#34;tip&#34;</span><span class="o">)</span>. If empty, use the latest version.
  show        Show the current version of installed Go
  version     Show goup version

Flags:
  -h, --help   <span class="nb">help</span> <span class="k">for</span> goup

Use <span class="s2">&#34;goup [command] --help&#34;</span> <span class="k">for</span> more information about a command.
</code></pre></div><ul>
<li>install：安装对应的 Go 版本，也可以是 tip。如果不提供版本，则安装当前最新版本；</li>
<li>show：显示当前生效的 Go 版本；</li>
<li>init：会在 <code>$HOME/.go</code> 目录下生成一个 env 文件，内容是设置 PATH 环境变量，即将 <code>$HOME/.go/bin</code> 和 <code>$HOME/.go/current/bin</code> 加入 PATH 中；同时会往一些系统配置文件中加上 <code>source &quot;$HOME/.go/env&quot;</code>；</li>
</ul>
<p>比如我想试试还不支持 Module 的版本：1.10.8</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ goup install 1.10.8
Downloaded   0.0% <span class="o">(</span>    <span class="m">3320</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded   3.7% <span class="o">(</span> <span class="m">3260416</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  11.7% <span class="o">(</span><span class="m">10338304</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  21.1% <span class="o">(</span><span class="m">18563072</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  27.9% <span class="o">(</span><span class="m">24592384</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  34.8% <span class="o">(</span><span class="m">30588928</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  41.6% <span class="o">(</span><span class="m">36618240</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  48.4% <span class="o">(</span><span class="m">42549248</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  55.2% <span class="o">(</span><span class="m">48611328</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  62.1% <span class="o">(</span><span class="m">54640640</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  68.9% <span class="o">(</span><span class="m">60669952</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  75.8% <span class="o">(</span><span class="m">66666496</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  82.6% <span class="o">(</span><span class="m">72695808</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  88.8% <span class="o">(</span><span class="m">78135296</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  93.3% <span class="o">(</span><span class="m">82100224</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  94.4% <span class="o">(</span><span class="m">83083264</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded  98.7% <span class="o">(</span><span class="m">86851584</span> / <span class="m">87999054</span> bytes<span class="o">)</span> ...
Downloaded 100.0% <span class="o">(</span><span class="m">87999054</span> / <span class="m">87999054</span> bytes<span class="o">)</span>
INFO<span class="o">[</span>0016<span class="o">]</span> Unpacking /Users/xuxinhua/.go/go1.10.8/go1.10.8.darwin-amd64.tar.gz ...
INFO<span class="o">[</span>0020<span class="o">]</span> Success: go1.10.8 downloaded in /Users/xuxinhua/.go/go1.10.8
INFO<span class="o">[</span>0020<span class="o">]</span> Default Go is <span class="nb">set</span> to <span class="s1">&#39;go1.10.8&#39;</span>
</code></pre></div><p>你当前系统的 Go 版本就是 1.10.8 了。如果之前安装过，上面的下载过程就没有了：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ goup install 1.10.8
INFO<span class="o">[</span>0000<span class="o">]</span> go1.10.8: already downloaded in /Users/xuxinhua/.go/go1.10.8
INFO<span class="o">[</span>0000<span class="o">]</span> Default Go is <span class="nb">set</span> to <span class="s1">&#39;go1.10.8&#39;</span>

$ goup show
go1.10.8
</code></pre></div><p>尽情地享受吧！</p>
<h2 id="4工作原理">4、工作原理</h2>
<p>这个工具的灵感来自 Rust 的工具：<a href="https://rustup.rs/" target="_blank" rel="noopener">rustup</a>
。</p>
<p>它的工作原理很简单，在 <code>$HOME/.go</code> 目录下创建对应的版本目录，然后在这个目录创建一个软链 current 来控制当前使用哪个 Go 版本。这个思路和我一直源码安装的思路类似。唯一区别是，它是从 dl.google.com 上下载对应编译好的版本。但 tip 版本，则需要 clone Go 源码，进行编译安装，因此要求有 Go 环境。</p>
<p>我本地 <code>$HOME/.go</code> 下的文件信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">lrwxr-xr-x   <span class="m">1</span> xuxinhua  staff   <span class="m">28</span> <span class="m">10</span>  <span class="m">9</span> 17:16 current -&gt; /Users/xuxinhua/.go/go1.10.8
-rw-r--r--   <span class="m">1</span> xuxinhua  staff   <span class="m">57</span> <span class="m">10</span>  <span class="m">9</span> 16:46 env
drwxr-xr-x  <span class="m">21</span> xuxinhua  staff  <span class="m">672</span> <span class="m">10</span>  <span class="m">9</span> 17:14 go1.10.8
drwxr-xr-x  <span class="m">22</span> xuxinhua  staff  <span class="m">704</span> <span class="m">10</span>  <span class="m">9</span> 10:03 go1.14.9
drwxr-xr-x  <span class="m">22</span> xuxinhua  staff  <span class="m">704</span> <span class="m">10</span>  <span class="m">9</span> 10:02 go1.15.2
drwxr-xr-x   <span class="m">2</span> xuxinhua  staff   <span class="m">64</span> <span class="m">10</span>  <span class="m">9</span> 17:10 gotip
</code></pre></div><h2 id="5存在的一些问题">5、存在的一些问题</h2>
<p>这个工具才出来十几天，试用下来，还存在一些问题：</p>
<ul>
<li>安装最新版本，需要知道当前最新版本是哪个？这是从 <a href="https://golang.org/VERSION?m=text">https://golang.org/VERSION?m=text</a> 获取的，但这个网址咱们无法访问；同样的道理，安装 tip 版本，源码是从 <a href="https://go.googlesource.com/go">https://go.googlesource.com/go</a> 获取的。因此目前大陆还无法使用；不过我已经给作者提了 issue，应该很快就会支持；</li>
<li>缺失一些功能。比如我想安装某个版本，比如 1.12.x，但我希望安装的是 1.12 系列的最新版本，这时候你只能去找 1.12 的最新版本是哪个。</li>
<li>。。。</li>
</ul>
<p>我参照 gvm 提供的功能，给 goup 作者提了 issue，希望增加如下功能：</p>
<ul>
<li>goup list 和 goup listall</li>
<li>goup uninstall</li>
</ul>
<h2 id="6小结">6、小结</h2>
<p>整体上，目前 goup 的使用还是比较顺畅的。欢迎大家试用，可以顺便给个 star。对了，项目地址：<a href="https://github.com/owenthereal/goup">https://github.com/owenthereal/goup</a>。</p>
<p>对了，至于为什么会需要管理多版本，我想很多人还会有这样的需求吧？！你为什么需要呢？欢迎留言。</p>
<h2 id="7更新">7、更新</h2>
<p>上面提到的点，目前差不多解决了。</p>
<ul>
<li>提供了 goup ls-ver 命令列出 Go 版本</li>
<li>提供 goup remove 命令删除某个已安装的 Go 版本</li>
<li>还提供了 goup upgrade 来升级自己</li>
</ul>
<p>此外当执行 goup install 时，默认会安装当前最新发布版本，大陆会有问题，可以通过如下方式解决：</p>
<blockquote>
<p>GOUP_GO_HOST=golang.google.cn goup install</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>题解：竟然半数以上的人做错了，基础真的很重要</title>
			<link>https://polarisxu.studygolang.com/posts/basic/complement/</link>
			<pubDate>Sat, 03 Oct 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/basic/complement/</guid>
			<description>双节发布了两道题： 题一： package main func main() { var a int8 = -1 var b int8 = -128 / a println(b) } 题二： package main func main() { const a int8 = -1 var b int8 = -128 / a println(b) } 答对的人真不多（半数以上答错了），特别是题一，一半以上竟然是 128，难道不知道 int8 能表示的范围吗？[-128, 127]。不过为什么答案是：题一 -128，题二编译错误？ 其实这是一道计算机基础题。 先看看网友 Jayce 的解释：第一题是 -128（untyped const）</description>
			<content type="html"><![CDATA[<p>双节发布了两道题：</p>
<p>题一：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="kt">int8</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="kt">int8</span> <span class="p">=</span> <span class="o">-</span><span class="mi">128</span> <span class="o">/</span> <span class="nx">a</span>

	<span class="nb">println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>题二：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">a</span> <span class="kt">int8</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="kd">var</span> <span class="nx">b</span> <span class="kt">int8</span> <span class="p">=</span> <span class="o">-</span><span class="mi">128</span> <span class="o">/</span> <span class="nx">a</span>

	<span class="nb">println</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>答对的人真不多（半数以上答错了），特别是题一，一半以上竟然是 128，难道不知道 int8 能表示的范围吗？[-128, 127]。不过为什么答案是：题一 -128，题二编译错误？</p>
<p>其实这是一道计算机基础题。</p>
<p>先看看网友 Jayce 的解释：第一题是 -128（untyped const）/ -1 (int8 var)，untyped 隐式转换为 int8，刚好在范围内，结果是 128 ，溢出 int8 的范围。因为结果不是常量，允许溢出，最高位为符号位，变成了补码，刚好又是 -128。 第二题 -128 和 -1 都是 const，直接在编译时求值，untyped 的 -128 隐式转 int8，结果为 128，仍然是一个 const。const 转换时不允许溢出，编译错误。 其实差别就是表达式的值，题一不是常量题二是，常量类型转换不允许溢出后 truncate。</p>
<h2 id="关于补码">关于补码</h2>
<p>如果你忘了补码（<code>Two's Complement</code>，2 的补码，一般直接称为补码），这里简单做个说明。</p>
<p>先问一个问题：在计算机内部 -1 二进制表示是什么（假如为 int8）？</p>
<p>我们很容易这么想：1 的二进制是 00000001，而最高位是符号位，因此 -1 是 10000001。因为 1 + (-1) = 0，但 00000001 + 10000001 = 10000010，很显然，这个结果不是 0。这是原码表示。</p>
<p><p class="md__image">
  <img src="../imgs/complement01.png"
    alt="原码形式"  />
</p>
</p>
<p>所以，计算机内部采用补码（Two&rsquo;s Complement）表示负数。补码怎么得到呢？一般分两步：</p>
<p><p class="md__image">
  <img src="../imgs/complement02.png"
    alt="-1的补码表示"  />
</p>
</p>
<ul>
<li>
<p>第一步，每一个二进制位都取相反值，0 变成 1，1 变成 0。比如，00000001 的相反值就是 11111110。</p>
</li>
<li>
<p>第二步，将上一步得到的值加 1。11111110 就变成 11111111。</p>
</li>
</ul>
<p><p class="md__image">
  <img src="../imgs/complement03.png"
    alt="补码形式的加法"  />
</p>
</p>
<p>关于原码、反码和补码，可以看这篇文章：<a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html</a>，很详细。</p>
<h2 id="题解">题解</h2>
<h3 id="先看题一">先看题一</h3>
<p>因为 <code>var b int8 = -128 / a</code> 不是常量表达式，因此 untyped 常量 -128 隐式转换为 int8 类型（即和 a 的类型一致），所以 <code>-128 / a</code> 的结果是 int8 类型，值是 128，超出了 int8 的范围。因为结果不是常量，允许溢出，128 的二进制表示是 10000000，正好是 -128 的补码。所以，第一题的结果是 -128。</p>
<blockquote>
<p>关于整数溢出的 Go 语言规范说明：<a href="https://hao.studygolang.com/golang_spec.html#id158">https://hao.studygolang.com/golang_spec.html#id158</a>。</p>
</blockquote>
<p>在 Go 语言规范中关于整数运算有这样的说明：<a href="https://hao.studygolang.com/golang_spec.html#id327">https://hao.studygolang.com/golang_spec.html#id327</a></p>
<blockquote>
<p>对于两个整数值 x 和 y ，其整数商 q = x / y 和余数 r = x % y 满足如下关系：</p>
<p>x = q*y + r 且 |r| &lt; |y|</p>
<p>这个规则有一个例外，如果对于 x 的整数类型来说，被除数 x 是该类型中最负的那个值，那么，因为 补码 的 整数溢出 ，商 q = x / -1 等于 x （并且 r = 0 ）。</p>
</blockquote>
<p>所以例外情况有：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>x, q 的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>int8</td>
<td>-128</td>
</tr>
<tr>
<td>int16</td>
<td>-32768</td>
</tr>
<tr>
<td>int32</td>
<td>-2147483648</td>
</tr>
<tr>
<td>int64</td>
<td>-9223372036854775808</td>
</tr>
</tbody>
</table>
<h3 id="再看题二">再看题二</h3>
<p>对于 <code>var b int8 = -128 / a</code>，因为 a 是 int8 类型常量，所以 <code>-128 / a</code> 是常量表达式，在编译器计算，结果必然也是常量。因为 a 的类型是 int8，因此 -128 也会隐式转为 int8 类型，128 这个结果超过了 int8 的范围，但常量不允许溢出，因此编译报错。</p>
<h2 id="总结">总结</h2>
<p>这题并非 Go 独有，而是计算机的基础。比如相应的 C 语言程序，结果和 Go 对应程序是一样的。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 对应题一
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span> <span class="o">/</span> <span class="n">a</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>结果 -128。</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// 对应题二
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">128</span> <span class="o">/</span> <span class="n">a</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>编译报错。</p>
]]></content>
		</item>
		
		<item>
			<title>何时使用 Rust 和何时使用 Golang</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/when-to-use-rust-and-when-to-use-golang/</link>
			<pubDate>Wed, 30 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/when-to-use-rust-and-when-to-use-golang/</guid>
			<description>Golang 和 Rust 之间有明显的区别。Golang 更加注重构建可以无限扩展的 Web API 和小型服务，尤其是在 goroutine 的强大支持下。Rust 也可以用于小型服务，但是从开发人员的经验来看，事情要困难得多。 Rust 非常适合处理大量数据和其他 CPU 密集型操作，例如执行算法。这是 Rust 超过 Golang 的最大优势。要求高性能的项目通常更适合 Rust。 在本教程中，我们将就 Golang 和 Rust 进行比较和对比，评估这两种编程语言的性能，并发</description>
			<content type="html"><![CDATA[<p><p class="md__image">
  <img src="../imgs/use-rust-go01.png"
    alt="何时使用Rust和何时使用Golang"  />
</p>
</p>
<p>Golang 和 Rust 之间有明显的区别。Golang 更加注重构建可以无限扩展的 Web API 和小型服务，尤其是在 goroutine 的强大支持下。Rust 也可以用于小型服务，但是从开发人员的经验来看，事情要困难得多。</p>
<p>Rust 非常适合处理大量数据和其他 CPU 密集型操作，例如执行算法。这是 Rust 超过 Golang 的最大优势。要求高性能的项目通常更适合 Rust。</p>
<p>在本教程中，我们将就 Golang 和 Rust 进行比较和对比，评估这两种编程语言的性能，并发性，内存管理和整体开发人员体验。我们还将概述这些元素，以帮助您一目了然地为项目选择正确的语言。</p>
<p>如果您刚开始使用 Rust，那么在继续阅读之前，最好先阅读一下<a href="https://blog.logrocket.com/getting-up-to-speed-with-rust/" target="_blank" rel="noopener">初学者指南</a>
。</p>
<p>如果您全都都准备好了，那就让我们开始吧！</p>
<h2 id="性能">性能</h2>
<p>Golang 最初是由 Google 的工程师设计的，于 2009 年向公众推出。它的创建是为 C++提供替代方案，该替代方案易于学习和编码，并且经过优化可在多核 CPU 上运行。</p>
<p>从那时起，Golang 对于希望利用该语言提供的并发性的开发人员来说非常有用。该语言提供了 goroutine，使您可以将函数作为 goroutine 运行。</p>
<p>Golang 的一大优势是您可以轻松使用 goroutines。只需将<code>go</code>添加到函数前即可使其作为 goroutine 运行。Golang 的并发模型允许您跨多个 CPU 内核部署工作负载，从而使其成为一种非常有效的语言。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">f</span><span class="p">(</span><span class="nx">from</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="s">&#34;:&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="nf">f</span><span class="p">(</span><span class="s">&#34;direct&#34;</span><span class="p">)</span>

    <span class="k">go</span> <span class="nf">f</span><span class="p">(</span><span class="s">&#34;goroutine&#34;</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>尽管有多核 CPU 支持，Rust 仍然跑赢 Golang。Rust 在执行算法和资源密集型操作方面效率更高。该<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html" target="_blank" rel="noopener">基准测试游戏</a>
比较了 rust 和 golang 的不同算法，如二叉树。对于所有经过测试的算法，Rust 至少快 30％；在二叉树计算的情况下，最高可达 1,000％。<a href="https://bitbucket.org/blog/why-rust" target="_blank" rel="noopener">Bitbucket 的</a>
一项研究表明，Rust 与 C++的性能相似。</p>
<p><p class="md__image">
  <img src="../imgs/use-rust-go02.png"
    alt="根据Bitbucket的性能"  />
</p>
</p>
<p><em>（来源：<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html" target="_blank" rel="noopener">基准测试游戏</a>
）</em></p>
<h2 id="并发">并发</h2>
<p>如上所述，Golang 支持并发。例如，假设您正在运行一个处理 API 请求的 Web 服务器。您可以使用 Golang 的 goroutine 程序将每个请求作为 goroutine 运行，通过将任务分发到所有可用的 CPU 内核来最大程度地提高效率。</p>
<p>Goroutines 是 Golang 内置功能的一部分，而 Rust 仅支持本地 async/await 语法来支持并发。因此，在并发方面，Golang 的开发人员有经验优势。但是，Rust 在保证内存安全方面要好得多。</p>
<p>这是 Rust 的简化线程的示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">thread</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">time</span>::<span class="n">Duration</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">   </span><span class="c1">// 1. create a new thread
</span><span class="c1"></span><span class="w">   </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="p">..</span><span class="mi">10</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">         </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;thread: number {}!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">         </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span><span class="w">
</span><span class="w">      </span><span class="p">}</span><span class="w">
</span><span class="w">   </span><span class="p">});</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;hi from the main thread!&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>并发一直是开发人员的棘手问题。在不影响开发人员体验的情况下保证内存安全的并发性并不是一项容易的任务。但是，这种极端的安全重点导致创建了<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" target="_blank" rel="noopener">可证明正确的并发</a>
。Rust 尝试使用所有权概念来防止未经请求的资源访问，以防止出现内存安全错误。</p>
<p>Rust 提供了四种不同的并发范例，以帮助您避免常见的内存安全陷阱。我们将仔细研究两个常见的范例：channel 和锁。</p>
<h3 id="channel">Channel</h3>
<p><a href="https://doc.rust-lang.org/stable/rust-by-example/std_misc/channels.html" target="_blank" rel="noopener">channel</a>
 有助于从一个线程传送消息到另一个。虽然 Golang 也存在此概念，但 Rust 允许您将<a href="https://doc.rust-lang.org/std/primitive.pointer.html" target="_blank" rel="noopener">指针</a>
从一个线程转移到另一个线程，以避免争用资源。通过传递指针，Rust 可以对 channel 强制执行线程隔离。同样，Rust 在并发模型方面表现出对内存安全的痴迷。</p>
<h3 id="锁">锁</h3>
<p>仅当持有<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html" target="_blank" rel="noopener">锁</a>
时才能访问数据。Rust 依赖于锁定数据而不是 cod 的原理，而 cod 经常在诸如 Java 之类的编程语言中找到。</p>
<p>有关所有权和所有并发范例的更多详细信息，请查看“<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html" target="_blank" rel="noopener">使用 Rust 进行无所畏惧的并发</a>
”。</p>
<h2 id="内存安全">内存安全</h2>
<p>较早的所有权概念是 Rust 的主要卖点之一。Rust 将<a href="https://en.wikipedia.org/wiki/Type_safety" target="_blank" rel="noopener">类型安全</a>
提升到了新的水平，这对于实现内存安全的并发性也很重要。</p>
<p>根据<a href="https://bitbucket.org/blog/why-rust" target="_blank" rel="noopener">Bitbucket 博客</a>
，“ Rust 非常严格和繁琐的编译器会检查您使用的每个变量以及您引用的每个内存地址。它避免了可能发生的数据争用情况，并通知您未定义的行为。”</p>
<p>这意味着由于 Rust 对内存安全性的极度痴迷，您最终不会出现缓冲区溢出或争用情况。但是，这也有其缺点。例如，您在编写代码时必须非常了解内存分配原则。始终保持您的内存安全防护并不容易。</p>
<h2 id="开发人员体验">开发人员体验</h2>
<p>首先，让我们看一下每种语言的学习曲线。Golang 在设计时考虑了简单性。开发人员经常将其称为“无聊”语言，也就是说，其有限的内置功能集使 Golang 易于学习、使用。</p>
<p>此外，Golang 提供了比 C++更简单的替代方案，隐藏了诸如内存安全性和内存分配等方面的内容。Rust 采用了另一种方法，迫使您考虑诸如内存安全性的概念。所有权的概念和传递指针的能力使 Rust 失去了学习的吸引力。当您不断考虑内存安全性时，您的工作效率就会降低，并且您的代码注定会变得更加复杂。</p>
<p>与 Golang 相比，Rust 的学习曲线非常陡峭。值得一提的是，与 Python 和 JavaScript 等动态语言相比，Golang 的学习曲线较为陡峭。</p>
<h2 id="何时使用-golang">何时使用 Golang</h2>
<p>Go 在各种用例中都能很好地工作，使其成为创建 Web API 的 Node.js 的绝佳替代品。正如<a href="https://kristoff.it/blog/why-go-and-not-rust/" target="_blank" rel="noopener">Loris Cro</a>
指出的那样，“ Go 的并发模型非常适合必须处理多个独立请求的服务器端应用程序”。这正是 Golang 提供 goroutines 的原因。</p>
<p>此外，Golang 内置了对 HTTP Web 协议的支持。您可以使用内置的 HTTP 支持快速设计一个小型 API，并将其作为微服务运行。因此，Golang 非常适合微服务架构并满足 API 开发人员的需求。</p>
<p>简而言之，如果您重视开发速度并且更喜欢语法简单而不是性能，那么 Golang 是一个很好的选择。最重要的是，Golang 提供了更好的代码可读性，这对于大型开发团队而言是一个重要标准。</p>
<p>在以下情况下选择 Golang：</p>
<ul>
<li>您关心简单性和可读性</li>
<li>您需要一种简单的语法来快速编写代码</li>
<li>您想使用支持 Web 开发的更灵活的语言</li>
</ul>
<h2 id="何时使用-rust">何时使用 Rust</h2>
<p>当性能很重要时，例如在处理大量数据时，Rust 是一个不错的选择。此外，Rust 为您提供了对线程行为以及线程之间资源共享方式的细粒度控制。</p>
<p>另一方面，Rust 具有陡峭的学习曲线，并且由于内存安全性的额外复杂性而减慢了开发速度。这并不一定是不利的。Rust 还保证当编译器检查每个数据指针时，您不会遇到内存安全性错误。对于复杂的系统，此保证会派上用场。</p>
<p>在以下情况下选择 Rust：</p>
<ul>
<li>您关心性能</li>
<li>您想要对线程进行细粒度的控制</li>
<li>您重视内存安全而不是简单性</li>
</ul>
<h2 id="go-vs-rust我的大实话">Go vs. Rust：我的大实话</h2>
<p>让我们从突出相似之处开始。Go 和 Rust 都是开源的，旨在支持微服务架构和并行计算环境。两者都通过并发优化了可用 CPU 内核的利用率。</p>
<p>但归根结底，哪种语言是最好的？</p>
<p>有很多方法可以解决这个问题。我建议考虑要构建哪种类型的应用程序。Golang 可很好地用于创建 Web 应用程序和 API，这些应用程序和 API 利用其内置的并发功能，同时支持微服务体系结构。</p>
<p>您还可以使用 Rust 来开发 Web API，但并不是在设计时考虑到此用例。Rust 对内存安全性的关注增加了复杂性和开发时间，尤其是对于相当简单的 Web API。但是，对代码的大量控制使您可以编写更优化，内存效率更高且性能更高的代码。</p>
<p>简而言之，Golang 与 Rust 的争论实际上是一个简单与安全的问题。</p>
<p>有关更多观点，请查看“<a href="https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/" target="_blank" rel="noopener">在 Go 和 Rust 之间选择</a>
”。</p>
<h2 id="logrocket全面了解线上-rust-应用程序">LogRocket：全面了解线上 Rust 应用程序</h2>
<p>调试 Rust 应用程序可能很困难，尤其是当用户遇到难以重现的问题时。如果您对监控和跟踪 Rust 应用程序的性能，自动显示错误以及跟踪缓慢的网络请求和加载时间感兴趣，请<a href="https://logrocket.com/signup" target="_blank" rel="noopener">尝试 LogRocket</a>
。</p>
<p><p class="md__image">
  <img src="../imgs/use-rust-go03.png"
    alt="LogRocket仪表板免费试用横幅"  />
</p>
</p>
<p><a href="https://logrocket.com/signup" target="_blank" rel="noopener">LogRocket</a>
就像 Web 应用程序的 DVR，实际上记录了 Rust 应用程序中发生的所有事情。您可以汇总并报告问题发生时应用程序所处的状态，而不用猜测为什么会发生问题。LogRocket 还监视您的应用程序的性能，报告诸如客户端 CPU 负载，客户端内存使用情况等指标。</p>
<blockquote>
<p>原文链接：https://blog.logrocket.com/when-to-use-rust-and-when-to-use-golang/</p>
<p>原文作者：Michiel Mulders</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>15 张图带你深入理解浮点数</title>
			<link>https://polarisxu.studygolang.com/posts/basic/diagram-float-point/</link>
			<pubDate>Tue, 29 Sep 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/basic/diagram-float-point/</guid>
			<description>大家好，我是站长 polarisxu。 团队一直保持着分享的习惯，而我却分享的较少。忘了当时同事分享什么主题，涉及到浮点数相关知识。于是我决定分享一期关于浮点数的，而且 Go 之父 Rob Pike 说不懂浮点数不配当码农。。。So？！ 本着「要学习就系统透彻的学」这个原则，本文通过图的方式尽可能详细的讲解浮点数，让大家能够对浮点数有一个更深层次的认识。 本文目录： 0、几个问题 开始之前请</description>
			<content type="html"><![CDATA[<p>大家好，我是站长 polarisxu。</p>
<p>团队一直保持着分享的习惯，而我却分享的较少。忘了当时同事分享什么主题，涉及到浮点数相关知识。于是我决定分享一期关于浮点数的，而且 Go 之父 Rob Pike 说不懂浮点数不配当码农。。。So？！</p>
<p><p class="md__image">
  <img src="../imgs/float-point01.png"
    alt=""  />
</p>
</p>
<p>本着「要学习就系统透彻的学」这个原则，本文通过图的方式尽可能详细的讲解浮点数，让大家能够对浮点数有一个更深层次的认识。</p>
<p>本文目录：</p>
<p><p class="md__image">
  <img src="../imgs/float-point-content.png"
    alt=""  />
</p>
</p>
<h2 id="0几个问题">0、几个问题</h2>
<p>开始之前请思考如下问题：</p>
<ul>
<li>二进制 0.1，用十进制表示的话是多少？十进制的 0.1，用二进制表示又是多少？</li>
<li>为什么 0.1 + 0.2 = 0.30000000000000004？</li>
<li>单精度和双精度浮点数的有效小数位分别是多少？</li>
<li>单精度浮点数能表示的范围是什么？</li>
<li>浮点数为什么会存在 -0？infinity 和 NaN 又是怎么表示的？</li>
</ul>
<p>如果现在不会，那这篇文章正好可以为你解惑。</p>
<h2 id="1什么是浮点数">1、什么是浮点数</h2>
<p>我们知道，数学中并没有浮点数的概念，虽然小数看起来像浮点数，但从不这么叫。那为什么计算机中不叫小数而叫浮点数呢？</p>
<p>因为资源的限制，数学中的小数无法直接在计算机中准确表示。为了更好地表示它，计算机科学家们发明了浮点数，这是对小数的近似表示。维基百科中关于<a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" target="_blank" rel="noopener">浮点数</a>
的概念说明如下：</p>
<blockquote>
<p>The term floating point refers to the fact that a number&rsquo;s radix point (decimal point, or, more commonly in computers, binary point) can float; that is, it can be placed anywhere relative to the significant digits of the number.</p>
</blockquote>
<p>也就是说浮点数是相对于定点数而言的，表示小数点位置是浮动的。比如 7.5 × 10、0.75 × 10² 等表示法，值一样，但小数点位置不一样。</p>
<p>具体来说，浮点数是指用符号、尾数、基数和指数这四部分来表示的小数。</p>
<p><p class="md__image">
  <img src="../imgs/float-point02.png"
    alt=""  />
</p>
</p>
<h2 id="2ieee754-又是什么">2、IEEE754 又是什么</h2>
<p>知道了浮点数的概念，但需要确定一套具体的表示、运算标准。其中最有名的就是 <a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE754 标准</a>
。William Kahan 正是因为浮点数标准化的工作获得了图灵奖。</p>
<blockquote>
<p>The <strong>IEEE Standard for Floating-Point Arithmetic</strong> (<strong>IEEE 754</strong>) is a <a href="https://en.wikipedia.org/wiki/Technical_standard" target="_blank" rel="noopener">technical standard</a>
 for <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" target="_blank" rel="noopener">floating-point arithmetic</a>
 established in 1985 by the <a href="https://en.wikipedia.org/wiki/Institute_of_Electrical_and_Electronics_Engineers" target="_blank" rel="noopener">Institute of Electrical and Electronics Engineers</a>
 (IEEE). The standard <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#IEEE_754_design_rationale" target="_blank" rel="noopener">addressed many problems</a>
 found in the diverse floating-point implementations that made them difficult to use reliably and <a href="https://en.wikipedia.org/wiki/Software_portability" target="_blank" rel="noopener">portably</a>
. Many hardware <a href="https://en.wikipedia.org/wiki/Floating-point_unit" target="_blank" rel="noopener">floating-point units</a>
 use the IEEE 754 standard.</p>
</blockquote>
<p>本文的讨论都基于 IEEE754 标准，这也是目前各大编程语言和硬件使用的标准。</p>
<p>根据上面浮点数的组成，因为是在计算机中表示浮点数，基数自然是 2，因此 IEEE754 浮点数只关注符号、尾数和指数三部分。</p>
<h2 id="3小数的二进制和十进制转换">3、小数的二进制和十进制转换</h2>
<p>为了方便后面的内容顺利进行，复习下二进制和十进制的转换，其中主要涉及到小数的转换。</p>
<h3 id="二进制转十进制">二进制转十进制</h3>
<p>和整数转换一样，采用各位数值和位权相乘。比如：</p>
<p>(0.101)₂ = 1×2⁻¹ + 0×2⁻² + 0×2⁻³ = (0.625)₁₀</p>
<p>记住小数点后第一位是从 -1 开始即可。</p>
<h3 id="十进制转二进制">十进制转二进制</h3>
<p>十进制整数转二进制采用“除 2 取余，逆序排列”法。例如十进制数 11 转为二进制：</p>
<pre><code>11/2=5 … 余1
5/2=2  … 余1
2/2=1  … 余0
1/2=0  … 余1
</code></pre><p>所以 (11)₁₀ 的二进制是 (1011)₂。</p>
<p>但如果十进制是小数，转为二进制小数如何做？采用“乘 2 取整，顺序排列”。例如十进制小数 0.625 转为二进制小数：</p>
<pre><code>0.625*2=1.25 … 取整数部分1
0.25*2=0.5 	 … 取整数部分0
0.5*2=1			 … 取整数部分1
</code></pre><p>顺序排列，所以 (0.625)₁₀ = (0.101)₂。</p>
<p>为了方便大家快速的做转换，网上有很多这样的工具。推荐一个我觉得最棒的：<a href="https://baseconvert.com/">https://baseconvert.com/</a>，支持各进制的转换，还支持浮点数。</p>
<h2 id="4经典问题01--02--030000000000000004">4、经典问题：0.1 + 0.2 = 0.30000000000000004</h2>
<p>这个问题网上相关的讨论很多，甚至有专门的一个网站：<a href="https://0.30000000000000004.com/">https://0.30000000000000004.com/</a>，这个网站上有各门语言的 0.1 + 0.2 的结果。比如 C 语言：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%.17f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="mf">.1</span> <span class="o">+</span> <span class="mf">.2</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>Go 语言：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">float64</span> <span class="p">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果都是 0.30000000000000004。</p>
<p>为什么会这样？这要回到 IEEE754 标准关于浮点数的规定。</p>
<h2 id="5浮点数的-ieee754-表示">5、浮点数的 IEEE754 表示</h2>
<p>上文提到，浮点数由四个部分构成，那 IEEE754 标准是如何规定它们的存储方式的呢？</p>
<p>一般地，IEEE754 浮点数有两种类型：单精度浮点数（float）和双精度浮点数（double），还有其他的，不常用。单精度浮点数使用 4 字节表示；双精度浮点数使用 8 字节表示。在 Go 语言中用 float32 和 float64 表示这两种类型。</p>
<p><p class="md__image">
  <img src="../imgs/float-point03.png"
    alt=""  />
</p>
</p>
<p>符号位不用说，0 表示正数，1 表示负数。着重看指数部分和尾数部分。（基数前文说了，固定是 2，因此不存）</p>
<h3 id="尾数部分">尾数部分</h3>
<p>前面提到过，浮点数名称的由来在于小数点是浮动的。但具体存储时，需要固定一种形式，这叫做尾数的标准化。IEEE754 规定，在二进制数中，通过移位，将小数点前面的值固定为 1。IEEE754 称这种形式的浮点数为规范化浮点数（normal number）。</p>
<p>比如十进制数 0.15625，转为二进制是 0.00101。为了让第 1 位为 1，执行逻辑右移 3 位，尾数部分成为 1.01，因为右移了 3 位，所以指数部分是 -3。因为规定第 1 位永远为 1，因此可以省略不存，这样尾数部分多了 1 位，只需存 0100（要记住，这是的数字是小数点后的数字，因此实际是 0.01，转为十进制是 0.25 — 没算未存的小数点前面的 1）。</p>
<p>因此对于规范化浮点数，尾数其实比实际的多 1 位，也就是说单精度的是 24 位，双精度是 53 位。为了作区分，IEEE754 称这种尾数为 significand。</p>
<blockquote>
<p>有规范化浮点数，自然会有<strong>非规范化浮点数</strong>（denormal number），这会在后文讲解。</p>
</blockquote>
<p>请牢记，尾数决定了精度，对于单精度浮点数，因为只有 23 位，而 <code>1&lt;&lt;23</code> 对应十进制是 8388608，因此不能完整表示全部的 7 个十进制位，所以说，单精度浮点数<strong>有效小数位</strong>最多 7 位；双精度的<strong>有效小数位</strong>是 15 位；切记切记，有精度问题！！</p>
<h3 id="指数部分">指数部分</h3>
<p>因为指数有正、有负，为了避免使用符号位，同时方便比较、排序，指数部分采用了 <strong>The Biased exponent</strong>（有偏指数）。IEEE754 规定，2ᵉ⁻¹-1 的值是 0，其中 e 表示指数部分的位数，小于这个值表示负数，大于这个值表示正数。因此，对于单精度浮点数而言， 2⁸⁻¹-1 = 127 是 0；双精度浮点数，2¹¹⁻¹-1 = 1023 是 0。</p>
<p>没看懂？举个栗子。</p>
<p>还是用十进制 0.15625 举例。上文知道，因为右移了 3 位，所以指数是 -3。根据 IEEE754 的定义，单精度浮点数情况下，-3 的实际值是 127 - 3 = 124。明白了吗？127 表示 0，124 就表示 -3 了。而十进制的 124 转为二进制就是 1111100。</p>
<p>如果你还不理解，想想这个问题。</p>
<blockquote>
<p>如果让你用扑克牌（A ~ K，也就是 1 ~ 13）来表示支持负数的。怎么办？我们会选择一个中间的数，比如 7 当做 0，因此 10 就是 +3，4 就是 -3。现在理解了吧！</p>
</blockquote>
<h3 id="小结">小结</h3>
<p>结合尾数和指数的规定，IEEE754 单精度浮点数，十进制 0.15625 对应的二进制内存表示是：0 01111100 01000000000000000000000。</p>
<h2 id="6程序确认下-ieee754-的如上规定">6、程序确认下 IEEE754 的如上规定</h2>
<p>读到这里，希望你能坚持下去。为了进一步加深理解，我画一张图和一个确认程序。</p>
<h3 id="一张图">一张图</h3>
<p><p class="md__image">
  <img src="../imgs/float-point04.png"
    alt=""  />
</p>
</p>
<p>这张图是单精度浮点数 0.15625 的内存存储表示。根据三部分的二进制表示，可以反推出计算该数的十进制表示。作为练习，十进制的 2.75，用上图表示的话，各个位置分别都是什么值呢？</p>
<h3 id="程序确认单精度浮点数的内存表示">程序确认单精度浮点数的内存表示</h3>
<p>使用 Go 语言编写一个程序，能够得到一个单精度浮点数的二进制内存表示。比如提供单精度浮点数 0.15625，该程序能够输出：0-01111100-01000000000000000000000。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">f</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">0.15625</span>
	<span class="nf">outputFEEE754</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">outputFEEE754</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float32</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 将该浮点数内存布局当做 uint32 看待（因为都占用 4 字节）
</span><span class="c1"></span>	<span class="c1">// 这里实际上是做强制转换，内部实现是：return *(*uint32)(unsafe.Pointer(&amp;f))
</span><span class="c1"></span>	<span class="nx">buf</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Float32bits</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>

	<span class="c1">// 加上两处 -，结果一共 34 byte
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">result</span> <span class="p">[</span><span class="mi">34</span><span class="p">]</span><span class="kt">byte</span>

	<span class="c1">// 从低字节开始
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">33</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">i</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">{</span>
			<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;-&#39;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">buf</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
				<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;1&#39;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">result</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;0&#39;</span>
			<span class="p">}</span>
			<span class="nx">buf</span> <span class="o">/=</span> <span class="mi">2</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// output: 0-01111100-01000000000000000000000
</span></code></pre></div><p>你可以使用上述程序，验证下 2.75，看看你做对没有！提供了一个在线可运行版本：<a href="https://play.studygolang.com/p/pg0QNQtBHYx">https://play.studygolang.com/p/pg0QNQtBHYx</a>。</p>
<p>其实上面推荐的那个工具就能够得到十进制浮点数的二进制内存表示，地址：<a href="https://baseconvert.com/ieee-754-floating-point">https://baseconvert.com/ieee-754-floating-point</a>。</p>
<p><p class="md__image">
  <img src="../imgs/float-point05.png"
    alt=""  />
</p>
</p>
<p>另外，在 Java 语言中也有类似的方法：Float.floatToIntBits()，你可以使用 Java 实现上面类似的功能。</p>
<h2 id="6再看-0102--030000000000000004">6、再看 0.1+0.2 = 0.30000000000000004</h2>
<p>有了上面的知识，我们回过头看看这个经典的问题。（讨论单精度的情况，因此实际是 0.1+0.2 = 0.300000004）</p>
<h3 id="出错的原因">出错的原因</h3>
<p>出现这种情况的根本原因是，有些十进制小数无法转换为二进制数。如下图：</p>
<p><p class="md__image">
  <img src="../imgs/float-point06.png"
    alt=""  />
</p>
</p>
<p>在小数点后 4 位时，连续的二进制数，对应的十进制数却是不连续的，因此只能增加位数来尽可能近似的表示。</p>
<h3 id="01-和-02-是如何表示的">0.1 和 0.2 是如何表示的？</h3>
<p>根据前面的讲解，十进制 0.1 转为二进制小数，得到的是 0.0001100… （重复1100）这样一个循环二进制小数，使用 IEEE754 表示如下图：</p>
<p><p class="md__image">
  <img src="../imgs/float-point07.png"
    alt=""  />
</p>
</p>
<p>同样的方法，0.2 用单精度浮点数表示是：0.20000000298023223876953125。所以，0.1 + 0.2 的结果是：0.300000004470348358154296875。</p>
<p><p class="md__image">
  <img src="../imgs/float-point08.png"
    alt=""  />
</p>
</p>
<h2 id="7特殊值">7、特殊值</h2>
<p>耐心的读者看到这里，你真的很棒！但还没完哦，继续加油！</p>
<h3 id="单精度浮点数的最大值">单精度浮点数的最大值</h3>
<p>讲解下一个知识点之前，请思考本文开始的一个问题：<strong>单精度浮点数的最大值是多少？</strong></p>
<p>根据前面学到的知识，我们很容易想到它的最大值的内存应该表示是这样的。</p>
<p><p class="md__image">
  <img src="../imgs/float-point09.png"
    alt=""  />
</p>
</p>
<p>即：01111111111111111111111111111111。然而我们把这个值填入 <a href="https://baseconvert.com/ieee-754-floating-point">https://baseconvert.com/ieee-754-floating-point</a> 中，发现结果是这样的：</p>
<p><p class="md__image">
  <img src="../imgs/float-point10.png"
    alt=""  />
</p>
</p>
<p>什么？NaN 是个什么鬼？！我就是按照你上面讲过的思考的。。。</p>
<p>别急，因为凡是都有特殊。现在就讲讲浮点数中的特殊值。</p>
<h3 id="特殊值-infinity无穷">特殊值 infinity（无穷）</h3>
<p>当指数位全是 1，尾数位全是 0 时，这样的浮点数表示无穷。根据符号位，有正无穷和负无穷（+infinity 和 -infinity）。为什么需要无穷？因为计算机资源的限制，没法表示所有的数，当一个数超过了浮点数的表示范围时，就可以用 infinity 来表示。而数学中也有无穷的概念。</p>
<p>在 Go 语言中，通过 math 包的 func Inf(sign int) float64 函数可以获取到正负无穷。</p>
<p>在 Java 语言中，通过 Float 或 Double 类中的常量可以获得：Float.POSITIVE_INFINITY、Float.NEGATIVE_INFINITY。</p>
<p>具体表示可以定义一个常量，比如：</p>
<blockquote>
<p>正无穷：0x7FF0000000000000，负无穷：0xFFF0000000000000</p>
</blockquote>
<p>和上面浮点数内存位模型强转 int 类似，这个执行相反操作（类似 Float64frombits 这样的函数），就得到了这个特殊的浮点值。可以看 Go 语言 math 标准库相应函数的实现。</p>
<h3 id="特殊值-nan">特殊值 NaN</h3>
<p>NaN 是 not-a-number 的缩写，即不是一个数。为什么需要它？例如，当对 -1 进行开根号时，浮点数不知道如何进行计算，就会使用 NaN，表示不是一个数。</p>
<p>NaN 的具体内存表示是：指数位全是 1，尾数位不全是 0。</p>
<p>和 infinity 类似，Go 和 Java 都定义了相应的函数或常量。</p>
<h3 id="小结-1">小结</h3>
<p>现在清楚上面单精度浮点数最大值是不对的了吧，它是一个 NaN。画一张图，方便你更清晰的记住这些特殊值。</p>
<p><p class="md__image">
  <img src="../imgs/float-point11.png"
    alt=""  />
</p>
</p>
<p>所以单精度浮点数的最大值应该能确认了，即：0 11111110 11111111111111111111111。</p>
<p><p class="md__image">
  <img src="../imgs/float-point12.png"
    alt=""  />
</p>
</p>
<h2 id="8非规范化浮点数">8、非规范化浮点数</h2>
<p>接着用问题的方式继续：单精度浮点数的最小值是多少（正数）？</p>
<p>根据前面的知识，我们会得到这样的最小值：0 00000000 00000000000000000000001。根据前面规范化浮点数的规定，我们知晓该值是：2⁻¹²⁷×(1+2⁻²³)。</p>
<p>然而，最小值的内存表示没错，但算出来的结果是错的。（额头冒汗没？怎么又错了~）</p>
<p>为了避免两个小浮点数相减结果是 0（也就是规范化浮点数无法表示）这样情况出现，同时根据规范化浮点数的定义，因为尾数部分有一个省略的前导 1，因此无法表示 0。所以，IEEE754 规定了另外一种浮点数：</p>
<blockquote>
<p>当指数位全是 0，尾数部分不全为 0，尾数部分没有省略的前导 1，同时指数部分的偏移值比规范形式的偏移值小 1，即单精度是 -126，双精度是 -2046。这种形式的浮点数叫非规范化浮点数（denormal number）。</p>
</blockquote>
<p>因此单精度浮点数的最小值（正数）如下图：</p>
<p><p class="md__image">
  <img src="../imgs/float-point13.png"
    alt=""  />
</p>
</p>
<p>有了非规范化浮点数，IEEE754 就可以表示 0 了，但会存在 +0 和 -0：即所有位全是 0 时是 +0；符号位是 1，其他位是 0 时是 -0。</p>
<h2 id="9ieee754-浮点数分类小结">9、IEEE754 浮点数分类小结</h2>
<p>至此，浮点数相关的知识就介绍差不多了。为了让大家对整体再有一个更好的掌握，对浮点数的分类进行一些总结。</p>
<p>从上面的讲解，IEEE754 浮点数，指数是关键，根据指数，将其分为：特殊值、非规范化浮点数和规范化浮点数。</p>
<p><p class="md__image">
  <img src="../imgs/float-point14.png"
    alt=""  />
</p>
</p>
<p>从上图规范化和非规范化浮点数的表示范围可以看出，两种类型的表示是具有连续性的。这也就是为什么非规范化浮点数指数规定为比规范形式的偏移值小 1（即单精度为 -126，双精度为 -2046）。</p>
<p>在数轴上，浮点数的分布：</p>
<p><p class="md__image">
  <img src="../imgs/float-point15.png"
    alt=""  />
</p>
</p>
<h2 id="10总结">10、总结</h2>
<p>《深入理解计算机系统》这本书在讲解浮点数时说：许多程序员认为浮点数没意思，往坏了说，深奥难懂。经过本文的四千多字图文并茂的方式讲解，如果你认真看完了，我相信你一定掌握了浮点数。</p>
<p>此外，还有其他一些知识点，比如浮点数的运算、不满足结合律、四舍但五不一定入等，有兴趣的可以查阅相关资料。</p>
<p>现在是时候回过头来看看开始的题目了，你都会了吗？</p>
<p>最后，建议你结合你熟悉的语言更进一步补充相关知识。比如 Go 语言的 math 标准库；Java 的 java.lang.Float/Double 等包。</p>
<h2 id="参考资料或相关链接">参考资料或相关链接</h2>
<ul>
<li><a href="https://floating-point-gui.de/">https://floating-point-gui.de/</a></li>
<li><a href="https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/">https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/</a></li>
<li><a href="https://baseconvert.com/">https://baseconvert.com/</a></li>
<li>这个交互式工具，很不错：http://evanw.github.io/float-toy/</li>
<li><a href="https://bartaz.github.io/ieee754-visualization/">https://bartaz.github.io/ieee754-visualization/</a></li>
<li>柴大：https://mp.weixin.qq.com/s/0lCte3UD5qYcaBnebwnYrQ</li>
<li>左神：https://mp.weixin.qq.com/s/QsEe34pcimNdqCb99h44cQ</li>
<li>图书《程序是怎样跑起来的》</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>这么一道“简单”的题，为什么结果出乎我的意料</title>
			<link>https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/</link>
			<pubDate>Sun, 27 Sep 2020 14:52:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/action/interview-len-shift/</guid>
			<description>今天在《Go语言爱好者周刊：第62期》 中贴了一道 Go101 的题，原题如下： package main const s = &amp;#34;Go101.org&amp;#34; // len(s) == 9 // 1 &amp;lt;&amp;lt; 9 == 512 // 512 / 128 == 4 var a byte = 1 &amp;lt;&amp;lt; len(s) / 128 var b byte = 1 &amp;lt;&amp;lt; len(s[:]) / 128 func main() { println(a, b) } 答案是 4 0。 不少人对这个结果应该很吃惊，因为从答题结果看，不到一半的人答对了。而且，如果只给 var b byte = 1 &amp;lt;&amp;lt; len(s[:]) / 128，没有 a 对比，我想答对的人会更少。因为有对比，很多人虽然直觉是 4 4，但想到一定有陷阱，所</description>
			<content type="html"><![CDATA[<p>今天在<a href="https://mp.weixin.qq.com/s/xvlAcDBqb77HUzTo7gjuCw" target="_blank" rel="noopener">《Go语言爱好者周刊：第62期》</a>
中贴了一道 Go101 的题，原题如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">const</span> <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;Go101.org&#34;</span>
<span class="c1">// len(s) == 9
</span><span class="c1">// 1 &lt;&lt; 9 == 512
</span><span class="c1">// 512 / 128 == 4
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>答案是 4 0。</p>
<p>不少人对这个结果应该很吃惊，因为从答题结果看，不到一半的人答对了。而且，如果只给 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，没有 a 对比，我想答对的人会更少。因为有对比，很多人虽然直觉是 4 4，但想到一定有陷阱，所以会重新思考。</p>
<p>好几个群都问，为什么结果会是 4 0，希望我解释下。因此有了此文。</p>
<p>这个小题涉及到几个知识点。</p>
<h2 id="len-函数的结果">len 函数的结果</h2>
<p>要注意，len 是一个内置函数。在官方标准库文档<a href="https://docs.studygolang.com/pkg/builtin/#len" target="_blank" rel="noopener">关于 len 函数</a>
有这么一句：</p>
<blockquote>
<p>For some arguments, such as a string literal or a simple array expression, the result can be a constant. See the Go language specification&rsquo;s &ldquo;Length and capacity&rdquo; section for details.</p>
</blockquote>
<p>明确支持，当参数是字符串字面量和简单 array 表达式，len 函数返回值是常量，这很重要。</p>
<p>上题中，如果 <code>const s = &quot;Go101.org”</code> 改为 <code>var s = &quot;Go101.org&quot;</code> 结果又会是什么呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;Go101.org&#34;</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果是 0 0。</p>
<p>但改为这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;G&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="sc">&#39;g&#39;</span><span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果又是 4 0。</p>
<p>接着看文档那句话的后半句，查看 Go 语言规范中<a href="https://hao.studygolang.com/golang_spec.html#id221" target="_blank" rel="noopener">关于长度和容量的说明</a>
。</p>
<blockquote>
<p>内置函数 len 和 cap 获取各种类型的实参并返回一个 int 类型结果。实现会保证结果总是一个 int 值。</p>
<p>如果 s 是一个字符串常量，那么 len(s) 是一个常量 。如果 s 类型是一个数组或到数组的指针且表达式 s 不包含 信道接收 或（非常量的） 函数调用的话， 那么表达式 len(s) 和 cap(s) 是常量；这种情况下， s 是不求值的。否则的话， len 和 cap 的调用结果不是常量且 s 会被求值。</p>
</blockquote>
<p>可见题目中：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">a</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">/</span> <span class="mi">128</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="kt">byte</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">[:])</span> <span class="o">/</span> <span class="mi">128</span>
</code></pre></div><p>第一句的 len(s) 是常量（因为 s 是字符串常量）；而第二句的 len(s[:]) 不是常量。这是这两条语句的唯一区别：两个 len 的返回结果数值并无差异，都是 9，但一个是常量一个不是。</p>
<h2 id="关于位移操作">关于位移操作</h2>
<p>根据上面的分析，现在问题的关键在于位移运算这里。Go 语言规范中有<a href="https://docs.studygolang.com/ref/spec#Operators" target="_blank" rel="noopener">这么一句</a>
：</p>
<blockquote>
<p>The right operand in a shift expression must have integer type or be an untyped constant representable by a value of type uint. If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.</p>
</blockquote>
<p>大意是：在位移表达式的右侧的操作数必须为整数类型，或者可以被 uint 类型的值所表示的无类型的常量。如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型。</p>
<p>这里的关键在于常量位移表达式。根据上文的分析，<code>1 &lt;&lt; len(s)</code> 是常量位移表达式，而 <code>1 &lt;&lt; len(s[:])</code> 不是。</p>
<p>规范上关于常量表达式中，还有<a href="https://docs.studygolang.com/ref/spec#Constant_expressions" target="_blank" rel="noopener">这么一句</a>
：</p>
<blockquote>
<p>If the left operand of a constant shift expression is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of integer type.</p>
</blockquote>
<p>大意是：如果常量 位移表达式 的左侧操作数是一个无类型常量，那么其结果是一个整数常量；否则就是和左侧操作数同一类型的常量（必须是 整数类型 ）</p>
<p>因此对于 <code>var a byte = 1 &lt;&lt; len(s) / 128</code>，因为 <code>1 &lt;&lt; len(s)</code> 是一个常量位移表达式，因此它的结果也是一个整数常量，所以是 512，最后除以 128，最终结果就是 4。</p>
<p>而对于 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code>，因为 <code>1 &lt;&lt; len(s[:])</code> 不是一个常量位移表达式，而做操作数是 1，一个无类型常量，根据规范定义它是 byte 类型（根据：如果一个非常量位移表达式的左侧的操作数是一个无类型常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型）。</p>
<p>为什么是 byte 类型，大家可能还是有点晕。这要回到关于常量的说明上。</p>
<h3 id="常量">常量</h3>
<p>常量是在编译的时候进行计算的。在 Go 语言中，常量分两种：无类型和有类型。Go 规范上说，字面值常量， true , false , iota 以及一些仅包含无类型的恒定操作数的 常量表达式 是无类型的。</p>
<p>那有类型常量是怎么来的呢？一般有两种：显示声明或隐式得到。比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">a</span> <span class="kt">int32</span> <span class="p">=</span> <span class="mi">23</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="kt">float32</span> <span class="p">=</span> <span class="mf">0.1</span>
</code></pre></div><p>无类型常量都有一个默认类型（无类型常量的默认类型分别是 bool , rune , int , float64 , complex128 或 string）。当在上下文中需要请求该常量为一个带类型的值时，这个 默认类型 便指向该常量隐式转换后的类型。</p>
<p>所以 <code>var b byte = 1 &lt;&lt; len(s[:]) / 128</code> 中，根据规范定义，1 会隐式转换为 byte 类型，因此 <code>1 &lt;&lt; len(s[:])</code> 的结果也是 byte 类型，而 byte 类型最大只能表示 255，很显然 512 溢出了，结果为 0，因此最后 b 的结果也是 0。</p>
<h2 id="小结">小结</h2>
<p>一道很具迷惑性的题目引出这么多小知识点。可能有人要喷：讨论这些有什么用？这也太细节了。我想说的是，Go 语言规范，细节点很多，能多掌握一些没坏处，说不定将来实际工作就遇到了类似的问题呢？！以上的知识点，很细节，但我认为也是挺有价值的。</p>
<p>当然了，你怎么说都行，你都是对的，你开心就好！</p>
]]></content>
		</item>
		
		<item>
			<title>如何在调试过程中查找 Goroutine</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/how-to-find-goroutines-during-debugging/</link>
			<pubDate>Fri, 18 Sep 2020 18:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/how-to-find-goroutines-during-debugging/</guid>
			<description>Goroutines 是大多数用 Go 编写的程序的重要组成部分。但是，使用大量 goroutines 会使程序难以调试。那怎么办？在此博文中，我们将介绍如何使用自定义数据为 goroutine 加上标签，这是 GoLand 2020.1（现已包含在 EAP 中）的最新功能之一。 目录 在 IDE 下使用 在命令行下使用 性能影响 使用自定义库启用调试标签 让我们以向 Web 服务器发出请求的应用程序为例： package main import ( &amp;#34;io&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;strings&amp;#34; &amp;#34;time&amp;#34; ) func fakeTraffic() { // Wait for the server to start time.Sleep(1 * time.Second) pages := []string{&amp;#34;/&amp;#34;, &amp;#34;/login&amp;#34;, &amp;#34;/logout&amp;#34;, &amp;#34;/products&amp;#34;, &amp;#34;/product/{productID}&amp;#34;, &amp;#34;/basket&amp;#34;, &amp;#34;/about&amp;#34;}</description>
			<content type="html"><![CDATA[<p>Goroutines 是大多数用 Go 编写的程序的重要组成部分。但是，使用大量 goroutines 会使程序难以调试。那怎么办？在此博文中，我们将介绍如何使用自定义数据为 goroutine 加上标签，这是 GoLand 2020.1（现已包含在 <a href="https://blog.jetbrains.com/go/tag/2020-1/" target="_blank" rel="noopener">EAP</a>
 中）的最新功能之一。</p>
<h2 id="目录">目录</h2>
<ul>
<li>在 IDE 下使用</li>
<li>在命令行下使用</li>
<li>性能影响</li>
<li>使用自定义库启用调试标签</li>
</ul>
<p>让我们以向 Web 服务器发出请求的应用程序为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
 
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;io&#34;</span>
    <span class="s">&#34;io/ioutil&#34;</span>
    <span class="s">&#34;math/rand&#34;</span>
    <span class="s">&#34;net/http&#34;</span>
    <span class="s">&#34;strconv&#34;</span>
    <span class="s">&#34;strings&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>
 
<span class="kd">func</span> <span class="nf">fakeTraffic</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Wait for the server to start
</span><span class="c1"></span>    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
 
    <span class="nx">pages</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="s">&#34;/login&#34;</span><span class="p">,</span> <span class="s">&#34;/logout&#34;</span><span class="p">,</span> <span class="s">&#34;/products&#34;</span><span class="p">,</span> <span class="s">&#34;/product/{productID}&#34;</span><span class="p">,</span> <span class="s">&#34;/basket&#34;</span><span class="p">,</span> <span class="s">&#34;/about&#34;</span><span class="p">}</span>
 
    <span class="nx">activeConns</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="mi">10</span><span class="p">)</span>
 
    <span class="nx">c</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{</span>
        <span class="nx">Timeout</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
    <span class="p">}</span>
 
    <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
 
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">activeConns</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
        <span class="nx">i</span><span class="o">++</span>
 
        <span class="nx">page</span> <span class="o">:=</span> <span class="nx">pages</span><span class="p">[</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">pages</span><span class="p">))]</span>
 
        <span class="c1">// We need to launch this using a closure function to
</span><span class="c1"></span>        <span class="c1">// ensure that we capture the correct value for the
</span><span class="c1"></span>        <span class="c1">// two parameters we need: page and i
</span><span class="c1"></span>        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rid</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">makeRequest</span><span class="p">(</span><span class="nx">activeConns</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">rid</span><span class="p">)</span>
        <span class="p">}(</span><span class="nx">page</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">makeRequest</span><span class="p">(</span><span class="nx">done</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">page</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Unblock the next request from the queue
</span><span class="c1"></span>        <span class="o">&lt;-</span><span class="nx">done</span>
    <span class="p">}()</span>
 
    <span class="nx">page</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="nx">page</span><span class="p">,</span> <span class="s">&#34;{productID}&#34;</span><span class="p">,</span> <span class="s">&#34;abc-&#34;</span><span class="o">+</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="p">)),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="nx">r</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">MethodGet</span><span class="p">,</span> <span class="s">&#34;http://localhost:8080&#34;</span><span class="o">+</span><span class="nx">page</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
 
    <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
 
    <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">ioutil</span><span class="p">.</span><span class="nx">Discard</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
 
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">40</span><span class="p">))</span> <span class="o">+</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="在-ide-下使用">在 IDE 下使用</h2>
<p>如果我们在调试器（debugger）中分析此代码，我们如何知道 makeRequest goroutines 在做什么？当我们看这样的清单时，这些 goroutine 的执行上下文什么？</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/03/debugger-classic-without-labels-optimized.png"
    alt="debugger without labels"  />
</p>
</p>
<p>这就是 GoLand 新版本支持读取 goroutines 标签的缘由。</p>
<p>我们调整下上面的代码：（polaris 注：pprof 是标准库的 runtime/pprof ）</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rid</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">labels</span> <span class="o">:=</span> <span class="nx">pprof</span><span class="p">.</span><span class="nf">Labels</span><span class="p">(</span><span class="s">&#34;request&#34;</span><span class="p">,</span> <span class="s">&#34;automated&#34;</span><span class="p">,</span> <span class="s">&#34;page&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="s">&#34;rid&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">rid</span><span class="p">)))</span>
    <span class="nx">pprof</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">labels</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">makeRequest</span><span class="p">(</span><span class="nx">activeConns</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">rid</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}(</span><span class="nx">page</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</code></pre></div><p>现在，当在调试器中运行相同的代码时，我们将看到以下视图：</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/03/debugger-classic-with-labels-optimized.png"
    alt="debugger with labels"  />
</p>
</p>
<p>看起来好多了。现在，我们可以看到在标签中设置的所有信息。而且，最重要的是，我们还可以看到通过函数调用在后台启动的其他 goroutine，它们都会自动携带标签。</p>
<p>由于 HTTP HandleFunc 这种形式的处理程序非常受欢迎，并且可以与其他处理程序类型进行比较，因此让我们看一下如何调整下面的代码以设置标签。</p>
<p>我们的原始代码将 m 用作 <code>*http.ServeMux</code>（或 <code>*github.com/gorilla/mux.Router</code>），看起来像这样：<code>m.HandleFunc(&quot;/&quot;, homeHandler)</code>。</p>
<p>应用标签代码后，它将变为如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">labels</span> <span class="o">:=</span> <span class="nx">pprof</span><span class="p">.</span><span class="nf">Labels</span><span class="p">(</span><span class="s">&#34;path&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">,</span> <span class="s">&#34;request&#34;</span><span class="p">,</span> <span class="s">&#34;real&#34;</span><span class="p">)</span>
    <span class="nx">pprof</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">labels</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">_</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">homeHandler</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">})</span>
</code></pre></div><p>这将标记处理每个 HTTP 请求的 goroutine，如下所示。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/03/debugger-http-with-labels-optimized.png"
    alt="debugging http middleware with labels"  />
</p>
</p>
<p>由于可以访问请求对象，因此可以使用比示例代码中更复杂的数据填充标签。</p>
<h2 id="在命令行下使用">在命令行下使用</h2>
<p>如果直接在命令行中使用 Delve，则需要使用 <a href="https://github.com/go-delve/delve/commit/186786235fc9c2bd9b16c26bb4b0aef60ffb731c" target="_blank" rel="noopener">1867862</a>
 或更高版本的 Delve。这些更改将包含在下一个版本中，而当前v1.4.0 版本中未包含。</p>
<p>要查看标签，请在调试会话期间调用 <code>goroutines -l</code> 命令，以查看到与 IDE 中相同的数据。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/03/debugger-dlv-with-labels-optimized.png"
    alt="debugger dlv from command line with labels"  />
</p>
</p>
<h2 id="性能影响">性能影响</h2>
<p>随之而来的自然问题是：使用上述代码对性能会有影响吗？</p>
<p>答案是肯定的，设置这些标签确实会降低性能。通常，它的影响很小，但是仍然会存在，因此最好使用一些基准测试代码在自己的硬件上进行测试。</p>
<p>考虑到这种影响，就会出现下一个问题：如果涉及性能，则意味着每次需要进行调试时，我都需要应用和撤消代码。这会影响我的开发速度，这能做得更好吗？</p>
<h2 id="使用自定义库启用调试标签">使用自定义库启用调试标签</h2>
<p>要回答上述问题并允许我们的调试代码在不影响性能的情况下进行编译，请使用 <a href="https://github.com/dlsniper/debugger" target="_blank" rel="noopener">github.com/dlsniper/debugger</a>
 库并更改我们的 makeRequest 代码以包括以下函数调用：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makeRequest</span><span class="p">(</span><span class="nx">done</span> <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{},</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">page</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Unblock the next request from the queue
</span><span class="c1"></span>        <span class="o">&lt;-</span><span class="nx">done</span>
    <span class="p">}()</span>
 
    <span class="nx">debugger</span><span class="p">.</span><span class="nf">SetLabels</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
            <span class="s">&#34;request&#34;</span><span class="p">,</span> <span class="s">&#34;automated&#34;</span><span class="p">,</span>
            <span class="s">&#34;page&#34;</span><span class="p">,</span> <span class="nx">page</span><span class="p">,</span>
            <span class="s">&#34;rid&#34;</span><span class="p">,</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="p">)),</span>
        <span class="p">}</span>
    <span class="p">})</span>
	<span class="c1">// ..
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>在调试器中运行此代码之前，我们需要进行其他更改。我们需要在运行配置的 Go 工具参数字段中添加 <code>-tags debugger</code>。否则，该库将加载生产代码，标签将不起作用。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/03/debugger-run-configuration-optimized.png"
    alt="debugger - run configuration"  />
</p>
</p>
<p>此处显示的库支持标准的 http.HandlerFunc 签名，以方便在现有应用程序中使用。</p>
<p>回到我们的代码，如下所示：<code>m.HandleFunc(&quot;/&quot;, homeHandler)</code>。</p>
<p>要将标签添加到这些处理程序，我们可以将代码更改为如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">m</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">debugger</span><span class="p">.</span><span class="nf">Middleware</span><span class="p">(</span><span class="nx">homeHandler</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span>
        <span class="s">&#34;request&#34;</span><span class="p">,</span> <span class="s">&#34;real&#34;</span><span class="p">,</span>
        <span class="s">&#34;path&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">RequestURI</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}))</span>
</code></pre></div><p><strong>专业提示：</strong></p>
<p>在单个函数或方法中对 <a href="https://pkg.go.dev/github.com/dlsniper/debugger?tab=doc#SetLabels" target="_blank" rel="noopener">debugger.SetLabels</a>
 函数进行多次调用，可以更轻松地跟踪执行进度并过滤掉不需要的数据。</p>
<p><strong>专业提示：</strong></p>
<p>可以复制运行配置，从而可以在有和没有调试器构建标记（build tag）的情况下使用代码。</p>
<p><strong>注意：</strong></p>
<p>如上所示，设置标签会导致性能下降。因此，仅在对性能要求不高的环境中使用 <code>-tags=debugger</code> 构建的二进制文件，或确保通过改善调试体验来抵消性能损失。</p>
<p>今天就这样。我们学习了如何使用 GoLand 调试复杂的 Go 应用程序并在 goroutine 中添加标签，从而使生活变得更轻松。</p>
<p>这篇文章中的所有代码都可以在 <a href="https://github.com/dlsniper/debugger" target="_blank" rel="noopener">github.com/dlsniper/debugger</a>
 上找到。用于测试该库的示例代码可在  <a href="https://github.com/dlsniper/serverdemo" target="_blank" rel="noopener">github.com/dlsniper/serverdemo</a>
 上找到。</p>
<blockquote>
<p>作者：<a href="https://blog.jetbrains.com/go/author/florin-patanjetbrains-com/" target="_blank" rel="noopener">Florin Pățan</a>
</p>
<p>原文链接：https://blog.jetbrains.com/go/2020/03/03/how-to-find-goroutines-during-debugging/</p>
<p>翻译：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>在 iOS 和 Android 上运行 Go 代码</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/running-go-code-on-ios-and-android/</link>
			<pubDate>Mon, 14 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/running-go-code-on-ios-and-android/</guid>
			<description>在本教程中，我们将构建一个简单的 Go 包，您可以从 iOS 应用程序（Swift）和 Android 应用程序（Kotlin）运行该软件包。 本教程不会使用go mobile 框架。相反，它使用 Cgo 构建可导入到您的移动项目中的原始静态（iOS）和共享（Android） C 库（Go Mobile 框架在后台进行此操作）。 构建 在本教程中，我们将创建具有以下结构的简单 monorepo： . ├── android/ ├── go/ │ ├── cmd/ │ │ └── libfoo/</description>
			<content type="html"><![CDATA[<p>在本教程中，我们将构建一个简单的 Go 包，您可以从 iOS 应用程序（Swift）和 Android 应用程序（Kotlin）运行该软件包。</p>
<p>本教程不会使用<a href="https://github.com/golang/mobile" target="_blank" rel="noopener">go mobile</a>
 框架。相反，它使用 Cgo 构建可导入到您的移动项目中的原始静态（iOS）和共享（Android） C 库（Go Mobile 框架在后台进行此操作）。</p>
<h2 id="构建">构建</h2>
<p>在本教程中，我们将创建具有以下结构的简单 monorepo：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">.
├── android/
├── go/
│   ├── cmd/
│   │   └── libfoo/
│   │       └── main.go
│   ├── foo/
│   │   └── foo.go
│   ├── go.mod
│   └── go.sum
└── ios/
$ mkdir -p android ios go/cmd/libfoo go/foo
</code></pre></div><p>我们将从 Go 代码开始，稍后再返回创建 iOS 和 Android 项目。</p>
<div class="highlight"><pre class="chroma"><code class="language-zsh" data-lang="zsh">$ <span class="nb">cd</span> go
$ go mod init rogchap.com/libfoo
</code></pre></div><h2 id="foo-包">Foo 包</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// go/foo/foo.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">foo</span>

<span class="c1">// Reverse reverses the given string by each utf8 character
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Reverse</span><span class="p">(</span><span class="nx">in</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="kt">rune</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">rune</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">in</span><span class="p">))</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">in</span> <span class="p">{</span>
        <span class="kt">rune</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">r</span>
        <span class="nx">n</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="kt">rune</span> <span class="p">=</span> <span class="kt">rune</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">n</span><span class="p">]</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="kt">rune</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="kt">rune</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kt">rune</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="nx">i</span><span class="p">],</span> <span class="kt">rune</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">string</span><span class="p">(</span><span class="kt">rune</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>我们的<code>foo</code>程序包有一个函数<code>Reverse</code>，该函数具有单个字符串参数<code>in</code>和单个字符串输出。</p>
<h2 id="导出为-c">导出为 C</h2>
<p>为了使我们的 C 库调用我们的<code>foo</code>包，我们需要导出所有要公开给 C 的函数，并带有特殊<code>export</code>注释。该包装器必须位于<code>main</code>包装中：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// go/cmd/libfoo/main.go
</span><span class="c1"></span><span class="nx">pacakge</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;C&#34;</span>

<span class="c1">// other imports should be seperate from the special Cgo import
</span><span class="c1"></span><span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;rogchap.com/libfoo/foo&#34;</span>
<span class="p">)</span>

<span class="c1">//export reverse
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">in</span> <span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)</span> <span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">C</span><span class="p">.</span><span class="nf">CString</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nf">Reverse</span><span class="p">(</span><span class="nx">C</span><span class="p">.</span><span class="nf">GoString</span><span class="p">(</span><span class="nx">in</span><span class="p">)))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</code></pre></div><p>我们正在使用特殊的 <code>C.GoString()</code>和<code>C.CString()</code>函数在 Go 字符串和 C 字符串之间进行转换。</p>
<p>*注意：*我们要导出的函数不必是导出的 Go 函数（即以大写字母开头）。还要注意是空<code>main</code>函数；这对于 Go 代码进行编译是必需的，否则会出现 <code>function main is undeclared in the main package</code>错误。</p>
<p>让我们通过使用 <code>-buildmode</code> 标志创建一个静态 C 库来测试我们的构建：</p>
<pre><code>go build -buildmode=c-archive -o foo.a ./cmd/libfoo
</code></pre><p>这应该已经输出了 C 库：<code>foo.a</code>和头文件：<code>foo.h</code>。您应该在头文件的底部看到导出的函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="k">extern</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">reverse</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">in</span><span class="p">);</span>
</code></pre></div><h2 id="为-ios-构建">为 iOS 构建</h2>
<p>我们的目标是创建一个可以在 iOS 设备和 iOS 模拟器上使用的 <a href="https://en.wikipedia.org/wiki/Fat_binary" target="_blank" rel="noopener">Fat 二进制文件</a>
。</p>
<p>Go 标准库包含用于构建 iOS 的脚本： <a href="https://golang.org/misc/ios/clangwrap.sh" target="_blank" rel="noopener"><code>$GOROOT/misc/ios/clangwrap.sh</code></a>
，但是该脚本仅针对生成<code>arm64</code>，而<code>x86_64</code>iOS Simulator 也需要该脚本 。因此，我们将创建自己的<code>clangwrap.sh</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="cp">#!/bin/sh
</span><span class="cp"></span>
<span class="c1"># go/clangwrap.sh</span>

<span class="nv">SDK_PATH</span><span class="o">=</span><span class="sb">`</span>xcrun --sdk <span class="nv">$SDK</span> --show-sdk-path<span class="sb">`</span>
<span class="nv">CLANG</span><span class="o">=</span><span class="sb">`</span>xcrun --sdk <span class="nv">$SDK</span> --find clang<span class="sb">`</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$GOARCH</span><span class="s2">&#34;</span> <span class="o">==</span> <span class="s2">&#34;amd64&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">CARCH</span><span class="o">=</span><span class="s2">&#34;x86_64&#34;</span>
<span class="k">elif</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$GOARCH</span><span class="s2">&#34;</span> <span class="o">==</span> <span class="s2">&#34;arm64&#34;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nv">CARCH</span><span class="o">=</span><span class="s2">&#34;arm64&#34;</span>
<span class="k">fi</span>

<span class="nb">exec</span> <span class="nv">$CLANG</span> -arch <span class="nv">$CARCH</span> -isysroot <span class="nv">$SDK_PATH</span> -mios-version-min<span class="o">=</span>10.0 <span class="s2">&#34;</span><span class="nv">$@</span><span class="s2">&#34;</span>
</code></pre></div><p>不要忘记让它可执行：</p>
<pre><code>chmod +x clangwrap.sh
</code></pre><p>现在，我们可以为每种体系结构构建库，并使用该<code>lipo</code>工具（通过 Makefile）合并为 Fat 二进制文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-makefile" data-lang="makefile"><span class="c"># go/Makefile
</span><span class="c"></span>
<span class="nf">ios-arm64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>darwin <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>arm64 <span class="se">\
</span><span class="se"></span>	<span class="nv">SDK</span><span class="o">=</span>iphoneos <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>PWD<span class="k">)</span>/clangwrap.sh <span class="se">\
</span><span class="se"></span>	<span class="nv">CGO_CFLAGS</span><span class="o">=</span><span class="s2">&#34;-fembed-bitcode&#34;</span> <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-archive -tags ios -o <span class="k">$(</span>IOS_OUT<span class="k">)</span>/arm64.a ./cmd/libfoo

<span class="nf">ios-x86_64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>darwin <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>amd64 <span class="se">\
</span><span class="se"></span>	<span class="nv">SDK</span><span class="o">=</span>iphonesimulator <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>PWD<span class="k">)</span>/clangwrap.sh <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-archive -tags ios -o <span class="k">$(</span>IOS_OUT<span class="k">)</span>/x86_64.a ./cmd/libfoo

<span class="nf">ios</span><span class="o">:</span> <span class="n">ios</span>-<span class="n">arm</span>64 <span class="n">ios</span>-<span class="n">x</span>86<span class="n">_</span>64
	lipo <span class="k">$(</span>IOS_OUT<span class="k">)</span>/x86_64.a <span class="k">$(</span>IOS_OUT<span class="k">)</span>/arm64.a -create -output <span class="k">$(</span>IOS_OUT<span class="k">)</span>/foo.a
	cp <span class="k">$(</span>IOS_OUT<span class="k">)</span>/arm64.h <span class="k">$(</span>IOS_OUT<span class="k">)</span>/foo.h
</code></pre></div><h2 id="创建我们的-ios-应用程序">创建我们的 iOS 应用程序</h2>
<p>使用 XCode，我们可以创建一个简单的单页应用程序。我将使用 Swift UI，但这与 UIKit 一样容易：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// ios/foobar/ContentView.swift</span>

<span class="kd">struct</span> <span class="nc">ContentView</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>

    <span class="p">@</span><span class="n">State</span> <span class="kd">private</span> <span class="kd">var</span> <span class="nv">txt</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>

    <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
        <span class="n">VStack</span><span class="p">{</span>
            <span class="n">TextField</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="err">$</span><span class="n">txt</span><span class="p">)</span>
            <span class="p">.</span><span class="n">textFieldStyle</span><span class="p">(</span><span class="n">RoundedBorderTextFieldStyle</span><span class="p">())</span>
            <span class="n">Button</span><span class="p">(</span><span class="s">&#34;Reverse&#34;</span><span class="p">){</span>
                <span class="c1">// Reverse text here</span>
            <span class="p">}</span>
            <span class="n">Spacer</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="p">.</span><span class="n">padding</span><span class="p">(.</span><span class="n">all</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>在 Xcode 中，将新生成的<code>foo.a</code> 和 <code>foo.h</code> 拖进我们的项目。为了使我们的 Swift 代码与我们的库互操作，我们需要创建一个桥接头文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">// ios/foobar/foobar-Bridging-Header.h
</span><span class="c1"></span>
<span class="cp">#import &#34;foo.h&#34;
</span></code></pre></div><p>在 Xcode <code>Build Settings</code> 中，<code>Swift Compiler - General</code> 下，设置 <code>Objective-C Bridging Header</code> 为我们刚刚创建的文件：<code>foobar/foobar-Bridging-Header.h</code>。</p>
<p>我们还需要设置 <code>Library Search Paths</code> 为包括我们生成的头文件 <code>foo.h</code> 的目录。（当您将文件拖放到项目中时，Xcode 可能已经为您完成了此操作）。</p>
<p>现在我们可以从 Swift 调用函数，然后构建并运行：</p>
<div class="highlight"><pre class="chroma"><code class="language-swift" data-lang="swift"><span class="c1">// ios/foobar/ContentView.swift</span>

<span class="n">Button</span><span class="p">(</span><span class="s">&#34;Reverse&#34;</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nv">str</span> <span class="p">=</span> <span class="bp">reverse</span><span class="p">(</span><span class="nb">UnsafeMutablePointer</span><span class="p">&lt;</span><span class="nb">Int8</span><span class="p">&gt;(</span><span class="kr">mutating</span><span class="p">:</span> <span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">txt</span> <span class="k">as</span> <span class="n">NSString</span><span class="p">).</span><span class="n">utf8String</span><span class="p">))</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">txt</span> <span class="p">=</span> <span class="nb">String</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">cString</span><span class="p">:</span> <span class="n">str</span><span class="p">!,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span><span class="o">!</span>
    <span class="c1">// don&#39;t forget to release the memory to the C String</span>
    <span class="n">str</span><span class="p">?.</span><span class="n">deallocate</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p><p class="md__image">
  <img src="https://rogchap.com/posts/img/libfoo_ios.gif"
    alt="libfoo ios应用程序"  />
</p>
</p>
<h2 id="创建-android-应用程序">创建 Android 应用程序</h2>
<p>使用 Android Studio，我们将创建一个新的 Android 项目。从 Project Templates 中选择 <code>Native C++</code>，这将创建一个带有 Empty Activity 的项目，该项目被配置为使用 Java Native Interface（JNI）。我们仍将选择 <code>Kotlin</code> 作为该项目的语言。</p>
<p>创建一个简单的 Activity 后，加上 <code>EditText</code> 和，<code>Button</code> 两个控件，为应用创建基本功能：</p>
<div class="highlight"><pre class="chroma"><code class="language-kotlin" data-lang="kotlin"><span class="c1">// android/app/src/main/java/com/rogchap/foobar/MainActivity.kt
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">MainActivity</span> <span class="p">:</span> <span class="n">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
        <span class="n">setContentView</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">layout</span><span class="p">.</span><span class="n">activity_main</span><span class="p">)</span>

        <span class="n">btn</span><span class="p">.</span><span class="n">setOnClickListener</span> <span class="p">{</span>
            <span class="n">txt</span><span class="p">.</span><span class="n">setText</span><span class="p">(</span><span class="n">reverse</span><span class="p">(</span><span class="n">txt</span><span class="p">.</span><span class="n">text</span><span class="p">.</span><span class="n">toString</span><span class="p">()))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/**
</span><span class="cm">     * A native method that is implemented by the &#39;native-lib&#39; native library,
</span><span class="cm">     * which is packaged with this application.
</span><span class="cm">     */</span>
    <span class="k">private</span> <span class="k">external</span> <span class="k">fun</span> <span class="nf">reverse</span><span class="p">(</span><span class="n">str</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">String</span>

    <span class="k">companion</span> <span class="k">object</span> <span class="p">{</span>
        <span class="c1">// Used to load the &#39;native-lib&#39; library on application startup.
</span><span class="c1"></span>        <span class="k">init</span> <span class="p">{</span>
            <span class="n">System</span><span class="p">.</span><span class="n">loadLibrary</span><span class="p">(</span><span class="s2">&#34;native-lib&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>我们创建了（并调用）一个外部函数 <code>reverse</code>，我们需要在 JNI （C++）实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// android/app/src/main/cpp/native-lib.cpp
</span><span class="c1"></span>
<span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="p">{</span>
    <span class="n">jstring</span>
    <span class="nf">Java_com_rogchap_foobar_MainActivity_reverse</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Reverse text here
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>JNI 代码必须遵循约定才能在本机 C++ 和 Kotlin（JVM）之间互操作。</p>
<h2 id="为-android-构建">为 Android 构建</h2>
<p>在许多版本的 Android 和 NDK 中，JNI 与外部库的工作方式已发生变化。当前（也是最简单的方法）是将输出的库放置到一个特殊的 <code>jniLibs</code> 文件夹中，该文件夹将复制到我们的最终 APK 文件中。</p>
<p>与创建 Fat 二进制文件（就像我们在 iOS 中所做的那样）不同，我将每个体系结构放置在正确的文件夹中。同样，对于 JNI，约定很重要。</p>
<div class="highlight"><pre class="chroma"><code class="language-makefile" data-lang="makefile"><span class="err">//</span> <span class="err">go/Makefile</span>

<span class="nv">ANDROID_OUT</span><span class="o">=</span>../android/app/src/main/jniLibs
<span class="nv">ANDROID_SDK</span><span class="o">=</span><span class="k">$(</span>HOME<span class="k">)</span>/Library/Android/sdk
<span class="nv">NDK_BIN</span><span class="o">=</span><span class="k">$(</span>ANDROID_SDK<span class="k">)</span>/ndk/21.0.6113669/toolchains/llvm/prebuilt/darwin-x86_64/bin

<span class="nf">android-armv7a</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>arm <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARM</span><span class="o">=</span><span class="m">7</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/armv7a-linux-androideabi21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/armeabi-v7a/libfoo.so ./cmd/libfoo

<span class="nf">android-arm64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>arm64 <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/aarch64-linux-android21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/arm64-v8a/libfoo.so ./cmd/libfoo

<span class="nf">android-x86</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span><span class="m">386</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/i686-linux-android21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/x86/libfoo.so ./cmd/libfoo

<span class="nf">android-x86_64</span><span class="o">:</span>
	<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">1</span> <span class="se">\
</span><span class="se"></span>	<span class="nv">GOOS</span><span class="o">=</span>android <span class="se">\
</span><span class="se"></span>	<span class="nv">GOARCH</span><span class="o">=</span>amd64 <span class="se">\
</span><span class="se"></span>	<span class="nv">CC</span><span class="o">=</span><span class="k">$(</span>NDK_BIN<span class="k">)</span>/x86_64-linux-android21-clang <span class="se">\
</span><span class="se"></span>	go build -buildmode<span class="o">=</span>c-shared -o <span class="k">$(</span>ANDROID_OUT<span class="k">)</span>/x86_64/libfoo.so ./cmd/libfoo

<span class="nf">android</span><span class="o">:</span> <span class="n">android</span>-<span class="n">armv</span>7<span class="n">a</span> <span class="n">android</span>-<span class="n">arm</span>64 <span class="n">android</span>-<span class="n">x</span>86 <span class="n">android</span>-<span class="n">x</span>86<span class="n">_</span>64
</code></pre></div><p><strong>注意</strong>确保为您的 Android SDK 和已下载的 NDK 版本设置正确的位置。</p>
<p><code>make android</code> 将我们需要的所有共享库构建到正确的文件夹中。现在，我们需要将库添加到 CMake：</p>
<div class="highlight"><pre class="chroma"><code class="language-cmake" data-lang="cmake"><span class="err">//</span> <span class="err">android/app/src/main/cpp/CMakeLists.txt
</span><span class="err">
</span><span class="err">//</span> <span class="err">...
</span><span class="err">
</span><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">lib_foo</span> <span class="s">SHARED</span> <span class="s">IMPORTED</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set_property</span><span class="p">(</span><span class="s">TARGET</span> <span class="s">lib_foo</span> <span class="s">PROPERTY</span> <span class="s">IMPORTED_NO_SONAME</span> <span class="s">1</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">set_target_properties</span><span class="p">(</span><span class="s">lib_foo</span> <span class="s">PROPERTIES</span> <span class="s">IMPORTED_LOCATION</span> <span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/../jniLibs/</span><span class="o">${</span><span class="nv">CMAKE_ANDROID_ARCH_ABI</span><span class="o">}</span><span class="s">/libfoo.so</span><span class="p">)</span><span class="err">
</span><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="o">}</span><span class="s">/../jniLibs/</span><span class="o">${</span><span class="nv">CMAKE_ANDROID_ARCH_ABI</span><span class="o">}</span><span class="s">/</span><span class="p">)</span><span class="err">
</span><span class="err">
</span><span class="err">//</span> <span class="err">...
</span><span class="err">
</span><span class="err"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">native-lib</span> <span class="s">lib_foo</span> <span class="o">${</span><span class="nv">log-lib</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></code></pre></div><p>我花了一段时间才弄清楚这些设置，再次命名很重要，因此使用库命名 <code>lib_xxxx</code> 并设置属性很重要，同时设置 <code>IMPORTED_NO_SONAME 1</code>，否则您的 apk 会在错误的位置查找你的库。</p>
<p>现在，我们可以将 JN I 代码连接到 Go 库中，然后运行我们的应用程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// android/app/src/main/cpp/native-lib.cpp
</span><span class="c1"></span>
<span class="cp">#include</span> <span class="cpf">&#34;libfoo.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">extern</span> <span class="s">&#34;C&#34;</span> <span class="p">{</span>
    <span class="n">jstring</span>
    <span class="nf">Java_com_rogchap_foobar_MainActivity_reverse</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cstr</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetStringUTFChars</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">cout</span> <span class="o">=</span> <span class="n">reverse</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">cstr</span><span class="p">));</span>
        <span class="n">jstring</span> <span class="n">out</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
        <span class="n">env</span><span class="o">-&gt;</span><span class="n">ReleaseStringUTFChars</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">cstr</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p><p class="md__image">
  <img src="https://rogchap.com/posts/img/libfoo_android.gif"
    alt="libfoo android应用"  />
</p>
</p>
<h2 id="结论">结论</h2>
<p>Go 的优势之一就是它是跨平台的，这不仅意味着 Window，Mac 和 Linux，Go 还可以针对许多其他体系结构，包括 iOS 和 Android。现在，您可以在工具栏中找到另一个选项，以创建在服务器、移动应用程序甚至 Web（通过 Web 程序集）上运行的共享库。</p>
<p>本教程的所有代码均可在 GitHub 上获得：<a href="https://github.com/rogchap/libfoo">https://github.com/rogchap/libfoo</a></p>
<p>期待听到您使用 Go 构建的新杀手级应用程序。</p>
<blockquote>
<p>原文链接：https://rogchap.com/2020/09/14/running-go-code-on-ios-and-android/</p>
<p>作者：Roger Chapman</p>
<p>译者：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>观点：Go 尚未准备好用于企业系统，原因在这里</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/golang-is-not-ready-for-enterprise-systems-yet-and-heres-why/</link>
			<pubDate>Sat, 12 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/golang-is-not-ready-for-enterprise-systems-yet-and-heres-why/</guid>
			<description>译注：发表这篇文章，不代表我认同作者的观点。大家都知道，在国内，Go 已经被很多大厂使用，早就可以用于企业系统。 对一门语言的爱，可以接受任何不同的观点，真理总是越辩越明，相信有不同的声音，Go 也会越来越好。欢迎大家留言发表你的看法。 介绍 企业应用程序是一个寿命长、可靠的系统，具有多年的持久数据。如今，Golang 的世界并没有提供以企业系统构建方式构建系统的可能性</description>
			<content type="html"><![CDATA[<blockquote>
<p>译注：发表这篇文章，不代表我认同作者的观点。大家都知道，在国内，Go 已经被很多大厂使用，早就可以用于企业系统。</p>
<p>对一门语言的爱，可以接受任何不同的观点，真理总是越辩越明，相信有不同的声音，Go 也会越来越好。欢迎大家留言发表你的看法。</p>
</blockquote>
<h2 id="介绍">介绍</h2>
<p>企业应用程序是一个寿命长、可靠的系统，具有多年的持久数据。如今，Golang 的世界并没有提供以企业系统构建方式构建系统的可能性。</p>
<p><p class="md__image">
  <img src="../imgs/not-ready-enterprice01.png"
    alt="Martin Fowler 的“企业应用程序”"  />
</p>
</p>
<h2 id="golang-的发展文化">Golang 的发展文化</h2>
<p>让我们考虑几个问题，如错误处理不当、 手动组合的 SQL 查询和面向轮子开发。</p>
<h3 id="错误处理不当">错误处理不当</h3>
<p>Golang 在错误处理方面提供了更多的自由。由于开发人员方面缺乏责任，这通常会导致应用程序中的错误处理不当。</p>
<p>最常见的情况与 sql 查询的执行有关：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">defer</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span> <span class="c1">// omitted errors from sql driver
</span></code></pre></div><p>没有明确的方法来处理此返回的错误。实际上，该语言提供了捕获错误的特定方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">foo</span><span class="p">()</span>
</code></pre></div><p>该错误是一个典型的返回值，可以通过各种方式忽略：</p>
<pre><code>defer rows.Close() // omitted errors from sql driver
defer body.Close() // omitted IO errors
result, _ := foo() // omitted errors from foo function
</code></pre><p><p class="md__image">
  <img src="../imgs/not-ready-enterprice02.png"
    alt="sketch: Now you come to Me and you say “Don Gopher, handle Me.” But you don’t ask with respect. you don’t offer friendship."  />
</p>
</p>
<p>此外，它会导致应用程序在 panic 函数调用后立即崩溃的风险增加，并且通常会降低可靠性。</p>
<blockquote>
<p>根据 M.Nygard 的 “Release it!”，可靠的系统必须处理每个不重要的错误而不会崩溃。没有权衡。</p>
</blockquote>
<p>作为解决方案，我们可以使用其他语言的 try/catch/finally 结构添加可靠的机制。此外，还需要消除 panic 函数。当然，这将是一种较慢的方法，但更可靠。</p>
<hr>
<h3 id="手动编写-sql-查询语句">手动编写 SQL 查询语句</h3>
<p>Golang 中处理数据库查询的典型方法是手动编写查询。如果 <strong>SQL 查询被手工编写的</strong>，那么数据库集成将是一个<strong>瓶颈</strong>。并非所有开发人员都擅长 SQL 和使用数据库。诸如 Hibernate（Java）和 Entity Framework（.NET）之类的功能齐全的 ORM 生成的典型查询已开放，用于数据库和缓存数据优化。<strong>这是根据 ‘Release it’ 来编写可靠的应用程序的最有效方法之一。</strong></p>
<p>有些库将来可能是功能齐全的ORM（例如 GORM 和 XORM）。我相信，与手工编写的 SQL  查询相比，它们将来会更受欢迎。</p>
<h3 id="重新发明轮子">重新发明轮子</h3>
<p>通常，Golang 开发人员都在选择重新发明轮子。轮子无处不在：task scheduler，迁移工具，logger，worker pool，十进制数字的库，授权库和其他工具。</p>
<blockquote>
<p>它们没有经过良好的测试，没有良好的文档，在生产中使用不足。风险太高，不能在企业应用程序中使用它们。</p>
</blockquote>
<p>为了减少使用风险代码的可能性，检查是否有可用的解决方案。例如可以查看 <a href="https://github.com/avelino/awesome-go" target="_blank" rel="noopener">awesome-go</a>
。</p>
<hr>
<h2 id="生态系统">生态系统</h2>
<p>Go 世界的生态系统包括 Consul, Kubernetes, Zipkin 和 Træfik 等。它是一个非常年轻且发展迅速的技术栈，没有公认的使用标准。</p>
<blockquote>
<p>Golang 生态系统中没有任何工具可以帮助建立可靠的企业系统。</p>
</blockquote>
<p>考虑到以上所有情况，我们需要非常谨慎地将第三方中间件集成到基础架构中，公司必须有足够的专业知识支持该过程。否则，它将成为具有不同技术的生产环境中的雷区。好消息是，市场有很多管理解决方案，以最大限度地降低风险。不幸的是，它很贵。</p>
<hr>
<p>Golang 生态系统太年轻，缺乏工具、编程文化，但我相信它将来会成为一个伟大的生态系统，并拥有伟大的程序员。语言社区正朝着正确的方向努力：性能和简化。但是，我们不能忘记可靠性也很重要。我们越早了解可靠性的价值，我们就会越快地用 Golang 编码更多、更好的企业系统。</p>
<h2 id="ps">P.S.</h2>
<p>我很惊讶，这篇文章有这么多的解释。可惜很多人错过了文章的重点。</p>
<p>这篇文章：</p>
<p><em>1）不是关于我</em></p>
<p><em>2）不是关于我的技能</em></p>
<p><em>3）不是关于我的狗</em></p>
<p>*4）*不是关于“为什么我的狗在其企业狗系统中不需要使用 Golang”</p>
<p><em>5）不是关于 Golang 的最佳编码实践</em></p>
<p><em>6）不是关于与处理 go 错误有关的最佳实践</em></p>
<p><em>7）不是关于如何以正确的方式选择正确的工具</em></p>
<p><em>8）不是关于 Golang 的一般设计</em></p>
<p><em>9）不是关于“没有人可以将 Go 用于企业系统”</em></p>
<p><em>10）不是关于“没有人需要将 Go 用于企业系统”</em></p>
<p>正如我所观察到的，这涉及将 Golang 用于企业的风险（在“ Golang”下，我的意思更多在于文化和生态系统，而不是语言设计）。这是我的看法。</p>
<p>当然，很多大公司，如谷歌和 Netflix 在企业中使用 Golang，在我看来，他们一样有风险（记住，谷歌使用 Golang 时，这种语言还没有包带版本的管理器 ）。其他开发人员可以有其他观点和其他经验并观察。</p>
<p>本文的主要目的是进行讨论，看看有多少人有相同的看法。</p>
<h2 id="参考">参考</h2>
<p>图书：《Release It! Design and Deploy Production-Ready Software》</p>
<p>图书：《Patterns of Enterprise Application Architecture》by Martin Fowler</p>
<blockquote>
<p>原文链接：https://medium.com/@afondmitro/golang-is-not-ready-for-enterprise-systems-yet-and-heres-why-c0ee72069963</p>
<p>作者：Dmitry Afonkin</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Google 的核心数据解决方案团队是如何使用 Go 的？</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/google-go-coredata/</link>
			<pubDate>Tue, 08 Sep 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/google-go-coredata/</guid>
			<description>关于 Google 的核心数据： Google 是一家技术公司，其使命是组织全世界的信息，并使其普遍可访问和有用。 在这个案例研究中，Google 的核心数据解决方案团队分享了他们的 Go 旅程，包括他们决定在 Go 中重写 web 索引服务，利用 Go 的内置并发性，并观察 Go 如何帮助改进开发过程。 Google 的使命是“组织世界各地的信息，并使其普遍可访问和有用。” Google 的核心数据解决方案团队是负责组织该信息的团队之一。除此之外</description>
			<content type="html"><![CDATA[<p>关于 Google 的核心数据：</p>
<blockquote>
<p>Google 是一家技术公司，其使命是组织全世界的信息，并使其普遍可访问和有用。</p>
<p>在这个案例研究中，Google 的核心数据解决方案团队分享了他们的 Go 旅程，包括他们决定在 Go 中重写 web 索引服务，利用 Go 的内置并发性，并观察 Go 如何帮助改进开发过程。</p>
</blockquote>
<p><p class="md__image">
  <img src="../imgs/go_core_data_case_study.png"
    alt="核心数据"  />
</p>
</p>
<p>Google 的使命是“组织世界各地的信息，并使其普遍可访问和有用。” Google 的核心数据解决方案团队是负责组织该信息的团队之一。除此之外，该团队维护服务以索引全球的网页。这些网络索引服务通过保持搜索结果的更新和全面来帮助支持诸如 Google 搜索之类的产品，这些产品都是用 Go 语言编写的。</p>
<p>2015 年，为了跟上 Google 的规模，我们的团队需要我们将索引堆栈从用 C++ 编写的单个整体二进制代码重写为微服务架构中的多个组件。我们决定使用 Go 重写许多索引服务，现在我们将其用于支持大多数架构。</p>
<p>“ 因为鼓励团队中的工程师使用并发和并行算法，所以 Go 的内置并发是很自然的选择。” —Minjae Hwang， 软件工程师</p>
<p>选择语言时，我们的团队发现 Go 的多种特性特别适合。例如，因为鼓励团队中的工程师使用并发和并行算法，所以 Go 的内置并发是很自然的选择。工程师还发现，“ Go 代码更为自然”，使他们可以将时间花在业务逻辑和分析上，而不是在管理内存和优化性能上。</p>
<p>使用 Go 时，编写的代码要简单的多，因为它有助于减轻开发过程中的认知负担。例如，当使用 C++ 时，复杂的 IDE 可能“显示出源代码没有编译错误实际上确实有错误”，而“在 Go 中，当 IDE 指出代码没有错误时，代码总是会编译。” Core Data Solutions 团队的软件工程师 MinJae Hwang 说。减少开发过程中的小摩擦点，例如缩短修复编译错误的周期，有助于我们的团队在原始重写期间更快地发布，并有助于保持较低的维护成本。</p>
<p>“当我使用 C++ 并想使用更多软件包时，必须写一些 header 文件。当我用 Go 语言时，<strong>内置工具使我可以更轻松地使用软件包。我的开发速度要快得多</strong>。</p>
<p>通过简单的语言语法和 Go 工具的支持，我们团队中的一些成员发现用 Go 编写代码要容易的多。我们还发现 Go 在静态类型检查方面做得非常好，并且某些 Go 基础知识（例如 godoc 命令）已帮助团队围绕编写文档建立了更规范的规则。</p>
<p>“…在一年内重新设计了 Google 的网络索引。更令人印象深刻的是，团队中的大多数开发人员在学习 Go 的同时也用 Go 进行了重写。”— Prasanna Meda，软件工程师</p>
<p>研发在全球范围内被广泛使用的产品绝非易事，而我们团队使用 Go 的决定并不是一件容易的事，但是这样做有助于我们更快地行动。结果，在一年内重新设计了 Google 的网络索引。更令人印象深刻的是，该团队中的大多数开发人员在学习 Go 的同时就用 Go 完成重写。</p>
<p>除了核心数据解决方案团队外，Google 的工程团队在开发过程中也采用了Go。了解 <a href="https://go.dev/solutions/google/chrome/" target="_blank" rel="noopener">Chrome</a>
 和 <a href="https://go.dev/solutions/google/firebase/" target="_blank" rel="noopener">Firebase 托管</a>
团队如何使用 Go 来大规模构建快速，可靠和高效的软件。关于他们的下次分享。</p>
<blockquote>
<p>原文链接：https://go.dev/solutions/google/coredata/</p>
<p>作者：Prasanna Meda, Software Engineer, Core Data Solutions</p>
<p>翻译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>关于 Go 语言泛型设计的最新进展和一些问题的说明</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/about-go-generic-progress/</link>
			<pubDate>Sun, 23 Aug 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/about-go-generic-progress/</guid>
			<description>前段时间 Go 官方发布了新的泛型草案，一时间在社区引起了很大的反响，各种关于泛型的文章、讨论涌现出来。8 月 21日 Ian Lance Taylor 在 golang-nuts 讨论组总结了泛型设计的最新进展和一些问题的说明。 Go Team 在经过多次讨论并阅读了许多评论后，计划对泛型设计进行一些更改并澄清草案的一些问题。 1 泛型语法极有可能使用方括号 []（不用 &amp;lt;&amp;gt; 是因为和比较运算符大于、小于冲突，为了保持 Go1 兼容性，所以选择了 []）</description>
			<content type="html"><![CDATA[<p>前段时间 Go 官方发布了新的泛型草案，一时间在社区引起了很大的反响，各种关于泛型的文章、讨论涌现出来。8 月 21日 Ian Lance Taylor 在 <a href="https://groups.google.com/g/golang-nuts/c/iAD0NBz3DYw/m/VcXSK55XAwAJ" target="_blank" rel="noopener">golang-nuts</a>
 讨论组总结了泛型设计的最新进展和一些问题的说明。</p>
<p>Go Team 在经过多次讨论并阅读了许多评论后，计划对泛型设计进行一些更改并澄清草案的一些问题。</p>
<h2 id="1">1</h2>
<p>泛型语法极有可能使用方括号 <code>[]</code>（不用 &lt;&gt; 是因为和比较运算符大于、小于冲突，为了保持 Go1 兼容性，所以选择了 []）但考虑删除类型参数中的 <code>type</code> 关键字，因为使用方括号足以区分类型参数和普通参数。为了避免与数组声明混淆，将要求所有类型参数都提供一个约束（constraint）。这样做的好处是可以给类型参数列表与普通参数列表使用完全相同的语法（除了括号的区别之外）。为简化类型参数的常见情况，该参数可以无限制，将引入一个新的预先声明的标识符 <code>any</code> 作为 <code>interface{}</code> 的别名。</p>
<p>所以支持泛型的声明类似这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Vector</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span> 
<span class="kd">func</span> <span class="nx">Print</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span> 
<span class="kd">func</span> <span class="nx">Index</span><span class="p">[</span><span class="nx">T</span> <span class="nx">comparable</span><span class="p">](</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">e</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="err">…</span> <span class="p">}</span> 
</code></pre></div><p>Go Team 认为预定义新标识符 <code>any</code> 的成本较低：因为每个常规参数始终都有一个类型，每个类型参数始终具有一个约束（其元类型）。</p>
<p>将 <code>[type T]</code> 更改为 <code>[T any]</code> 似乎同样易读，并且节省了一个字符。我们将能够简化许多现有的标准库和其他地方的代码，只需替换 <code>interface {}</code> 为 <code>any</code> 即可。</p>
<h2 id="2">2</h2>
<p>将简化类型列表满足的规则。如果类型参数或者类型参数的底层（underlying ）类型和类型列表中的任意类型相同，则类型参数满足约定。调整后的规则意味着，类型列表可以决定是否接受除预先声明的类型外的确切定义的类型，或者是否接受具有匹配底层类型的任何类型。</p>
<p>这是一个微小的变化，预计不会影响任何现有的实验代码。</p>
<h2 id="3">3</h2>
<p>需要澄清的是，在考虑允许的操作时，对于类型参数中某个类型的值，将忽略在类型列表中的任何类型方法。一般规则是，泛型函数可以使用类型中每种类型允许的任何操作清单。但是，这仅适用于自定义函数和预声明的函数（例如 <code>len</code> 和 <code>cap</code>）。它不适用于方法，因为类型列表包含所有定义了方法的类型列表。任何方法都必须在 interface 中单独列出，而不是从类型列表中继承。即泛型函数只能使用类型约束所定义的那些操作。</p>
<p>该规则通常看起来很清晰，并且避免了一些复杂的推理涉及类型列表，其中包括带有嵌入式类型的结构参数。</p>
<h2 id="4">4</h2>
<p>允许对具有类型列表的类型参数执行类型开关（type switch）操作。用 (.type) 的语法来阐明类似 <code>switch v := x.(type)</code> 的代码。在类型参数上的类型开关不能使用 <code>:=</code> 语法，因此 <code>.(type)</code> 是不必要的。在具有类型列表的类型参数上执行类型开关操作时，列出的每一个 case 都必须是出现在类型列表中的（当然也允许使用 <code>default</code>）。如果和类型参数匹配，则该 case 被选中。如上面讨论的那样，可能该 case 不是完全匹配的类型参数而是类型参数的底层类型，该 case 也会被选中。</p>
<p>为了使该规则更明确。没有类型列表的类型参数不允许使用类型开关。但这种情况是允许的：对于一个没有类型列表的类型参数值 <code>x</code>，可以写这样的代码，<code>switch (interface{})(x).(type)</code>，根据上面的说明，以后应该写成这样 <code>switch any(x).(type)</code>。这个结构不是最简单的，但它仅使用了语言已有的特性。</p>
<h2 id="接下来">接下来</h2>
<p>这些更改将很快在以下实验设计中实现：dev.generics 分支，并在 go2go Playground 可用。以上有些已经可以完成了。同时 Go Team 会相应地更新设计草案。</p>
]]></content>
		</item>
		
		<item>
			<title>对比三款 Go Playground：你喜欢哪款？</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/compare-three-playground/</link>
			<pubDate>Wed, 19 Aug 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/compare-three-playground/</guid>
			<description>曾几何时，语言的在线运行（Playground）似乎成了标配。确实，Playground 能够让我们可以快速试验一些想法。Go 语言在发布之初就提供了一个，这就是 https://play.golang.org。然而，由于众所周知的原因，我们访问不了。为了方便国内广大 gopher，我搞了一个国内镜像：https://play.studygolang.com，尽情使</description>
			<content type="html"><![CDATA[<p>曾几何时，语言的在线运行（Playground）似乎成了标配。确实，Playground 能够让我们可以快速试验一些想法。Go 语言在发布之初就提供了一个，这就是 <a href="https://play.golang.org">https://play.golang.org</a>。然而，由于众所周知的原因，我们访问不了。为了方便国内广大 gopher，我搞了一个国内镜像：<a href="https://play.studygolang.com">https://play.studygolang.com</a>，尽情使用、分享吧。</p>
<h2 id="官方的-playground">官方的 Playground</h2>
<p>不得不说，Go 官方的 Playground 真的比较原始。</p>
<p><p class="md__image">
  <img src="../imgs/playgolangorg.png"
    alt=""  />
</p>
</p>
<p>提供的功能比较少，主要有：</p>
<ul>
<li>格式化，但需要手动点击。在点击格式化时，如果勾选了 Imports，会自动对使用的标准库做导入；</li>
<li>分享。能够将你的代码分享给其他人，方便对方查看、运行；</li>
<li>代码片段。顶部下拉列表中提供了一些代码片段，点击可以直接切换编辑框内容；</li>
</ul>
<p>总结下：官方的 Playground 主要提供了在线编辑、运行、分享 Go 代码的功能，其中分享对全球的 gopher 来说，可以更方便的进行代码交流，排查问题等，分享也是使用最多的。</p>
<p>然而官方的 Playground 缺点也很明显：</p>
<ul>
<li>界面简单，略显丑陋；</li>
<li>不支持代码高亮；</li>
<li>不支持代码提示；</li>
<li>语法错误无法实时提示；</li>
<li>。。。</li>
</ul>
<p>于是有了第三方的 Playground。</p>
<h2 id="goplayspace">goplay.space</h2>
<p>第一个出场的是 <a href="https://goplay.space">https://goplay.space</a>。这是 iafan 在 2017 年开发的，</p>
<blockquote>
<p>Go Play Space is an experimental alternative <a href="https://play.golang.org/" target="_blank" rel="noopener">Go Playground</a>
 frontend that is built in Go itself (using <a href="https://github.com/gopherjs/gopherjs" target="_blank" rel="noopener">GopherJS</a>
), a Go→JavaScript transpiler, and <a href="https://github.com/gopherjs/vecty" target="_blank" rel="noopener">Vecty</a>
, a React-like frontend library for GopherJS).</p>
</blockquote>
<p><p class="md__image">
  <img src="../imgs/goplayspace.gif"
    alt=""  />
</p>
</p>
<p>可见，goplay.space 的代码运行依然使用官方的，只是替换了前端部分。看看它提供了哪些功能：</p>
<ul>
<li>语法高亮显示，大括号和引号自动关闭，正确的撤消/重做，自动缩进；</li>
<li>智能文档查找：例如双击源代码中的包名或 Println 等函数名称，在右边将看到相关的文档；这个功能真的很实用；</li>
<li>实时的语法错误检查；</li>
<li>错误行高亮显示（语法错误和编译器返回的错误）；</li>
<li>能够突出显示代码行和代码块（类似在 Github 上，但更好！）—只需单击行号即可。使用 Shift 和 Ctrl 修改选择；</li>
<li>键盘快捷键（请参阅顶部按钮标题处）；</li>
<li>支持多个 UI 主题；</li>
<li>支持 <a href="https://github.com/tonsky/FiraCode" target="_blank" rel="noopener">Fira Code</a>
 字体（系统中已安装的字体或 Webfont）；</li>
<li>go import 始终在运行代码之前运行，因此您通常不必担心导入问题；</li>
</ul>
<p>代码执行是官方的 Go Playground 的代理，因此它保证了程序将有相同的结果。同时共享的代码段也存储在 golang.org 服务器上。所以，分享的代码，可以直接在 goplay.space 展示。比如这个代码：<a href="https://play.golang.org/p/aouL6zP4O35">https://play.golang.org/p/aouL6zP4O35</a>，对应的 goplay.space 就是：<a href="https://goplay.space/#aouL6zP4O35">https://goplay.space/#aouL6zP4O35</a>。</p>
<p>个人认为 goplay.space 最大的特色是智能文档查找，可以在写代码时及时查看文档。要是加上自动完成功能就好了。</p>
<h2 id="goplaytools">goplay.tools</h2>
<p><a href="https://twitter.com/x1unix" target="_blank" rel="noopener">x1unix</a>
 觉得以上两个 Playground 都不够好。就在前些天（2020-08-12），发布了一个 “Better Go Playground”，这就是 <a href="https://goplay.tools/">https://goplay.tools/</a>。</p>
<p>几个月前，x1unix 决定尝试创建一个更好的 Go Play 版本，该版本将具有一些有价值的小功能，使原型制作足够舒适，例如基本代码自动完成（仅支持 stdlib），语法检查，代码段和示例。另外，随着 Go in WebAssembly 趋势开始增长，添加了 WebAssembly 支持。</p>
<p>此外，用户可以选择编辑器字体以及一些其他选项的小选项来自定义编辑器。</p>
<p>这个项目基于 React 和 Monaco editor 创建。</p>
<p><p class="md__image">
  <img src="../imgs/goplaytools.gif"
    alt=""  />
</p>
</p>
<p>目前该 Playground 有如下特性：</p>
<ul>
<li>代码完成：标准库</li>
<li>加载和保存文件</li>
<li>代码片段和教程，基于 <a href="https://gobyexample.com/" target="_blank" rel="noopener">gobyexample.com</a>
</li>
<li>WebAssembly 支持</li>
<li>暗黑模式</li>
<li>更多定制选项</li>
</ul>
<p>和 goplay.space 一样，它也是官方 Playground 的代理，因此官方分享的，在这里也可以直接查看，方便国内用户。上面例子对应该 Playground 是：<a href="https://goplay.tools/snippet/aouL6zP4O35">https://goplay.tools/snippet/aouL6zP4O35</a>。</p>
<p>仔细研究会发现它还支持鼠标右键菜单，有类似 VSCode 的 Command Palette 功能，调出该面板的快捷键是 F1。</p>
<p><p class="md__image">
  <img src="../imgs/goplaytools.png"
    alt=""  />
</p>
</p>
<p>代码完成功能可以显示对应的文档（针对标准库），如下：</p>
<p><p class="md__image">
  <img src="../imgs/goplaytools-doc.png"
    alt=""  />
</p>
</p>
<p>可见这真的是一个更好的 Playground，一定程度上有点在线编辑器的感觉。该项目在 GitHub 的地址：<a href="https://github.com/x1unix/go-playground">https://github.com/x1unix/go-playground</a>。</p>
<h2 id="后记">后记</h2>
<p>除了以上三款，其实还有一些其他的，比较小众，因此不做对比。最后，推荐大家以后可以使用 <a href="https://goplay.tools/">https://goplay.tools/</a>，有兴趣的也可以为它贡献代码。</p>
]]></content>
		</item>
		
		<item>
			<title>GoUI：一个非常简单的 GUI 框架</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/goui-a-very-simple-ui-framework/</link>
			<pubDate>Mon, 17 Aug 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/goui-a-very-simple-ui-framework/</guid>
			<description>最近，我一直想开发一些桌面（主要是 Windows，但也可以考虑 MacOS 或 Linux）应用程序。虽然 Go 不是开发 UI 应用程序时首选语言，但是该语言的简单性和健壮性仍然使它成为我的首选语言。是的，这是我的锤子（hammer）&amp;hellip; 但这是一个该死的漂亮锤子。 以前，我曾将 Ebiten 图形库用于 Go，以便与孩子们一起编写一些游戏。但是，对于一般的“应用程序”开发（即需要“小部件</description>
			<content type="html"><![CDATA[<p>最近，我一直想开发一些桌面（主要是 Windows，但也可以考虑 MacOS 或 Linux）应用程序。虽然 Go 不是开发 UI 应用程序时首选语言，但是该语言的简单性和健壮性仍然使它成为我的首选语言。是的，这是我的锤子（hammer）&hellip; 但这是一个该死的漂亮锤子。</p>
<p>以前，我曾将 Ebiten 图形库用于 Go，以便与孩子们一起编写一些游戏。但是，对于一般的“应用程序”开发（即需要“小部件 widgets”，例如按钮，菜单等），Ebiten 并非真的适合。因此，我一直在寻找可以使用的 Go UI 库。然而大多数都使用 cgo，但我真的希望我的应用程序是纯 Go。这纯粹是个人喜好，我不知道使用 cgo 而不是纯 Go 会有什么影响。如果我要使用 cgo，我认为首选的 UI 库肯定是 <a href="https://fyne.io/" target="_blank" rel="noopener">Fyne</a>
。Fyne 看起来是一个非常全面的框架，如果您不介意 cgo，我绝对会建议你看看看 Fyne。</p>
<p>还有其他一些库，但没有吸引我。他们说你永远不应该编写自己的安全性代码，并且我也相信你不应该编写自己的 UI 库。但是我忽略了这个建议&hellip;</p>
<p>因此，我写了一个 <a href="https://github.com/kpfaulkner/goui" target="_blank" rel="noopener">GoUI</a>
 !!</p>
<p>这纯粹是那些“抓痒”的项目之一。虽然现在还很早，但 UI 库的基本知识（由 Ebiten 进行实际渲染）正在慢慢融合。在详细介绍下面细节之前，我想先说明一下，我认为程序在 CLI 达到了顶峰。其次，我不是 UI 编程人员……写这些是我个人的兴趣。</p>
<p>GoUI 的基本思想是两种类型的图形元素。一个是可以包含其他面板或小部件的面板（Panel）。另一个是小部件，它是基本的 UI 元素（按钮，文本输入等）。我们目前使用的面板类型有 HPanel（水平添加）和 VPanel（我让你猜）。从技术上讲，我们确实有其他面板，例如工具栏，但这实际上只是 HPanel，需要一点点定制工作。总体而言，如果我可以结合其他现有面板/小工具来构造一些“新”东西，那么我会做的。如果我需要优化或与已有产品脱节，那么我将做一些全新的事情。</p>
<p>我们目前拥有的小部件是：</p>
<ul>
<li>
<p>ImageButton：（由应用程序提供的单击/未单击的图像）。</p>
</li>
<li>
<p>TextButton：基本的彩色矩形，其中包含您想要的任何文本。</p>
</li>
<li>
<p>Checkbox：与 TextButton 相同，但是旁边有一个小方框，可以打对勾。</p>
</li>
<li>
<p>EmptySpace：完全由我控制。用于强制其他小部件之间的空间。一旦添加适当的填充，该填充可能会消失。</p>
</li>
<li>
<p>Label：文本标签，不能输入。</p>
</li>
<li>
<p>Text Input：文本输入框。</p>
</li>
<li>
<p>RadioButtonGroup：这是一个面板，其中包含 vpanel 或 hpanel（取决于标志），然后其中包含许多复选框。复选框将图像（带有刻度）替换为常规的单选按钮。这是重新使用现有窗口小部件的好例子。如果事实证明我需要对复选框进行足够的修改以使其不适合用作单选按钮，那么我将不得不放入一个真正的单选按钮。但是目前，它运行良好。</p>
</li>
</ul>
<p>我还没有完成菜单，模态窗口等，但是正如我所说的……这还是早期。</p>
<p>现在，让我们尝试一个超级简单的 Demo。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
 
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;github.com/hajimehoshi/ebiten&#34;</span>
    <span class="s">&#34;github.com/kpfaulkner/goui/pkg&#34;</span>
    <span class="s">&#34;github.com/kpfaulkner/goui/pkg/widgets&#34;</span>
    <span class="nx">log</span> <span class="s">&#34;github.com/sirupsen/logrus&#34;</span>
    <span class="s">&#34;image/color&#34;</span>
<span class="p">)</span>
 
<span class="kd">type</span> <span class="nx">MyApp</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">window</span> <span class="nx">pkg</span><span class="p">.</span><span class="nx">Window</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">NewMyApp</span><span class="p">()</span> <span class="o">*</span><span class="nx">MyApp</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="nx">MyApp</span><span class="p">{}</span>
    <span class="nx">a</span><span class="p">.</span><span class="nx">window</span> <span class="p">=</span> <span class="nx">pkg</span><span class="p">.</span><span class="nf">NewWindow</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="s">&#34;test app&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">a</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">SetupUI</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">vPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewVPanel</span><span class="p">(</span><span class="s">&#34;main vpanel&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">})</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">AddPanel</span><span class="p">(</span><span class="nx">vPanel</span><span class="p">)</span>
    <span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">button1</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">Run</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nf">SetupUI</span><span class="p">()</span>
    <span class="nx">ebiten</span><span class="p">.</span><span class="nf">SetRunnableInBackground</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
    <span class="nx">ebiten</span><span class="p">.</span><span class="nf">SetWindowResizable</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">MainLoop</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">DebugLevel</span><span class="p">)</span>
    <span class="nx">app</span> <span class="o">:=</span> <span class="nf">NewMyApp</span><span class="p">()</span>
    <span class="nx">app</span><span class="p">.</span><span class="nf">Run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>让我们解释一下以上代码。</p>
<p>首先，该程序的核心仍然是直接调用 Ebiten。这些尚未封装。因此，你将在 main 和 Run 函数中看到，我们基本上已经制作了 MyApp 结构的实例，然后调用 SetupUI，设置一些 Ebiten 标志，然后调用 MainLoop。</p>
<p>NewMyApp 函数调用 pkg.NewWindow 函数。这是应用程序的主窗口。一旦添加了模态/其他窗口，这可能会更改，但是就目前而言，这将创建给定大小的主 UI 窗口。</p>
<p>SetupUI 是你需要注意的地方。我们要做的第一件事是创建一个 VPanel。请记住，VPanel 把小部件垂直堆叠放置。我们将 vPanel 添加到主窗口。实际上（当前），我们应该只在主窗口中添加 1 个面板，其他所有内容都应放入该面板中。因此，在这种情况下，我们创建 button1（新的 TextButton）并将其添加到 vPanel。</p>
<p><p class="md__image">
  <img src="../imgs/goui-01.png"
    alt=""  />
</p>
</p>
<p>花点时间来学习理解一下上面的 UI 技能。</p>
<p>下面，让我们做一些更有趣的事情。假设我们要在按下按钮时做出响应。创建 TextButton 的行是：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</code></pre></div><p>所有细节就不描述了，但是最后一个参数是带有 <strong>func (event IEvent) error</strong> 签名的事件处理程序。因此，如果我们创建一个带有该签名的方法，并将其作为最后一个参数传递给 NewTextButton。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">ButtonAction1</span><span class="p">(</span><span class="nx">event</span> <span class="nx">events</span><span class="p">.</span><span class="nx">IEvent</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;My button1 action 1!!!&#34;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>然后我们将按钮创建修改为</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ButtonAction1</span><span class="p">)</span>
</code></pre></div><p>现在，当单击按钮时，将调用 ButtonAction1 函数，我们可以触发所需的任何功能。</p>
<p>是不是很简单。</p>
<p>现在，如果我想要在按钮旁边放点东西该怎么办？我们在这里要做的是创建一个 HPanel，并将其首先放入 VPanel。然后，将按钮添加到 HPanel。如果这样做，我们最终将得到如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">SetupUI</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
 
    <span class="nx">vPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewVPanel</span><span class="p">(</span><span class="s">&#34;main vpanel&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">})</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">AddPanel</span><span class="p">(</span><span class="nx">vPanel</span><span class="p">)</span>
 
    <span class="nx">hPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewHPanel</span><span class="p">(</span><span class="s">&#34;hpanel1&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">})</span>
    <span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">hPanel</span><span class="p">)</span>
 
    <span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ButtonAction1</span><span class="p">)</span>
    <span class="nx">hPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">button1</span><span class="p">)</span>
 
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>从视觉上看，什么都不会改变。我们仍然只显示 1 个小部件。</p>
<p>现在，如果我们在同一 HPanel 中添加一个复选框怎么办？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MyApp</span><span class="p">)</span> <span class="nf">SetupUI</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
 
    <span class="nx">vPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewVPanel</span><span class="p">(</span><span class="s">&#34;main vpanel&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">})</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">window</span><span class="p">.</span><span class="nf">AddPanel</span><span class="p">(</span><span class="nx">vPanel</span><span class="p">)</span>
 
    <span class="nx">hPanel</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewHPanel</span><span class="p">(</span><span class="s">&#34;hpanel1&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">color</span><span class="p">.</span><span class="nx">RGBA</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">})</span>
    <span class="nx">button1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewTextButton</span><span class="p">(</span><span class="s">&#34;text button 1&#34;</span><span class="p">,</span> <span class="s">&#34;my button1&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ButtonAction1</span><span class="p">)</span>
    <span class="nx">hPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">button1</span><span class="p">)</span>
 
    <span class="nx">cb1</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewCheckBox</span><span class="p">(</span><span class="s">&#34;my checkbox1&#34;</span><span class="p">,</span> <span class="s">&#34;check me please&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="nx">hPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">cb1</span><span class="p">)</span>
 
    <span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">hPanel</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>因此，与之前完全相同，但只有这额外的两条：创建复选框，然后添加到 hPanel。</p>
<p>现在 UI 看起来是这样：</p>
<p><p class="md__image">
  <img src="../imgs/goui-02.png"
    alt=""  />
</p>
</p>
<p>现在不担心这里的间距了。</p>
<p>现在让我们在 TextButton 下面添加一个 ImageButton。这意味着我们将向 vPanel 添加第二项（第一项是 hPanel）</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">imageButton</span> <span class="o">:=</span> <span class="nx">widgets</span><span class="p">.</span><span class="nf">NewImageButton</span><span class="p">(</span><span class="s">&#34;ib1&#34;</span><span class="p">,</span> <span class="s">&#34;images/pressedbutton.png&#34;</span><span class="p">,</span> <span class="s">&#34;images/nonpressedbutton.png&#34;</span><span class="p">,</span><span class="kc">nil</span> <span class="p">)</span>
<span class="nx">vPanel</span><span class="p">.</span><span class="nf">AddWidget</span><span class="p">(</span><span class="nx">imageButton</span><span class="p">)</span>
</code></pre></div><p>这是效果如下：</p>
<p><p class="md__image">
  <img src="../imgs/goui-03.png"
    alt=""  />
</p>
</p>
<p>这时，我们有了 2 张图片（屏幕截图中只显示了一张）。按下按钮时一个，不按下时一个（只更改了阴影）。懂了吧。</p>
<p>好了，介绍就这么多。虽然该 UI 库还不完善，但 GUI 的基本功能已经可以实现了。再次放上该库的地址：<a href="https://github.com/kpfaulkner/goui">https://github.com/kpfaulkner/goui</a>。</p>
<blockquote>
<p>作者：<a href="https://kpfaulkner.wordpress.com/author/kpfaulkner/" target="_blank" rel="noopener">kpfaulkner</a>
</p>
<p>日期：2020 年 8 月 17 日</p>
<p>原文链接：<a href="https://kpfaulkner.wordpress.com/2020/08/17/goui-a-very-simple-ui-framework/">https://kpfaulkner.wordpress.com/2020/08/17/goui-a-very-simple-ui-framework/</a></p>
<p>译者：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Go 源代码中的复活节彩蛋</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/easter-eggs-in-go-source-code-2l02/</link>
			<pubDate>Fri, 17 Jul 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/easter-eggs-in-go-source-code-2l02/</guid>
			<description>前言 前段时间，我在某个 Slack 工作区与朋友聊天： 朋友：“有人知道为什么time.minWall 的默认值是 1885 吗？” 我：“不知道，也许是从《回到未来 3》那一年开始的？” 我那么说基本是在开玩笑，因为我也不知道为什么将其设置为 1885 年。尽管其背后的事实与我在 Go 中的日常编码没有任何关系，但我还是情不自禁地询问了幕后花絮。我在团队聊天中问了我的同伴 Gophers，但似乎没人能找到</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>前段时间，我在某个 Slack 工作区与朋友聊天：</p>
<blockquote>
<p>朋友：“有人知道为什么<code>time.minWall</code> 的默认值是 1885 吗？”
我：“不知道，也许是从《<em>回到未来 3</em>》那一年开始的？”</p>
</blockquote>
<p>我那么说基本是在开玩笑，因为我也不知道为什么将其设置为 1885 年。尽管其背后的事实与我在 Go 中的日常编码没有任何关系，但我还是情不自禁地询问了幕后花絮。我在团队聊天中问了我的同伴 Gophers，但似乎没人能找到相关的线索。</p>
<p>最后，我直接向 Russ Cox（<a href="https://twitter.com/_rsc" target="_blank" rel="noopener">@_rsc</a>
）发送了一封电子邮件，以了解背景。</p>
<h2 id="timeminwall">time.minWall</h2>
<p>一个 const 值<code>time.minWall</code>设置为 1885，在如下代码中：</p>
<ul>
<li><a href="https://github.com/golang/go/blob/release-branch.go1.15/src/time/time.go#L153" target="_blank" rel="noopener">src/time/time.go</a>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="nx">hasMonotonic</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">63</span>
    <span class="nx">maxWall</span>      <span class="p">=</span> <span class="nx">wallToInternal</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">33</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// year 2157
</span><span class="c1"></span>    <span class="nx">minWall</span>      <span class="p">=</span> <span class="nx">wallToInternal</span>               <span class="c1">// year 1885
</span><span class="c1"></span>    <span class="nx">nsecMask</span>     <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nx">nsecShift</span>    <span class="p">=</span> <span class="mi">30</span>
<span class="p">)</span>
</code></pre></div><p>这是个常数值，它定义了时间包中值的时代。这是一个常量值，它定义了 time 包的时间纪元。我们经常使用 UNIX 纪元（即 1970 年 1 月 1 日 UTC 的 00:00:00），但这只是几个用于表示日期时间值的标准或实现中的一个纪元，当然 Go 是一种多平台语言，因此 Go 中的纪元需要涵盖所有这些平台。</p>
<p>Russ Cox 在以下地方公开评论了 Go 的纪元。第一个是在 <a href="https://github.com/golang/go/issues/12914#issuecomment-277335863" target="_blank" rel="noopener">GitHub issue 上</a>
：</p>
<blockquote>
<p>已合入 Go 1.9。我将内部纪元移到 1885 年（最大年份为 2157 年），以避免 NTP 纪元派生的时间出现任何可能的问题。我还调整了设计文档，以调整此更改和一些较小的编码更改。</p>
</blockquote>
<p>但是这个评论只提到了为什么以及何时将内部纪元移到 1885 年，而没有提及为什么他们没有移至其他年份，例如 1900 年。</p>
<p>第二个是内部纪元移动的提案文档。</p>
<ul>
<li><a href="https://github.com/golang/proposal/blob/master/design/12914-monotonic.md" target="_blank" rel="noopener">提案：Go 中的单调时间测量</a>
</li>
</ul>
<blockquote>
<p>基于 Unix 的系统通常使用 1970，而基于 Windows 的系统通常使用 1980。我们不知道任何使用更早默认壁钟时间（Wall Time）的系统，但是由于 NTP 协议纪元使用 1900，因此选择 1900 之前的年份似乎更具前瞻性。</p>
</blockquote>
<p>可见，理论依据也只是支持 1900 年之前的任何年份，而不是特指 1885 年。我几乎可以肯定，这一年来自“<em>回到未来 3”</em>，但我想 100％ 确定这一年，所以我联系了肯定知道这一点的人，即向 Russ Cox 发送了一封电子邮件，询问原因。他在一天之内做出了回应（考虑到 EDT 和 JST 之间的时区差异，这是非常快的）：</p>
<blockquote>
<p>是的，人们说服我移到 1900 年之前，而 1885 年是显而易见的选择，因为它对加利福尼亚的希尔山谷（Hill Valley）具有历史意义。:-)</p>
</blockquote>
<p>这就是我知道的！！同样，我很高兴能够从谁做出决定中得到真正的答案。</p>
<h2 id="httpalongtimeago">http.aLongTimeAgo</h2>
<p>尽管我很欣赏 Russ 的回答，但这还不是故事的结局。Russ 的回信中还有另外一行。</p>
<blockquote>
<p>另请参见 http.aLongTimeAgo，现在将其设置为 time.Unix(1, 0)，但以前是 time.Unix(233431200, 0)。</p>
</blockquote>
<p>正如他所说，在 Go1.15 中，它设置为<code>time.Unix(1, 0)</code>。</p>
<ul>
<li><a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.15/src/net/http/http.go#L30" target="_blank" rel="noopener">Go 1.15: src/net/http/http.go</a>
</li>
</ul>
<pre><code>// aLongTimeAgo is a non-zero time, far in the past, used for
// immediate cancellation of network operations.
var aLongTimeAgo = time.Unix(1, 0)
</code></pre><p>因此，我们在源码中确认其原始值。你可以在 Go 1.8 中找到它。</p>
<ul>
<li><a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.8/src/net/http/http.go#L23" target="_blank" rel="noopener">Go 1.8: src/net/http/http.go</a>
</li>
</ul>
<pre><code>// aLongTimeAgo is a non-zero time, far in the past, used for
// immediate cancelation of network operations.
var aLongTimeAgo = time.Unix(233431200, 0)
</code></pre><p>我们将 UNIX 时间转换为人类可读的格式。当然，Go 提供了超级简单的方法。</p>
<ul>
<li><a href="https://play.golang.org/p/c4u1lF5Q6xQ" target="_blank" rel="noopener">示例代码：以人类可读的格式读取 UNIX 时间</a>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">pdt</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">LoadLocation</span><span class="p">(</span><span class="s">&#34;America/Los_Angeles&#34;</span><span class="p">)</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Unix</span><span class="p">(</span><span class="mi">233431200</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="nf">In</span><span class="p">(</span><span class="nx">pdt</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>结果是：</p>
<pre><code>1977-05-25 11:00:00 -0700 PDT
</code></pre><p>我们得到 2 条提示：“A Long Time Ago”和 “1977-05-25”。这两个是：</p>
<p><p class="md__image">
  <img src="../imgs/eggs01.jpeg"
    alt=""  />
</p>
</p>
<p>当然，除了*《星球大战：第四集》外*，别无其他。它于1977年5月25日发布的（<a href="https://en.wikipedia.org/wiki/Star_Wars_%28film%29" target="_blank" rel="noopener">Wikipedia</a>
）</p>
<p>Go 包中如何使用此值呢？这是通过指定过去时间的截止日期来强制取消现有连接，例如：</p>
<pre><code>cr.conn.rwc.SetReadDeadline(aLongTimeAgo)
</code></pre><p>当该值被改为 <code>time.Unix(1, 0)</code> 时，有人注意到了，因此对此作了一些评论（比如 1977-05-25 是谁的生日吗？）。我喜欢看到这些评论。这些有趣的聊天有时会在更改列表中进行。</p>
<ul>
<li><a href="https://github.com/golang/go/commit/6983b9a57955fa12ecd81ab8394ee09e64ef21b9" target="_blank" rel="noopener">net, net/http: 调整过去的时间到更早的时间</a>
</li>
</ul>
<h2 id="致谢">致谢</h2>
<ul>
<li>Russ Cox：感谢您回答我的问题和其他信息。另外，感谢您允许公开分享此内容。引用他的评论：</li>
</ul>
<blockquote>
<p>放心吧。这里没有秘密。</p>
</blockquote>
<ul>
<li><a href="https://twitter.com/broady" target="_blank" rel="noopener">Chris Broadfoot</a>
 和 <a href="https://twitter.com/val_deleplace" target="_blank" rel="noopener">Valentin Deleplace</a>
：感谢你们在群聊中一起找到线索。</li>
<li><a href="https://twitter.com/mattn_jp" target="_blank" rel="noopener">mattn</a>
：感谢您让我知道人们对此价值<a href="https://twitter.com/mattn_jp" target="_blank" rel="noopener">有何</a>
反应的 GitHub 评论线。</li>
</ul>
<h2 id="注意">注意</h2>
<p>该文最初于 2020-07-17 发布于我的日语博客中。</p>
<ul>
<li><a href="https://ymotongpoo.hatenablog.com/entry/2020/07/17/093000">https://ymotongpoo.hatenablog.com/entry/2020/07/17/093000</a></li>
</ul>
<blockquote>
<p>原文链接：https://dev.to/ymotongpoo/easter-eggs-in-go-source-code-2l02</p>
<p>作者：Yoshi Yamaguchi</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>GoLand 2020.2 Beta 版发布：go.mod 升级以及对泛型的实验性支持</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/2020.2.beta/</link>
			<pubDate>Thu, 16 Jul 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/2020.2.beta/</guid>
			<description>GoLand 2020.2 达到 Beta。这意味着我们将结束一连串的新功能开发，将重点转移到完善我们已经完成的工作上，并开始计算发布日之前的日子！
与我们的“抢先体验计划”版本相比，该测试版非常稳定，但请记住，可能仍然在某处存在 Bug。
同样请注意，此 Beta 版本是 EAP 周期中的最后一个版本，不需要订阅即可使用（如果您只是想尝试 GoLand，请尝试）。测试版通常会在发布候选版本之后出现，一旦我们发现该版本足够好并且可以在您的计算机上安装了。
在此发布周期中，我们为即将推出的 GoLand 2020.2 打包了 Go 模块的新功能，更好地呈现了代码中可能存在的问题和薄弱环节，提供了新的代码检查功能以及新的代码编辑功能，例如期待已久的 “Add Caret Per Selected Line”，改进了后台流程，使其更透明，更快，更多！
让我们来看看即将发布的版本中的新功能。选择您感兴趣的主题，或浏览整个博客文章以了解每个新功能。
 Go Modules Generics a.k.a. Type Parameters Code Editing Code Inspections Take Variadic Arguments Under Сontrol References from Comments Save Projects as Templates Under the Hood Processes Version Control  Go Modules 支持 GOMODCACHE 环境变量 从 Go 1.15 开始，可以使用新的 GOMODCACHE 环境变量将 Go Modules 缓存的默认位置从 $GOPATH/pkg/mod 更改为另一个文件夹。
为此，只需在 “Preferences/Settings | Go Modules | Environment” 设置 GOMODCACHE 即可。
IDE 将识别自定义位置，并将其用于具有依赖关系的所有后续操作。同步依赖项快速修复程序（可通过 Alt + Enter 实现）会将依赖项下载到 GOMODCACHE，外部库也将在新的自定义位置显示依赖项。
升级 go.mod 文件 行注释（在 Windows/Linux 上为 Ctrl + /，在 macOS 上为 ⌘ + /）可用于 go.mod 文件。
现在，当您键入 replace，exclude 和 require 语句的左括号时，GoLang 立即自动为你添加右括号。
泛型（又称类型参数） 6月16日，Go Team 宣布了泛型（也称为类型参数）设计草案。请访问 Golang 文档以获取有关该概念的完整详细信息 。
这是一个重大的发展，因此我们立即着手增加对它的支持。GoLand 2020.2 Beta 提供了对泛型的实验性支持，您可以通过在 Settings/Preferences | Go 启用对泛型的实验性支持。
此初始支持提供语法高亮显示和基本参考解析，并且仅在 go2 文件中有效。
请注意，有关泛型的工作仍在进行中，我们目前尚无法提供全面的支持。
尽管如此，请分享您的体验和您可能有的任何建议。它确实可以帮助我们完善到目前为止已完成的工作，因此我们可以使其可靠并使用更高级的功能进行填充。
代码编辑 想要将快速修复的结果应用于代码之前预览其结果，请使用 Alt + Enter 快捷方式调用显示上下文操作，选择所需的快速修复，然后在 macOS 上按 Alt + Space 或在 Windows 和 Linux 上为 Ctrl + Shift + I。
新的“按选定的行添加插入（多行操作）”操作会在每个选定行的末尾插入，并取消选择这些行。在 Windows/Linux 上使用快捷键 Alt + Shift + G 或在 macOS 上使用 ⌥ + ⇧ + G 调用它。
在 Preferences/Settings | Editor | Code Style | Go | Wrapping and Braces 中为调用参数，函数参数和复合文字元素配置换行。或者，您可以使用 Alt + Enter 键，调出 Put arguments on separate lines 和 *Put arguments on one line，*以手动拆分和合并元素。</description>
			<content type="html"><![CDATA[<p>GoLand 2020.2 达到 Beta。这意味着我们将结束一连串的新功能开发，将重点转移到完善我们已经完成的工作上，并开始计算发布日之前的日子！</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-1.png"
    alt=""  />
</p>
</p>
<p>与我们的“抢先体验计划”版本相比，该测试版非常稳定，但请记住，可能仍然在某处存在 Bug。</p>
<p>同样请注意，此 Beta 版本是 EAP 周期中的最后一个版本，不需要订阅即可使用（如果您只是想尝试 GoLand，请尝试）。测试版通常会在发布候选版本之后出现，一旦我们发现该版本足够好并且可以在您的计算机上安装了。</p>
<p>在此发布周期中，我们为即将推出的 GoLand 2020.2 打包了 Go 模块的新功能，更好地呈现了代码中可能存在的问题和薄弱环节，提供了新的代码检查功能以及新的代码编辑功能，例如期待已久的 “Add Caret Per Selected Line”，改进了后台流程，使其更透明，更快，更多！</p>
<p>让我们来看看即将发布的版本中的新功能。选择您感兴趣的主题，或浏览整个博客文章以了解每个新功能。</p>
<ul>
<li>Go Modules</li>
<li>Generics a.k.a. Type Parameters</li>
<li>Code Editing</li>
<li>Code Inspections</li>
<li>Take Variadic Arguments Under Сontrol</li>
<li>References from Comments</li>
<li>Save Projects as Templates</li>
<li>Under the Hood Processes</li>
<li>Version Control</li>
</ul>
<h2 id="go-modules">Go Modules</h2>
<h3 id="支持-gomodcache-环境变量">支持 GOMODCACHE 环境变量</h3>
<p>从 Go 1.15 开始，可以使用新的 GOMODCACHE 环境变量将 Go Modules 缓存的默认位置从 $GOPATH/pkg/mod 更改为另一个文件夹。</p>
<p>为此，只需在 “<em>Preferences/Settings | Go Modules | Environment</em>” 设置 GOMODCACHE 即可。</p>
<p>IDE 将识别自定义位置，并将其用于具有依赖关系的所有后续操作。同步依赖项快速修复程序（可通过 Alt + Enter 实现）会将依赖项下载到 GOMODCACHE，外部库也将在新的自定义位置显示依赖项。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-2.png"
    alt=""  />
</p>
</p>
<h2 id="升级-gomod-文件">升级 go.mod 文件</h2>
<p>行注释（在 Windows/Linux 上为 Ctrl + /，在 macOS 上为 ⌘ + /）可用于 go.mod 文件。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-3.gif"
    alt=""  />
</p>
</p>
<p>现在，当您键入 replace，exclude 和 require 语句的左括号时，GoLang 立即自动为你添加右括号。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-4.gif"
    alt=""  />
</p>
</p>
<h2 id="泛型又称类型参数">泛型（又称类型参数）</h2>
<p>6月16日，Go Team 宣布了泛型（也称为类型参数）设计草案。请访问 Golang 文档以获取有关该概念的<a href="https://go.googlesource.com/proposal/&#43;/refs/heads/master/design/go2draft-type-parameters.md" target="_blank" rel="noopener">完整详细信息</a>
。</p>
<p>这是一个重大的发展，因此我们立即着手增加对它的支持。GoLand 2020.2 Beta 提供了对泛型的实验性支持，您可以通过在 <em>Settings/Preferences | Go</em> 启用对泛型的实验性支持。</p>
<p>此初始支持提供语法高亮显示和基本参考解析，并且仅在 go2 文件中有效。</p>
<p>请注意，有关泛型的工作仍在进行中，我们目前尚无法提供全面的支持。</p>
<p>尽管如此，请分享您的体验和您可能有的任何建议。它确实可以帮助我们完善到目前为止已完成的工作，因此我们可以使其可靠并使用更高级的功能进行填充。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-5.png"
    alt=""  />
</p>
</p>
<h2 id="代码编辑">代码编辑</h2>
<p>想要将快速修复的结果应用于代码之前预览其结果，请使用 Alt + Enter 快捷方式调用显示上下文操作，选择所需的快速修复，然后在 macOS 上按 Alt + Space 或在 Windows 和 Linux 上为 Ctrl + Shift + I。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-6.gif"
    alt=""  />
</p>
</p>
<p>新的“按选定的行添加插入（多行操作）”操作会在每个选定行的末尾插入，并取消选择这些行。在 Windows/Linux 上使用快捷键 Alt + Shift + G 或在 macOS 上使用 ⌥ + ⇧ + G 调用它。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-7.gif"
    alt=""  />
</p>
</p>
<p>在 <em>Preferences/Settings | Editor | Code Style | Go | Wrapping and Braces</em> 中为调用参数，函数参数和复合文字元素配置换行。或者，您可以使用 Alt + Enter 键，调出 <em>Put arguments on separate lines</em> 和 *Put arguments on one line，*以手动拆分和合并元素。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-8.gif"
    alt=""  />
</p>
</p>
<h2 id="代码检查">代码检查</h2>
<p>GoLand 2020.2 有了一个新的检查部件（<em>Inspections Widget</em>）！它位于代码编辑器的右上角，显示当前文件中的警告，错误和错别字数量。您可以使用箭头图标或“下一个错误”操作（F2）遍历它们。</p>
<p>该小部件可让您配置突出显示级别（从无、仅错误或所有问题中选择），更改检查的严重性级别以及切换紧凑视图。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-9.gif"
    alt=""  />
</p>
</p>
<p>我们还添加了一个“问题视图”工具窗口，该窗口显示当前文件中的警告和错误列表，为您提供这些问题的描述，并让您立即使用 Alt + Enter 进行修复。在“问题视图”工具窗口中右键单击问题，以直接移至发生错误的代码行。要打开“问题视图”，请单击“检查”小部件或转到 <em>View | Tool Window | Problems</em>。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-10.gif"
    alt=""  />
</p>
</p>
<p>GoLand 2020.2 现在在所有情况下都在项目视图中标记包含错误的文件，以使您更容易发现它们。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-11.png"
    alt=""  />
</p>
</p>
<p>现在，新的代码检查可以处理 string(int) 转换可能出现的问题，这些转换返回 Unicode代码点 x 的 UTF-8 表示形式，而不是预期的 x 十进制字符串表示形式。GoLand 将通知您有关此类潜在错误的信息，并提供专用的快速修复程序。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-12.gif"
    alt=""  />
</p>
</p>
<p>GoLand 会通知您有关测试和示例的常见错误用法，因此您不再需要为此而明确地使用 go vet。在简单情况下，IDE 还提供了快速修复程序。例如，它建议将 Testme 重命名为 TestMe。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-13.png"
    alt=""  />
</p>
</p>
<p>格式错误的 struct tags 代码检查将检查 struct tags 是否符合 Go 约定，并通知您潜在的问题。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-14.png"
    alt=""  />
</p>
</p>
<p>不可能的接口类型断言代码检查将检查类型断言 v.(T) 和相应的 type-switch case，其中 v 的静态类型 V 是无法实现目标接口 T 的接口。这发生在当 V 和 T 包含相同名称但签名不同的方法时。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-15.png"
    alt=""  />
</p>
</p>
<h2 id="在控制下接受可变参数的论证">在控制下接受可变参数的论证</h2>
<p>引入变量重构（在 Windows 和 Linux 上为 Ctrl + Alt + V，在 macOS 上为 ⌘ + ⌥ + V）可以将一些可变参数打包到新的 slice 变量中；相反的，内联变量（在 MacOS 上为 ⌥ + ⌘ + N 和在 Linux 上为 Ctrl + Alt + N），则将切片分解为可变参数。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-16.gif"
    alt=""  />
</p>
</p>
<p>此外，您现在可以通过 Unpack slice 快速修复来处理解包的可变参数的问题。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-17.gif"
    alt=""  />
</p>
</p>
<h2 id="注释中的引用">注释中的引用</h2>
<p>IDE 显示注释中对相关程序包级别声明的引用，并允许您通过“导航到声明或使用”操作（在 macOS 上为 ⌘ + B，在Windows / Linux上为 Ctrl + B）来跳转。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-18.gif"
    alt=""  />
</p>
</p>
<h2 id="将项目另存为模板">将项目另存为模板</h2>
<p>现在，您可以通过将项目或文件另存为自定义项目模板来重复使用它们：选择 <em>Tools</em> | <em>Save Project as Template</em>。IDE 将使用文件、文件夹和构建配置重新创建项目树。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-19.png"
    alt=""  />
</p>
</p>
<h2 id="后台进程">后台进程</h2>
<h3 id="更好地解决带有-vendor-文件夹的项目">更好地解决带有 Vendor 文件夹的项目</h3>
<p>启用 vendoring 模式后，仅使用项目中 Vendor 文件夹中存储的依赖项包来构建应用程序。</p>
<p>现在，如果项目有一个 vendor 文件夹，并且您已经选中了 <em>Settings/Preferences | Go | Go Modules</em> 中的 <em>Enable vendoring mode**automatically</em>，这时只会使用 vendor 文件夹，而不会查询模块缓存。一个重要的优点是您可以更快地发现未解决的依赖项。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-20.gif"
    alt=""  />
</p>
</p>
<h2 id="go-list-命令">Go list 命令</h2>
<p>GoLand 依序运行 go list 命令，并提供一个进度条，其中包含有关队列中 go list 命令的实际数量的信息。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-21.png"
    alt=""  />
</p>
</p>
<h2 id="版本控制">版本控制</h2>
<h3 id="wsl2-在-windows-上对-git-的支持">WSL2 在 Windows 上对 Git 的支持</h3>
<p>GoLand 2020.2 将允许您使用 WSL2 中的 Git，该版本在 Windows 10（2004 年 5 月更新）的本地版本中可用。如果 Windows 中未安装 Git，GoLand 将在 WSL 中自动查找 Git 并使用它。对于从 WSL 打开的项目，它还将自动从 WSL 切换到 Git（通过 \wsl$ 路径）。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-22.gif"
    alt=""  />
</p>
</p>
<h3 id="改进的-git-操作对话框">改进的 Git 操作对话框</h3>
<p>我们针对 <em>Merge</em>, <em>Pull</em> 和 <em>Rebase</em> 之类的操作重新设计了 Git 对话框，以使它们更加一致和好用。我们还使您更容易理解将执行哪个 Git 命令，并在 “Pull” 对话框中添加了 &ndash;rebase 选项，在“Merge”对话框中添加了&ndash;no-verify 选项。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-23.png"
    alt=""  />
</p>
</p>
<h3 id="全面支持-github-pull-request">全面支持 GitHub Pull Request</h3>
<p>GitHub Pull Requests 配备齐全！在不离开 GoLand 的情况下浏览，分配，管理，甚至合并拉取请求，查看时间线和内联注释，提交注释和评论以及接受更改。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-24.png"
    alt=""  />
</p>
</p>
<h3 id="从日志中压缩squash本地提交">从日志中压缩（Squash）本地提交</h3>
<p>现在，您可以在 Git 工具窗口的“日志”选项卡中选择多个本地提交，并将其压缩为一个。可以从右键单击上下文菜单中执行此操作。</p>
<h3 id="改进了比较分支结果的表示方式">改进了“比较分支”结果的表示方式</h3>
<p>现在，当您在 GoLand 中比较 2 个分支时，可以在一个视图中查看比较后的分支的提交。IDE 现在将在编辑器中而不是在 VCS 工具窗口中打开要比较的两个分支的日志，在该窗口中没有足够的空间来显示所有信息。</p>
<p><p class="md__image">
  <img src="../imgs/goland-2020.2-25.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/2020/07/16/goland-2020-2-reaches-beta/</p>
<p>作者：<a href="https://blog.jetbrains.com/author/ekaterina-zharovajetbrains-com" target="_blank" rel="noopener">Ekaterina Zharova</a>
</p>
<p>日期：2020-07-16</p>
<p>编译：polarisxu</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>对 gRPC 的 Rust 和 Go 版本进行基准测试</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/benchmarking-grpc-in-rust-go/</link>
			<pubDate>Thu, 16 Jul 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/benchmarking-grpc-in-rust-go/</guid>
			<description>背景 如果你计划构建可靠，内存安全 ，高性能的应用程序，那么 Rust＆Go 无疑会是你的选择。 如果您希望从内部应用程序中获得更高的性能，则可能还需要考虑使用 gRPC 而不是普通的 REST API。所有这些都是减少您的计算开销的解决方案。 我尝试比较各种库以了解它们的性能，并希望对你有所帮助。 关注的库 tower-grpc (Rust) 高性能 rust 库，尽管已被 tonic 替代 grpc-go (Golang) grpc 的官方 Go 模块 grpc-rust (Rust) 仍在开发中，另一个 rust grpc 库。看起来</description>
			<content type="html"><![CDATA[<h2 id="背景">背景</h2>
<p>如果你计划构建可靠，<a href="https://blog.gds-gov.tech/appreciating-rust-memory-safety-438301fee097" target="_blank" rel="noopener">内存安全</a>
，高性能的应用程序，那么 Rust＆Go 无疑会是你的选择。</p>
<p>如果您希望从内部应用程序中获得更高的性能，则可能还需要考虑使用 <a href="https://grpc.io/docs/what-is-grpc/introduction/" target="_blank" rel="noopener">gRPC</a>
 而不是普通的 <a href="https://restfulapi.net/" target="_blank" rel="noopener">REST</a>
 API。所有这些都是减少您的计算开销的解决方案。</p>
<p>我尝试比较各种库以了解它们的性能，并希望对你有所帮助。</p>
<h2 id="关注的库">关注的库</h2>
<ul>
<li>
<p><a href="https://github.com/tower-rs/tower-grpc" target="_blank" rel="noopener">tower-grpc</a>
 (Rust)</p>
<p>高性能 rust 库，尽管已被 tonic 替代</p>
</li>
<li>
<p><a href="https://github.com/grpc/grpc-go" target="_blank" rel="noopener">grpc-go</a>
 (Golang)</p>
<p>grpc 的官方 Go 模块</p>
</li>
<li>
<p><a href="https://github.com/stepancheg/grpc-rust" target="_blank" rel="noopener">grpc-rust</a>
 (Rust)</p>
<p>仍在开发中，另一个 rust grpc 库。看起来很不错</p>
</li>
<li>
<p><a href="https://github.com/hyperium/tonic" target="_blank" rel="noopener">tonic</a>
 (Rust)</p>
<p>tower-grpc 库的改进更新，支持新的 await 语法</p>
</li>
<li>
<p><a href="https://github.com/grpc/grpc-node" target="_blank" rel="noopener">grpc-node</a>
 (NodeJs)</p>
<p>包含有基准基准点</p>
</li>
<li>
<p><a href="https://github.com/tikv/grpc-rs" target="_blank" rel="noopener">grpc-rs</a>
 (Rust — C bindings)</p>
<p>使用 <a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">grpc</a>
 的 rust 库</p>
</li>
</ul>
<h2 id="基准测试工具">基准测试工具</h2>
<p>对于基准测试，我将在 gRPC 中使用与 <a href="https://github.com/rakyll/hey" target="_blank" rel="noopener">Hey</a>
 等效的 <a href="https://github.com/bojand/ghz" target="_blank" rel="noopener">ghz</a>
。</p>
<p>该测试将重点关注如果使用上述每个库将 10,000 个并发请求的相同负载发送到服务器，将有多少开销。我将为每个使用相同的 <a href="https://github.com/grpc/grpc-go/blob/master/examples/helloworld/helloworld/helloworld.proto" target="_blank" rel="noopener">helloworld</a>
 greeter。不会为任何测试启用 TLS，因此我们可以大致了解每种测试的原始性能。</p>
<h3 id="grpc-go">grpc-go</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 229.40 ms
  Slowest: 6.26 ms
  Fastest: 0.11 ms
  Average: 1.04 ms
  Requests/sec: 43591.54Response <span class="nb">time</span> histogram:
  0.114 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  0.728 <span class="o">[</span>3355<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.343 <span class="o">[</span>4580<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.957 <span class="o">[</span>1519<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎
  2.572 <span class="o">[</span>294<span class="o">]</span>  <span class="p">|</span>∎∎∎
  3.187 <span class="o">[</span>36<span class="o">]</span>   <span class="p">|</span>
  3.801 <span class="o">[</span>11<span class="o">]</span>   <span class="p">|</span>
  4.416 <span class="o">[</span>74<span class="o">]</span>   <span class="p">|</span>∎
  5.030 <span class="o">[</span>52<span class="o">]</span>   <span class="p">|</span>
  5.645 <span class="o">[</span>45<span class="o">]</span>   <span class="p">|</span>
  6.259 <span class="o">[</span>33<span class="o">]</span>   <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 0.46 ms
  <span class="m">25</span> % in 0.64 ms
  <span class="m">50</span> % in 0.88 ms
  <span class="m">75</span> % in 1.24 ms
  <span class="m">90</span> % in 1.68 ms
  <span class="m">95</span> % in 2.00 ms
  <span class="m">99</span> % in 4.77 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="tonic">tonic</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 581.81 ms
  Slowest: 6.39 ms
  Fastest: 0.17 ms
  Average: 2.84 ms
  Requests/sec: 17187.66Response <span class="nb">time</span> histogram:
  0.174 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  0.796 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>
  1.418 <span class="o">[</span>6<span class="o">]</span>    <span class="p">|</span>
  2.040 <span class="o">[</span>167<span class="o">]</span>  <span class="p">|</span>∎
  2.662 <span class="o">[</span>3427<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.284 <span class="o">[</span>5074<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.906 <span class="o">[</span>1048<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎
  4.528 <span class="o">[</span>217<span class="o">]</span>  <span class="p">|</span>∎∎
  5.150 <span class="o">[</span>29<span class="o">]</span>   <span class="p">|</span>
  5.773 <span class="o">[</span>21<span class="o">]</span>   <span class="p">|</span>
  6.395 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 2.35 ms
  <span class="m">25</span> % in 2.55 ms
  <span class="m">50</span> % in 2.79 ms
  <span class="m">75</span> % in 3.07 ms
  <span class="m">90</span> % in 3.39 ms
  <span class="m">95</span> % in 3.66 ms
  <span class="m">99</span> % in 4.22 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="grpc-node">grpc-node</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 589.25 ms
  Slowest: 12.56 ms
  Fastest: 1.21 ms
  Average: 2.88 ms
  Requests/sec: 16970.81Response <span class="nb">time</span> histogram:
  1.206 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  2.341 <span class="o">[</span>2592<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.476 <span class="o">[</span>5516<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  4.612 <span class="o">[</span>1588<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎
  5.747 <span class="o">[</span>180<span class="o">]</span>  <span class="p">|</span>∎
  6.882 <span class="o">[</span>42<span class="o">]</span>   <span class="p">|</span>
  8.017 <span class="o">[</span>32<span class="o">]</span>   <span class="p">|</span>
  9.152 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>
  10.288 <span class="o">[</span>20<span class="o">]</span>  <span class="p">|</span>
  11.423 <span class="o">[</span>6<span class="o">]</span>   <span class="p">|</span>
  12.558 <span class="o">[</span>18<span class="o">]</span>  <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 2.14 ms
  <span class="m">25</span> % in 2.33 ms
  <span class="m">50</span> % in 2.62 ms
  <span class="m">75</span> % in 3.24 ms
  <span class="m">90</span> % in 3.85 ms
  <span class="m">95</span> % in 4.26 ms
  <span class="m">99</span> % in 6.41 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="tower-grpc">tower-grpc</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 571.88 ms
  Slowest: 10.59 ms
  Fastest: 0.25 ms
  Average: 2.76 ms
  Requests/sec: 17486.12Response <span class="nb">time</span> histogram:
  0.246 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  1.280 <span class="o">[</span>139<span class="o">]</span>  <span class="p">|</span>∎
  2.314 <span class="o">[</span>2927<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.348 <span class="o">[</span>5198<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  4.382 <span class="o">[</span>1390<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎
  5.416 <span class="o">[</span>114<span class="o">]</span>  <span class="p">|</span>∎
  6.450 <span class="o">[</span>61<span class="o">]</span>   <span class="p">|</span>
  7.484 <span class="o">[</span>80<span class="o">]</span>   <span class="p">|</span>∎
  8.518 <span class="o">[</span>47<span class="o">]</span>   <span class="p">|</span>
  9.552 <span class="o">[</span>31<span class="o">]</span>   <span class="p">|</span>
  10.586 <span class="o">[</span>12<span class="o">]</span>  <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 1.80 ms
  <span class="m">25</span> % in 2.20 ms
  <span class="m">50</span> % in 2.65 ms
  <span class="m">75</span> % in 3.13 ms
  <span class="m">90</span> % in 3.64 ms
  <span class="m">95</span> % in 4.05 ms
  <span class="m">99</span> % in 7.18 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="grpc-rust">grpc-rust</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 479.30 ms
  Slowest: 8.15 ms
  Fastest: 0.90 ms
  Average: 2.34 ms
  Requests/sec: 20863.64Response <span class="nb">time</span> histogram:
  0.901 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  1.626 <span class="o">[</span>193<span class="o">]</span>  <span class="p">|</span>∎
  2.351 <span class="o">[</span>5587<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.076 <span class="o">[</span>3562<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  3.801 <span class="o">[</span>506<span class="o">]</span>  <span class="p">|</span>∎∎∎∎
  4.526 <span class="o">[</span>119<span class="o">]</span>  <span class="p">|</span>∎
  5.251 <span class="o">[</span>16<span class="o">]</span>   <span class="p">|</span>
  5.976 <span class="o">[</span>5<span class="o">]</span>    <span class="p">|</span>
  6.701 <span class="o">[</span>2<span class="o">]</span>    <span class="p">|</span>
  7.426 <span class="o">[</span>2<span class="o">]</span>    <span class="p">|</span>
  8.151 <span class="o">[</span>7<span class="o">]</span>    <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 1.87 ms
  <span class="m">25</span> % in 2.03 ms
  <span class="m">50</span> % in 2.25 ms
  <span class="m">75</span> % in 2.57 ms
  <span class="m">90</span> % in 2.90 ms
  <span class="m">95</span> % in 3.23 ms
  <span class="m">99</span> % in 4.11 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h3 id="grpc-rs">Grpc-rs</h3>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">Summary:
  Count: <span class="m">10000</span>
  Total: 289.82 ms
  Slowest: 4.22 ms
  Fastest: 0.22 ms
  Average: 1.36 ms
  Requests/sec: 34504.74Response <span class="nb">time</span> histogram:
  0.222 <span class="o">[</span>1<span class="o">]</span>    <span class="p">|</span>
  0.621 <span class="o">[</span>195<span class="o">]</span>  <span class="p">|</span>∎∎
  1.021 <span class="o">[</span>1829<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.420 <span class="o">[</span>4059<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  1.820 <span class="o">[</span>2625<span class="o">]</span> <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎∎
  2.219 <span class="o">[</span>972<span class="o">]</span>  <span class="p">|</span>∎∎∎∎∎∎∎∎∎∎
  2.618 <span class="o">[</span>239<span class="o">]</span>  <span class="p">|</span>∎∎
  3.018 <span class="o">[</span>45<span class="o">]</span>   <span class="p">|</span>
  3.417 <span class="o">[</span>18<span class="o">]</span>   <span class="p">|</span>
  3.817 <span class="o">[</span>6<span class="o">]</span>    <span class="p">|</span>
  4.216 <span class="o">[</span>11<span class="o">]</span>   <span class="p">|</span>Latency distribution:
  <span class="m">10</span> % in 0.87 ms
  <span class="m">25</span> % in 1.07 ms
  <span class="m">50</span> % in 1.30 ms
  <span class="m">75</span> % in 1.62 ms
  <span class="m">90</span> % in 1.90 ms
  <span class="m">95</span> % in 2.07 ms
  <span class="m">99</span> % in 2.56 msStatus code distribution:
  <span class="o">[</span>OK<span class="o">]</span>   <span class="m">10000</span> responses
</code></pre></div><h2 id="汇总概要">汇总概要</h2>
<p><p class="md__image">
  <img src="../imgs/rust-go-bench-01.png"
    alt="总响应时间（以毫秒为单位）。越低越好。"  />
</p>
</p>
<p>总响应时间（以毫秒为单位）。越低越好。</p>
<p><p class="md__image">
  <img src="../imgs/rust-go-bench-02.png"
    alt="吞吐量（请求/秒）。越高越好。"  />
</p>
</p>
<p>吞吐量（请求/秒）。越高越好。</p>
<h2 id="总结">总结</h2>
<p>结果表明，在性能方面，rust 与 node 相当，这是一个令人震惊的结果。</p>
<p>Go 库在并发性和最小开销方面均表现出色。</p>
<p>如果有人对 Go 库表现优异有些疑惑，请给留言给出你的看法！</p>
<blockquote>
<p>原文链接：<a href="https://medium.com/@Rustling_gopher/benchmarking-grpc-in-rust-go-184545e7688a">https://medium.com/@Rustling_gopher/benchmarking-grpc-in-rust-go-184545e7688a</a></p>
<p>作者：Rustler</p>
<p>编译：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>从签名售书说起</title>
			<link>https://polarisxu.studygolang.com/posts/talk/sell-my-book/</link>
			<pubDate>Thu, 09 Jul 2020 18:12:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/sell-my-book/</guid>
			<description>上周通过公众号对外公布新手开卖后，有人想要签名版。由于双作者，涉及到双签，知道可能会很麻烦，但第一次，也有可能是最后一次，和煎鱼沟通后决定搞搞。 大概谈谈我们的操作过程。 1、编辑帮我们买书，104 本；也是想办法弄到了当时最便宜的价格； 2、寄到我家里。周六、日分批到的，去封皮签名，大部分还写了一些 Go 箴言，但还有 26 本周末没到； 3、弄好后寄到深圳。用什么快递也是有讲</description>
			<content type="html"><![CDATA[<p>上周通过公众号对外公布新手开卖后，有人想要签名版。由于双作者，涉及到双签，知道可能会很麻烦，但第一次，也有可能是最后一次，和煎鱼沟通后决定搞搞。</p>
<p>大概谈谈我们的操作过程。</p>
<p>1、编辑帮我们买书，104 本；也是想办法弄到了当时最便宜的价格；</p>
<p>2、寄到我家里。周六、日分批到的，去封皮签名，大部分还写了一些 Go 箴言，但还有 26 本周末没到；</p>
<p><p class="md__image">
  <img src="../imgs/go-tour-01.png"
    alt=""  />
</p>
</p>
<p>3、弄好后寄到深圳。用什么快递也是有讲究的。目标是尽可能费用低。对比 了多家，最后找了德邦物流。超重物品运输走物流比较合适。称了一下，一本书 0.8kg，104 本至少 83kg。</p>
<p>4、到深圳后煎鱼签完字一个个寄出去。</p>
<p>这里最麻烦的就是统计需要签名的读者信息和收款。</p>
<p>开始想的比较简单，把意向者拉入群，避免隐私问题，通过问卷的形式收集收货地址。在确认了运费后，通过支付宝收款。主要考虑支付宝可以看到实名，能够和收货地址上的对应上。但支付宝只显示姓名最后一个字。这还好，勉强能搞定。最麻烦的是让大家提交信息或付款。n 多次通过群公告通知所有人，还设置了群待办，依然有人或者没填信息或者填了信息不付款。一个个加好友，有些没法加，有些加了没反应等，各种情况都有。</p>
<p>说了上面这些，我到底想说什么？本文重点来了。</p>
<p><strong>重点 1</strong></p>
<p>不要低估任何看似简单的事情。这在我们的日常工作中很常见。大家脑海中应该浮现了类似的场景吧。</p>
<blockquote>
<p>场景一：</p>
<p>产品经理：这个很简单吧，不就是加一个按钮吗？</p>
<p>程序员：。。。</p>
</blockquote>
<blockquote>
<p>场景二：</p>
<p>老板：什么？这么简单的功能要开发这么久？</p>
<p>程序员：。。。</p>
</blockquote>
<p>有一项研究表明，人们总是会低估他人工作的难度，根源在于自己没有做过或对他人工作不了解。因此，一个重视效率，珍惜时间的人，在做自己从来没有做过的事情时，应该进行一些思考，分析评估事情的难点，可能存在的问题。如果是专业性的，可能需要咨询专业人士，避免浪费时间。</p>
<p>针对签名售书这件事，煎鱼问了曹大当初签名的情况，给的回馈是很麻烦，也给了一些建议或可能的坑。当然我们还是重视不够，没有深究，也许坑自己走一遍印象能够更深刻。</p>
<blockquote>
<p>温馨建议：在工作或生活中，不要麻木指责别人的工作，除非你自己做过或掌握了足够的信息；对于自己来说，准备做没做过的事情，如果比较耗时或重要，应该认真评估，避免浪费不必要的时间，同时效果可能还不好。</p>
</blockquote>
<p><strong>重点 2</strong></p>
<p>靠自觉遵守很多时候是不可行的，总是会出现不遵守的情况，特别是人数或次数多的时候。我们以为进群了就是要签名书的；我们以为 @ 所有人了，大家会看到消息并进行处理；我们以为填了信息的人会进行支付。。。好吧，我们太年轻~</p>
<p>对于程序员，你所在的公司会有这样那样的规范，不说遵守，有时候都不一定能记住。比如代码规范。如果只是简单的约定，靠程序员自觉的遵守，往往是不可行的。程序员号称都很懒，因此能自动化的一定要自动化，能用工具做的绝不人工。</p>
<p>那 Go 语言有哪些规范？如何借助工具辅助进行约束呢？</p>
<p>规范推荐阅读官方的文档：<a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">Go Code Review Comments</a>
，这是每个 Gopher 都应该至少阅读一遍的官方代码规范指南。另外 Uber 公开了其内部的 Go 语言代码规范，供参考：<a href="https://mp.weixin.qq.com/s/nA26g46tM_hu-khaGYniAQ" target="_blank" rel="noopener">Uber Go语言编码规范</a>
。</p>
<p>针对规范，我们有什么工具可以使用呢？</p>
<p>Go 语言提供的工具链是我喜欢 Go 的原因之一，官方提供了一系列工具，其中有一些用于辅助代码规范，使用最多的有：gofmt、goimports、golint 等，此外还有第三方的工具，像 <a href="https://github.com/golangci/golangci-lint" target="_blank" rel="noopener">golangci-lint</a>
 等。这些工具都可以配合你的编辑器使用。好的工具是效率提升的必要条件，因此建议大家花时间折腾下你使用的编辑器或熟悉你使用的编辑器（或 IDE）的一些功能。</p>
<p>以上闲扯，希望对大家之后工作或做事有一定帮助。</p>
<p><strong>福利</strong></p>
<p>上次朋友支持我们的新书，搞了一个抽奖，我看到了就参与一下，结果我竟然中奖了。大家调侃有黑幕，调侃应该双倍重抽。所以，我今天送两本《Go语言编程之旅》，感谢大家的支持！</p>
<p><strong>参与抽奖的请关注下我的公众号，你不会后悔，如果未关注，中奖了无效哦！</strong></p>
]]></content>
		</item>
		
		<item>
			<title>重磅！史上第一本带你做项目的 Go 图书开卖</title>
			<link>https://polarisxu.studygolang.com/posts/talk/my-first-action-book/</link>
			<pubDate>Thu, 02 Jul 2020 20:00:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/talk/my-first-action-book/</guid>
			<description>2020 年过去了一半，这半年对所有人来说都不寻常。但也是这场疫情，让我完成了一件大事：出了一本 Go 语言图书，书名是：《Go 语言编程之旅：一起用 Go 做项目》。 海报 先上海报： 全书共分为 6 章，分别是命令行应用、HTTP 应用、RPC 应用、WebSocket 应用、进程内缓存和 Go 语言中的大杀器，其中前 5 章是 Go 语言开发中最常见的项目类型。本书对项目开发、细节分析、运行时分析等核心内</description>
			<content type="html"><![CDATA[<p>2020 年过去了一半，这半年对所有人来说都不寻常。但也是这场疫情，让我完成了一件大事：出了一本 Go 语言图书，书名是：《Go 语言编程之旅：一起用 Go 做项目》。</p>
<h2 id="海报">海报</h2>
<p>先上海报：</p>
<p><p class="md__image">
  <img src="https://img30.360buyimg.com/vc/jfs/t1/143768/33/1853/1056513/5efd2c6aEa179705e/48099b6c7b9e9c05.jpg"
    alt=""  />
</p>
</p>
<p>全书共分为 6 章，分别是命令行应用、HTTP 应用、RPC 应用、WebSocket 应用、进程内缓存和 Go 语言中的大杀器，其中前 5 章是 Go 语言开发中最常见的项目类型。本书对项目开发、细节分析、运行时分析等核心内容进行了较为深入的剖析，提供了相对完整的项目实践经验。在项目迭代过程中，难免会遇到问题，因此本书针对 Go 语言的大杀器（分析工具）及常见问题进行了全面讲解，帮助读者对各类问题进行排查。本书适合有一定 Go 语言基础的读者以及相关开发人员阅读。</p>
<h2 id="写书那些事">写书那些事</h2>
<p>2019 年 8 月份，博文视点的安娜加我微信，想我出一本 Go 语言的图书。因为时间关系，我并没有打算出。安娜直接约我见面聊，到我公司找我，还送我一本书。之后在微信上多次问我有无意向。有点心动，但担心烂尾。</p>
<p>之前跟 《Go 语言高级编程》的作者柴大交流，他写书时，因为怕烂尾，邀请了曹大一起，两个人相互鼓励、交流、讨论能更好的的完成。正好 2019 年年初认识了煎鱼，之后交流也比较多，他产出很高，写的文章质量不错，于是我和他沟通一起出书的事情。</p>
<p><p class="md__image">
  <img src="../imgs/book-01.png"
    alt=""  />
</p>
</p>
<p>事实证明我没看错人，煎鱼很靠谱，很自律，产出高、质量高，由于我比较忙，因此他主动承担了更多内容，不是找了他，这本书现在肯定不会面世。因此，他理所当然成为了第一作者。由衷感谢，合作愉快。2019 年 12 月中旬我还去了一趟深圳，和煎鱼一起吃了顿饭，交流了很多。年轻人很有想法，前途无量！</p>
<p>所以，看了很多煎鱼文章的，欢迎购买支持；如果你在学习 Go 语言的过程中，Go 语言中文网对你有点帮助，我运营的社区对你有帮助，欢迎购买支持；如果苦于学了 Go 没法实践，这本书也许可以帮助你，那就下单购买吧。</p>
<p>目前京东 7.5 折。</p>
<h2 id="感谢">感谢</h2>
<p>最后感谢我的伙伴煎鱼，感谢博文编辑美丽的安娜，感谢曹大、无闻、杨文大佬推荐，感谢傲飞、大彬、晓东花费宝贵的时间进行 Review。同时要感谢我的老婆，春节期间对我无微不至的照顾，让我全身心投入该书的写作中。</p>
]]></content>
		</item>
		
		<item>
			<title>从这些角度看 Go 是一门很棒的语言</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-is-awesome/</link>
			<pubDate>Mon, 22 Jun 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-is-awesome/</guid>
			<description>Go 当前引起了很多关注。让我们看一下 Go 好的部分。 我最近用 Go 写了一个 SSH 服务器 ，在其中启动容器。该项目已经发展到很大规模，并且我还向 Go 发起了 PR ，以修复我发现的错误。在积累了比 “Hello world！” 更多的经验之后，现在我有信心写出我真正喜欢的 Go 语言部分。 跨平台 Go 引起我注意的原因之一是其构建系统。Java 的最初承诺是它是跨平台的，但是它需要安装运行时的事实显然是一</description>
			<content type="html"><![CDATA[<p>Go 当前引起了很多关注。让我们看一下 Go 好的部分。</p>
<p><p class="md__image">
  <img src="../imgs/go-is-awesome.jpg"
    alt=""  />
</p>
</p>
<p>我最近用 Go 写了一个 <a href="https://github.com/janoszen/containerssh" target="_blank" rel="noopener">SSH 服务器</a>
，在其中启动容器。该项目已经发展到很大规模，并且我还向 Go <a href="https://go-review.googlesource.com/c/crypto/&#43;/236517" target="_blank" rel="noopener">发起了 PR</a>
，以修复我发现的错误。在积累了比 “Hello world！” 更多的经验之后，现在我有信心写出我真正喜欢的 Go 语言部分。</p>
<h2 id="跨平台">跨平台</h2>
<p>Go 引起我注意的原因之一是其构建系统。Java 的最初承诺是它是跨平台的，但是它需要安装运行时的事实显然是一个失败。而 Go 编译为本地二进制文件。在 Windows 上，您将获得一个 .exe 文件，在 Linux 上，您将获得一个 ELF 二进制文件，依此类推。而且，除非您使用 cgo，否则 Go 程序可以在几乎没有外部依赖的情况下运行。无需安装任何 .dll 或 .so 文件，Go 程序即可<a href="https://www.youtube.com/watch?v=YPN0qhSyWy8" target="_blank" rel="noopener">直接使用</a>
。</p>
<p>大部分时候，除了某些函数需要 libc 外，Go 程序可以在完全没有外部依赖的情况下运行。</p>
<p>Go 可以用来构建真正的跨平台二进制文件而无需安装笨拙的运行时（例如使用 Java 或 Python），这一事实是 Go 的主要吸引点。</p>
<h2 id="goroutines-和-channels">Goroutines 和 Channels</h2>
<p>当我开始使用 Go 语言时，我意识到它对并发的处理是多么的酷。传统上，您将使用线程或单独的进程来同时运行多个任务（例如 Java，C，C ++）。另外，您也可以依靠协作式多任务处理（例如 Javascript）来达到相同的效果。</p>
<p>对于线程和进程，操作系统必须执行的每个切换都会造成资源损耗。这称为上下文切换。换句话说，一个使用大量线程的粗心程序员将带来性能问题。</p>
<p>另一方面，协作多任务将在单个线程上运行。每当一项任务必须等待某件事时，另一项任务就会运行。如果一个任务占用了 CPU，其他任务将被饿死。</p>
<p>Go 以巧妙的方式将两者结合在一起。让我们以以下示例为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nf">someOtherFunction</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>注意 go 关键字。通过使用此关键字，someOtherFunction() 可在 goroutine 中运行。想象一下 Go 作为线程池处理并发的方式。每当您运行 goroutine 时，它将在这些线程之一中运行。这样 Go 可以优化线程的使用以提高性能。</p>
<p>为了促进 goroutine 之间的数据传输，Go 引入了通道（channel），通道是应用程序中的消息队列，用于发送数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">chan</span> <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kt">bool</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kc">true</span>
    <span class="p">}()</span>

    <span class="c1">//This will wait until the goroutine finishes
</span><span class="c1"></span>    <span class="o">&lt;-</span> <span class="nx">done</span>
<span class="p">}</span>
</code></pre></div><p>从上面的代码中可以看到，<code>&lt;- channelname</code> 将堵塞当前 goroutine 的执行，直到有可用数据为止，这使得并发编程非常容易。</p>
<p>如果您对更多细节感兴趣，请查看 <a href="https://gobyexample.com/channels" target="_blank" rel="noopener">channel</a>
，<a href="https://gobyexample.com/context" target="_blank" rel="noopener">上下文</a>
和<a href="https://gobyexample.com/mutexes" target="_blank" rel="noopener">互斥锁</a>
。</p>
<h2 id="指针defer-和垃圾收集">指针，Defer 和垃圾收集</h2>
<p>当提到指针时，首先想到的是 C 或 C++。通常，这种记忆并不愉快。</p>
<p>在 Go 中，指针更像是引用。指针并非总是将数据复制到变量中，而是指向原始的内存。不管传递包含指针的变量多少次，任何修改都将始终更改原始值。</p>
<p>让我们看一个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">someVar</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">someStruct</span><span class="p">{}</span>
</code></pre></div><p>现在，变量包含指向该结构的指针。传递时，无论您复制指针多少次，它始终指代相同的内存空间。</p>
<p>但是，与 C 指针不同，Go 指针在不再需要时会自动进行垃圾回收。您无需担心使用后释放或缓冲区溢出漏洞，这些在 Go 中都不是问题。太棒了！</p>
<p>此外，您还可以使用 defer 语句来帮助您进行函数清除。考虑以下函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">close</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Do somehing to clean up stuff
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// Do something else
</span><span class="c1"></span>    <span class="nb">close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>如您所见，我们在此函数中调用了 close() 两次。如果 foo 函数有多个出口（返回），则需要为每个出口重复 close() 调用。</p>
<p>defer 语句完全可以解决此问题：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">foo</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">close</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Do somehing to clean up stuff
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">defer</span> <span class="nb">close</span><span class="p">()</span>

    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">// Do something else
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>defer 语句保证 close 总是会被调用。</p>
<h2 id="多返回值">多返回值</h2>
<p>这看似没什么，但是在编程语言中却很少见。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sshConn</span><span class="p">,</span> <span class="nx">chans</span><span class="p">,</span> <span class="nx">reqs</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ssh</span><span class="p">.</span><span class="nf">NewServerConn</span><span class="p">(</span><span class="nx">tcpConn</span><span class="p">,</span> <span class="nx">config</span><span class="p">)</span>
</code></pre></div><p>有什么理由不喜欢？</p>
<h2 id="oop好的部分">OOP（好的部分）</h2>
<p>尽管 Go 没有类的概念，但仍然可以编写面向对象的代码。</p>
<p>假设有以下 Java 代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">TreeNode</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addChild</span><span class="o">(</span><span class="n">child</span> <span class="n">TreeNode</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nodes</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">child</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>在 Go 中，类似的代码如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TreeNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">children</span> <span class="p">[]</span><span class="nx">treeNode</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">()</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">treeNode</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="nf">AddChild</span><span class="p">(</span><span class="nx">child</span> <span class="o">*</span> <span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>Go 将（<code>treeNode *TreeNode</code>）部分称为接收器。Go 中的 Receiver 可以使用与其他语言中的 this 关键字非常相似的任何数据类型和功能。</p>
<h2 id="slices">Slices</h2>
<p>和许多其他低级语言一样，Go 将数组实现为固定大小的元素列表。创建后无法更改其大小。</p>
<p>另一方面，切片（Slice）是使它们动态化的技巧。当切片已满时，Go 会创建一个更大的切片新副本。Go 以尽可能少的复制的方式优化过程。</p>
<p>此外，Go slice 还具有创建不占用额外内存的子切片的简洁功能。这些切片引用原始的数组。如果更改切片中的数据，则原始数据也将更改。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">data</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;a&#34;</span><span class="p">,</span> <span class="s">&#34;b&#34;</span><span class="p">,</span> <span class="s">&#34;c&#34;</span><span class="p">,</span> <span class="s">&#34;d&#34;</span><span class="p">}</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
	<span class="c1">// Will print [c]
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
	<span class="nx">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;f&#34;</span>
	<span class="c1">//Will print [a b f d]
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>如果您想深入了解，请继续阅读 <a href="https://gobyexample.com/slices" target="_blank" rel="noopener">Go by Example</a>
。</p>
<h2 id="库">库</h2>
<p>选择 Go 的原因之一是库数量众多。SSH 客户端和服务器库？<a href="https://godoc.org/golang.org/x/crypto/ssh" target="_blank" rel="noopener">有</a>
。适用于 AWS 的 SDK？<a href="https://aws.amazon.com/sdk-for-go/" target="_blank" rel="noopener">同样有</a>
。GitHub 操作库？<a href="https://github.com/google/go-github" target="_blank" rel="noopener">当然有</a>
。让我们尝试一些非常少用的东西……FastCGI 协议实现如何？<a href="https://golang.org/pkg/net/http/fcgi/" target="_blank" rel="noopener">当然也有</a>
。</p>
<p>我可以继续，但是没多大必要了。Go 的普及无疑对生态系统有所帮助。</p>
<h2 id="工具">工具</h2>
<p>构建 Go 拥有大量可用的工具。您拥有从<a href="https://blog.golang.org/gofmt" target="_blank" rel="noopener">自动代码格式化</a>
，测试到<a href="https://goreleaser.com/" target="_blank" rel="noopener">完整发布工具</a>
的全套工具。几乎所有的都有很多工具。</p>
<h2 id="结论">结论</h2>
<p>在代码组织方面，Go 当然有其缺点。但是，它特别适合用于各种任务的高性能软件开发。</p>
<p>那 Go 具体有哪些缺点呢？下次我们“喷一喷” Go 的缺点。</p>
<blockquote>
<p>原文链接：https://pasztor.at/blog/go-is-awesome
编译：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>从这些角度看 Go 是一门糟糕的语言</title>
			<link>https://polarisxu.studygolang.com/posts/go/translation/go-is-terrible/</link>
			<pubDate>Mon, 22 Jun 2020 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/translation/go-is-terrible/</guid>
			<description>上篇文章作者讲到了 Go 的优点，这篇文章提到一些缺点。然而，不少内容我是不认可的。欢迎留言说说你的观点。 Go 当前引起了很多关注。让我们看一下 Go 不好的部分。 作为开发人员，如今很难忽视 Go。因为诸如 Docker 和 Kubernetes 之类的软件，它已迅速崛起。但是，如果仅看一下该语言的流行度图表，Go 就与最流行或增长最快的编程语言相去甚远。 为何每个人似乎都在谈论和招聘 Go？从系统级工程到建立网上商</description>
			<content type="html"><![CDATA[<blockquote>
<p>上篇文章作者讲到了 Go 的优点，这篇文章提到一些缺点。然而，不少内容我是不认可的。欢迎留言说说你的观点。</p>
</blockquote>
<p>Go 当前引起了很多关注。让我们看一下 Go 不好的部分。</p>
<p><p class="md__image">
  <img src="../imgs/go-is-terrible.jpg"
    alt=""  />
</p>
</p>
<p>作为开发人员，如今很难忽视 Go。因为诸如 Docker 和 Kubernetes 之类的软件，它已迅速崛起。但是，如果仅看一下该语言的流行度图表，Go 就与最流行或增长最快的编程语言相去甚远。</p>
<p>为何每个人似乎都在谈论和招聘 Go？从系统级工程到建立网上商店，似乎每个人都想使用 Go？这仅仅是炒作曲线吗，Go 适用于它正在执行的任务吗？</p>
<p>我最近用 Go 写了一个 <a href="https://github.com/janoszen/containerssh" target="_blank" rel="noopener">SSH 服务器</a>
，在其中启动容器。该项目已经发展到很大规模，并且我还向 Go <a href="https://go-review.googlesource.com/c/crypto/&#43;/236517" target="_blank" rel="noopener">发起了 PR</a>
，以修复我发现的错误。</p>
<p>在本文中，我将介绍一些不好的部分：语言设计的缺陷，Go 需要进一步成熟的部分，甚至是令人讨厌的地方。</p>
<p>但是，这并非完全不好：Go 具有一些很棒的功能，使其成为许多应用程序的宝贵工具。如果您对此感兴趣，请“继续”阅读上篇文章。</p>
<p>让我们看一下令人讨厌的部分。请记住，本文是基于 Go 1.14 撰写的。时间推移，这些可能会改进。</p>
<h2 id="错误处理">错误处理</h2>
<p>Go 没有异常。在我看来，尽管对异常有非常有效的批评，但 Go 选择用于处理错误的方法却更加糟糕。</p>
<p>你会看到，在 Go 中可以声明如下的函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;this is an error&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>调用此函数时，可以选择处理此错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">doSomethingElse</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">err</span>
    <span class="p">}</span>
    <span class="c1">//More things to do
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这里有很多东西要解释。首先，没有什么可以强制您处理此潜在错误。当然，像 Goland 这样的 IDE 会警告您，但是编译器不会强制您处理此错误。（这个问题也可以通过 linter 来部分缓解，因为 linter 会检查您的源代码是否有类似的意外遗漏。）</p>
<p>更进一步，在 99.9％ 的情况下，错误基本上是字符串。是的，错误是您可以根据需要实现的任何接口，但是我见过的大多数 Go 代码都没有利用此接口来提供类型错误。提供类型错误的标准方法似乎如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">MyError</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;this is an error&#34;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">doSomething</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">MyError</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">doSomethingElse</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="nf">doSomething</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">MyError</span> <span class="p">{</span>
            <span class="c1">// Handle MyError specifically
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Handle other errors
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//More things to do
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>这是样板代码，用于简单的错误处理。但是，更大的问题是函数无法声明它们返回的错误类型。当我使用第三方库的函数进行此操作时，有两个选择：</p>
<ol>
<li>我使用 IDE 跳入第三方库，对它引发的错误类型进行反向工程，然后对其进行处理。在我的职业生涯中，我已经用大约十二种编程语言编写了生产级代码，但是我从来没有像 Go 那样做过这么多的逆向工程。</li>
<li>将错误视为一串未知内容。</li>
</ol>
<p>我研究过的几乎所有 Go 代码都使用选项 2。难怪，这是更简单的代码选项。这导致以下两种模式之一：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;an error happened (%v)&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>第一种选择基本上等同于异常。除了会导致大量的样板代码。第二个选项使程序崩溃，并显示无用的错误消息。</p>
<p>我有强迫开发人员显式处理错误的想法，但是我见过的大多数 Go 代码都只是使用这两种无意识模式之一。</p>
<p>为什么我们不仅仅拥有捕获类型错误的异常？这样会更简单，并且会导致更少的样板代码。哎，现在可能为时已晚。</p>
<h2 id="nullability可空性">Nullability（可空性）</h2>
<p>Go 中的 nil 值可用于任何<a href="https://tour.golang.org/moretypes/1" target="_blank" rel="noopener">指针类型</a>
。指针保存一块内存的地址。在 Go 中，您无法直接分配内存，但是其他编程语言（例如 C）可以实现这一点。指针地址 0 是不指向任何地方的同义词。当然，内存地址为 0 并不一定意味着内存位置无效，但是现代的编译器可以理解这一点，并将空指针转换为要编译的 CPU 体系结构的相应无值类型。</p>
<p>现在，在 Go 中，nil 值实际上是一个问题，因为没有用语言的方式来指示值是否可以为 null。</p>
<pre><code class="language-ggo" data-lang="ggo">something := getSomething()
something.process()
</code></pre><p>如果 something 是 nil，此代码可能会导致崩溃。是的，全面崩溃。当然，您可以重写代码以包括错误处理，但是，如果 Go 从其他语言的错误中学到什么了，那就更好了。</p>
<h2 id="范围界定和代码结构">范围界定和代码结构</h2>
<p>到目前为止，我发现最大的 Bug 是范围界定。Go 没有公开，私有或受保护的限定词。编译器将所有 .go 文件放在同一包中并合并。如果变量名，接口等以小写开头字母书写，则将其视为“私有”，并且仅在程序包中可见。如果以大写首字母书写，则为“公开”。</p>
<p>换句话说，小写字母只能在同一包中访问，大写字母是全局可见的。不幸的是，没有办法限制同一程序包中的可见性。</p>
<blockquote>
<p>注意：使用 Go 模块（这是首选方法）时，一个软件包表示一个目录。其他构建系统（如 Bazel）允许每个目录包含多个软件包。这在某种程度上减轻了范围界定的不足。</p>
</blockquote>
<p>假设您有一个数据结构，以及一组实现非常特定的业务逻辑的函数。某些不熟悉业务逻辑的人可能不会考虑太多，而是在同一包中实现了一种功能，该功能以一种从业务角度来看并不理想的方式更改数据。</p>
<p>在其他编程语言中，通常可以通过更精细的作用域来防止这种情况。例如，您可以使用类并创建私有成员变量来封装数据。</p>
<p>您有两种选择来解决此问题：</p>
<ol>
<li>相信没有人会违反任何存储数据的完整性。</li>
<li>以这样的方式组织您的代码，即每个软件包仅包含最少数量的代码。</li>
</ol>
<p>当然，您可以选择选项 1，但我从未见过这样的选择。总是有一个同事匆忙地执行某些事情而没有思考。范围界定可以使不好的事情变得困难，而让好事情变得容易。这称为防御性编程。</p>
<p>在 Go 防御性编程中，您必须创建许多目录。我认为太多了。可能你会认为 Java 的文件和目录太多了……</p>
<h2 id="缺乏不变性">缺乏不变性</h2>
<p>防御性编程中的另一个有用工具是不变性。不变的数据结构可防止在创建数据结构后对其进行修改，因此只能对其进行复制。尽管就性能而言这不是很有效，但也需要防止意外的副作用。</p>
<p>想象一下一个 HTTP 请求结构体：应用程序的第一层创建它，然后将其向下传递给几个模块。如果将请求结构作为指针向下传递，则修改请求的任何层都将对其进行全局修改，从而在顶层产生潜在的副作用。</p>
<p>即使您不使用指针而按值切片传递结构，仍然是可变的数据结构。</p>
<p>Go 似乎在很大程度上优先考虑性能，而不是避免潜在的错误。除了<a href="https://github.com/jinzhu/copier" target="_blank" rel="noopener">第三方深层复制库</a>
之外，没有语言可以在模块边界创建安全的数据传输。</p>
<p>换句话说，除非使用深层复制库，否则开发人员必须知道整个应用程序中的数据会发生什么，以确保没有意外的副作用。</p>
<h2 id="缺乏泛型">缺乏泛型</h2>
<p>泛型是创建可重用代码的便捷方法。假设我们要建造一棵树。在 Java 中，它可能如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">()</span>
<span class="n">tree</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span>
    <span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="s">&#34;Hello world!&#34;</span><span class="o">)</span>
<span class="o">)</span>
<span class="c1">//...
</span><span class="c1"></span><span class="n">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">getChild</span><span class="o">(</span><span class="n">0</span><span class="o">).</span><span class="na">getData</span><span class="o">()</span>
</code></pre></div><p>如果我们这样编写代码，则数据变量将具有 Object 类型，而没有特定信息。实际上，它是一个字符串，因此我们将没有代码自动提示。我们将需要进行类型转换：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="o">(</span><span class="n">String</span><span class="o">)</span><span class="n">tree</span><span class="o">.</span><span class="na">getChild</span><span class="o">(</span><span class="n">0</span><span class="o">).</span><span class="na">getData</span><span class="o">()</span>
</code></pre></div><p>如果包含的数据不是字符串，则将导致错误。要变通解决此问题，我们可以使用泛型为包含的数据指定类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;()</span>
<span class="n">tree</span><span class="o">.</span><span class="na">addChild</span><span class="o">(</span>
    <span class="k">new</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;(</span><span class="s">&#34;Hello world!&#34;</span><span class="o">)</span>
<span class="o">)</span>
<span class="c1">//...
</span><span class="c1"></span><span class="n">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="na">getChild</span><span class="o">(</span><span class="n">0</span><span class="o">).</span><span class="na">getData</span><span class="o">()</span>
</code></pre></div><p>在这种情况下，数据将是字符串，并且我们可以确保树中只有字符串。</p>
<p>现在 Go 缺乏此特性。因为我们总是需要强制转换为我们相信或希望将返回的数据类型。</p>
<h2 id="oop不好的部分">OOP（不好的部分）</h2>
<p>既然我们讨论了树结构，让我们看一下如何在 Go 中实现树节点。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">tree</span>

<span class="kd">type</span> <span class="nx">TreeNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">children</span> <span class="p">[]</span><span class="nx">treeNode</span>
    <span class="nx">data</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nf">TreeNode</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">treeNode</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="nf">AddChild</span><span class="p">(</span><span class="nx">child</span> <span class="o">*</span> <span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span><span class="p">,</span> <span class="nx">child</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">treeNode</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="nf">GetChild</span><span class="p">(</span><span class="nx">childIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">treeNode</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">childIndex</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p>是的，它没有错误处理，但你知晓了。我们本身没有一个类，但是我们有一个叫做接收器的怪异结构，它是这部分的：<code>（treeNode *TreeNode）</code>。接收者基本上就是其他 OOP 语言中的 this 或 self 关键字。</p>
<p>在 Go 中，您将像这样使用 TreeNode：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tree</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">(</span><span class="nx">data</span> <span class="nx">here</span><span class="p">)</span>
<span class="nx">tree</span><span class="p">.</span><span class="nf">AddChild</span><span class="p">(</span><span class="nf">New</span><span class="p">(</span><span class="nx">data</span> <span class="nx">here</span><span class="p">))</span>
</code></pre></div><p>您甚至可以实现接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TreeNodeInterface</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">AddChild</span><span class="p">(</span><span class="nx">child</span> <span class="nx">TreeNode</span><span class="p">)</span>
    <span class="nf">GetChild</span><span class="p">(</span><span class="nx">childIndex</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">TreeNode</span>
<span class="p">}</span>
</code></pre></div><p>非常简单，上面的接口已经实现了此接口。不需要特殊的关键字，当深入研究新代码时，这并不是完全有帮助。像 Goland 这样的 IDE 可以帮助您进行代码导航，但是很难知道哪种实现在哪里。此外，如果因为没有实现某个接口的一个方法，则代码导航将不再起作用。</p>
<p>此外值得一提的是，缺少继承和泛型，使编写可重用代码非常困难。</p>
<h2 id="没有枚举">没有枚举</h2>
<p>有一个古怪的问题，可能是由于语言的构建方式引起的。现在我们彻头彻尾的傻了。在实现 <a href="https://github.com/janoszen/containerssh" target="_blank" rel="noopener">SSH 服务器</a>
时，我遇到了一段代码，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">newChannel</span><span class="p">.</span><span class="nf">Reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
</code></pre></div><p>参数 reason 是一个 channel.RejectionReason 类型。你认为该类型是什么？让我们使用 IDE 的功能来解决它。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// RejectionReason is an enumeration used when rejecting channel creation
</span><span class="c1">// requests. See RFC 4254, section 5.1.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RejectionReason</span> <span class="kt">uint32</span>
</code></pre></div><p>酷！这是一个 32 位无符号整数。它可以有什么值？不清楚。可以检查我是否发送了无效的值吗？不能。Go 中没有枚举。可能的值分别定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Prohibited</span> <span class="nx">RejectionReason</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">ConnectionFailed</span>
	<span class="nx">UnknownChannelType</span>
	<span class="nx">ResourceShortage</span>
<span class="p">)</span>
</code></pre></div><p>这些值与上面的类型定义无关。世界上没有任何 IDE 可以为您提供代码完成功能，因此您必须深入研究用于解决此问题的库。</p>
<h2 id="包管理">包管理</h2>
<p>长期以来，Go 中的软件包管理绝对是糟糕的。值得庆幸的是，从 1.11 Go 起引入了模块，但是依赖管理距离其他语言还有很长的路要走。</p>
<p>一个主要问题是，它们使用 git 作为软件包管理工具。程序包通常不包含有关其作者，许可证，版本号等的任何元信息。发布版本后，不会冻结任何代码，这完全打破了以后不会更改版本的假设。没有简洁的方法来遵守 Apache 许可要求，以任何合理的方式在您的最终版本中包括 NOTICE 文件。是的，我知道，大多数人不会瞎弄，但实际上你能保证吗？</p>
<h2 id="炒作">炒作</h2>
<p>最后，最愚蠢的是：炒作。如果您想构建系统级的东西，甚至微小优化都可以带来明显的好处，那么 Go 是一种很棒的语言。很明显，它是在考虑执行速度的基础上构建的，以及代码的可维护性。</p>
<p>我遇到的每个较大的 Go 项目都存在一个可怕的混乱局面，它比普通的 Javascript 框架具有更多的依赖项。您必须专注于微小的实现细节，而不是宏观的概念。</p>
<p>Go 不太适合具有大量业务逻辑的应用程序。或网上商店。或您作为普通开发人员遇到的 99％ 的项目 。您不是 Google，并且没有类似 Google 的性能问题。</p>
<h2 id="结论">结论</h2>
<p>Go 当然是系统级开发的绝佳工具，但付出的代价是认知负担。我绝对不想编写带有沉重业务逻辑的内容，但我一直在努力寻找一种更好的工具来编写高性能的系统工具或实用程序。</p>
<blockquote>
<p>原文链接：<a href="https://pasztor.at/blog/go-is-terrible">https://pasztor.at/blog/go-is-terrible</a></p>
<p>编译：polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——实战篇0：使用 Echo 开发一个博客系统</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/action00-intro/</link>
			<pubDate>Sat, 16 May 2020 15:08:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/action00-intro/</guid>
			<description>实战是掌握一门技术很好的方式：纸上得来终觉浅，绝知此事要躬行！ 在初步了解了 Echo 框架的特性、功能后，我们通过具体的一个项目来掌握 Echo 框架，这个项目就是写一个博客系统。 实战篇目标 掌握 go/echo 开发项目的方法； 通过项目更深入掌握 echo； 完善完善，甚至可以作为自己的一个博客系统使用； 因此，在项目实战过程中可能引申讲解 Echo 的特性，毕竟基础篇对 Echo 的特性没有深入讲解。 依赖技术 该实战项</description>
			<content type="html"><![CDATA[<p>实战是掌握一门技术很好的方式：纸上得来终觉浅，绝知此事要躬行！</p>
<p>在初步了解了 Echo 框架的特性、功能后，我们通过具体的一个项目来掌握 Echo 框架，这个项目就是写一个博客系统。</p>
<h2 id="实战篇目标">实战篇目标</h2>
<ul>
<li>掌握 go/echo 开发项目的方法；</li>
<li>通过项目更深入掌握 echo；</li>
<li>完善完善，甚至可以作为自己的一个博客系统使用；</li>
</ul>
<p>因此，在项目实战过程中可能引申讲解 Echo 的特性，毕竟基础篇对 Echo 的特性没有深入讲解。</p>
<h2 id="依赖技术">依赖技术</h2>
<p>该实战项目计划采用前后端分离的方式进行。前端采用 Vue + ElementUI。前端不是强项，目标就是争取能做出来，还凑合，如果你是 Vue 老手，欢迎帮忙处理这块。</p>
<h2 id="主要功能">主要功能</h2>
<p>我们会实现博客系统常用的一些功能，包括：</p>
<ul>
<li>列表页</li>
<li>详情页</li>
<li>归档</li>
<li>标签</li>
<li>浏览数</li>
<li>简单的管理后台</li>
</ul>
<p>该项目代码放在 GitHub 上：<a href="https://github.com/polaris1119/go-echo-example">https://github.com/polaris1119/go-echo-example</a> ，欢迎 star 。</p>
]]></content>
		</item>
		
		<item>
			<title>当 GoLand 遇到 Kubernetes：如何调试和运行 Go 程序</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/using-kubernetes-from-goland/</link>
			<pubDate>Mon, 11 May 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/using-kubernetes-from-goland/</guid>
			<description>这是我们使用 Docker，Docker Compose 或 Kubernetes 运行 Go 服务的系列文章的最后一部分。在这一部分中，我们将专注于使用 Kubernetes 集群时的运行和调试。
虽然我们不会介绍如何安装和配置 Kubernetes 集群，但是可以使用各种工具（例如 kubeadm ，minikube 和 microk8s ）来实现这一目标。如果您使用的是 Windows，则 Docker Desktop for Windows 附带内置的 Kubernetes 支持 。如果您打算使用基于 ARM 芯片的平台（例如 Raspberry Pi 4 ），则可以使用 k3s 之类的东西来入门。
在开始之前，还应该安装 Kubernetes 插件，因为它没有与 IDE 捆绑在一起。您可以通过打开 Settings/Preferences | Plugins | Marketplace并搜索 Kubernetes 找到并安装插件。
在 IDE 中使用 Kubernetes 运行服务 如果您到目前为止一直在关注本系列，那么您会知道所有代码都可以在此 下载和使用，使用 Kubernetes 也是这种情况。我们可以从 kubernetes 分支 开始。
在这里我们可以找到两个不同的文件：db.yaml 和 web.yaml。这些文件包含了我们开始使用 Kubernetes 集群中的应用程序所需的所有定义。为了方便起见，他们还假定 Kubernetes 与 IDE 在同一台计算机上运行。
打开 db.yaml：
apiVersion:v1kind:ConfigMapmetadata:name:db-configlabels:dockerdev:dbdata:POSTGRES_DB:golandPOSTGRES_USER:golandPOSTGRES_PASSWORD:goland---apiVersion:apps/v1kind:StatefulSetmetadata:labels:dockerdev:dbname:dbspec:serviceName:dockerdev-dbselector:matchLabels:dockerdev:dbtemplate:metadata:labels:dockerdev:dbspec:containers:- name:dbimage:postgres:12.2-alpineimagePullPolicy:IfNotPresentenvFrom:- configMapRef:name:db-configports:- containerPort:5432volumeMounts:- name:db-initmountPath:/docker-entrypoint-initdb.d/init.sqlsubPath:init.sqlvolumes:- name:db-inithostPath:path:/d/GoLandProjects/dockerdev---apiVersion:v1kind:Servicemetadata:labels:dockerdev:dbname:dockerdev-db-exportedspec:type:NodePortports:- name:5432-tcpport:5432targetPort:5432nodePort:30432selector:dockerdev:db注意：在启动此示例之前，我们需要确保更改了 init.sql 文件在主机上的位置。您可以通过将路径：/d/ GoLandProjects / dockerdev 替换为先前克隆该项目的位置的路径来实现。
完成此操作后，我们可以使用文件顶部编辑器装订线上的绿色箭头在 Kubernetes 中部署数据库。
部署数据库将创建一个 StatefulSet 并在 pod 中运行数据库。将出现 “Services Tool” 窗口，并显示用于创建资源的命令以及该命令的输出。
Kubernetes 集群概述 在 Kubernetes 集群中，我们将看到工作负载信息，例如正在运行的 Pods, Deployments, Stateful Sets, Daemon Sets, Jobs, Cron Jobs, Replica Sets, 和 Replication Controllers。
我们还可以查看有关集群中服务和入口点的网络信息。
“Configuration” 部分包含当前名称空间或群集的所有配置信息，例如有关运行名称空间，节点，群集角色，角色，配置 map 和秘钥的信息。
最后，“Storage” 部分将向我们显示当前配置中的“持久卷”，“持久卷声明”和“存储类”。
在 IDE 中使用 Kubernetes 集群运行 Go 应用程序 让我们在同一个 Kubernetes 集群中运行 Go 应用程序，看看它是如何工作的。
不过，在运行该应用程序之前，我们首先需要构建该应用程序所在的 Docker 容器。示例代码库中包含一个名为 build Dockerfile 的运行配置，需要运行该配置才能在集群中使用我们的容器。
正如您可能已经猜到的那样，此后，我们终于可以使用先前与 db.yaml 文件一起使用的绿色箭头在 Kubernetes 中运行 Go 应用程序，只有这次我们才在 web.yaml 文件中使用它。
apiVersion:apps/v1kind:Deploymentmetadata:labels:dockerdev:webname:webspec:selector:matchLabels:dockerdev:webtemplate:metadata:labels:dockerdev:webspec:containers:- name:dockerdev-webimage:dockerdev-web:latestimagePullPolicy:Neverenv:- name:DD_DB_HOSTvalue:&amp;#34;dockerdev-db-exported&amp;#34;ports:- containerPort:8000---apiVersion:v1kind:Servicemetadata:labels:dockerdev:webname:dockerdev-web-exportedspec:type:NodePortports:- name:8000-tcpport:8000targetPort:8000nodePort:30800selector:dockerdev:webPro tip：我们可以使用 HTTP 请求文件的方式从 IDE 运行请求，以检查服务是否已启动并正在运行。
从 Kubernetes 调试服务 在使用 GoLand 调试 Kubernetes 服务之前，我们需要对 web.yaml 文件进行一些更改。这些变化可以在我们代码库的 kubernetes-debug 分支中看到。
我们需要进行一些与调试常规 Docker 容器非常相似的更改。
首先，我们需要调整 Dockerfile，然后我们必须使用 Run | Run … | ‘build Dockerfile’ 来配置。</description>
			<content type="html"><![CDATA[<p>这是我们使用 Docker，Docker Compose 或 Kubernetes 运行 Go 服务的系列文章的最后一部分。在这一部分中，我们将专注于使用 Kubernetes 集群时的运行和调试。</p>
<p>虽然我们不会介绍如何安装和配置 Kubernetes 集群，但是可以使用各种工具（例如 <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/" target="_blank" rel="noopener">kubeadm</a>
，<a href="https://kubernetes.io/docs/setup/learning-environment/minikube/" target="_blank" rel="noopener">minikube</a>
 和 <a href="https://microk8s.io/" target="_blank" rel="noopener">microk8s</a>
）来实现这一目标。如果您使用的是 Windows，则 <a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">Docker Desktop for Windows</a>
 附带<a href="https://docs.docker.com/docker-for-windows/kubernetes/" target="_blank" rel="noopener">内置的 Kubernetes 支持</a>
。如果您打算使用基于 ARM 芯片的平台（例如 <a href="https://blog.jetbrains.com/go/2020/02/18/running-goland-on-a-raspberry-pi-4/" target="_blank" rel="noopener">Raspberry Pi 4</a>
），则可以使用 <a href="https://k3s.io/" target="_blank" rel="noopener">k3s</a>
 之类的东西来入门。</p>
<p>在开始之前，还应该安装 Kubernetes 插件，因为它没有与 IDE 捆绑在一起。您可以通过打开 <code>Settings/Preferences | Plugins | Marketplace</code>并搜索 Kubernetes 找到并安装插件。</p>
<h2 id="在-ide-中使用-kubernetes-运行服务">在 IDE 中使用 Kubernetes 运行服务</h2>
<p>如果您到目前为止一直在关注本系列，那么您会知道所有代码都可以<a href="https://github.com/dlsniper/dockerdev" target="_blank" rel="noopener">在此</a>
下载和使用，使用 Kubernetes 也是这种情况。我们可以从 <a href="https://github.com/dlsniper/dockerdev/tree/kubernetes" target="_blank" rel="noopener">kubernetes 分支</a>
开始。</p>
<p>在这里我们可以找到两个不同的文件：db.yaml 和 web.yaml。这些文件包含了我们开始使用 Kubernetes 集群中的应用程序所需的所有定义。为了方便起见，他们还假定 Kubernetes 与 IDE 在同一台计算机上运行。</p>
<p>打开 db.yaml：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">ConfigMap</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-config</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w"></span><span class="nt">data</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">POSTGRES_DB</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">  </span><span class="nt">POSTGRES_USER</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">  </span><span class="nt">POSTGRES_PASSWORD</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">StatefulSet</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">serviceName</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">          </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">postgres:12.2-alpine</span><span class="w">
</span><span class="w">          </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">IfNotPresent</span><span class="w">
</span><span class="w">          </span><span class="nt">envFrom</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">configMapRef</span><span class="p">:</span><span class="w">
</span><span class="w">                </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-config</span><span class="w">
</span><span class="w">          </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span><span class="w">
</span><span class="w">          </span><span class="nt">volumeMounts</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-init</span><span class="w">
</span><span class="w">              </span><span class="nt">mountPath</span><span class="p">:</span><span class="w"> </span><span class="l">/docker-entrypoint-initdb.d/init.sql</span><span class="w">
</span><span class="w">              </span><span class="nt">subPath</span><span class="p">:</span><span class="w"> </span><span class="l">init.sql</span><span class="w">
</span><span class="w">      </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">db-init</span><span class="w">
</span><span class="w">           </span><span class="nt">hostPath</span><span class="p">:</span><span class="w">
</span><span class="w">             </span><span class="nt">path</span><span class="p">:</span><span class="w"> </span><span class="l">/d/GoLandProjects/dockerdev</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db-exported</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">NodePort</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span>-<span class="l">tcp</span><span class="w">
</span><span class="w">      </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span><span class="w">
</span><span class="w">      </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">5432</span><span class="w">
</span><span class="w">      </span><span class="nt">nodePort</span><span class="p">:</span><span class="w"> </span><span class="m">30432</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span></code></pre></div><p><strong>注意</strong>：在启动此示例之前，我们需要确保更改了 init.sql 文件在主机上的位置。您可以通过将路径：/d/ GoLandProjects / dockerdev 替换为先前克隆该项目的位置的路径来实现。</p>
<p>完成此操作后，我们可以使用文件顶部编辑器装订线上的绿色箭头在 Kubernetes 中部署数据库。</p>
<p>部署数据库将创建一个 StatefulSet 并在 pod 中运行数据库。将出现 “Services Tool” 窗口，并显示用于创建资源的命令以及该命令的输出。</p>
<h2 id="kubernetes-集群概述">Kubernetes 集群概述</h2>
<p>在 Kubernetes 集群中，我们将看到工作负载信息，例如正在运行的 Pods, Deployments, Stateful Sets, Daemon Sets, Jobs, Cron Jobs, Replica Sets, 和 Replication Controllers。</p>
<p><p class="md__image">
  <img src="../imgs/14-Launching-a-Kubernetes-ReplicaSet-from-GoLand.gif"
    alt=""  />
</p>
</p>
<p>我们还可以查看有关集群中服务和入口点的网络信息。</p>
<p><p class="md__image">
  <img src="../imgs/15-Kubernetes-Services-and-Ingress-points.gif"
    alt=""  />
</p>
</p>
<p>“Configuration” 部分包含当前名称空间或群集的所有配置信息，例如有关运行名称空间，节点，群集角色，角色，配置 map 和秘钥的信息。</p>
<p><p class="md__image">
  <img src="../imgs/16-Kubernetes-Configuration-options.gif"
    alt=""  />
</p>
</p>
<p>最后，“Storage” 部分将向我们显示当前配置中的“持久卷”，“持久卷声明”和“存储类”。</p>
<p><p class="md__image">
  <img src="../imgs/17-Kubernetes-Storage-options.gif"
    alt=""  />
</p>
</p>
<h2 id="在-ide-中使用-kubernetes-集群运行-go-应用程序">在 IDE 中使用 Kubernetes 集群运行 Go 应用程序</h2>
<p>让我们在同一个 Kubernetes 集群中运行 Go 应用程序，看看它是如何工作的。</p>
<p>不过，在运行该应用程序之前，我们首先需要构建该应用程序所在的 Docker 容器。示例代码库中包含一个名为 build Dockerfile 的运行配置，需要运行该配置才能在集群中使用我们的容器。</p>
<p>正如您可能已经猜到的那样，此后，我们终于可以使用先前与 db.yaml 文件一起使用的绿色箭头在 Kubernetes 中运行 Go 应用程序，只有这次我们才在 web.yaml 文件中使用它。</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-web</span><span class="w">
</span><span class="w">          </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-web:latest</span><span class="w">
</span><span class="w">          </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Never</span><span class="w">
</span><span class="w">          </span><span class="nt">env</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">DD_DB_HOST</span><span class="w">
</span><span class="w">              </span><span class="nt">value</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;dockerdev-db-exported&#34;</span><span class="w">
</span><span class="w">          </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">            </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span><span class="w">
</span><span class="w"></span><span class="nn">---</span><span class="w">
</span><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">v1</span><span class="w">
</span><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Service</span><span class="w">
</span><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-web-exported</span><span class="w">
</span><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">NodePort</span><span class="w">
</span><span class="w">  </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span>-<span class="l">tcp</span><span class="w">
</span><span class="w">      </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span><span class="w">
</span><span class="w">      </span><span class="nt">targetPort</span><span class="p">:</span><span class="w"> </span><span class="m">8000</span><span class="w">
</span><span class="w">      </span><span class="nt">nodePort</span><span class="p">:</span><span class="w"> </span><span class="m">30800</span><span class="w">
</span><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">dockerdev</span><span class="p">:</span><span class="w"> </span><span class="l">web</span><span class="w">
</span></code></pre></div><p><p class="md__image">
  <img src="../imgs/18-Run-a-Go-service-in-Kubernetes-with-GoLand.gif"
    alt=""  />
</p>
</p>
<p><strong>Pro tip</strong>：我们可以使用 HTTP 请求文件的方式从 IDE 运行请求，以检查服务是否已启动并正在运行。</p>
<p><p class="md__image">
  <img src="../imgs/19-Run-HTTP-Request-from-IDE.gif"
    alt=""  />
</p>
</p>
<h2 id="从-kubernetes-调试服务">从 Kubernetes 调试服务</h2>
<p>在使用 GoLand 调试 Kubernetes 服务之前，我们需要对 web.yaml 文件进行一些更改。这些变化可以在我们代码库的 kubernetes-debug 分支中看到。</p>
<p>我们需要进行一些与调试常规 Docker 容器非常相似的更改。</p>
<p>首先，我们需要调整 Dockerfile，然后我们必须使用 <code>Run | Run … | ‘build Dockerfile’ </code>来配置。</p>
<p>接着我们可以使用 <code>Run | Debug … | Kubernetes Service</code>，它将启动 Go Remote 调试配置。</p>
<p><p class="md__image">
  <img src="../imgs/20-Debugging-Go-Service-running-in-Kubernetes.gif"
    alt=""  />
</p>
</p>
<p>调试器将跟之前我们习惯的调试形式一样工作。</p>
<p>这个系列文章是我们使用 Docker，Docker Compose 和 Kubernetes 运行和调试 Go 微服务的总结。</p>
<p>在本文中，我们讨论了如何使用 Kubernetes 插件来编辑 Deployment 文件，以便它将正常启动，从而可以对其进行调试。</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/go/2020/05/11/using-kubernetes-from-goland/</p>
<p>作者：Florin Pățan</p>
<p>翻译：Go语言中文网 polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>在 GoLang 中使用 Docker Compose 运行 Go 应用程序</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/running-go-applications-using-docker-compose-in-goland/</link>
			<pubDate>Fri, 08 May 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/running-go-applications-using-docker-compose-in-goland/</guid>
			<description>今天，我们将继续有关如何使用 Docker 运行 和调试 Go 应用程序 的系列文章。
在本文中，我们将使用 Docker Compose 运行和调试我们的应用程序。对于本文，我们将使用此处的源代码 ，在开始之前切换到 compose 分支 。
使用 Docker Compose 运行 Go 应用程序 让我们从使用 Docker Compose 运行应用程序开始。
查看我们已经创建的项目，可以在代码仓库中找到 docker-compose.yaml 文件：
version:&amp;#34;3.5&amp;#34;services:web:container_name:dockerdevbuild:./ports:- &amp;#34;8000:8000&amp;#34;environment:DD_DB_HOST:dbcommand:/serverdepends_on:- dbdb:container_name:dockerdev-dbimage:postgres:12.2-alpineports:- &amp;#34;5432:5432&amp;#34;environment:POSTGRES_USER:golandPOSTGRES_PASSWORD:golandPOSTGRES_DB:golandvolumes:- ./init.sql:/docker-entrypoint-initdb.d/init.sql在数据库部分，我们需要创建一个名为 init.sql 的新文件。该文件的内容用于设置服务运行所需的数据库。
最后，让我们在 main.go 文件中运行 Sync packages of &amp;lt;project&amp;gt; 来 quick-fix，以下载 pgx 库并运行该应用程序。注意：如果你的模块缓存中还没有 pgx 的 4.5.0 版本，则需要执行此步骤。
运行基于 Docker Compose 的应用程序类似于其他 Run Configurations。单击 docker-compose.yaml 中 services 指令旁边的双绿色箭头按钮。要仅运行一项服务，请点击要运行的服务类型旁边的绿色箭头，例如上面的示例配置中的 web 或 db。
配置运行后，在 Docker 节点下的 Services Tool 窗口中会有一个名为 Compose 的新节点。这里会显示正在运行的每个 Docker Compose 服务套件。
可以浏览每个服务定义，并为每个服务显示所有正在运行的实例。Docker Compose 服务中可用于容器的信息与常规 Docker 容器可使用的信息相同。
注意：如果你要启动较重的服务（例如数据库服务器），或者这些服务需要一些初始化时间，则我们的 Go 程序服务需要考虑这些服务的启动时间。
在我们的示例代码中，这是使用 getDBConnection 函数处理的，该函数尝试在放弃之前尝试几次以指数退避的方式连接到数据库。
重启动 Docker Compose 服务 更改我们的代码后，我们需要重新启动服务以重新加载这些更改。目前，使用 IDE 重新启动它有点复杂，因为这样做需要你执行以下步骤：
 执行 Run | Edit Configurations 并复制一份现有的 Docker Compose 配置； 编辑新创建的配置以添加重新启动的服务的名称，并启用 –build 选项以强制在运行镜像之前对其进行重建；  完成这些步骤之后，你可以停止现有服务，删除现有容器，然后启动新创建的配置。
Pro tip：你可以使用 “Delete” 功能同时停止和删除服务。
使用 Docker Compose 调试 Go 应用程序 要使用 Docker Compose 调试应用程序，我们需要同时更改 Dockerfile 和 docker-compose.yaml 文件。我们可以切换到代码库的 compose-debug 分支 ，这样更容易理解。
现在，docker-compose.yaml 文件如下所示：
version:&amp;#34;3.5&amp;#34;services:web:container_name:dockerdevbuild:./ports:- &amp;#34;8000:8000&amp;#34;- &amp;#34;40000:40000&amp;#34;environment:DD_DB_HOST:dbsecurity_opt:- &amp;#34;seccomp:unconfined&amp;#34;cap_add:- SYS_PTRACEcommand:/dlv --headless --listen=:40000 --api-version=2 exec /serverdepends_on:- dbdb:container_name:dockerdev-dbimage:postgres:12.2-alpineports:- &amp;#34;5432:5432&amp;#34;environment:POSTGRES_USER:golandPOSTGRES_PASSWORD:golandPOSTGRES_DB:golandvolumes:- ./init.sql:/docker-entrypoint-initdb.d/init.sql注意：这里的重要部分是 security_opt 和 cap_add 属性，因为它们允许调试器在 Docker 环境中运行。
运行此操作类似于运行常规 Docker Compose 配置。我们可以使用 Go Remote 配置连接到容器，调试器会话将像调试常规配置一样开始。
今天我们的文章到此结束。我们已经讨论了如何使用 Docker Compose，以及如何从 GoLand 运行和调试我们的应用程序。
在下一篇文章中，我们将介绍如何在 IDE 中使用 Kubernetes，以及如何使用它运行和调试我们的应用程序。
 原文链接：https://blog.jetbrains.com/go/2020/05/08/running-go-applications-using-docker-compose-in-goland/
作者：Florin Pățan
翻译：Go语言中文网 polaris
 </description>
			<content type="html"><![CDATA[<p>今天，我们将继续有关<a href="https://mp.weixin.qq.com/s/2tajxPBhGwgwlT4TzAgmVw" target="_blank" rel="noopener">如何使用 Docker 运行</a>
和<a href="https://mp.weixin.qq.com/s/4-fkIWcr_3LdLFALVk4ZTA" target="_blank" rel="noopener">调试 Go 应用程序</a>
的系列文章。</p>
<p>在本文中，我们将使用 Docker Compose 运行和调试我们的应用程序。对于本文，我们将使用<a href="https://github.com/dlsniper/dockerdev/tree/compose" target="_blank" rel="noopener">此处的源代码</a>
，在开始之前切换到 <a href="https://github.com/dlsniper/dockerdev/tree/compose" target="_blank" rel="noopener">compose 分支</a>
。</p>
<h2 id="使用-docker-compose-运行-go-应用程序">使用 Docker Compose 运行 Go 应用程序</h2>
<p>让我们从使用 Docker Compose 运行应用程序开始。</p>
<p>查看我们已经创建的项目，可以在代码仓库中找到 docker-compose.yaml 文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3.5&#34;</span><span class="w">
</span><span class="w"> 
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">web</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev</span><span class="w">
</span><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;8000:8000&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">DD_DB_HOST</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">/server</span><span class="w">
</span><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">db</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">postgres:12.2-alpine</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;5432:5432&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_USER</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_PASSWORD</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_DB</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">./init.sql:/docker-entrypoint-initdb.d/init.sql</span><span class="w">
</span></code></pre></div><p>在数据库部分，我们需要创建一个名为 init.sql 的新文件。该文件的内容用于设置服务运行所需的数据库。</p>
<p>最后，让我们在 main.go 文件中运行 <code>Sync packages of &lt;project&gt;</code> 来 quick-fix，以下载 <a href="https://github.com/jackc/pgx/" target="_blank" rel="noopener">pgx</a>
 库并运行该应用程序。注意：如果你的模块缓存中还没有 pgx 的 4.5.0 版本，则需要执行此步骤。</p>
<p>运行基于 Docker Compose 的应用程序类似于其他 <code>Run Configurations</code>。单击 docker-compose.yaml 中 services 指令旁边的双绿色箭头按钮。要仅运行一项服务，请点击要运行的服务类型旁边的绿色箭头，例如上面的示例配置中的 web 或 db。</p>
<p><p class="md__image">
  <img src="../imgs/11-Running-Docker-Compose-from-the-IDE.gif"
    alt=""  />
</p>
</p>
<p>配置运行后，在 Docker 节点下的 <code>Services Tool</code> 窗口中会有一个名为 Compose 的新节点。这里会显示正在运行的每个 Docker Compose 服务套件。</p>
<p>可以浏览每个服务定义，并为每个服务显示所有正在运行的实例。Docker Compose 服务中可用于容器的信息与常规 Docker 容器可使用的信息相同。</p>
<p><strong>注意</strong>：如果你要启动较重的服务（例如数据库服务器），或者这些服务需要一些初始化时间，则我们的 Go 程序服务需要考虑这些服务的启动时间。</p>
<p>在我们的示例代码中，这是使用 getDBConnection 函数处理的，该函数尝试在放弃之前尝试几次以指数退避的方式连接到数据库。</p>
<h2 id="重启动-docker-compose-服务">重启动 Docker Compose 服务</h2>
<p>更改我们的代码后，我们需要重新启动服务以重新加载这些更改。目前，使用 IDE 重新启动它有点复杂，因为这样做需要你执行以下步骤：</p>
<ul>
<li>执行 <code>Run | Edit Configurations</code> 并复制一份现有的 Docker Compose 配置；</li>
<li>编辑新创建的配置以添加重新启动的服务的名称，并启用 <code>–build</code> 选项以强制在运行镜像之前对其进行重建；</li>
</ul>
<p>完成这些步骤之后，你可以停止现有服务，删除现有容器，然后启动新创建的配置。</p>
<p><p class="md__image">
  <img src="../imgs/12-Restart-Docker-Compose-service.gif"
    alt=""  />
</p>
</p>
<p><strong>Pro tip</strong>：你可以使用 “Delete” 功能同时停止和删除服务。</p>
<h2 id="使用-docker-compose-调试-go-应用程序">使用 Docker Compose 调试 Go 应用程序</h2>
<p>要使用 Docker Compose 调试应用程序，我们需要同时更改 Dockerfile 和 docker-compose.yaml 文件。我们可以切换到代码库的 <a href="https://github.com/dlsniper/dockerdev/tree/compose-debug" target="_blank" rel="noopener">compose-debug 分支</a>
，这样更容易理解。</p>
<p>现在，docker-compose.yaml 文件如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s2">&#34;3.5&#34;</span><span class="w">
</span><span class="w"> 
</span><span class="w"></span><span class="nt">services</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">web</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev</span><span class="w">
</span><span class="w">    </span><span class="nt">build</span><span class="p">:</span><span class="w"> </span><span class="l">./</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;8000:8000&#34;</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;40000:40000&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">DD_DB_HOST</span><span class="p">:</span><span class="w"> </span><span class="l">db</span><span class="w">
</span><span class="w">    </span><span class="nt">security_opt</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;seccomp:unconfined&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">cap_add</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">SYS_PTRACE</span><span class="w">
</span><span class="w">    </span><span class="nt">command</span><span class="p">:</span><span class="w"> </span><span class="l">/dlv --headless --listen=:40000 --api-version=2 exec /server</span><span class="w">
</span><span class="w">    </span><span class="nt">depends_on</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">db</span><span class="w">
</span><span class="w">  </span><span class="nt">db</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">container_name</span><span class="p">:</span><span class="w"> </span><span class="l">dockerdev-db</span><span class="w">
</span><span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">postgres:12.2-alpine</span><span class="w">
</span><span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="s2">&#34;5432:5432&#34;</span><span class="w">
</span><span class="w">    </span><span class="nt">environment</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_USER</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_PASSWORD</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">      </span><span class="nt">POSTGRES_DB</span><span class="p">:</span><span class="w"> </span><span class="l">goland</span><span class="w">
</span><span class="w">    </span><span class="nt">volumes</span><span class="p">:</span><span class="w">
</span><span class="w">      </span>- <span class="l">./init.sql:/docker-entrypoint-initdb.d/init.sql</span><span class="w">
</span></code></pre></div><p><strong>注意</strong>：这里的重要部分是 security_opt 和 cap_add 属性，因为它们允许调试器在 Docker 环境中运行。</p>
<p>运行此操作类似于运行常规 Docker Compose 配置。我们可以使用 Go Remote 配置连接到容器，调试器会话将像调试常规配置一样开始。</p>
<p><p class="md__image">
  <img src="../imgs/13-Debugging-Go-Service-in-Docker-Compose.gif"
    alt=""  />
</p>
</p>
<p>今天我们的文章到此结束。我们已经讨论了如何使用 Docker Compose，以及如何从 GoLand 运行和调试我们的应用程序。</p>
<p>在下一篇文章中，我们将介绍如何在 IDE 中使用 Kubernetes，以及如何使用它运行和调试我们的应用程序。</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/go/2020/05/08/running-go-applications-using-docker-compose-in-goland/</p>
<p>作者：Florin Pățan</p>
<p>翻译：Go语言中文网 polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>基于 GoLand 使用 Docker 容器进行 Go 开发</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/debugging-a-go-application-inside-a-docker-container/</link>
			<pubDate>Mon, 04 May 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/debugging-a-go-application-inside-a-docker-container/</guid>
			<description>今天，我们开始撰写一系列有关 GoLand 内部对 Docker，Docker Compose 和 Kubernetes 的支持以及它如何帮助我们在 Go 中编写（微）服务的文章。
我们将研究如何在 IDE 中配置项目，如何使用 Docker 或 Kubernetes 运行或调试我们的项目，以及如何将项目连接到我们选择的数据库 PostgreSQL。
让我们从介绍普通的 Docker 工作流程开始，然后我们将构建容器并运行它。
在继续之前，我们需要 GoLand 2020.1.1 或更高版本，该版本带有最新的 Docker 插件。我们还需要一个相当现代的 Docker 版本，例如 17.06 或更高版本。注意：虽然旧版本的 IDE 在一定程度上可以使用，但是本文使用了新功能，并且 IDE 的外观可能有所不同。
项目设置 让我们开始设置我们的项目。
我们可以创建一个新的 Go Modules 项目，也可以使用现有的项目。
项目结构应类似于此仓库中的结构：https://github.com/dlsniper/dockerdev。
本教程不会介绍如何为你的系统安装和配置 Docker。
相反，我们将从配置 Docker 服务器开始，以便我们可以运行我们的应用程序。将 Docker 安装到系统中后，转到 Settings/Preferences | Build, Execution, Deployment | Docker，然后单击 + 按钮添加新的 Docker 服务器连接。
默认情况下，该插件将创建与本地计算机 Docker 服务器的连接，对于我们的教程而言已经足够了。单击确定按钮以创建服务器配置。
使用 Dockerfile 首先，让我们在项目的根目录中打开 Dockerfile。
# Compile stage FROM golang:1.13.8 AS build-env ADD . /dockerdev WORKDIR /dockerdev RUN go build -o /server # Final stage FROM debian:buster EXPOSE 8000 WORKDIR / COPY --from=build-env /server / CMD [&amp;quot;/server&amp;quot;] 该 Dockerfile 使用多阶段构建，该方式使我们能够生成最小的 Docker 映像，因为构建应用程序二进制文件的编译阶段与构建容器的最终阶段是分开的。
将上面的代码粘贴到 Dockerfile 中后，第一个 FROM […] 指令旁边会出现一个绿色箭头。这是运行容器的最快方法。
但是，我们需要进行一些编辑才能运行它，因为我们需要为容器公开正确的端口以接收连接。
为容器创建一个新的运行配置 我们可以创建一个新的运行配置，也可以编辑仓库中存在的配置。为了简单起见，直接使用现有的，因为它已经预先填写了我们需要的所有值。要对其进行编辑，请单击选项列表底部的 Edit ‘Docker – Web – Standalone’  选项。
在这里，我们可以设置运行 Docker 容器所需的所有选项。我们的运行配置已经填上了重要内容，例如配置名称：“ Docker – Web Dev – Standalone”。容器名称设置为 docker-web-dev-standalone。最后，在“绑定端口”字段中，我们将“主机”端口和“容器”端口都设置为 8000，以便可以访问应用程序。
现在，我们可以单击对话框底部的 “Run” 按钮，来启动我们的容器。
了解服务工具窗口 Docker 完成构建过程后，我们可以查看 “Services Tool Window” 窗口，并在 “Containers” 部分中看到新创建的容器。我们还将在 “Images” 部分中看到使用的镜像。
对于每个容器，有以下可用选项卡：
 Build Log：它显示用于构建容器的日志； Log：显示容器的输出； Attached console：如果可以的话，这允许我们与容器的应用程序/shell 交互； Properties：将显示有关容器的更多信息，例如 镜像 ID 或容器 ID； Environment variables：显示容器使用的环境变量； Port bindings：显示容器暴露给主机的所有端口； Volume bindings：显示为容器安装的卷； Files：如果它支持运行 ls 命令，则允许我们浏览容器中的文件。对于像我们这样的基于 Alpine 的容器，我们可以添加 RUN apk add &amp;ndash;no-cache coreutils 指令来启用此功能；  在左侧，我们可以看到各种按钮。首先，有一个 “Redeploy” 按钮，它使我们可以再次运行容器的构建配置。</description>
			<content type="html"><![CDATA[<p>今天，我们开始撰写一系列有关 GoLand 内部对 Docker，Docker Compose 和 Kubernetes 的支持以及它如何帮助我们在 Go 中编写（微）服务的文章。</p>
<p>我们将研究如何在 IDE 中配置项目，如何使用 Docker 或 Kubernetes 运行或调试我们的项目，以及如何将项目连接到我们选择的数据库 PostgreSQL。</p>
<p>让我们从介绍普通的 Docker 工作流程开始，然后我们将构建容器并运行它。</p>
<p>在继续之前，我们需要 GoLand 2020.1.1 或更高版本，该版本带有最新的 Docker 插件。我们还需要一个相当现代的 Docker 版本，例如 17.06 或更高版本。注意：虽然旧版本的 IDE 在一定程度上可以使用，但是本文使用了新功能，并且 IDE 的外观可能有所不同。</p>
<h2 id="项目设置">项目设置</h2>
<p>让我们开始设置我们的项目。</p>
<p>我们可以创建一个新的 Go Modules 项目，也可以使用现有的项目。</p>
<p>项目结构应类似于此仓库中的结构：<a href="https://github.com/dlsniper/dockerdev">https://github.com/dlsniper/dockerdev</a>。</p>
<p>本教程不会介绍如何为你的系统安装和配置 Docker。</p>
<p>相反，我们将从配置 Docker 服务器开始，以便我们可以运行我们的应用程序。将 Docker 安装到系统中后，转到 <code>Settings/Preferences | Build, Execution, Deployment | Docker</code>，然后单击 + 按钮添加新的 Docker 服务器连接。</p>
<p>默认情况下，该插件将创建与本地计算机 Docker 服务器的连接，对于我们的教程而言已经足够了。单击确定按钮以创建服务器配置。</p>
<p><p class="md__image">
  <img src="../imgs/01-Configure-Docker-Server.gif"
    alt=""  />
</p>
</p>
<h2 id="使用-dockerfile">使用 Dockerfile</h2>
<p>首先，让我们在项目的根目录中打开 Dockerfile。</p>
<pre><code class="language-dockefile" data-lang="dockefile"># Compile stage
FROM golang:1.13.8 AS build-env
 
ADD . /dockerdev
WORKDIR /dockerdev
 
RUN go build -o /server
 
# Final stage
FROM debian:buster
 
EXPOSE 8000
 
WORKDIR /
COPY --from=build-env /server /
 
CMD [&quot;/server&quot;]
</code></pre><p>该 Dockerfile 使用多阶段构建，该方式使我们能够生成最小的 Docker 映像，因为构建应用程序二进制文件的编译阶段与构建容器的最终阶段是分开的。</p>
<p>将上面的代码粘贴到 Dockerfile 中后，第一个 <code>FROM […]</code> 指令旁边会出现一个绿色箭头。这是运行容器的最快方法。</p>
<p>但是，我们需要进行一些编辑才能运行它，因为我们需要为容器公开正确的端口以接收连接。</p>
<p><p class="md__image">
  <img src="../imgs/02-Dockerfile.png"
    alt="02 - Dockerfile"  />
</p>
</p>
<h2 id="为容器创建一个新的运行配置">为容器创建一个新的运行配置</h2>
<p>我们可以创建一个新的运行配置，也可以编辑仓库中存在的配置。为了简单起见，直接使用现有的，因为它已经预先填写了我们需要的所有值。要对其进行编辑，请单击选项列表底部的 <code>Edit ‘Docker – Web – Standalone’ </code> 选项。</p>
<p>在这里，我们可以设置运行 Docker 容器所需的所有选项。我们的运行配置已经填上了重要内容，例如配置名称：“ Docker – Web Dev – Standalone”。容器名称设置为 docker-web-dev-standalone。最后，在“绑定端口”字段中，我们将“主机”端口和“容器”端口都设置为 8000，以便可以访问应用程序。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/05/03-Edit-Dockerfile-Run-Configuration.png"
    alt="03 - Edit Dockerfile Run Configuration"  />
</p>
</p>
<p>现在，我们可以单击对话框底部的 “Run” 按钮，来启动我们的容器。</p>
<h2 id="了解服务工具窗口">了解服务工具窗口</h2>
<p>Docker 完成构建过程后，我们可以查看 “Services Tool Window” 窗口，并在 “Containers” 部分中看到新创建的容器。我们还将在 “Images” 部分中看到使用的镜像。</p>
<p>对于每个容器，有以下可用选项卡：</p>
<ul>
<li>Build Log：它显示用于构建容器的日志；</li>
<li>Log：显示容器的输出；</li>
<li>Attached console：如果可以的话，这允许我们与容器的应用程序/shell 交互；</li>
<li>Properties：将显示有关容器的更多信息，例如 镜像 ID 或容器 ID；</li>
<li>Environment variables：显示容器使用的环境变量；</li>
<li>Port bindings：显示容器暴露给主机的所有端口；</li>
<li>Volume bindings：显示为容器安装的卷；</li>
<li>Files：如果它支持运行 ls 命令，则允许我们浏览容器中的文件。对于像我们这样的基于 Alpine 的容器，我们可以添加 RUN apk add &ndash;no-cache coreutils 指令来启用此功能；</li>
</ul>
<p><p class="md__image">
  <img src="../imgs/04-Running-a-Docker-Container.gif"
    alt=""  />
</p>
</p>
<p>在左侧，我们可以看到各种按钮。首先，有一个 “Redeploy” 按钮，它使我们可以再次运行容器的构建配置。</p>
<p>还有 “Edit Configuration” 按钮，可用于对容器的 “Run Configuration” 进行任何调整。</p>
<p>最后， “Start/Stop” 按钮，用于启动或停止容器，以及 “Delete” 按钮，用于删除容器。</p>
<p><p class="md__image">
  <img src="../imgs/05-Docker-Tool-Window-Service-Overview.gif"
    alt=""  />
</p>
</p>
<p>容器上的右键单击操作可以访问一些其他有用的功能。我们可以使用 List Processes 看到正在运行的进程的列表，也可以使用 Exec 在正在运行的容器中执行命令。最后，Inspect 将提供有关容器及其当前配置的更多信息。</p>
<p><p class="md__image">
  <img src="../imgs/06-Docker-Container-menu-options.gif"
    alt=""  />
</p>
</p>
<p><strong>Pro tip</strong>：如果将鼠标悬停在容器名称上，则可以看到容器的正常运行时间。</p>
<p><strong>Pro tip</strong>：要加快容器的构建速度，请使用 Go vendoring mode。在 IDE 终端中运行 go mod vendor 命令可确保 IDE 自动选择 vendor 文件夹。为此，您还需要在容器的环境变量列表中添加 <code>GOFLAGS =&quot;-mod = vendor&quot;</code>。</p>
<h2 id="总结">总结</h2>
<p>我们讨论了如何创建和运行 Docker 配置。在下一篇文章中，我们将介绍如何调试 Docker 中的应用程序。</p>
<blockquote>
<p>原文链接：https://blog.jetbrains.com/go/2020/05/04/go-development-with-docker-containers/</p>
<p>作者：Florin Pățan</p>
<p>翻译：Go语言中文网 polaris</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>还在用 2019.3 就 Out 了：GoLand 2020.1 版本正式发布</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/goland-2020-1-release/</link>
			<pubDate>Fri, 10 Apr 2020 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/goland-2020-1-release/</guid>
			<description>北京时间 2020 年 4 月 10 日凌晨，Jetbrains 宣布正式发布 GoLand 2020.1 版本。
该版本主要的变化有：
引入了对 Go 模块支持的各种升级以及代码编辑功能，这些功能几乎不需要用户交互，也不需要扩展的代码补全系列。
除此之外，还添加了新的代码检查、快速修复和其他改进，例如新的 LightEdit 模式（可让您在文本编辑器中打开文件，而无需创建或加载项目）、智能拼写和语法检查以及用于 Web 开发和数据库处理的新功能。
Go 语言中文网在 2020.1 还未正式发布之前，就发过关于该版本特性的文章，现在 2020.1 正式发布了，相关功能特性稳定了，我们再次介绍下相关新特性。
Go 模块改进 2020.1 现已支持 Go 1.13 的环境变量 GOPROXY、GOPRIVATE、GOSUMDB、GONOPROXY 和 GONOSUMB。
使用 Go Modules 项目模板配置其默认值。只需点击 Environment 字段中的 Browse 图标即可打开新的 Environment Variables 对话框。
go.mod 文件支持 go、module、require、replace 和 exclude 关键字代码补全、依赖项名称以及本地路径替换。
此外，也可以使用 Rename 和 Move 重构。 重命名或移动由 replace 语句引用的目录时，GoLand 将相应地更改 go.mod 文件中的路径。
现在，您还可以通过 Project 视图调用 Find Usages，以探索 go.mod 文件中特定目录路径的使用位置。
在 GoLand 2020.1 中，您可以通过 Alt-Enter 获取缺失的依赖项并移除未使用的依赖项。
最后但同样重要的是，如果存在本地路径替换，则新版本将在您提交之前显示一条通知，这样您就不会意外提交它们。
您无需学习如何使用的代码补全功能 GoLand 2020.1 将建议 if err != nil { &amp;hellip; } 来补全错误处理模式。 只需在表达式内输入 if。
只需输入 type 关键字或 struct 和 interface，即可更快地定义结构和接口类型。
Fill Fields 操作在格式化规则要求时会在冒号后面添加空格。 它还会在组合文字声明中语句的末尾添加逗号。
现在，使用 map 时，代码补全会在您补全键类型后将光标移到右中括号后面。
对于函数的返回类型，补全功能将为局部变量和零值提供适合相应返回值类型的建议。
智能代码补全（⌥⇧Space 或 Ctrl+Shift+Space） 智能代码补全会建议一个指向结构初始值设定项的指针。
它还会建议在断言和类型 switch 用例中首先使用兼容类型。
在类型断言中，它提供已赋值变量的类型。
最后，它提供了表达式中可能指针的建议列表。
基本代码补全（⌃空格或 Ctrl+空格） 为注释添加了基本代码补全，这将使编写文档更加轻松！ 它可为当前包声明建议名称，并为函数和方法建议参数名称。除此之外，基本代码补全还可以建议文字和转换。
代码编辑 编写多值返回函数的签名时，GoLand 2020.1 会在逗号后面的返回类型周围添加括号。当您在字符串文字中粘贴一些文本时，IDE 会转义双引号。
Go 1.14 支持 1）支持重叠接口
Go 1.14 添加了对嵌入重叠接口的支持，我们也添加了此功能！ 当您使用重叠接口描述类型的不同方面时，GoLand 不会将这些方面的重复方法报告为错误。
2）自动 vendoring 模式
如果模块根包含 vendor 目录，则会在 Go 1.14 中自动启用 vendoring 模式。 对于 GoLand 2020.1，我们决定为 Go 1.13 及更早版本实现类似的行为。 IDE 会自动将导入解析到 vendor/ 文件夹（如果模块中存在）。
调试器更新 1）分析器标签支持
为了帮助您在调试或核心转储分析过程中更轻松地区分 goroutine，我们为其添加了分析器标签。更多详情请参考：如何在调试过程中查找 Goroutine 。
2）宏支持
现在，可以将宏用作运行或调试应用程序的参数。 在 Run/Debug Configurations 对话框中，点击 Go Tool 中的 + 或 Program arguments 字段即可打开新的 Macros 对话框，其中会列出要使用的可用宏。
此外，您现在还可以将配置文件存储在项目中。 在 Run/Debug Configurations 对话框的顶部，选择 Store 作为项目文件选项。</description>
			<content type="html"><![CDATA[<p>北京时间 2020 年 4 月 10 日凌晨，Jetbrains 宣布正式发布 GoLand 2020.1 版本。</p>
<p>该版本主要的变化有：</p>
<p>引入了对 Go 模块支持的各种升级以及代码编辑功能，这些功能几乎不需要用户交互，也不需要扩展的代码补全系列。</p>
<p>除此之外，还添加了新的代码检查、快速修复和其他改进，例如新的 LightEdit 模式（可让您在文本编辑器中打开文件，而无需创建或加载项目）、智能拼写和语法检查以及用于 Web 开发和数据库处理的新功能。</p>
<p>Go 语言中文网在 2020.1 还未正式发布之前，就发过关于该版本特性的文章，现在 2020.1 正式发布了，相关功能特性稳定了，我们再次介绍下相关新特性。</p>
<h2 id="go-模块改进">Go 模块改进</h2>
<p>2020.1 现已支持 Go 1.13 的环境变量 GOPROXY、GOPRIVATE、GOSUMDB、GONOPROXY 和 GONOSUMB。</p>
<p>使用 Go Modules 项目模板配置其默认值。只需点击 Environment 字段中的 Browse 图标即可打开新的 Environment Variables 对话框。</p>
<p>go.mod 文件支持 go、module、require、replace 和 exclude 关键字代码补全、依赖项名称以及本地路径替换。</p>
<p>此外，也可以使用 Rename 和 Move 重构。 重命名或移动由 replace 语句引用的目录时，GoLand 将相应地更改 go.mod 文件中的路径。</p>
<p>现在，您还可以通过 Project 视图调用 Find Usages，以探索 go.mod 文件中特定目录路径的使用位置。</p>
<p>在 GoLand 2020.1 中，您可以通过 Alt-Enter 获取缺失的依赖项并移除未使用的依赖项。</p>
<p>最后但同样重要的是，如果存在本地路径替换，则新版本将在您提交之前显示一条通知，这样您就不会意外提交它们。</p>
<h2 id="您无需学习如何使用的代码补全功能">您无需学习如何使用的代码补全功能</h2>
<p>GoLand 2020.1 将建议 if err != nil { &hellip; } 来补全错误处理模式。 只需在表达式内输入 if。</p>
<p>只需输入 type 关键字或 struct 和 interface，即可更快地定义结构和接口类型。</p>
<p>Fill Fields 操作在格式化规则要求时会在冒号后面添加空格。 它还会在组合文字声明中语句的末尾添加逗号。</p>
<p>现在，使用 map 时，代码补全会在您补全键类型后将光标移到右中括号后面。</p>
<p>对于函数的返回类型，补全功能将为局部变量和零值提供适合相应返回值类型的建议。</p>
<h2 id="智能代码补全space-或-ctrlshiftspace">智能代码补全（⌥⇧Space 或 Ctrl+Shift+Space）</h2>
<p>智能代码补全会建议一个指向结构初始值设定项的指针。</p>
<p>它还会建议在断言和类型 switch 用例中首先使用兼容类型。</p>
<p>在类型断言中，它提供已赋值变量的类型。</p>
<p>最后，它提供了表达式中可能指针的建议列表。</p>
<h2 id="基本代码补全空格或-ctrl空格">基本代码补全（⌃空格或 Ctrl+空格）</h2>
<p>为注释添加了基本代码补全，这将使编写文档更加轻松！ 它可为当前包声明建议名称，并为函数和方法建议参数名称。除此之外，基本代码补全还可以建议文字和转换。</p>
<h2 id="代码编辑">代码编辑</h2>
<p>编写多值返回函数的签名时，GoLand 2020.1 会在逗号后面的返回类型周围添加括号。当您在字符串文字中粘贴一些文本时，IDE 会转义双引号。</p>
<h2 id="go-114-支持">Go 1.14 支持</h2>
<p>1）支持重叠接口</p>
<p>Go 1.14 添加了对嵌入重叠接口的支持，我们也添加了此功能！ 当您使用重叠接口描述类型的不同方面时，GoLand 不会将这些方面的重复方法报告为错误。</p>
<p>2）自动 vendoring 模式</p>
<p>如果模块根包含 vendor 目录，则会在 Go 1.14 中自动启用 vendoring 模式。 对于 GoLand 2020.1，我们决定为 Go 1.13 及更早版本实现类似的行为。 IDE 会自动将导入解析到 vendor/ 文件夹（如果模块中存在）。</p>
<h2 id="调试器更新">调试器更新</h2>
<p>1）分析器标签支持</p>
<p>为了帮助您在调试或核心转储分析过程中更轻松地区分 goroutine，我们为其添加了分析器标签。更多详情请参考：<a href="https://mp.weixin.qq.com/s/ANNUlYvWshNikNwCw6qSHw" target="_blank" rel="noopener">如何在调试过程中查找 Goroutine</a>
。</p>
<p>2）宏支持</p>
<p>现在，可以将宏用作运行或调试应用程序的参数。 在 Run/Debug Configurations 对话框中，点击 Go Tool 中的 + 或 Program arguments 字段即可打开新的 Macros 对话框，其中会列出要使用的可用宏。</p>
<p>此外，您现在还可以将配置文件存储在项目中。 在 Run/Debug Configurations 对话框的顶部，选择 Store 作为项目文件选项。</p>
<h2 id="后缀补全">后缀补全</h2>
<p><code>.else</code> <em>Postfix Completion</em> 模板可以快速添加 <code>if</code> 语句来检查表达式是否为假。</p>
<h2 id="快速修复">快速修复</h2>
<p>按下 Alt+Enter，可立即将非格式化调用更改为格式化调用。现在，Create variable 快速修复会显示预期的类型提示，以便您更轻松地输入正确的值。</p>
<h2 id="代码检查">代码检查</h2>
<p>新代码检查可以警告您注意非指针接收器上指针方法的无效调用，并提供了快速修复。</p>
<p>如果错误使用 uintptr 和 unsafe.Pointer 将整数转换为指针，Invalid conversions of uintptr to unsafe.Pointer 代码检查会发出警告。</p>
<p>Unmarshal is called with incorrect argument 检查可以分析对 json.Unmarshal 以及 encoding/json、encoding/xml 和 encoding/gob 包的类似函数的调用。</p>
<p>Locks mistakenly passed by value 代码检查可帮助您避免意外复制包含锁定的值。</p>
<h2 id="实时模板">实时模板</h2>
<p>添加了新模板来帮助您快速创建声明组。 其中包括 consts、vars、types 和 imports。 当您使用这些模板之一时，GoLand 将在声明名称周围添加大括号。</p>
<p>fori 模板可为经典的 for 循环插入样板代码。</p>
<h2 id="重构">重构</h2>
<p>Extract Method 重构会保留父函数和方法参数的原始顺序。Rename 重构现在会自动检测声明的重命名。 这意味着当您手动重命名声明时，IDE 将显示一个间距图标，此图标会建议重命名其所有用法。</p>
<h2 id="导航">导航</h2>
<p>Navigate to implementations（macOS 上为 ⌥⌘B，Windows/Linux 上为 Ctrl+Alt+B）和 Navigate to Declaration 或 Usages（macOS 上为 ⌘B，Windows/Linux 上为 Ctrl+B）现在会首先显示当前项目中的结果。</p>
<p>此外，默认情况下，Find Usages（Windows/Linux 上为 Alt+F7，macOS 上为 ⌥F7）操作现在会始终查找接口方法的用法。 要像以前一样查找当前方法的用法，请在 Windows/Linux 上使用 Alt+Shift+Ctrl+F7 或在 macOS 上使用 ⌥⇧⌘F7。</p>
<h2 id="改进-vcs">改进 VCS</h2>
<p>1）新 Commit 工具窗口</p>
<p>现在，新的 Commit 工具窗口包含 <em>Local Changes</em> 和 <em>Shelf</em> 选项卡。 此工具窗口涵盖了与提交有关的所有任务，例如检查差异，选择要提交的文件和块，以及输入提交消息。 Commit 是位于屏幕左侧的垂直工具窗口，这样就为整个编辑器留出了显示差异的空间。</p>
<p>2）改进了 Branches 弹出窗口</p>
<p><em>Branches</em> 弹出窗口在多个方面进行了重新设计：</p>
<ul>
<li>我们添加了一个显式搜索字段，您可以借助此字段查找现有的远程和本地分支。</li>
<li>现在，您可以使用 <em>Refresh</em> 按钮更新现有的远程分支。</li>
<li>传入（蓝色）和传出（绿色）提交指示器已添加到状态栏。</li>
</ul>
<p>3）Interactively Rebase from Here 对话框</p>
<p>大幅重新设计了 Interactively Rebase from Here。 您可以利用此对话框编辑、组合及移除之前的提交，从而让您的提交历史记录更加清晰易懂。</p>
<p>要调用此对话框，请转到 Git 工具窗口的 Log 选项卡，在要编辑的一系列提交中选择最旧的提交，点击右键，然后选择 Interactively Rebase from Here。</p>
<h2 id="数据库更新">数据库更新</h2>
<ul>
<li>使用 <em>Run configurations</em> 运行脚本文件和代码段。 这样，您可以在启动前一次运行多个文件，对它们进行重新排序，添加新文件以及运行其他程序或配置。</li>
<li>现在，您可以在代码编辑器中查看结果。 默认情况下，此选项处于禁用状态。 要启用此功能，请转到 <em>Settings/Preferences | Database | General | Show output results in the editor</em>。</li>
<li>创建 SSH 隧道的配置，并在许多数据源或项目中使用。</li>
<li>我们添加了以 Excel 格式导出数据的功能。</li>
<li>另外，您也可以在提取程序下拉列表中选择首选数据格式。</li>
</ul>
<h2 id="web开发">Web开发</h2>
<p>1）用于 JavaScript 和 TypeScript 的新智能意图和检查</p>
<p>使用新的智能意图和检查 (Alt+Enter) 可在编码时节省时间！ 例如，您现在可以快速地将现有代码转换为可选链和/或空值合并，该语法已在最新版本的 JavaScript 和 TypeScript 中引入。</p>
<p>2）更有帮助的快速文档</p>
<p>对于 JavaScript 和 TypeScript，<em>Documentation</em> 弹出窗口现在会显示更多有用的信息，包括符号类型和可视性的详细信息以及定义符号的位置。</p>
<h2 id="其他变更">其他变更</h2>
<ul>
<li>JetBrains 的新字体 <em>JetBrains Mono</em> 默认可用。 要详细了解该字体，请访问<a href="https://www.jetbrains.com/lp/mono/" target="_blank" rel="noopener">此页面</a>
。</li>
<li>默认捆绑了 <em>Grazie</em>，此插件可为您在 IDE 中编写的文本提供智能的拼写和语法检查。</li>
<li>新的 <em>LightEdit 模式</em>允许您在文本编辑器中打开文件，而无需创建或加载项目。 要试用此这一功能，您首先需要从 <em>Tools | Create Command-line Launcher</em> 创建命令行启动器，如<a href="https://www.jetbrains.com/help/idea/working-with-the-ide-features-from-command-line.html" target="_blank" rel="noopener">此处</a>
所述（如果您使用的是 Toolbox App，步骤<a href="https://www.jetbrains.com/help/idea/working-with-the-ide-features-from-command-line.html#toolbox" target="_blank" rel="noopener">略有不同</a>
）。 有关如何打开文件、比较/合并文件甚至运行代码检查的详细说明，请参阅<a href="https://www.jetbrains.com/help/idea/opening-files-from-command-line.html" target="_blank" rel="noopener">此 Web 帮助部分</a>
。</li>
<li>我们添加了新的 <em>Zen 模式</em>，它消除了可能的干扰，可帮助您完全专注于代码。 本质上，此模式结合了<em>免打扰模式</em>和<em>全屏模式</em>。 要启用此模式，请转到 <em>View | Appearance | Enter Zen Mod</em>，或者从 <em>Quick Switch Scheme</em> 弹出窗口中选择 (<em>Ctrl+` | View mode | Enter Zen Mode</em>)。</li>
<li><em>外部文档</em>现在指向 <a href="https://pkg.go.dev/" target="_blank" rel="noopener">https://pkg.go.dev</a>
 而不是 <a href="https://godoc.org/" target="_blank" rel="noopener">https://godoc.org</a>
。</li>
<li>我们恢复了<em>默认</em>配色方案，但采用新名称 <em>Classic Light</em>。</li>
</ul>
<h2 id="结语">结语</h2>
<p>新版本可以免费试用 30 天。新版本下载地址：<a href="https://www.jetbrains.com/zh-cn/go/download/">https://www.jetbrains.com/zh-cn/go/download/</a>。该下载页面支持通过微信和支付宝支付。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇4：自定义 Renderer，增强或替换模板引擎</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom04-renderer/</link>
			<pubDate>Mon, 16 Mar 2020 10:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom04-renderer/</guid>
			<description>Render，顾名思义，要进行页面渲染。Go 语言不但自带有强大的 http 库，还自带了 HTML 模板引擎。Echo 框架对模板引擎进行了一些额外处理，并提供了给用户自定义页面渲染的接口。本文就相关问题进行探讨。 模板渲染 Echo 框架的 Context 接口提供了下面的方法进行页面渲染： // echo 包中 Context 接口的方法 Render(code int, name string, data interface{}) error 其中，code 是 HTTP Status，name 是定义的模板名，data 是模板可能需要的数</description>
			<content type="html"><![CDATA[<p>Render，顾名思义，要进行页面渲染。Go 语言不但自带有强大的 http 库，还自带了 HTML 模板引擎。Echo 框架对模板引擎进行了一些额外处理，并提供了给用户自定义页面渲染的接口。本文就相关问题进行探讨。</p>
<h2 id="模板渲染">模板渲染</h2>
<p>Echo 框架的 Context 接口提供了下面的方法进行页面渲染：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// echo 包中 Context 接口的方法
</span><span class="c1"></span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
</code></pre></div><p>其中，code 是 HTTP Status，name 是定义的模板名，data 是模板可能需要的数据。执行这个方法后，通过数据渲染模板，并发送带有 HTTP 状态的 text/html 响应。可以通过 Echo.Renderer 来注册模板，从而允许我们使用任何模板引擎。</p>
<p>Renderer 接口定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Renderer is the interface that wraps the Render function.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Renderer</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">Render</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>这里可能会有点迷糊，怎么有两个 Render 方法，而且它们的签名还不一样。这里的逻辑是这样的：</p>
<ul>
<li>echo.Echo 类型有一个 Renderer 接口类型的字段，用来注册模板引擎；</li>
<li>echo.Context 接口类型有一个 Render 方法，在 Handle 中我们通过调用 Context 的 Render 方法进行模板渲染；</li>
<li>在 Context 的 Render 方法内部（当然是 echo 中 Context 接口的默认实现），会调用 echo.Echo 的字段 Renderer 的 Render 方法，进行具体的模板渲染；</li>
</ul>
<p>这里是具体的渲染源码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">context</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">code</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">echo</span><span class="p">.</span><span class="nx">Renderer</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ErrRendererNotRegistered</span>
	<span class="p">}</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">echo</span><span class="p">.</span><span class="nx">Renderer</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">HTMLBlob</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div><p>可见，如果调用了 Context#Render 进行模板渲染，但并没有注册模板引擎则会报错（ErrRendererNotRegistered）。</p>
<h3 id="集成标准库模板引擎">集成标准库模板引擎</h3>
<p>1、我们先定义一个类型：Template，然后实现 Echo.Renderer 接口，即提供 Render 方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Template</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">templates</span> <span class="o">*</span><span class="nx">template</span><span class="p">.</span><span class="nx">Template</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Template</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nx">templates</span><span class="p">.</span><span class="nf">ExecuteTemplate</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>2、接着预编译一个模板。定义一个模板文件：template/index.html，内容如下：</p>
<pre><code>{{define &quot;index&quot;}}Hello, {{.}}!{{end}}
</code></pre><p>然后预编译得到 Template 的实例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">tpl</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Template</span><span class="p">{</span>
    <span class="nx">templates</span><span class="p">:</span> <span class="nx">template</span><span class="p">.</span><span class="nf">Must</span><span class="p">(</span><span class="nx">template</span><span class="p">.</span><span class="nf">ParseGlob</span><span class="p">(</span><span class="s">&#34;template/*.html&#34;</span><span class="p">)),</span>
<span class="p">}</span>
</code></pre></div><p>3、注册模板引擎：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

<span class="nx">e</span><span class="p">.</span><span class="nx">Renderer</span> <span class="p">=</span> <span class="nx">tpl</span>
</code></pre></div><p>4、在 Handler 中渲染模板：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;index&#34;</span><span class="p">,</span> <span class="s">&#34;studygolang&#34;</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div><p>注意这里的 index 是模板文件中 <code>define &quot;index&quot;</code> ，而不是文件名。</p>
<p>编译后运行，浏览器正常显示：Hello，studygolang!</p>
<p><p class="md__image">
  <img src="https://s2.ax1x.com/2020/03/08/3v2XQ0.png"
    alt=""  />
</p>
</p>
<h2 id="通用化定制">通用化定制</h2>
<p>一般的，页面会有一些通用的部分，比如头部、尾部等。所以业界通常的做法是有一个 layout，而且还可能不止一个 layout，因为普通用户看到的和后台看到的头部、尾部一般会不一样。那这样的通用化定制需求该如何集成到 Echo 的 Render 中呢？</p>
<p>先考虑只有一种 layout 的情况。定义一个类型 layoutTemplate，实现 Echo.Renderer 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">layoutTemplate</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">var</span> <span class="nx">LayoutTemplate</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">layoutTemplate</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">layoutTemplate</span><span class="p">)</span> <span class="nf">Render</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">contentTpl</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">layout</span> <span class="o">:=</span> <span class="s">&#34;layout.html&#34;</span>
	<span class="nx">tpl</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">template</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">layout</span><span class="p">).</span><span class="nf">ParseFiles</span><span class="p">(</span><span class="s">&#34;template/common/&#34;</span><span class="o">+</span><span class="nx">layout</span><span class="p">,</span> <span class="s">&#34;template/&#34;</span><span class="o">+</span><span class="nx">contentTpl</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">tpl</span><span class="p">.</span><span class="nf">Execute</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>然后注册该 Renderer，并在 Handler 中渲染，注意 ctx.Render 的第二个参数，跟上面说的不一样，我们传递的是子模板的文件名：index.html。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

<span class="nx">e</span><span class="p">.</span><span class="nx">Renderer</span> <span class="p">=</span> <span class="nx">render</span><span class="p">.</span><span class="nx">LayoutTemplate</span>

<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;index.html&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div><p>这里用到了两个模板文件：layout.html 和  index.html，来源 Hugo 的 <a href="https://themes.gohugo.io/theme/soho/" target="_blank" rel="noopener">soho 这个模板</a>
。</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">xmlns</span><span class="o">=</span><span class="s">&#34;http://www.w3.org/1999/xhtml&#34;</span> <span class="na">xml:lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">http-equiv</span><span class="o">=</span><span class="s">&#34;content-type&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;text/html; charset=utf-8&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Echo博客系统<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;author&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;Go语言中文网站长polaris&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;keywords&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;&#34;</span> <span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;description&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;&#34;</span> <span class="p">/&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/static/css/print.css&#34;</span> <span class="na">media</span><span class="o">=</span><span class="s">&#34;print&#34;</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/static/css/poole.css&#34;</span><span class="p">&gt;</span> 
  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">type</span><span class="o">=</span><span class="s">&#34;text/css&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/static/css/hyde.css&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span>
        <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&amp;display=swap&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;stylesheet&#34;</span>
        <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css&#34;</span>
        <span class="na">integrity</span><span class="o">=</span><span class="s">&#34;sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=&#34;</span>
        <span class="na">crossorigin</span><span class="o">=</span><span class="s">&#34;anonymous&#34;</span> <span class="p">/&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;apple-touch-icon-precomposed&#34;</span>
        <span class="na">sizes</span><span class="o">=</span><span class="s">&#34;144x144&#34;</span>
        <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://themes.gohugo.io//theme/soho/apple-touch-icon-144-precomposed.png&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;shortcut icon&#34;</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://themes.gohugo.io//theme/soho/favicon.png&#34;</span><span class="p">&gt;</span>

  <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">aside</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;sidebar&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;container&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;sidebar-about&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;author-image&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">img</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://themes.gohugo.io/theme/soho/images/profile.png&#34;</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;img-circle img-headshot center&#34;</span> <span class="na">alt</span><span class="o">=</span><span class="s">&#34;Profile Picture&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Echo-Gopher<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">nav</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">ul</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;sidebar-nav&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/&#34;</span><span class="p">&gt;</span>Home<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span> <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/about/&#34;</span><span class="p">&gt;</span> About <span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span> <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">nav</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">section</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;social-icons&#34;</span><span class="p">&gt;</span>

            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://github.com/polaris1119&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;me&#34;</span> <span class="na">title</span><span class="o">=</span><span class="s">&#34;GitHub&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">i</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;fab fa-github&#34;</span> <span class="na">aria-hidden</span><span class="o">=</span><span class="s">&#34;true&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">i</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
            
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://weibo.com/studygolang&#34;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&#34;me&#34;</span> <span class="na">title</span><span class="o">=</span><span class="s">&#34;Weibo&#34;</span><span class="p">&gt;</span>
                <span class="p">&lt;</span><span class="nt">i</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;fab fa-weibo&#34;</span> <span class="na">aria-hidden</span><span class="o">=</span><span class="s">&#34;true&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">i</span><span class="p">&gt;</span>
            <span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
            
        <span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">aside</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">main</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;content container&#34;</span><span class="p">&gt;</span>
    {{template &#34;content&#34; .}}
  <span class="p">&lt;/</span><span class="nt">main</span><span class="p">&gt;</span>

  <span class="p">&lt;</span><span class="nt">footer</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;copyright&#34;</span><span class="p">&gt;</span>
      <span class="ni">&amp;copy;</span> polaris 2020 · <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;https://creativecommons.org/licenses/by-sa/4.0&#34;</span><span class="p">&gt;</span>CC BY-SA 4.0<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="nt">footer</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&#34;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js&#34;</span>
  <span class="na">integrity</span><span class="o">=</span><span class="s">&#34;sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0=&#34;</span>
  <span class="na">crossorigin</span><span class="o">=</span><span class="s">&#34;anonymous&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
  
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><p>这是 layout.html 的内容，核心在于 <code>{{template &quot;content&quot; .}}</code>，表示具体内容模板需要定义 content，所以看看 index.html 文件：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">{{define &#34;content&#34;}}
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;posts&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">article</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h2</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-title&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/&#34;</span><span class="p">&gt;</span>Echo 系列教程 — 定制篇3：自定义 Logger，用你喜欢的日志库<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-date&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">time</span> <span class="na">datetime</span><span class="o">=</span><span class="s">&#34;2020-03-06T00:00:00Z&#34;</span><span class="p">&gt;</span>Mar 06, 2020<span class="p">&lt;/</span><span class="nt">time</span><span class="p">&gt;</span> · 3 min read
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
        在知识星球简书项目中，我们分析对比了目前的一些日志库。虽然 Go 标准库有一个 log，但功能有限，所以才出现了很多第三方的日志库。
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;read-more-link&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;http://blog.studygolang.com/2020/03/echo-custom-logger/&#34;</span><span class="p">&gt;</span>阅读全文<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>

    <span class="p">&lt;</span><span class="nt">article</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h2</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-title&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;/&#34;</span><span class="p">&gt;</span>Echo 系列教程 — 定制篇2：自定义 Validator，进行输入校验<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>

        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-date&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">time</span> <span class="na">datetime</span><span class="o">=</span><span class="s">&#34;2020-02-28T00:00:00Z&#34;</span><span class="p">&gt;</span>Feb 28, 2020<span class="p">&lt;/</span><span class="nt">time</span><span class="p">&gt;</span> · 4 min read
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
        上一篇讲 Binder 时提到，参数自动绑定和校验是 Web 框架很重要的两个功能，可以极大的提升开发速度，并更好的保证数据的可靠性（服务端数据校验很重要）。
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;read-more-link&#34;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&#34;http://blog.studygolang.com/2020/02/echo-custom-validator/&#34;</span><span class="p">&gt;</span>阅读全文<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
{{end}}
</code></pre></div><p>运行后打开浏览器访问 http://localhost:2020 ：</p>
<p><p class="md__image">
  <img src="https://s1.ax1x.com/2020/03/13/8uzXAf.png"
    alt=""  />
</p>
</p>
<p>接下来看看如何处理多个 layout 的情况。</p>
<p>因为 Render 的签名是固定的，不同的 layout 通过什么方式告知 Render 呢？观察 Render 方法的参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nf">Render</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">name</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span>
</code></pre></div><p>可以在 data 和 ctx 上下功夫：</p>
<ol>
<li>
<p>将 data 指定为 map[string]interface{}，layout 通过 data 传递；</p>
</li>
<li>
<p>通过 ctx 的 Set 方法设置 layout，方法内通过 ctx.Get 获取 layout；</p>
</li>
</ol>
<p>先看第 1 种方式：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NoNavRender 没有导航的 layout html 输出
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NoNavRender</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">contentTpl</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">data</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">data</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{})</span>
	<span class="p">}</span>
	<span class="nx">data</span><span class="p">[</span><span class="s">&#34;layout&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;nonav_layout.html&#34;</span>

	<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">contentTpl</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在 render 包中增加了一个 NoVaRender 函数，该函数要求 data 必须是 map[string]interface{}，这样就可以做到将 layout 传递给 Render 方法，不过因为 Render 方法的 data 参数是 interface{} 类型，因此得做类型断言。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">layout</span> <span class="o">:=</span> <span class="s">&#34;layout.html&#34;</span>

<span class="k">if</span> <span class="nx">data</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">dataMap</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">.(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{});</span> <span class="nx">ok</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">layoutInter</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">dataMap</span><span class="p">[</span><span class="s">&#34;layout&#34;</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
      <span class="nx">layout</span> <span class="p">=</span> <span class="nx">layoutInter</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>看看第 2 种方式如何实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// NoNavRender 没有导航的 layout html 输出
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NoNavRender</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">contentTpl</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">data</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ctx</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;layout&#34;</span><span class="p">,</span> <span class="s">&#34;nonav_layout.html&#34;</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">contentTpl</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在 Render 中获取 layout 的值：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">layout</span> <span class="o">:=</span> <span class="s">&#34;layout.html&#34;</span>

<span class="nx">layoutInter</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;layout&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">layoutInter</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">layout</span> <span class="p">=</span> <span class="nx">layoutInter</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>两种方式个人觉得第 2 种更优雅。不过需要注意的是，两种方式要注意 layout 不能冲突，也就是不能他用。</p>
<p>另外，我个人建议，data 参数永远要么传递 nil，要么传递 map[string]interface{} 。个人感觉 Echo 的 Render 方法 data 参数的类型不应该用 interface{} 而是用 map[string]interface{}，这样可以更方便地往 data 中加入更多全局的数据。在简书项目中，我们会通过其他方式弥补这个问题。</p>
<h2 id="小结">小结</h2>
<p>通过本节，你应该掌握了 Render 的使用、集成和大项目 layout 的处理。</p>
<p>额外提一句，因为 Context.Render 方法最终是调用的 Context.HTML 方法进行渲染，因此我们也完全可以抛弃 Render 方法，而是使用自己的 Render。目前简书的代码（后续会改掉）和 studygolang 的源码采用的就是完全抛弃 Context.Render 的方式，主要考虑还是有一些 Render 不能很好满足的地方，比如上面说的多 layout、data 类型等，不过也是可以解决的。因此还是建议采用 Echo 框架的 Render。</p>
<p>本节<a href="https://github.com/polaris1119/go-echo-example/tree/0cd46e8b1f38317439e95d55e3fe29a173a2e3c1" target="_blank" rel="noopener">完整代码点这里</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇5：自定义 HTTP Error Handler，让 HTTP 错误处理更友好</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom05-error-handler/</link>
			<pubDate>Mon, 16 Mar 2020 10:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom05-error-handler/</guid>
			<description>Echo 倡导通过从中间件和 Handler 返回错误来进行集中式 HTTP 错误处理。集中式错误处理程序使我们能够从统一位置将错误记录到外部服务，并向客户端发送自定义的 HTTP 响应。本节一起学习如何定制化，进行集中式错误处理。 默认的错误处理 在定制篇 4 中，我们讲到了 Render。如果在 Handler 中调用了 Render，但是并没有给 Echo.Renderer 赋值或其他原因，导致出错，页面看到的信息如下： { &amp;#34;message&amp;#34;: &amp;#34;Internal Server Error&amp;#34; } 这是 Echo 默认的 HTTP Error H</description>
			<content type="html"><![CDATA[<p>Echo 倡导通过从中间件和 Handler 返回错误来进行集中式 HTTP 错误处理。集中式错误处理程序使我们能够从统一位置将错误记录到外部服务，并向客户端发送自定义的 HTTP 响应。本节一起学习如何定制化，进行集中式错误处理。</p>
<h2 id="默认的错误处理">默认的错误处理</h2>
<p>在定制篇 4 中，我们讲到了 Render。如果在 Handler 中调用了 Render，但是并没有给 Echo.Renderer 赋值或其他原因，导致出错，页面看到的信息如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
	<span class="nt">&#34;message&#34;</span><span class="p">:</span> <span class="s2">&#34;Internal Server Error&#34;</span>
<span class="p">}</span>
</code></pre></div><p>这是 Echo 默认的 HTTP Error Handler，表示发生了 500 - Internal Server Error 错误。看看该默认 Error Handler 的代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// DefaultHTTPErrorHandler is the default HTTP error handler. It sends a JSON response
</span><span class="c1">// with status code.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">DefaultHTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">he</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">HTTPError</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Internal</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">herr</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Internal</span><span class="p">.(</span><span class="o">*</span><span class="nx">HTTPError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">he</span> <span class="p">=</span> <span class="nx">herr</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">he</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">HTTPError</span><span class="p">{</span>
			<span class="nx">Code</span><span class="p">:</span>    <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">,</span>
			<span class="nx">Message</span><span class="p">:</span> <span class="nx">http</span><span class="p">.</span><span class="nf">StatusText</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">),</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Issue #1426
</span><span class="c1"></span>	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Code</span>
	<span class="nx">message</span> <span class="o">:=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Message</span>
	<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Debug</span> <span class="p">{</span>
		<span class="nx">message</span> <span class="p">=</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.(</span><span class="kt">string</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">message</span> <span class="p">=</span> <span class="nx">Map</span><span class="p">{</span><span class="s">&#34;message&#34;</span><span class="p">:</span> <span class="nx">m</span><span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Send response
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">Response</span><span class="p">().</span><span class="nx">Committed</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Request</span><span class="p">().</span><span class="nx">Method</span> <span class="o">==</span> <span class="nx">http</span><span class="p">.</span><span class="nx">MethodHead</span> <span class="p">{</span> <span class="c1">// Issue #608
</span><span class="c1"></span>			<span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">NoContent</span><span class="p">(</span><span class="nx">he</span><span class="p">.</span><span class="nx">Code</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>如果是非 HTTPError，会包装成 HTTPError，并设置为 500 - Internal Server Error；</li>
<li>如果开启了 Debug 模式，则会输出具体的错误信息；</li>
</ul>
<p>因此，开启 Debug 模式（e.Debug = true）后，输出是：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="s2">&#34;renderer not registered&#34;</span>
</code></pre></div><p>这对于调试很方便。</p>
<h2 id="集中化自定义错误处理">集中化自定义错误处理</h2>
<p>在有些时候，默认错误 HTTP 处理程序可能足够了；但是，如果你想捕获其他类型的错误并采取相应的处理，比如，发送通知电子邮件或将错误记录到外部日志系统中，这时集中化自定义错误处理就很有用了。除此之外，你可能还希望错误页面更好看，或发送个性化的 JSON 响应。</p>
<p>通过给 Echo#HTTPErrorHandler 设置一个 HTTPErrorHandler 来设置自定义的错误处理程序，HTTPErrorHandler 的定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// HTTPErrorHandler is a centralized HTTP error handler.
</span><span class="c1"></span><span class="kd">type</span>	<span class="nx">HTTPErrorHandler</span> <span class="kd">func</span><span class="p">(</span><span class="kt">error</span><span class="p">,</span> <span class="nx">Context</span><span class="p">)</span>
</code></pre></div><h3 id="自定义错误页面">自定义错误页面</h3>
<p>一般来说，通过 Go 语言渲染页面的话，在发生错误时，渲染对应的错误页面，比如：404.html、500.html 等。</p>
<p>以下自定义 HTTP 错误处理程序根据不同类型的错误显示对应的错误页面并记录错误。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 放在 http 包下的 error.go 中
</span><span class="c1">// CustomHTTPErrorHandler 自定义 HTTP 错误处理
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">CustomHTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span>
	<span class="k">if</span> <span class="nx">he</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HTTPError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">code</span> <span class="p">=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Code</span>
	<span class="p">}</span>
	<span class="nx">errorPage</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d.html&#34;</span><span class="p">,</span> <span class="nx">code</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">File</span><span class="p">(</span><span class="s">&#34;template/&#34;</span> <span class="o">+</span> <span class="nx">errorPage</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在项目的 template 目录下加上相应的 html 文件，比如：404.html、500.html。之后设置上自定义的 CustomHTTPErrorHandler：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nx">HTTPErrorHandler</span> <span class="p">=</span> <span class="nx">myhttp</span><span class="p">.</span><span class="nx">CustomHTTPErrorHandler</span>
</code></pre></div><p>页面简单的包含一些内容，如 404.html 页面内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span> <span class="na">lang</span><span class="o">=</span><span class="s">&#34;en&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&#34;viewport&#34;</span> <span class="na">content</span><span class="o">=</span><span class="s">&#34;width=device-width, initial-scale=1.0&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>404<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span>这是404错误页面<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><p>编译启动程序后，随意访问一个不存在的路径：http://localhost:2020/notfound ，结果如下：</p>
<p><p class="md__image">
  <img src="../imgs/404.png"
    alt=""  />
</p>
</p>
<p>这里的错误，我们简单的记录下来。实际业务中，根据你的情况，可以发送到你需要记录的第三方系统中。</p>
<p>另外，这里给客户端的响应，不一定是 HTML 页面，还有可能是 JSON，根据实际的情况进行相应的处理。而且，实际中，HTML 页面也不会是这么简单的一个页面，可能涉及到一些通用数据，比如通用的头尾等。比如让这个错误页面更符合我们网站的风格，可以这么做：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// CustomHTTPErrorHandler 自定义 HTTP 错误处理
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">CustomHTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">code</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span>
	<span class="k">if</span> <span class="nx">he</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HTTPError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">code</span> <span class="p">=</span> <span class="nx">he</span><span class="p">.</span><span class="nx">Code</span>
	<span class="p">}</span>
	<span class="nx">errorPage</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%d.html&#34;</span><span class="p">,</span> <span class="nx">code</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Render</span><span class="p">(</span><span class="nx">code</span><span class="p">,</span> <span class="nx">errorPage</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>404.html 页面内容变为：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html">{{define &#34;content&#34;}}
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;posts&#34;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">article</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post&#34;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h2</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;post-title&#34;</span><span class="p">&gt;</span>你想要的页面走丢了！<span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">hr</span><span class="p">&gt;</span>
        404
    <span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
{{end}}
</code></pre></div><p>这时 404 页面看起来像这样：</p>
<p><p class="md__image">
  <img src="../imgs/404-pretty.png"
    alt=""  />
</p>
</p>
<h3 id="怎么做到的">怎么做到的？</h3>
<p>为什么这么一句：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nx">HTTPErrorHandler</span> <span class="p">=</span> <span class="nx">myhttp</span><span class="p">.</span><span class="nx">CustomHTTPErrorHandler</span>
</code></pre></div><p>就可以接管错误处理？在 Echo 框架源码中搜索 <code>Echo#HTTPErrorHandler</code> 在哪里调用的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ServeHTTP implements `http.Handler` interface, which serves HTTP requests.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Acquire context
</span><span class="c1"></span>	<span class="nx">c</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="o">*</span><span class="nx">context</span><span class="p">)</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span>

	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">NotFoundHandler</span>

	<span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">premiddleware</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">e</span><span class="p">.</span><span class="nf">findRouter</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Host</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nf">getPath</span><span class="p">(</span><span class="nx">r</span><span class="p">),</span> <span class="nx">c</span><span class="p">)</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Handler</span><span class="p">()</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nf">applyMiddleware</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">middleware</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="nx">e</span><span class="p">.</span><span class="nf">findRouter</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Host</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nf">getPath</span><span class="p">(</span><span class="nx">r</span><span class="p">),</span> <span class="nx">c</span><span class="p">)</span>
			<span class="nx">h</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Handler</span><span class="p">()</span>
			<span class="nx">h</span> <span class="p">=</span> <span class="nf">applyMiddleware</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">middleware</span><span class="o">...</span><span class="p">)</span>
			<span class="k">return</span> <span class="nf">h</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">h</span> <span class="p">=</span> <span class="nf">applyMiddleware</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">premiddleware</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Execute chain
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">h</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">e</span><span class="p">.</span><span class="nf">HTTPErrorHandler</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Release context
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>以上代码的逻辑大体是：</p>
<ul>
<li>从池中获取一个 Context；</li>
<li>解析路由和中间件；</li>
<li>执行中间件链，发生错误时，调用 <code>e.HTTPErrorHandler</code>；</li>
<li>将 Context 放回池中；</li>
</ul>
<p>如果中间件（包括 Handler）执行没有出错，HTTPErrorHandler 自然执行不到。因此，我们可以不用上文提到的方式进行集中错误处理。**你知道是什么方式吗？**当然我们应该使用 HTTPErrorHandler 的方式，这是使用该框架的正确姿势。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇6：自定义 Server 相关，替换或扩展默认的 Server</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom06-ext-server/</link>
			<pubDate>Mon, 16 Mar 2020 10:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom06-ext-server/</guid>
			<description>这是定制篇的最后一节，讲解 Server 的自定义。 默认 Server 通常情况下，Echo 通过如下方式启动一个 HTTP Server： e := echo.New() e.GET(&amp;#34;/&amp;#34;, func(c echo.Context) error { return c.String(http.StatusOK, &amp;#34;Hello, World!&amp;#34;) }) e.Logger.Fatal(e.Start(&amp;#34;:2020&amp;#34;)) 我们打开源码一探究竟： // Start starts an HTTP server. func (e *Echo) Start(address string) error { e.Server.Addr = address return e.StartServer(e.Server) } 原来调用的是 StartServer，参数是默认的 Server 实例，它是一个 http.Server 的指针类型。 自定义 Server 知道了 Echo#Start 最终调用的是 Echo#StartServer，而且它的参数是一个 *http.Server 类型，所以自</description>
			<content type="html"><![CDATA[<p>这是定制篇的最后一节，讲解 Server 的自定义。</p>
<h2 id="默认-server">默认 Server</h2>
<p>通常情况下，Echo 通过如下方式启动一个 HTTP Server：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
</code></pre></div><p>我们打开源码一探究竟：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Start starts an HTTP server.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">Start</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Server</span><span class="p">.</span><span class="nx">Addr</span> <span class="p">=</span> <span class="nx">address</span>
	<span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nf">StartServer</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Server</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>原来调用的是 StartServer，参数是默认的 Server 实例，它是一个 http.Server 的指针类型。</p>
<h2 id="自定义-server">自定义 Server</h2>
<p>知道了 Echo#Start 最终调用的是 Echo#StartServer，而且它的参数是一个 <code>*http.Server</code> 类型，所以自定义一个 Server 很容易。我们先看看 http.Server 这个结构。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Server</span> <span class="kd">struct</span> <span class="p">{</span>
  	<span class="c1">// 指定 TCP 的监听地址，形式：&#34;host:port&#34;。如果空，则使用 &#34;:http&#34;，即 80 端口
</span><span class="c1"></span>    <span class="nx">Addr</span> <span class="kt">string</span>
	
		<span class="c1">// 当前服务器的 Handler，如果未设置，使用 http.DefaultServeMux
</span><span class="c1"></span>    <span class="nx">Handler</span> <span class="nx">Handler</span>

  	<span class="c1">// TLS 配置
</span><span class="c1"></span>    <span class="nx">TLSConfig</span> <span class="o">*</span><span class="nx">tls</span><span class="p">.</span><span class="nx">Config</span>

  	<span class="c1">// 读取整个 request（包括 body）的最大允许时间（超时时间）
</span><span class="c1"></span>    <span class="nx">ReadTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

  	<span class="c1">// 从 Go1.8 开始增加。只是读取请求头的最大允许时间（超时时间）
</span><span class="c1"></span>    <span class="nx">ReadHeaderTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// Go 1.8
</span><span class="c1"></span>
  	<span class="c1">// 和 ReadTimeout 对应，这是写 response 的最大允许时间（超时时间）
</span><span class="c1"></span>    <span class="nx">WriteTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>

  	<span class="c1">// 从 Go1.8 开始增加。下个请求到来前允许的最大空闲时间（keep-alive 启用时）。
</span><span class="c1"></span>  	<span class="c1">// 如果是 0，使用 ReadTimeout，都为 0 ，不会超时。
</span><span class="c1"></span>    <span class="nx">IdleTimeout</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="c1">// Go 1.8
</span><span class="c1"></span>
  	<span class="c1">// 允许的最大请求头（单位字节），默认值 DefaultMaxHeaderBytes
</span><span class="c1"></span>    <span class="nx">MaxHeaderBytes</span> <span class="kt">int</span>
		
  	<span class="c1">// 其他字段忽略。。。
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>默认情况下启动的 Server，超时时间是 0，也就是不会超时。我们自定义一个 Server，设置超时时间：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">s</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
  <span class="nx">Addr</span><span class="p">:</span>         <span class="s">&#34;:2020&#34;</span><span class="p">,</span>
  <span class="nx">ReadTimeout</span><span class="p">:</span>  <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
  <span class="nx">WriteTimeout</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
<span class="p">}</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">StartServer</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>
</code></pre></div><p>为了方便验证，我们将超时时间设置的较短：10s，实际项目这个肯定太短了。</p>
<h3 id="验证读超时是否生效">验证读超时是否生效</h3>
<p>往下看之前，你想想用什么办法可以验证？</p>
<p>因为 HTTP 是基于 TCP 的，我们可以简单的通过建立 TCP 连接，然后等待一段时间后，再发送 HTTP 报文，具体代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:2020&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">11</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="s">&#34;GET / HTTP/1.0\r\n\r\n&#34;</span><span class="p">)</span>
	<span class="nx">status</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">bufio</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">conn</span><span class="p">).</span><span class="nf">ReadString</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">status</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>通过修改 Sleep 的时间来控制等待时间，可以看看 10s 以内是否成功（刚好 10s 可能也会失败），10s 以上又是什么情况。</p>
<blockquote>
<p>注意，这里的 HTTP/1.0 不能改为 1.1 等，否则得提供 Host 头部</p>
</blockquote>
<p>Sleep 设置为 11s ，运行客户端后，如果返回 EOF，则表明超时设置生效了。</p>
<h2 id="自定义-listener">自定义 Listener</h2>
<p>Echo 框架支持自定义 Listener，即通过 <code>Echo#Listener</code> 进行设置。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;tcp&#34;</span><span class="p">,</span> <span class="s">&#34;:1323&#34;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Listener</span> <span class="p">=</span> <span class="nx">l</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))</span>
</code></pre></div><p>什么场景下会需要自定义？或者说为什么 Echo 要让用户可以自定义 Listener？我认为有两种考虑：</p>
<ol>
<li>
<p>Listener 支持配置，具体就是 net.ListenConfig 类型。实际上，net 包中，net.Listen() 函数就是用了这个类型获取 Listener 实例；</p>
</li>
<li>
<p>除了使用 net.Listen 获取一个 Listener 接口的实例外，还有其他的方式可以获取 Listener 接口的实例；</p>
</li>
</ol>
<h3 id="unixlistener">UnixListener</h3>
<p>我们着重看看第 2 种情况。</p>
<p>net.Listener 是一个接口。在 net 库中，有 TCPListener 和 UnixListener，除此之外，其他的 Listener 都是基于这两种。比如 net.FileListener() 函数，最终是 TCPListener。</p>
<p>一般我们使用的就是 TCPListener，如果想在 echo 中使用 UnixListener，如何实现？（这个例子没有太多现实意义）</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">unixAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ResolveUnixAddr</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="s">&#34;/tmp/echo.sock&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">unixListener</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ListenUnix</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="nx">unixAddr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello Unix！&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Listener</span> <span class="p">=</span> <span class="nx">unixListener</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>因为基于 Unix Domain Socket，所以，没法直接浏览器访问。写一个测试程序：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">unixAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">ResolveUnixAddr</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="s">&#34;/tmp/echo.sock&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">DialUnix</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">unixAddr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintf</span><span class="p">(</span><span class="nx">conn</span><span class="p">,</span> <span class="s">&#34;GET / HTTP/1.0\r\n\r\n&#34;</span><span class="p">)</span>
	<span class="nx">body</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">conn</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">body</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>客户端能够输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">HTTP/1.0 <span class="m">200</span> OK
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Wed, <span class="m">25</span> Mar <span class="m">2020</span> 06:35:12 GMT
Content-Length: <span class="m">13</span>

Hello Unix！
</code></pre></div><p>表示成功！</p>
<p>再提醒下，一般不会定义 Listener，你知晓能定义即可。</p>
<h2 id="tls-相关">TLS 相关</h2>
<p>这里顺便介绍下 Echo 对 TLS 的支持。一般来说是用不到的，因为实际中，我们会使用 Web Server 进行反向代理，由 Web Server 来处理 TLS。但了解相关内容还是有利的。</p>
<h3 id="https-server">HTTPS Server</h3>
<p>看下相应的方法签名：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">StartTLS</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">certFile</span><span class="p">,</span> <span class="nx">keyFile</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>相比 Echo#Start 方法，StartTLS 多了两个参数：certFile 和 keyFile。这两个参数是什么意思？这里简单介绍下，知晓什么意思即可。</p>
<ul>
<li>certFile：证书</li>
<li>keyFile：私钥</li>
</ul>
<p>net/http 包，这两个参数是字符串，代表两个文件的路径。Echo 对此进行了扩展，除了可以代表文件的路径，还可以是字节数组，表示证书和私钥的具体内容。</p>
<p>CA 证书可以购买，也可以申请免费的（阿里云、七牛云都有），也可以使用 let’s encrypt 免费证书。这里我们先自己生成证书，本地验证。（注意，自己生成的证书，浏览器是不认的）</p>
<h4 id="证书生成">证书生成</h4>
<p>证书的生成可以用 Linux/Mac 的 OpenSSL 工具链。对于一个网站，首先必须有自己的私钥，私钥的生成方式为：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> go-cache-example <span class="c1"># 切换到我们的项目根目录</span>
$ openssl genrsa -out server.key <span class="m">2048</span>
</code></pre></div><p>会在当前目录下生成一个 server.key 文件，这就是私钥。</p>
<p>利用私钥就可以生成证书了。OpenSSL 使用 x509 命令生成证书。这里需要区分两个概念：证书（certificate）和证书请求（certificate sign request）</p>
<ul>
<li>证书是自签名或 CA 签名过的凭据，用来进行身份认证</li>
<li>证书请求是对签名的请求，需要使用私钥进行签名</li>
</ul>
<p>x509 命令可以将证书和证书请求相互转换。</p>
<p>从私钥可以生成自签名证书：（跳过了证书请求，一步到位）</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">openssl req -new -x509 -key server.key -out server.crt -days <span class="m">365</span>
</code></pre></div><p>req 命令会通过命令行要求用户输入国家、地区、组织等信息，这些信息会附加在证书中展示给连接方。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter <span class="s1">&#39;.&#39;</span>, the field will be left blank.
-----
Country Name <span class="o">(</span><span class="m">2</span> letter code<span class="o">)</span> <span class="o">[]</span>:CN
State or Province Name <span class="o">(</span>full name<span class="o">)</span> <span class="o">[]</span>:Beijing
Locality Name <span class="o">(</span>eg, city<span class="o">)</span> <span class="o">[]</span>:Beijing
Organization Name <span class="o">(</span>eg, company<span class="o">)</span> <span class="o">[]</span>:studygolang
Organizational Unit Name <span class="o">(</span>eg, section<span class="o">)</span> <span class="o">[]</span>:
Common Name <span class="o">(</span>eg, fully qualified host name<span class="o">)</span> <span class="o">[]</span>:localhost
Email Address <span class="o">[]</span>:polaris@studygolang.com
</code></pre></div><p>以上命令会在当前目录生成 server.crt 文件。</p>
<p>这样我们有了上面需要的 cert 和 key。</p>
<h3 id="验证本地的-https-server">验证本地的 HTTPS Server</h3>
<p>在 go-cache-example 项目中的 cmd/custom/main.go 包含如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello TLS！&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">StartTLS</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">,</span> <span class="s">&#34;server.crt&#34;</span><span class="p">,</span> <span class="s">&#34;server.key&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>启动服务：go run cmd/custom/main.go</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">   ____    __
  / __/___/ /  ___
 / _// __/ _ <span class="se">\/</span> _ <span class="se">\
</span><span class="se"></span>/___/<span class="se">\_</span>_/_//_/<span class="se">\_</span>__/ v4.1.15
High performance, minimalist Go web framework
https://echo.labstack.com
____________________________________O/_______
                                    O<span class="se">\
</span><span class="se"></span>⇨ https server started on <span class="o">[</span>::<span class="o">]</span>:2020
</code></pre></div><p>打开 Chrome 浏览器，请求：https://localhost:2020 （注意是 HTTPS），出现如下错误：</p>
<p><p class="md__image">
  <img src="../imgs/custom-https.png"
    alt=""  />
</p>
</p>
<p>在浏览器输出：<code>chrome://flags/#allow-insecure-localhost</code> ，高亮的置为 Enabled，Reload Chrome。</p>
<p><p class="md__image">
  <img src="../imgs/chrome-insecure-localhost.png"
    alt=""  />
</p>
</p>
<p>再次请求 https://localhost:2020 ，能正常输出：Hello TLS！表明成功了。</p>
<p>通过 FireFox 浏览器，可以方便看到，我们这个服务支持 HTTP/2：</p>
<p><p class="md__image">
  <img src="../imgs/firefox-http2.png"
    alt=""  />
</p>
</p>
<blockquote>
<p>Echo 还支持自动 TLS，即：Echo#StartAutoTLS 方法，它从 <a href="https://letsencrypt.org">https://letsencrypt.org</a> 获取证书。这涉及到正式域名等，在此不演示！</p>
</blockquote>
<h2 id="自定义-http2-cleartext-server">自定义 HTTP/2 Cleartext Server</h2>
<p>默认情况下，HTTP/2 是基于 TLS 的。上面也看到，当是 HTTPS Server 时，浏览器支持 HTTP/2，默认使用了它。如果我们想使用 HTTP/2，但是又不想使用 TLS，可以吗？这就是 H2C，即：HTTP/2 Cleartext Server。</p>
<p>从 Echo4.1.15 开始支持启动 H2C 服务器：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Echo</span><span class="p">)</span> <span class="nf">StartH2CServer</span><span class="p">(</span><span class="nx">address</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">h2s</span> <span class="o">*</span><span class="nx">http2</span><span class="p">.</span><span class="nx">Server</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>Go 从 1.6 开始，标准库 net/http 支持 HTTP/2，Go1.8 支持 HTTP/2 的 Push。Go 对 HTTP/2 的支持，最初通过 golang.org/x/net/http2 包实现。Echo 中，上面方法的参数 http2.Server 就是 golang.org/x/net/http2 包中的。</p>
<p>实现一个支持 H2C 的 HTTP Server：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">().</span><span class="nx">Proto</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello HTTP/2！&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">server</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http2</span><span class="p">.</span><span class="nx">Server</span><span class="p">{</span>
		<span class="nx">MaxConcurrentStreams</span><span class="p">:</span> <span class="mi">250</span><span class="p">,</span>
		<span class="nx">MaxReadFrameSize</span><span class="p">:</span>     <span class="mi">1048576</span><span class="p">,</span>
		<span class="nx">IdleTimeout</span><span class="p">:</span>          <span class="mi">10</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">StartH2CServer</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">,</span> <span class="nx">server</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>然而，因为现代的浏览器都不支持  H2C，所以测试我们通过 curl 来进行。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ curl -v --http2 -k http://localhost:2020

*   Trying ::1...
* TCP_NODELAY <span class="nb">set</span>
* Connected to localhost <span class="o">(</span>::1<span class="o">)</span> port <span class="m">2020</span> <span class="o">(</span><span class="c1">#0)</span>
&gt; GET / HTTP/1.1
&gt; Host: localhost:2020
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt; Connection: Upgrade, HTTP2-Settings
&gt; Upgrade: h2c
&gt; HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
&gt;
&lt; HTTP/1.1 <span class="m">101</span> Switching Protocols
&lt; Connection: Upgrade
&lt; Upgrade: h2c
* Received <span class="m">101</span>
* Using HTTP2, server supports multi-use
* Connection state changed <span class="o">(</span>HTTP/2 confirmed<span class="o">)</span>
* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: <span class="nv">len</span><span class="o">=</span><span class="m">0</span>
* Connection state changed <span class="o">(</span><span class="nv">MAX_CONCURRENT_STREAMS</span> <span class="o">==</span> 250<span class="o">)</span>!
&lt; HTTP/2 <span class="m">200</span>
&lt; content-type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
&lt; content-length: <span class="m">15</span>
&lt; date: Thu, <span class="m">26</span> Mar <span class="m">2020</span> 08:20:58 GMT
&lt;
* Connection <span class="c1">#0 to host localhost left intact</span>
Hello HTTP/2！* Closing connection <span class="m">0</span>
</code></pre></div><p>而且服务端的输出也确实证明是 HTTP/2。</p>
<p>另外可以通过 Echo#DisableHTTP2 禁用 HTTP/2。</p>
<p>至此，关于 Server 的定制就介绍完了。Echo 的定制也全部讲解完。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇3：自定义 Logger，用你喜欢的日志库</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom03-logger/</link>
			<pubDate>Fri, 06 Mar 2020 11:50:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom03-logger/</guid>
			<description>在知识星球简书项目中，我们分析对比了目前的一些日志库。虽然 Go 标准库有一个 log，但功能有限，所以才出现了很多第三方的日志库。在 用 Go 实现一个简书 8：日志记录和优秀库的学习 中，我们得出结论，推荐大家使用 zerolog 。现在我们就将 zerolog 集成进 Echo 框架中。 Echo 默认的 Logger Echo 日志记录的默认格式是 JSON，可以通过修改标头来更改，即 Echo#Logger.SetHeader(io.Write</description>
			<content type="html"><![CDATA[<p>在知识星球简书项目中，我们分析对比了目前的一些日志库。虽然 Go 标准库有一个 log，但功能有限，所以才出现了很多第三方的日志库。在 <a href="https://studygolang.com/topics/10625" target="_blank" rel="noopener">用 Go 实现一个简书 8：日志记录和优秀库的学习</a>
 中，我们得出结论，推荐大家使用 <a href="https://github.com/rs/zerolog" target="_blank" rel="noopener">zerolog</a>
。现在我们就将 zerolog 集成进 Echo 框架中。</p>
<h2 id="echo-默认的-logger">Echo 默认的 Logger</h2>
<p>Echo 日志记录的默认格式是 JSON，可以通过修改标头来更改，即 <code>Echo#Logger.SetHeader(io.Writer)</code>。</p>
<h3 id="log-header">Log Header</h3>
<p>标头默认值为：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span><span class="nt">&#34;time&#34;</span><span class="p">:</span><span class="s2">&#34;${time_rfc3339_nano}&#34;</span><span class="p">,</span><span class="nt">&#34;level&#34;</span><span class="p">:</span><span class="s2">&#34;${level}&#34;</span><span class="p">,</span><span class="nt">&#34;prefix&#34;</span><span class="p">:</span><span class="s2">&#34;${prefix}&#34;</span><span class="p">,</span><span class="nt">&#34;file&#34;</span><span class="p">:</span><span class="s2">&#34;${short_file}&#34;</span><span class="p">,</span><span class="nt">&#34;line&#34;</span><span class="p">:</span><span class="s2">&#34;${line}&#34;</span><span class="p">}</span>
</code></pre></div><p>因为 Echo 默认使用的 Logger 是作者开发的 <code>github.com/labstack/gommon/log</code> 库，我们看看怎么自定义默认标头。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;github.com/labstack/gommon/log&#34;</span>

<span class="cm">/* ... */</span>

<span class="k">if</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.(</span><span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
  <span class="nx">l</span><span class="p">.</span><span class="nf">SetHeader</span><span class="p">(</span><span class="s">&#34;${time_rfc3339} ${level}&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>这样输出的标头成为：<code>2018-05-08T20:30:06-07:00 INFO info</code>。</p>
<p>目前，预定义的 tag 有：</p>
<ul>
<li><code>time_rfc3339</code>：时间格式</li>
<li><code>time_rfc3339_nano</code>：带纳秒的时间格式</li>
<li><code>level</code>：级别</li>
<li><code>prefix</code>：前缀</li>
<li><code>long_file</code>：长文件名（带路径）</li>
<li><code>short_file</code>：短文件名（不带路径）</li>
<li><code>line</code>：文件行号</li>
</ul>
<h3 id="log-输出">Log 输出</h3>
<p><code>Echo#Logger.SetOutput(io.Writer)</code> 可以设置日志输出的目的地。默认输出到标准输出。如果想禁用日志，有两种方式：</p>
<ul>
<li>Echo#Logger.SetOutput(ioutil.Discard)</li>
<li>Echo#Logger.SetLevel(log.OFF)</li>
</ul>
<h3 id="log-级别">Log 级别</h3>
<p>默认情况下，日志的级别是 ERROR。可以通过 <code>Echo#Logger.SetLevel(log.Lvl)</code> 修改。一共有如下一些级别：</p>
<ul>
<li><code>DEBUG</code></li>
<li><code>INFO</code></li>
<li><code>WARN</code></li>
<li><code>ERROR</code></li>
<li><code>OFF</code></li>
</ul>
<p>以上就是 Echo 框架提供的可以定制 Log 的相关接口。</p>
<h2 id="自定义-logger">自定义 Logger</h2>
<p>Echo 支持通过<code>Echo#Logger</code> 注册自定义的 Logger，前提是这个 Logger 必须实现 Echo 提供的接口：echo.Logger：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Output</span><span class="p">()</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span>
    <span class="nf">SetOutput</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span>
    <span class="nf">Prefix</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nf">SetPrefix</span><span class="p">(</span><span class="nx">p</span> <span class="kt">string</span><span class="p">)</span>
    <span class="nf">Level</span><span class="p">()</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Lvl</span>
    <span class="nf">SetLevel</span><span class="p">(</span><span class="nx">v</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Lvl</span><span class="p">)</span>
    <span class="nf">SetHeader</span><span class="p">(</span><span class="nx">h</span> <span class="kt">string</span><span class="p">)</span>
    <span class="nf">Print</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Printf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Printj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Debug</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Debugf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Debugj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Info</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Infof</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Infoj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Warn</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Warnf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Warnj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Error</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Errorf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Errorj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Fatal</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Fatalj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Fatalf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Panic</span><span class="p">(</span><span class="nx">i</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
    <span class="nf">Panicj</span><span class="p">(</span><span class="nx">j</span> <span class="nx">log</span><span class="p">.</span><span class="nx">JSON</span><span class="p">)</span>
    <span class="nf">Panicf</span><span class="p">(</span><span class="nx">format</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">args</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span>
<span class="p">}</span>
</code></pre></div><p>这个接口看着很吓人，基本上是几个日志级别对应的方法。因此，如果我们要将 zerolog 集成进 Echo，让 zerolog 实现该接口（zerolog 本身肯定没有实现该接口）。</p>
<p>因为 zerolog 库的设计和 API 与 echo.Logger 接口差异极大，想要直接为 zerolog 实现一个 Adapter 以便实现 echo.Logger 接口不太现实。于是我们做如下处理来进行适配：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Logger</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">log</span><span class="p">.</span><span class="nx">Logger</span>
	<span class="nx">ZeroLog</span> <span class="nx">zerolog</span><span class="p">.</span><span class="nx">Logger</span>
<span class="p">}</span>
</code></pre></div><p>我们定义一个自己的 Logger 结构体，内嵌一个 github.com/labstack/gommon/log 库的 Logger 指针，这样默认就实现了 echo.Logger 接口，然后再是 zerolog.Logger。看看构造函数如何实现？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">writer</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="o">*</span><span class="nx">Logger</span> <span class="p">{</span>
	<span class="nx">l</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Logger</span><span class="p">{</span>
		<span class="nx">Logger</span><span class="p">:</span>  <span class="nx">log</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;-&#34;</span><span class="p">),</span>
		<span class="nx">ZeroLog</span><span class="p">:</span> <span class="nx">zerolog</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">writer</span><span class="p">).</span><span class="nf">With</span><span class="p">().</span><span class="nf">Caller</span><span class="p">().</span><span class="nf">Timestamp</span><span class="p">().</span><span class="nf">Logger</span><span class="p">(),</span>
	<span class="p">}</span>
  
	<span class="c1">// log 默认是 ERROR，将 Level 默认都改为 INFO
</span><span class="c1"></span>	<span class="nx">l</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">INFO</span><span class="p">)</span>

	<span class="nx">l</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetOutput</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">l</span>
<span class="p">}</span>
</code></pre></div><p>这么做有什么用？还不如干脆 echo 框架自己的日志由它处理，我们的日志使用 zerolog 处理。这样当然是可以的。但集成在一起有如下好处：</p>
<ul>
<li>形式上变成了一个日志类，也就是我们自定义的 Logger；</li>
<li>方便统一控制，比如输出目标、日志级别；</li>
<li>通过一个日志库，既可以做到单独控制 echo 的行为，也可以单独控制 zerolog 的行为；</li>
</ul>
<p>那统一控制行为如何实现呢？这里实现了两个，控制输出目的地和日志级别。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">SetOutput</span><span class="p">(</span><span class="nx">writer</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetOutput</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span><span class="p">.</span><span class="nf">Output</span><span class="p">(</span><span class="nx">writer</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">Logger</span><span class="p">)</span> <span class="nf">SetLevel</span><span class="p">(</span><span class="nx">level</span> <span class="nx">log</span><span class="p">.</span><span class="nx">Lvl</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">level</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">level</span> <span class="o">==</span> <span class="nx">log</span><span class="p">.</span><span class="nx">OFF</span> <span class="p">{</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span><span class="p">.</span><span class="nf">Level</span><span class="p">(</span><span class="nx">zerolog</span><span class="p">.</span><span class="nx">Disabled</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">zeroLevel</span> <span class="o">:=</span> <span class="nb">int8</span><span class="p">(</span><span class="nx">level</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span> <span class="p">=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">ZeroLog</span><span class="p">.</span><span class="nf">Level</span><span class="p">(</span><span class="nx">zerolog</span><span class="p">.</span><span class="nf">Level</span><span class="p">(</span><span class="nx">zeroLevel</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>当然这种方式也有麻烦的地方，那就是通过 echo 的 Context 获得 zerolog 日志实例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">zerolog</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().(</span><span class="o">*</span><span class="nx">logger</span><span class="p">.</span><span class="nx">Logger</span><span class="p">).</span><span class="nx">ZeroLog</span>
</code></pre></div><p>这样自定义日志库就完成了。该库完整代码见：<a href="https://github.com/polaris1119/go-echo-example/blob/master/pkg/logger/logger.go">https://github.com/polaris1119/go-echo-example/blob/master/pkg/logger/logger.go</a>。</p>
<h2 id="在-echo-项目中使用自定义日志库">在 Echo 项目中使用自定义日志库</h2>
<p>在 go-echo-example 项目的 cmd 下创建一个目录 gopher，将来我们的实战篇就用它作为入口。之后创建一个 main.go 文件，核心代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span> <span class="p">=</span> <span class="nx">logger</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">)</span>
  <span class="c1">// e.Logger.SetLevel(log.DEBUG)
</span><span class="c1"></span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Recover</span><span class="p">())</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;This is echo logger debug msg!&#34;</span><span class="p">)</span>

		<span class="nx">zerolog</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Logger</span><span class="p">().(</span><span class="o">*</span><span class="nx">logger</span><span class="p">.</span><span class="nx">Logger</span><span class="p">).</span><span class="nx">ZeroLog</span>
		<span class="nx">zerolog</span><span class="p">.</span><span class="nf">Debug</span><span class="p">().</span><span class="nf">Str</span><span class="p">(</span><span class="s">&#34;path&#34;</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Path</span><span class="p">()).</span><span class="nf">Msg</span><span class="p">(</span><span class="s">&#34;This is Debug msg!&#34;</span><span class="p">)</span>

		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">HTML</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>我们得到 echo 的实例后，将其日志设置为我们自定义的 logger：<code>e.Logger = logger.New(os.Stdout)</code>。注意注释掉的代码。运行程序：go run main.go，打开浏览器访问 http://localhost:2020 ，看看日志是否有两条 Debug 记录。接着将注释去掉再次测试，看日志是否有输出。</p>
<p>不出意外，一切都符合预期。恭喜你大功告成！</p>
<p><a href="https://github.com/polaris1119/go-echo-example/tree/091967f4bea4a3f9ee7c20411f15287d2c950e02" target="_blank" rel="noopener">完整代码点这里</a>
。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇2：自定义 Validator，进行输入校验</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom02-validator/</link>
			<pubDate>Fri, 28 Feb 2020 18:53:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom02-validator/</guid>
			<description>上一篇讲 Binder 时提到，参数自动绑定和校验是 Web 框架很重要的两个功能，可以极大的提升开发速度，并更好的保证数据的可靠性（服务端数据校验很重要）。本节，我们就一起看看如何自定义 Echo 的表单校验功能。 不同于 Binder，Echo 并没有内置数据校验的能力，也就是没有默认的 Validator 实现。然而，你可以很方便的集成第三方的数据校验库。跟 Binder 类似，Echo 提供了一个 Validator 接口，方便将第三方数据校</description>
			<content type="html"><![CDATA[<p>上一篇讲 Binder 时提到，参数自动绑定和校验是 Web 框架很重要的两个功能，可以极大的提升开发速度，并更好的保证数据的可靠性（服务端数据校验很重要）。本节，我们就一起看看如何自定义 Echo 的表单校验功能。</p>
<p>不同于 Binder，Echo 并没有内置数据校验的能力，也就是没有默认的 Validator 实现。然而，你可以很方便的集成第三方的数据校验库。跟 Binder 类似，Echo 提供了一个 Validator 接口，方便将第三方数据校验库集成进来。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Validator</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">Validate</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>通过这个实现这个接口，可以很方便的将任何第三方数据校验库集成到 Echo 中。在 Awesome-Go 上可以找到第三方数据校验库：<a href="https://github.com/avelino/awesome-go#validation">https://github.com/avelino/awesome-go#validation</a>。本文我们使用最流行的 <a href="https://github.com/go-playground/validator">https://github.com/go-playground/validator</a> 库来讲解。</p>
<h2 id="go-playgroundvalidator">go-playground/validator</h2>
<p>这是一个 Go 结构体及字段校验器，包括：跨字段和跨结构体校验，Map，切片和数组，是目前校验器相关库中 Star 数最高的一个，对国际化支持也很好，建议大家使用它。</p>
<p>它具有以下独特功能：</p>
<ul>
<li>通过使用验证标签（tag）或自定义验证程序进行跨字段和跨结构体验证；</li>
<li>切片，数组和 map，可以验证任何的多维字段或多层级；</li>
<li>能够深入（多维）了解 map 键和值以进行验证；</li>
<li>通过在验证之前确定其基础类型来处理接口类型；</li>
<li>处理自定义字段类型，例如 sql driver Valuer；</li>
<li>别名验证标签，允许将多个验证映射到单个标签，以便更轻松地定义结构上的验证；</li>
<li>提取自定义定义的字段名称，例如可以指定在验证时提取 JSON 名称，并将其用于结果 FieldError 中；</li>
<li>可自定义的 i18n 错误消息；</li>
<li>gin Web 框架的默认验证器；</li>
</ul>
<h3 id="一个简单的例子">一个简单的例子</h3>
<p>通过一个简单例子来看看如何使用该库。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;flag&#34;</span>

	<span class="s">&#34;github.com/go-playground/validator/v10&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`validate:&#34;required&#34;`</span>
	<span class="nx">Age</span>   <span class="kt">uint</span>   <span class="s">`validate:&#34;gte=1,lte=130&#34;`</span>
	<span class="nx">Email</span> <span class="kt">string</span> <span class="s">`validate:&#34;required,email&#34;`</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">name</span>  <span class="kt">string</span>
	<span class="nx">age</span>   <span class="kt">uint</span>
	<span class="nx">email</span> <span class="kt">string</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">name</span><span class="p">,</span> <span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;输入名字&#34;</span><span class="p">)</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">UintVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">age</span><span class="p">,</span> <span class="s">&#34;age&#34;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;输入年龄&#34;</span><span class="p">)</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">StringVar</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">email</span><span class="p">,</span> <span class="s">&#34;email&#34;</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="s">&#34;输入邮箱&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>

	<span class="nx">user</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="nx">name</span><span class="p">,</span>
		<span class="nx">Age</span><span class="p">:</span>   <span class="nx">age</span><span class="p">,</span>
		<span class="nx">Email</span><span class="p">:</span> <span class="nx">email</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">validate</span> <span class="o">:=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>执行如下命令，运行代码：</p>
<pre><code>go run main.go -name studygolang -age 7 -email polaris@studygolang.com
</code></pre><p>什么都没有输出，表示一切正常。如果我们提供一个非法的邮箱地址：</p>
<pre><code>go run main.go -name studygolang -age 7 -email polaris@studygolang
</code></pre><p>输出如下错误：</p>
<pre><code>Key: 'User.Email' Error:Field validation for 'Email' failed on the 'email' tag
</code></pre><p>错误显示不友好。怎么能够更友好，并进行国际化呢？</p>
<h3 id="国际化i18n">国际化（i18n）</h3>
<p>在介绍校验库错误消息国际化之前，有一个概念需要了解下，那就是 CLDR。</p>
<h4 id="什么是-cldr">什么是 CLDR？</h4>
<p>它是 i18n 的一套核心规范（ Common Locale Data Respository），即通用的本地化数据存储库，什么意思呢？比如我们的手机，电脑都可以选择语言模式为 英语、汉语、日语、法语等等，这套操作背后的规范，就是 CLDR；CLDR 是以 Unicode 的编码标准作为前提，将多国的语言文字进行编码的。</p>
<p>看看官方对于 CLDR 的说明，官方网址：<a href="http://cldr.unicode.org/">http://cldr.unicode.org/</a></p>
<blockquote>
<p>Unicode CLDR 提供了支持世界语言的软件的关键构建块，并且具有最大和最广泛的本地设置数据标准存储库。大量的公司使用此数据进行软件的国际化和本地化，使它们的软件适应此类通用软件任务的不同语言的约定。</p>
</blockquote>
<p>需要进行国际化和本地化的主要包括：</p>
<ul>
<li>用于格式化和解析的特定于语言环境的模式：日期，时间，时区，数字和货币值，度量单位，…</li>
<li>名称的翻译：语言，脚本，国家和地区，货币，时代，月份，工作日，白天，时区，城市和时间单位，表情符号字符和序列（和搜索关键字），…</li>
<li>语言和文字信息：使用的字符；复数情况；性别；大写；分类和搜索规则；写作方向；音译规则；拼写数字的规则；将文本分割成字符，单词和句子的规则；键盘布局…</li>
<li>国家/地区信息：语言使用情况，货币信息，日历首选项，星期惯例等…</li>
<li>有效性：Unicode 语言环境，语言，脚本，区域和扩展名的定义，别名和有效性信息，…</li>
</ul>
<h4 id="cldr-的-go-语言实现">CLDR 的 Go 语言实现</h4>
<p>本文讲解的校验库是 go-playground 这个组织创建的，它们还提供了其他的一些有用库，其中就包括了 CLDR 的 Go 语言实现，这就是 <a href="https://github.com/go-playground/locales" target="_blank" rel="noopener">locales</a>
。</p>
<blockquote>
<p>该库是从 CLDR 项目生成的一组语言环境，可以单独使用或在 i18n 软件包中使用；这些是专为 <a href="https://github.com/go-playground/universal-translator">https://github.com/go-playground/universal-translator</a> 构建的，但也可以单独他用。</p>
</blockquote>
<p>这引出了该组织的另外一个库：<a href="https://github.com/go-playground/universal-translator" target="_blank" rel="noopener">universal-translator</a>
。</p>
<p><a href="https://github.com/go-playground/universal-translator" target="_blank" rel="noopener">universal-translator</a>
：一个使用 CLDR 数据+复数规则（比如英语很多复数规则是加 s）的 Go i18n 转换器（翻译器）。该库是  <a href="https://github.com/go-playground/locales" target="_blank" rel="noopener">locales</a>
 的薄包装，以便存储和翻译文本，供你在应用程序中使用。</p>
<h4 id="universal-translator-简明教程">universal-translator 简明教程</h4>
<p>这个通用的翻译器包主要包含了两个核心数据结构：Translator 接口和 UniversalTranslator 结构体，其他的是错误类型。我们先看 Translator 接口。（注意，该包的包名是 ut）</p>
<p><strong>Translator 接口</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Translator</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">locales</span><span class="p">.</span><span class="nx">Translator</span>

    <span class="c1">// adds a normal translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {#} is the only replacement type accepted and are ad infinitum
</span><span class="c1"></span>    <span class="c1">// eg. one: &#39;{0} day left&#39; other: &#39;{0} days left&#39;
</span><span class="c1"></span>    <span class="nf">Add</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// adds a cardinal plural translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {0} is the only replacement type accepted and only one variable is accepted as
</span><span class="c1"></span>    <span class="c1">// multiple cannot be used for a plural rule determination, unless it is a range;
</span><span class="c1"></span>    <span class="c1">// see AddRange below.
</span><span class="c1"></span>    <span class="c1">// eg. in locale &#39;en&#39; one: &#39;{0} day left&#39; other: &#39;{0} days left&#39;
</span><span class="c1"></span>    <span class="nf">AddCardinal</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rule</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRule</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// adds an ordinal plural translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {0} is the only replacement type accepted and only one variable is accepted as
</span><span class="c1"></span>    <span class="c1">// multiple cannot be used for a plural rule determination, unless it is a range;
</span><span class="c1"></span>    <span class="c1">// see AddRange below.
</span><span class="c1"></span>    <span class="c1">// eg. in locale &#39;en&#39; one: &#39;{0}st day of spring&#39; other: &#39;{0}nd day of spring&#39;
</span><span class="c1"></span>    <span class="c1">// - 1st, 2nd, 3rd...
</span><span class="c1"></span>    <span class="nf">AddOrdinal</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rule</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRule</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// adds a range plural translation for a particular language/locale
</span><span class="c1"></span>    <span class="c1">// {0} and {1} are the only replacement types accepted and only these are accepted.
</span><span class="c1"></span>    <span class="c1">// eg. in locale &#39;nl&#39; one: &#39;{0}-{1} day left&#39; other: &#39;{0}-{1} days left&#39;
</span><span class="c1"></span>    <span class="nf">AddRange</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">text</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">rule</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRule</span><span class="p">,</span> <span class="nx">override</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// creates the translation for the locale given the &#39;key&#39; and params passed in
</span><span class="c1"></span>    <span class="nf">T</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">params</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// creates the cardinal translation for the locale given the &#39;key&#39;, &#39;num&#39; and &#39;digit&#39; arguments
</span><span class="c1"></span>    <span class="c1">//  and param passed in
</span><span class="c1"></span>    <span class="nf">C</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">num</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">param</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// creates the ordinal translation for the locale given the &#39;key&#39;, &#39;num&#39; and &#39;digit&#39; arguments
</span><span class="c1"></span>    <span class="c1">// and param passed in
</span><span class="c1"></span>    <span class="nf">O</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">num</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">param</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">//  creates the range translation for the locale given the &#39;key&#39;, &#39;num1&#39;, &#39;digit1&#39;, &#39;num2&#39; and
</span><span class="c1"></span>    <span class="c1">//  &#39;digit2&#39; arguments and &#39;param1&#39; and &#39;param2&#39; passed in
</span><span class="c1"></span>    <span class="nf">R</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">num1</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits1</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">num2</span> <span class="kt">float64</span><span class="p">,</span> <span class="nx">digits2</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">param1</span><span class="p">,</span> <span class="nx">param2</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// VerifyTranslations checks to ensures that no plural rules have been
</span><span class="c1"></span>    <span class="c1">// missed within the translations.
</span><span class="c1"></span>    <span class="nf">VerifyTranslations</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>关于该接口需要需要如下几点说明</p>
<ul>
<li>内嵌了 locales.Translator 接口；</li>
<li>几类复数规则：cardinal plural（基数复数规则，即单数和复数两种）；ordinal plural（序数复数规则，如 1st, 2nd, 3rd…）；ordinal plural （范围复数规则，如 0-1）。对中文来说，这里大部分不需要。</li>
<li>几个 Add 方法，和上面几类规则对应；一个 key 和 一个带站位符的 text；</li>
<li>单字符的几个方法和 Add 几个方法的对应关系：T -&gt; Add；C -&gt; AddCardinal；O -&gt; AddOrdinal；R -&gt; AddRange ；表示用具体的值替换 key 表示的文本 text 中的占位符。</li>
<li>以上方法参数中，num 表示占位符处的值，但对于有复数形式的语言，这个值必须符合复数语言的规范，否则会报错；digits 表示 num 值的有效数字（或者说小数位数）；</li>
<li>VerifyTranslations 确保翻译库中没有缺少对应的语言规则；</li>
</ul>
<p><strong>UniversalTranslator 结构体</strong></p>
<p>它用于保存所有语言环境和翻译数据。该结构体方法不多，我们关注几个核心的。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">fallback</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">Translator</span><span class="p">,</span> <span class="nx">supportedLocales</span> <span class="o">...</span><span class="nx">locales</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="o">*</span><span class="nx">UniversalTranslator</span>
</code></pre></div><p>New 返回一个 UniversalTranslator 实例，该实例具有后备语言环境（fallback）和应支持的语言环境（supportedLocales）。可以看到，New 函数接收的参数是 locales.Translator 类型，因此我们肯定需要用到 locales 包。</p>
<p>得到 UniversalTranslator 实例后，需要获得 universal-translator 包中的 Translator 接口实例，这就用到了下面几个方法。</p>
<p>1）GetTranslator</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">UniversalTranslator</span><span class="p">)</span> <span class="nf">GetTranslator</span><span class="p">(</span><span class="nx">locale</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">trans</span> <span class="nx">Translator</span><span class="p">,</span> <span class="nx">found</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></div><p>返回给定语言环境的指定翻译器，如果未找到，则返回后备语言环境的翻译器（即 New 中的 fallback）。</p>
<p>2）GetFallback</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">UniversalTranslator</span><span class="p">)</span> <span class="nf">GetFallback</span><span class="p">()</span> <span class="nx">Translator</span>
</code></pre></div><p>直接返回后备语言环境的翻译器。</p>
<p>3）FindTranslator</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">UniversalTranslator</span><span class="p">)</span> <span class="nf">FindTranslator</span><span class="p">(</span><span class="nx">locales</span> <span class="o">...</span><span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">trans</span> <span class="nx">Translator</span><span class="p">,</span> <span class="nx">found</span> <span class="kt">bool</span><span class="p">)</span>
</code></pre></div><p>尝试根据语言环境数组查找翻译器，并返回它可以找到的第一个翻译器，否则返回后备翻译器。</p>
<p>总结来说，New 函数加上这三个方法，相当于是 locales.Translator 到 ut.Translator 的转换。</p>
<p><strong>示例</strong></p>
<p>通过一个实际的例子来学习下这两个包的使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;fmt&#34;</span>

	<span class="s">&#34;github.com/go-playground/locales&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/en&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/zh&#34;</span>
	<span class="s">&#34;github.com/go-playground/locales/zh_Hant_TW&#34;</span>
	<span class="nx">ut</span> <span class="s">&#34;github.com/go-playground/universal-translator&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">universalTraslator</span> <span class="o">*</span><span class="nx">ut</span><span class="p">.</span><span class="nx">UniversalTranslator</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">acceptLanguage</span> <span class="o">:=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;language&#34;</span><span class="p">,</span> <span class="s">&#34;zh&#34;</span><span class="p">,</span> <span class="s">&#34;语言&#34;</span><span class="p">)</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>

	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">en</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">universalTraslator</span> <span class="p">=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">zh</span><span class="p">.</span><span class="nf">New</span><span class="p">(),</span> <span class="nx">zh_Hant_TW</span><span class="p">.</span><span class="nf">New</span><span class="p">())</span>

	<span class="nx">translator</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">universalTraslator</span><span class="p">.</span><span class="nf">GetTranslator</span><span class="p">(</span><span class="o">*</span><span class="nx">acceptLanguage</span><span class="p">)</span>

	<span class="k">switch</span> <span class="o">*</span><span class="nx">acceptLanguage</span> <span class="p">{</span>
	<span class="k">case</span> <span class="s">&#34;zh&#34;</span><span class="p">:</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;welcome&#34;</span><span class="p">,</span> <span class="s">&#34;欢迎 {0} 来到 studygolang.com！&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddCardinal</span><span class="p">(</span><span class="s">&#34;days&#34;</span><span class="p">,</span> <span class="s">&#34;你只剩 {0} 天时间可以注册&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddOrdinal</span><span class="p">(</span><span class="s">&#34;day-of-month&#34;</span><span class="p">,</span> <span class="s">&#34;第{0}天&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddRange</span><span class="p">(</span><span class="s">&#34;between&#34;</span><span class="p">,</span> <span class="s">&#34;距离 {0}-{1} 天&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="k">case</span> <span class="s">&#34;en&#34;</span><span class="p">:</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="s">&#34;welcome&#34;</span><span class="p">,</span> <span class="s">&#34;Welcome {0} to studygolang.com.&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddCardinal</span><span class="p">(</span><span class="s">&#34;days&#34;</span><span class="p">,</span> <span class="s">&#34;You have {0} day left to register&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOne</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddOrdinal</span><span class="p">(</span><span class="s">&#34;day-of-month&#34;</span><span class="p">,</span> <span class="s">&#34;{0}st&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOne</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
		<span class="nx">translator</span><span class="p">.</span><span class="nf">AddRange</span><span class="p">(</span><span class="s">&#34;between&#34;</span><span class="p">,</span> <span class="s">&#34;It&#39;s {0}-{1} days away&#34;</span><span class="p">,</span> <span class="nx">locales</span><span class="p">.</span><span class="nx">PluralRuleOther</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">T</span><span class="p">(</span><span class="s">&#34;welcome&#34;</span><span class="p">,</span> <span class="s">&#34;polaris&#34;</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">C</span><span class="p">(</span><span class="s">&#34;days&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">O</span><span class="p">(</span><span class="s">&#34;day-of-month&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">translator</span><span class="p">.</span><span class="nf">R</span><span class="p">(</span><span class="s">&#34;between&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="nx">translator</span><span class="p">.</span><span class="nf">FmtNumber</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><p>主要通过这个例子说明相关函数的使用。</p>
<ul>
<li>根据 acceptLanguage 的不同值，设置不同的语言文案；</li>
<li>对于中文来说，没有复数，因此 AddXX 三个方法的第二个参数都是 locales.PluralRuleOther，表示该语言环境没有复数形式；</li>
<li>英文环境下，PluralRule 规则不能乱填，根据实际情况来；</li>
<li>最后在实际填充值时，num 表示占位符要填入的值，digits 表示 num 这个值最终要保留几位小数；</li>
<li>FmtNumber 方法的参数需要和前面的 num 和 digits 对应上，第一个参数是 num 的值，第二个是 digits 的值；</li>
</ul>
<h3 id="validator-怎么和以上两个库集成提供-i18n">Validator 怎么和以上两个库集成提供 i18n</h3>
<p>Validator 库提供了相应的子库，对以上两个库进行了封装。比如中文的库：github.com/go-playground/validator/translations/zh ，这些子库提供了一个 RegisterDefaultTranslations ，为所有内置标签的验证器注册一组默认翻译。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span><span class="p">,</span> <span class="nx">trans</span> <span class="nx">ut</span><span class="p">.</span><span class="nx">Translator</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div><p>具体怎么做？还是看最开始的例子，其他不变，main 函数改为如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>

	<span class="nx">user</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>  <span class="nx">name</span><span class="p">,</span>
		<span class="nx">Age</span><span class="p">:</span>   <span class="nx">age</span><span class="p">,</span>
		<span class="nx">Email</span><span class="p">:</span> <span class="nx">email</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">validate</span> <span class="o">:=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">en</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">uniTrans</span> <span class="o">:=</span> <span class="nx">ut</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">zh</span><span class="p">.</span><span class="nf">New</span><span class="p">(),</span> <span class="nx">zh_Hant_TW</span><span class="p">.</span><span class="nf">New</span><span class="p">())</span>
	<span class="nx">translator</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">uniTrans</span><span class="p">.</span><span class="nf">GetTranslator</span><span class="p">(</span><span class="s">&#34;zh&#34;</span><span class="p">)</span>
	<span class="nx">zh_translate</span><span class="p">.</span><span class="nf">RegisterDefaultTranslations</span><span class="p">(</span><span class="nx">validate</span><span class="p">,</span> <span class="nx">translator</span><span class="p">)</span>

	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">errs</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="nx">validator</span><span class="p">.</span><span class="nx">ValidationErrors</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">errs</span> <span class="p">{</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Translate</span><span class="p">(</span><span class="nx">translator</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>注册一个默认的中文翻译器，在校验出错后，对错误进行翻译。不输入任何参数运行程序，输出：</p>
<blockquote>
<p>Name为必填字段
Age必须大于或等于1
Email为必填字段</p>
</blockquote>
<p>大功告成。</p>
<h2 id="将-validator-集成到-echo-中">将 Validator 集成到 Echo 中</h2>
<p>首先，需要定义一个类型，实现 Echo 的接口 Validator ：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">CustomValidator</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">once</span>     <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">validate</span> <span class="o">*</span><span class="nx">validator</span><span class="p">.</span><span class="nx">Validate</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CustomValidator</span><span class="p">)</span> <span class="nf">Validate</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nf">lazyInit</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">validate</span><span class="p">.</span><span class="nf">Struct</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">CustomValidator</span><span class="p">)</span> <span class="nf">lazyInit</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">validate</span> <span class="p">=</span> <span class="nx">validator</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>因为 validator.Validate 实例化做了不少事情，这里将实例化推迟到使用时。简单几行代码就实现了一个自定义的 Validator。</p>
<p>接下来和 Echo 集成起来就很容易了。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">e</span><span class="p">.</span><span class="nx">Validator</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">CustomValidator</span><span class="p">{}</span>
</code></pre></div><p>之后就可以在需要进行表单校验的地方通过 <code>ctx.Validate()</code> 进行校验。</p>
<p>自此我们完成了 Validator 集成到 Echo 的功能。</p>
<p>还剩最后一块内容，那就是校验错误信息的国际化显示。国际化相关的内容，上面有了较详细的介绍，Validator 集成到 Echo 后如何国际化我们在后面实战篇再讲。</p>
<p>完整代码见：<a href="https://github.com/polaris1119/go-echo-example/blob/master/pkg/validator/validator.go">https://github.com/polaris1119/go-echo-example/blob/master/pkg/validator/validator.go</a>。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇1：自定义 Binder，处理 Request 数据绑定</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom01-binder/</link>
			<pubDate>Fri, 21 Feb 2020 19:26:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom01-binder/</guid>
			<description>Web 开发，数据获取和校验是两个最基本的功能。在数据获取时，我们可以通过标准库的 *http.Request 提供的相关功能进行获取。然而这样效率是很低，重复工作较多，而且考虑到数据自动校验，我们更应该做到自动绑定。 在讲述 Echo 的 Binder 前，先探讨一下客户端数据一般通过什么方式发送给服务端的。 客户端如何传递数据给服务端？ 这个问题其实对大部分人来说太简单了，然而，很多客户端的人却不清楚。工作中，我接触</description>
			<content type="html"><![CDATA[<p>Web 开发，数据获取和校验是两个最基本的功能。在数据获取时，我们可以通过标准库的 <code>*http.Request</code> 提供的相关功能进行获取。然而这样效率是很低，重复工作较多，而且考虑到数据自动校验，我们更应该做到自动绑定。</p>
<p>在讲述 Echo 的 Binder 前，先探讨一下客户端数据一般通过什么方式发送给服务端的。</p>
<h2 id="客户端如何传递数据给服务端">客户端如何传递数据给服务端？</h2>
<p>这个问题其实对大部分人来说太简单了，然而，很多客户端的人却不清楚。工作中，我接触过不少客户端的人，对于数据怎么传递给服务端，他们是没有概念的，找到一个能用的方法发送给服务端就行了。比如，一个普通的数据通过 HTTP Header 来发送；分不清自己发送的数据是 key=json 形式还是 Body 中直接放 JSON，也就是不清楚 Content-Type 相关的含义。</p>
<p>为了让大家更容易掌握相关知识点，我通过问题的形式讲解。</p>
<h3 id="问题-1get-和-post-参数如何获取">问题 1：Get 和 Post 参数如何获取</h3>
<p>讲再多都不如一个实际的程序演示来的清楚明白。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">http</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">req</span><span class="p">.</span><span class="nf">ParseMultipartForm</span><span class="p">(</span><span class="mi">32</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span>

		<span class="nx">data</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span>
			<span class="s">&#34;form&#34;</span><span class="p">:</span>      <span class="nx">req</span><span class="p">.</span><span class="nx">Form</span><span class="p">,</span>
			<span class="s">&#34;post_form&#34;</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">PostForm</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Fprintln</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>这是一个简单的 Server，启动它：</p>
<blockquote>
<p>go run main.go</p>
</blockquote>
<p>接着，我们通过 <a href="https://github.com/jakubroztocil/httpie" target="_blank" rel="noopener">httpie</a>
 来模拟请求，看不同的输出。（关于 httpie 的使用可以看官方文档）</p>
<p>1）<code>http -v :2020 name==polaris</code></p>
<p>命令的输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">GET /?name<span class="o">=</span>polaris HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:2020
User-Agent: HTTPie/2.0.0



HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">46</span>
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 07:27:56 GMT

map<span class="o">[</span>form:map<span class="o">[</span>name:<span class="o">[</span>polaris<span class="o">]]</span> post_form:map<span class="o">[]]</span>
</code></pre></div><p>作为一个服务端工程师，很有必要了解 HTTP 请求报文和响应报文。</p>
<p>从输出可以看出，GET 参数放在了 req.Form 中，实际开发中，一般这样获取 GET 的参数：<code>req.FormValue(&quot;name&quot;)</code>。因为默认情况下，参数并没有解析，也就是 Form 中没有，这也就是我们上面代码中 <code>req.ParseMultipartForm(32 &lt;&lt; 20)</code> 这样代码的作用。而 req.FormValue 会判断有没有解析。</p>
<p>2）<code>http -v --form :2020 name==polaris name=xuxinhua sex=male</code></p>
<p>直接看命令的输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">POST /?name<span class="o">=</span>polaris HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">22</span>
Content-Type: application/x-www-form-urlencoded<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="nv">name</span><span class="o">=</span>xuxinhua<span class="p">&amp;</span><span class="nv">sex</span><span class="o">=</span>male

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">92</span>
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 07:35:56 GMT

map<span class="o">[</span>form:map<span class="o">[</span>name:<span class="o">[</span>xuxinhua polaris<span class="o">]</span> sex:<span class="o">[</span>male<span class="o">]]</span> post_form:map<span class="o">[</span>name:<span class="o">[</span>xuxinhua<span class="o">]</span> sex:<span class="o">[</span>male<span class="o">]]]</span>
</code></pre></div><p>这里发起了一个 POST 请求。需要关注以下几点：</p>
<ul>
<li>请求中有参数：name=polaris</li>
<li>请求头：Content-Type: application/x-www-form-urlencoded; charset=utf-8</li>
<li>请求体（body）：name=xuxinhua&amp;sex=male</li>
</ul>
<p>因为 name 在 url 和 body 中分别有一个值：polaris 和 xuxinhua，因此，form 中 name 包含了两个值。从响应中结果可以看出，Form 同时包含了 url 参数和 body 的 key=value；而 PostForm 只包含 body 中的 key=value。（PUT 和 POST 是一样的效果）</p>
<p>因此，req.FormValue() 可以获取所有请求参数；而 req.PostFormValue() 获取 POST 之类的参数，如果同一个参数有多个值，只会取第一个，而 POST 参数优先级高于 URL 参数。</p>
<blockquote>
<p>小问题：上面例子中，如果想要获取 name=polaris，而不是 name=xuxinhua，怎么做？</p>
</blockquote>
<h3 id="问题-2客户端传递-json-怎么办">问题 2：客户端传递 JSON 怎么办？</h3>
<p>继续基于上面的例子，执行如下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020 <span class="nv">name</span><span class="o">=</span>xuxinhua <span class="nv">sex</span><span class="o">=</span>male
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">POST / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">35</span>
Content-Type: application/json
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">32</span>
Content-Type: text/plain<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 07:58:05 GMT

map<span class="o">[</span>form:map<span class="o">[]</span> post_form:map<span class="o">[]]</span>
</code></pre></div><p>这次请求头的 Content-Type 值是：application/json，表明客户端将参数通过 JSON 格式传递，具体参数放在了 Body 中：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;xuxinhua&#34;</span><span class="p">,</span>
    <span class="nt">&#34;sex&#34;</span><span class="p">:</span> <span class="s2">&#34;male&#34;</span>
<span class="p">}</span>
</code></pre></div><p>从服务端的输出可以看到，Form 和 PostForm 都没有获取到这些参数，怎么办？答案是从 Body 中读取。如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">reqBody</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
  <span class="nx">http</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">(),</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusInternalServerError</span><span class="p">)</span>
  <span class="k">return</span>
<span class="p">}</span>
<span class="nx">data</span><span class="p">[</span><span class="s">&#34;json_data&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">reqBody</span><span class="p">)</span>
</code></pre></div><p>最后简单说下 Content-Type 是 multipart/form-data 的情况。</p>
<p>当需要进行文件上传时，要求 Content-Type 设置为 multipart/form-data，对应的页面表单就是：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="p">&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">&#34;/&#34;</span> <span class="na">method</span><span class="o">=</span><span class="s">&#34;POST&#34;</span> <span class="na">enctype</span><span class="o">=</span><span class="s">&#34;multipart/form-data&#34;</span><span class="p">&gt;&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</code></pre></div><p>这样的表单才能进行文件上传。对文件上传的处理，Go 中对应的是 req.MultipartForm 和 req.FormFile()。</p>
<p>当然，除此之外，Content-Type 还有其他值（一般叫做 MIME），但常用的已经介绍了（相较而言，GET 只有一种 Content-Type: application/x-www-form-urlencoding）。</p>
<h2 id="echo-的-binder-是如何做的">Echo 的 Binder 是如何做的？</h2>
<p>上面介绍的都是标准库 net/http 的相关 API，回到 Echo，有如下对应关系：</p>
<ul>
<li>Conetxt#QueryParam() 和  QueryParams() 方法获取 URL 参数；</li>
<li>Context#FormValue() 和 FormParams() 方法获取 Form 参数，对应标准库的 PostForm；</li>
<li>Context#FormFile() 和 MultipartForm() 方法处理文件上传；</li>
</ul>
<p>除此之外，因为 Echo 路由支持路径参数（Path Param），对应的获取方法：Context#Param() 和 ParamNames()。</p>
<p>对于 Binder，Echo 默认提供了一个实现：echo.DefaultBinder，通常情况下，这个默认实现就能够满足要求。我们先看看它的实现。</p>
<h3 id="defaultbinder-的实现">DefaultBinder 的实现</h3>
<p>首先，Echo 定义了一个接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Binder</span> <span class="kd">interface</span><span class="p">{</span>
  <span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><p>任何 Binder 必须实现该接口，也就是提供 Bind 方法。一起看看 DefaultBinder 的 Bind 方法实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">DefaultBinder</span><span class="p">)</span> <span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">c</span> <span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Request</span><span class="p">()</span>

	<span class="nx">names</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ParamNames</span><span class="p">()</span>
	<span class="nx">values</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">ParamValues</span><span class="p">()</span>
	<span class="nx">params</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">name</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">names</span> <span class="p">{</span>
		<span class="nx">params</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">values</span><span class="p">[</span><span class="nx">i</span><span class="p">]}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">bindData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">params</span><span class="p">,</span> <span class="s">&#34;param&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">bindData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">QueryParams</span><span class="p">(),</span> <span class="s">&#34;query&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">ContentLength</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">ctype</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">HeaderContentType</span><span class="p">)</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEApplicationJSON</span><span class="p">):</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">ute</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">json</span><span class="p">.</span><span class="nx">UnmarshalTypeError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Unmarshal type error: expected=%v, got=%v, field=%v, offset=%v&#34;</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Field</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Offset</span><span class="p">)).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">se</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">json</span><span class="p">.</span><span class="nx">SyntaxError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Syntax error: offset=%v, error=%v&#34;</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nx">Offset</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nf">Error</span><span class="p">())).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEApplicationXML</span><span class="p">),</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMETextXML</span><span class="p">):</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">xml</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">ute</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">xml</span><span class="p">.</span><span class="nx">UnsupportedTypeError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Unsupported type error: type=%v, error=%v&#34;</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nx">Type</span><span class="p">,</span> <span class="nx">ute</span><span class="p">.</span><span class="nf">Error</span><span class="p">())).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">se</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">err</span><span class="p">.(</span><span class="o">*</span><span class="nx">xml</span><span class="p">.</span><span class="nx">SyntaxError</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Syntax error: line=%v, error=%v&#34;</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nx">Line</span><span class="p">,</span> <span class="nx">se</span><span class="p">.</span><span class="nf">Error</span><span class="p">())).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEApplicationForm</span><span class="p">),</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">MIMEMultipartForm</span><span class="p">):</span>
		<span class="nx">params</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">FormParams</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">bindData</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">params</span><span class="p">,</span> <span class="s">&#34;form&#34;</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">ErrUnsupportedMediaType</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div><p>一起分析下这个方法：</p>
<ul>
<li>DefaultBinder 的 bindData 方法进行实际的数据绑定，主要通过反射进行处理，要求被绑定的类型是 map[string]interface{} 或 struct（实际是时间它们的指针），有兴趣的可以查看它的源码；<a href="https://github.com/labstack/echo/blob/master/bind.go#L86">https://github.com/labstack/echo/blob/master/bind.go#L86</a></li>
<li>通过给 Struct 的字段加上不同的 Tag 来接收不同类型的值：
<ul>
<li>param tag 对应路径参数；</li>
<li>query tag 对应 URL 参数；</li>
<li>json tag 对应 application/json 方式参数；</li>
<li>form tag 对应 POST 表单数据；</li>
<li>xml tag 对应 application/xml 或 text/xml；</li>
</ul>
</li>
<li>从代码的顺序可以看出，当同一个字段在多种方式存在值时，优先级顺序：param &lt; query &lt; 其他；</li>
</ul>
<p>讲解完了，来一个实际的例子加深理解。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`query:&#34;name&#34; form:&#34;name&#34; json:&#34;name&#34;`</span>
	<span class="nx">Sex</span>  <span class="kt">string</span> <span class="s">`query:&#34;sex&#34; form:&#34;sex&#34; json:&#34;sex&#34;`</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="nx">e</span><span class="p">.</span><span class="nf">Any</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">user</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">User</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span>
	<span class="p">})</span>

	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>同样使用 httpie 来进行测试。</p>
<p><strong>1）GET 请求</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020 <span class="nv">name</span><span class="o">==</span>xuxinhua <span class="nv">sex</span><span class="o">==</span>male
</code></pre></div><p>输出：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">GET /?name<span class="o">=</span>xuxinhua<span class="p">&amp;</span><span class="nv">sex</span><span class="o">=</span>male HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:2020
User-Agent: HTTPie/2.0.0



HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">33</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:27:25 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>
</code></pre></div><p>能够正确绑定值。</p>
<p><strong>2）POST 请求</strong></p>
<p>特意加上 URL 参数混淆下，看看结果</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ http -v --form :2020 <span class="nv">name</span><span class="o">==</span>polaris <span class="nv">name</span><span class="o">=</span>xuxinhua <span class="nv">sex</span><span class="o">=</span>male
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">POST /?name<span class="o">=</span>polaris HTTP/1.1
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">22</span>
Content-Type: application/x-www-form-urlencoded<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>utf-8
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="nv">name</span><span class="o">=</span>xuxinhua<span class="p">&amp;</span><span class="nv">sex</span><span class="o">=</span>male

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">33</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:46:09 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>
</code></pre></div><p>从结果 name 是 xuxinhua 可以看出，URL 参数的优先级较低。</p>
<p><strong>3）请求参数是 JSON</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020  <span class="nv">name</span><span class="o">=</span>xuxinhua <span class="nv">sex</span><span class="o">=</span>male
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">POST / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">35</span>
Content-Type: application/json
Host: localhost:2020
User-Agent: HTTPie/2.0.0

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">33</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:48:48 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;xuxinhua&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;male&#34;</span>
<span class="o">}</span>
</code></pre></div><p>一切正常。</p>
<p><strong>4）试试 XML ？</strong></p>
<p>目前 XML 用的还是比较少，基本是 JSON。所以，我们的例子代码默认并没有支持 XML。</p>
<p>我们先创建一个 XML 文件，作为输入：</p>
<div class="highlight"><pre class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34;?&gt;</span>
<span class="nt">&lt;user&gt;</span>
	<span class="nt">&lt;name&gt;</span>xuxinhua<span class="nt">&lt;/name&gt;</span>
	<span class="nt">&lt;sex&gt;</span>male<span class="nt">&lt;/sex&gt;</span>
<span class="nt">&lt;/user&gt;</span>
</code></pre></div><p>接着执行如下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ http -v :2020 @user.xml
</code></pre></div><p>输出如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">POST / HTTP/1.1
Accept: application/json, */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Content-Length: <span class="m">78</span>
Content-Type: application/xml
Host: localhost:2020
User-Agent: HTTPie/2.0.0

&lt;?xml <span class="nv">version</span><span class="o">=</span><span class="s2">&#34;1.0&#34;</span>?&gt;

&lt;user&gt;
	&lt;name&gt;xuxinhua&lt;/name&gt;
	&lt;sex&gt;male&lt;/sex&gt;
&lt;/user&gt;

HTTP/1.1 <span class="m">200</span> OK
Content-Length: <span class="m">21</span>
Content-Type: application/json<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Date: Fri, <span class="m">21</span> Feb <span class="m">2020</span> 09:55:54 GMT

<span class="o">{</span>
    <span class="s2">&#34;name&#34;</span>: <span class="s2">&#34;&#34;</span>,
    <span class="s2">&#34;sex&#34;</span>: <span class="s2">&#34;&#34;</span>
<span class="o">}</span>
</code></pre></div><p>一方面，请求的 Content-Type 是 application/xml，但响应却不对。原因是 User 结构中，我们没有为字段指定 xml 这个 tag，加上 tag 再试一下就会正确：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`query:&#34;name&#34; form:&#34;name&#34; json:&#34;name&#34; xml:&#34;name&#34;`</span>
	<span class="nx">Sex</span>  <span class="kt">string</span> <span class="s">`query:&#34;sex&#34; form:&#34;sex&#34; json:&#34;sex&#34; xml:&#34;sex&#34;`</span>
<span class="p">}</span>
</code></pre></div><p>实际中，需要设置什么 tag，你应该心里有数，没必要把所有支持的 tag 都设置上。</p>
<h2 id="自定义-binder">自定义 Binder</h2>
<p>Echo 默认提供的 Binder 已经满足了大部分的需求，那什么时候需要自定义 Binder 呢？</p>
<p>现在一般接口都是用 JSON 作为数据交换格式，假如你老板觉得 JSON 性能不够，希望换其他格式，比如 <a href="https://msgpack.org/" target="_blank" rel="noopener">msgpack</a>
 格式。这时候，echo 默认的 DefaultBinder 已经没法满足我们的需求了，这时候就需要自定义 Binder。类似的还有 protobuf 等。</p>
<h3 id="自定义-msgpackbinder">自定义 MsgpackBinder</h3>
<p>现在，我们就自己实现一个支持 msgpack 格式的 Binder。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MsgpackBinder</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">MsgpackBinder</span><span class="p">)</span> <span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 也支持默认 Binder 相关的绑定
</span><span class="c1"></span>	<span class="nx">db</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">echo</span><span class="p">.</span><span class="nx">DefaultBinder</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrUnsupportedMediaType</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">req</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">()</span>
	<span class="nx">ctype</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HeaderContentType</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">ctype</span><span class="p">,</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">MIMEApplicationMsgpack</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">msgpack</span><span class="p">.</span><span class="nf">NewDecoder</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">Body</span><span class="p">).</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">NewHTTPError</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()).</span><span class="nf">SetInternal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">ErrUnsupportedMediaType</span>
<span class="p">}</span>
</code></pre></div><p>我们的自定义 Binder 除了支持 msgpack 外，还支持默认 Binder 支持的绑定方式。所以，在 Bind 方法入口，先实例化了一个 DefaultBinder，用它进行绑定处理。只有它返回的 err 是 ErrUnsupportedMediaType 时，才进行我们自定义 Binder 的处理逻辑。关于 msgpack 的解析，使用了第三方库：github.com/vmihailenco/msgpack ，使用方式和 JSON 类似。</p>
<p>这样，自定义的 Binder 就完成了。接下来需要替换到 Echo 默认的 Binder：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

<span class="nx">e</span><span class="p">.</span><span class="nx">Binder</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">MsgpackBinder</span><span class="p">)</span>
</code></pre></div><p>即在得到 echo.Echo 的实例后，通过 e.Binder 来覆盖默认的 Binder。</p>
<h3 id="验证自定义的-binder">验证自定义的 Binder</h3>
<p>因为 msgpack 是二进制格式，不方便直接使用 httpie 进行验证。我们写一个简单的客户端工具进行验证。代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;io/ioutil&#34;</span>
	<span class="s">&#34;net/http&#34;</span>

	<span class="s">&#34;github.com/vmihailenco/msgpack&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
		<span class="nx">Name</span> <span class="kt">string</span>
		<span class="nx">Sex</span>  <span class="kt">string</span>
	<span class="p">}</span>

	<span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">msgpack</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;xuxinhua&#34;</span><span class="p">,</span> <span class="nx">Sex</span><span class="p">:</span> <span class="s">&#34;male&#34;</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultClient</span><span class="p">.</span><span class="nf">Post</span><span class="p">(</span><span class="s">&#34;http://localhost:2020/&#34;</span><span class="p">,</span> <span class="s">&#34;application/msgpack&#34;</span><span class="p">,</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewReader</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">defer</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

	<span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadAll</span><span class="p">(</span><span class="nx">resp</span><span class="p">.</span><span class="nx">Body</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s\n&#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>启动服务端，然后运行客户端。我本地试验，输出结果如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span><span class="nt">&#34;name&#34;</span><span class="p">:</span><span class="s2">&#34;xuxinhua&#34;</span><span class="p">,</span><span class="nt">&#34;sex&#34;</span><span class="p">:</span><span class="s2">&#34;male&#34;</span><span class="p">}</span>
</code></pre></div><p>表明我们的自定义 Binder 生效了。</p>
<blockquote>
<p>说明一下，跟标准库的 json 一样，没有 tag 时，msgpack 库能根据导出字段识别出对应关系。默认情况，msgpack 库使用 msgpack 这个 tag，同时可以通过 UseJSONTag 方法来退而求其次使用 json 这个 tag。当然，我们这里没有使用 tag，而是根据导出字段自动识别对应关系的。</p>
</blockquote>
<h2 id="小结">小结</h2>
<p>到这里，自定义 Binder 就介绍完了。内容比较简单，但是必须掌握，这是基础知识。另外，这里没有提到 cookie，标准库和 echo 都提供了相关的方法进行处理，但一般 cookie 不需要进行数据绑定，额外处理即可。</p>
<p>本文完整代码：<a href="https://github.com/polaris1119/go-echo-example/tree/master/cmd/binder">https://github.com/polaris1119/go-echo-example/tree/master/cmd/binder</a></p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——定制篇0：让 Echo 更强大、更好用</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/custom00-intro/</link>
			<pubDate>Fri, 21 Feb 2020 19:24:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/custom00-intro/</guid>
			<description>一个强大的框架，一定是可以定制的，或者说可以扩展，能够根据用户自己的需求进行改变、增强，甚至某些功能的替换。作为一个强大的框架，Echo 必然也是可以定制、可以扩展的。本篇起，我们一起探讨如何对 Echo 框架进行定制或扩展，打造成符合你个性需求的框架。 定制化主要包含如下一些方面： 自定义 Binder，用来处理 Request 数据绑定 自定义 Validator，用来处理输入验证 自定义 Lo</description>
			<content type="html"><![CDATA[<p>一个强大的框架，一定是可以定制的，或者说可以扩展，能够根据用户自己的需求进行改变、增强，甚至某些功能的替换。作为一个强大的框架，Echo 必然也是可以定制、可以扩展的。本篇起，我们一起探讨如何对 Echo 框架进行定制或扩展，打造成符合你个性需求的框架。</p>
<p>定制化主要包含如下一些方面：</p>
<ul>
<li>自定义 Binder，用来处理 Request 数据绑定</li>
<li>自定义 Validator，用来处理输入验证</li>
<li>自定义 Logger，用你喜欢的日志库</li>
<li>自定义 Renderer，增强或替换模板引擎</li>
<li>自定义 HTTP Error Handler，让 HTTP 错误处理更友好</li>
<li>自定义 Server 相关，替换或扩展默认的 Server</li>
</ul>
<p>关于扩展 Echo，主要通过中间件来实现，而这部分内容，我们已经在<a href="http://blog.studygolang.com/2019/12/echo-login-example/" target="_blank" rel="noopener">《基础篇：通过一个例子串联各特性》</a>
中讲解了，具体常见中间件的使用，会在实战篇讲解。</p>
<p>除此之外，Echo#Debug 可以决定是否进入调试模式，在开发阶段，建议设置为 true，生产环境改为 false。</p>
<p>在开篇我们看到，在启动 Echo 项目时，默认会显示一个 Startup Banner，我们可以通过 Echo#HideBanner 控制它不显示。</p>
]]></content>
		</item>
		
		<item>
			<title>欢迎加入 GoLand 2020.1 抢先体验计划</title>
			<link>https://polarisxu.studygolang.com/posts/devtool/goland/welcome-to-the-goland-2020-1-eap/</link>
			<pubDate>Tue, 24 Dec 2019 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/devtool/goland/welcome-to-the-goland-2020-1-eap/</guid>
			<description>GoLand 2020.1 抢先体验计划已经启动。对于此发行版，我们着重于易用性，性能以及减少浪费在样板代码和 IDE 中的冗余操作上的时间。我们还包括对 Go Modules 支持的升级，和其他更多功能。您可以在 2020.1 的路线图博客 文章中找到简短说明。
你可以通过 Toolbox App 获得它，也可以从网站上下载 ，也可以使用快照包（对于 Ubuntu）；或者直接在 GoLand 中通过自动更新的方式获取。Preferences / Settings | Appearance &amp;amp; Behavior | System Settings | Updates。
如果您想知道什么是抢先体验计划，这里有一个简短的解释：
 EAP 版本使您可以试用 Goland 仍在开发中的最新功能和增强功能。这些版本尚未经过全面测试，可能会不稳定，但是您可以在这里为我们提供帮助。通过将这些内部版本和功能用于实际项目和场景中来测试，您可以帮助我们完善它们。这样，当最终版本准备就绪时，它将为您更好地工作。
  EAP 使您可以首先试用所有最新功能; 自构建日期起 30 天内免费使用 EAP 版本。您可以将这段时间用作 GoLand 的扩展试用版； 我们会提供 EAP 版本，直到几乎可以发布稳定版本为止。对于即将推出的 2020.1 版本，EAP 期将大致持续到 3 月底； 在每个发布周期中，我们都会为他们提供免费的 1 年 GoLand 订阅和一件独家的 GoLand T 恤 ，以表彰他们中最活跃的评估人员。 此外，我们几乎每天都提供最新版本。因此，如果您不想等待正式的 EAP 版本公告，则只需下载这些夜间版本之一，即可通过 Toolbox App 获得。请注意，每晚构建的质量通常低于我们的标准，并且没有随附发行说明。与 EAP 版本一样，它们也将在发布后 30 天内过期；  因此，让我们看一下第一个 EAP 版本中包含的内容。
Go Modules 现在，您可以通过 go.mod 文件中的 Alt-Enter 来获取缺失的依赖项并删除未使用的依赖项。
Go 1.14 支持 Go 1.14 增加了对嵌入重叠接口的支持，我们也是如此！当您使用重叠的接口时，GoLand 不会将重复的方法报告为错误。
为什么将此功能添加到语言中？
主要好处是我们可以使用嵌入定义接口，而不需要手动定义。这是一个例子：
type Person interface { Name() string String() string } type Employee interface { Person Department() string String() string } 在 Go 1.14 之前，我们无法在 Employee 接口上添加 String() 方法，因为该方法已在 Person 接口上定义了。现在，我们可以使用接口嵌入定义它，如果 Person 接口有更新，我们自己更可控。
代码补全/完成增强 我们对样板代码说不！GoLand 为常见的错误处理模式添加了代码完成功能。现在，当您在函数中键入if 时，您可以选择 err！= nil {…} 以自动完成它。
为了更快地定义接口和结构，现在，当您键入type 关键字时，IDE 会为它们建议模板。当您输入 interface 或 struct 时，将显示相同的补全内容。
现在，根据格式设置规则的要求，Fill Fields 操作会在冒号后添加空格，并在复合文字中的语句末尾添加逗号。
现在，当您使用 map 时，完成键类型后，代码补全将光标移到右括号后面。
智能代码补全建议使用指向结构的指针。
最终，代码补全变得更加智能，现在在断言和 type-switch-case 中会首先建议兼容类型。
代码编辑增强 当编写多值返回函数的签名时，GoLang 2020.1 将在逗号后面的返回类型周围自动添加括号。
此外，当您在字符串中粘贴一些文本时，GoLand 会自动转义双引号。
Postfix 完成模板 .else Postfix 完成模板可以快速添加 if 语句，以检查表达式是否为假。
实时模板 我们添加了新的 consts, vars, types, 和 import 模板 。对于这些模板，默认情况下，GoLand 将在表达式周围添加括号。
fori 模板插入经典 for 循环的样板代码。
重构 现在，即使接口定义中省略了参数名称，Implement Methods（在 macOS 和 Windows/Linux 上为 Ctrl + I）也允许您指定参数名称。</description>
			<content type="html"><![CDATA[<p>GoLand 2020.1 抢先体验计划已经启动。对于此发行版，我们着重于易用性，性能以及减少浪费在样板代码和 IDE 中的冗余操作上的时间。我们还包括对 Go Modules 支持的升级，和其他更多功能。您可以在 2020.1 的<a href="https://blog.jetbrains.com/go/2019/12/24/whats-next-goland-2020-1-roadmap/" target="_blank" rel="noopener">路线图博客</a>
文章中找到简短说明。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/blog@2x.jpg"
    alt=""  />
</p>
</p>
<p>你可以通过 <a href="https://www.jetbrains.com/toolbox/app/?_ga=2.109771525.1651118980.1581665300-159533074.1581665300" target="_blank" rel="noopener">Toolbox App</a>
 获得它，也可以从<a href="https://www.jetbrains.com/go/nextversion/" target="_blank" rel="noopener">网站上下载</a>
，也可以使用快照包（对于 Ubuntu）；或者直接在 GoLand 中通过自动更新的方式获取。<em>Preferences / Settings | Appearance &amp; Behavior | System Settings | Updates</em>。</p>
<p>如果您想知道什么是抢先体验计划，这里有一个简短的解释：</p>
<blockquote>
<p>EAP 版本使您可以试用 Goland 仍在开发中的最新功能和增强功能。这些版本尚未经过全面测试，可能会不稳定，但是您可以在这里为我们提供帮助。通过将这些内部版本和功能用于实际项目和场景中来测试，您可以帮助我们完善它们。这样，当最终版本准备就绪时，它将为您更好地工作。</p>
</blockquote>
<ul>
<li>EAP 使您可以首先试用所有最新功能;</li>
<li>自构建日期起 30 天内免费使用 EAP 版本。您可以将这段时间用作 GoLand 的扩展试用版；</li>
<li>我们会提供 EAP 版本，直到几乎可以发布稳定版本为止。对于即将推出的 2020.1 版本，EAP 期将大致持续到 3 月底；</li>
<li>在每个发布周期中，我们都会为他们提供免费的 1 年 GoLand 订阅和一件独家的 <a href="https://twitter.com/GoLandIDE/status/1116361899308912645" target="_blank" rel="noopener">GoLand T 恤</a>
，以表彰他们中最活跃的评估人员。<p class="md__image">
  <img src="https://s2.ax1x.com/2020/02/15/1xBtL8.jpg"
    alt=""  />
</p>
</li>
<li>此外，我们几乎每天都提供最新版本。因此，如果您不想等待正式的 EAP 版本公告，则只需下载这些夜间版本之一，即可通过 Toolbox App 获得。请注意，每晚构建的质量通常低于我们的标准，并且没有随附发行说明。与 EAP 版本一样，它们也将在发布后 30 天内过期；</li>
</ul>
<p>因此，让我们看一下第一个 EAP 版本中包含的内容。</p>
<h2 id="go-modules">Go Modules</h2>
<p>现在，您可以通过 go.mod 文件中的 <strong>Alt-Enter</strong> 来获取缺失的依赖项并删除未使用的依赖项。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/go-mod-file-support.gif"
    alt=""  />
</p>
</p>
<h2 id="go-114-支持">Go 1.14 支持</h2>
<p>Go 1.14 增加了对嵌入重叠接口的支持，我们也是如此！当您使用重叠的接口时，GoLand 不会将重复的方法报告为错误。</p>
<p>为什么将此功能添加到语言中？</p>
<p>主要好处是我们可以使用嵌入定义接口，而不需要手动定义。这是一个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Person</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Name</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
 
<span class="kd">type</span> <span class="nx">Employee</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Person</span>
	<span class="nf">Department</span><span class="p">()</span> <span class="kt">string</span>
	<span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div><p>在 Go 1.14 之前，我们无法在 Employee 接口上添加 String() 方法，因为该方法已在 Person 接口上定义了。现在，我们可以使用接口嵌入定义它，如果 Person 接口有更新，我们自己更可控。</p>
<h2 id="代码补全完成增强">代码补全/完成增强</h2>
<p>我们对样板代码说不！GoLand 为常见的错误处理模式添加了代码完成功能。现在，当您在函数中键入<code>if </code>时，您可以选择 <code>err！= nil {…}</code> 以自动完成它。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/code-completion-handling-errors.gif"
    alt=""  />
</p>
</p>
<p>为了更快地定义接口和结构，现在，当您键入<code>type</code> 关键字时，IDE 会为它们建议模板。当您输入 <code>interface</code> 或 <code>struct</code> 时，将显示相同的补全内容。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/type-keyword-completion-struct-interfaces.gif"
    alt=""  />
</p>
</p>
<p>现在，根据格式设置规则的要求，<strong>Fill Fields</strong> 操作会在冒号后添加空格，并在复合文字中的语句末尾添加逗号。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/field-name-completion.gif"
    alt=""  />
</p>
</p>
<p>现在，当您使用 map 时，完成键类型后，代码补全将光标移到右括号后面。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/code-compltion-map.gif"
    alt=""  />
</p>
</p>
<p><strong>智能代码补全</strong>建议使用指向结构的指针。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/code-completion-for-pointer-to-struct-initializer.gif"
    alt=""  />
</p>
</p>
<p>最终，代码补全变得更加智能，现在在断言和 type-switch-case 中会首先建议兼容类型。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/type-assertion-completion.gif"
    alt=""  />
</p>
</p>
<h2 id="代码编辑增强">代码编辑增强</h2>
<p>当编写多值返回函数的签名时，GoLang 2020.1 将在逗号后面的返回类型周围自动添加括号。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/multi-value-return-function.gif"
    alt=""  />
</p>
</p>
<p>此外，当您在字符串中粘贴一些文本时，GoLand 会自动转义双引号。</p>
<h2 id="postfix-完成模板">Postfix 完成模板</h2>
<p><code>.else</code> Postfix 完成模板可以快速添加 <code>if</code> 语句，以检查表达式是否为假。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/else-postfix-completion.gif"
    alt=""  />
</p>
</p>
<h2 id="实时模板">实时模板</h2>
<p>我们添加了新的 <em>consts</em>, <em>vars</em>, <em>types</em>, 和 <em>import</em> 模板 。对于这些模板，默认情况下，GoLand 将在表达式周围添加括号。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/consts-vars-live-templates.gif"
    alt=""  />
</p>
</p>
<p>fori 模板插入经典 for 循环的样板代码。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/fori-live-template.gif"
    alt=""  />
</p>
</p>
<h2 id="重构">重构</h2>
<p>现在，即使接口定义中省略了参数名称，<em>Implement Methods</em>（在 macOS 和 Windows/Linux 上为 Ctrl + I）也允许您指定参数名称。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/implement-methods.gif"
    alt=""  />
</p>
</p>
<h2 id="性能">性能</h2>
<p>现在 <em>Navigate to implementations</em>（在 MacOS 上为 ⌥⌘B，在 Windows/Linux 上为 Ctrl + Alt + B）和 <em>Navigate to Declaration or Usages</em>（在 macOS 上为 ⌘B，在 Windows/Linux 上为 Ctrl + B）速度更快，因为它们首先在项目范围内寻找实现。另外，搜索结果在非项目元素之前显示项目元素，而不是按字母顺序对它们进行排序。</p>
<p>我们还限制了 dep 和 Go Modules 项目的参考搜索范围，以提高其搜索性能。</p>
<h2 id="jetbrains-mono-字体">JetBrains Mono 字体</h2>
<p>如果您想知道本博客文章中的屏幕截图和 GIF 使用的是哪种字体 — 我们在 JetBrains 上为开发人员创建了一种新的字体，称为 <a href="https://www.jetbrains.com/lp/mono/" target="_blank" rel="noopener">JetBrains Mono</a>
。现在默认情况下它在 GoLand 中可用，请打开 <em>Preferences / Settings | Editor | Font</em>，然后选择 JetBrains Mono 尝试一下。</p>
<p><p class="md__image">
  <img src="https://d3nmt5vlzunoa1.cloudfront.net/go/files/2020/02/jetbrains-mono-font.png"
    alt=""  />
</p>
</p>
<h2 id="拼写检查器">拼写检查器</h2>
<p>前一段时间，我们宣布了一个名为 Grazie 的插件。此插件可为您在 IDE 中编写的文本提供智能的拼写和语法检查，并且支持 15 种以上的语言，包括英语，德语，俄语，中文等。在此 EAP 版本和即将发布的 2020.1 版本中，默认情况下捆绑了 Grazie。要了解更多信息，请阅读此<a href="https://blog.jetbrains.com/idea/2019/11/meet-grazie-the-ultimate-spelling-grammar-and-style-checker-for-intellij-idea/" target="_blank" rel="noopener">博客文章</a>
。</p>
<h2 id="默认配色方案改回为亮色">默认配色方案改回为亮色</h2>
<p>许多用户要求我们为 Default 和 Darcula 配色方案中突出显示的语义代码增加更多种类，而我们在 2019.2 版本中进行了添加。一些用户很高兴，而其他用户则不满意，请我们还原更改。</p>
<p>因此，为了使所有人感到高兴，我们决定恢复默认配色方案，但使用了新名称 Classic Light。</p>
<p>要切换配色方案，请打开 <em>Preferences/Settings | Editor | Color Scheme</em> 选择。</p>
<h2 id="jbr8-支持终止">JBR8 支持终止</h2>
<p>从现在开始，我们将完全转向 JetBrains Runtime 11（JBR11），并且将不再分发带有 JetBrains Runtime 8（JBR8）的内部版本。请注意，IDE 和工具箱应用程序中的所有 GoLand 2020.1 更新都将随附 JBR11。</p>
<p>请记住，我们始终感谢您的反馈，因此请在留言区，Twitter 或 <a href="https://youtrack.jetbrains.com/issues/GO" target="_blank" rel="noopener">issue tracker</a>
 中与我们分享您的试用情况。</p>
<blockquote>
<p>由 Ekaterina Zharova 在 2020 年 2 月 6 日发布</p>
<p>原文：https://blog.jetbrains.com/go/2020/02/06/welcome-to-the-goland-2020-1-eap/</p>
</blockquote>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——基础篇3：通过一个例子串联各特性</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/basic03-example/</link>
			<pubDate>Tue, 03 Dec 2019 20:31:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/basic03-example/</guid>
			<description>通过前面的介绍，相信对 echo 有了一个初步的认识。本文我们通过一个简单的登录页面来串联 echo 的相关特性。因为该文主要关注各个特性，所以在目录结构和代码组织方面很随意。 本节最终效果 1）登录页面 2）登录失败 3）登录成功 main 函数骨架 使用 echo 框架，在程序入口处一般包含如下内容： func main() { // 创建 echo 实例 e := echo.New() // 配置日志 configLogger(e) // 注册静态文件路由 e.Static(&amp;#34;img&amp;#34;, &amp;#34;img&amp;#34;) e.File(&amp;#34;/favicon.ico&amp;#34;, &amp;#34;img/favicon.ico&amp;#34;) // 设置中间件 setMiddleware(e) // 注册路由 RegisterRoutes(e) // 启动服务 e.Logger.Fatal(e.Start(&amp;#34;:2019&amp;#34;)) } 日</description>
			<content type="html"><![CDATA[<p>通过前面的介绍，相信对 echo 有了一个初步的认识。本文我们通过一个简单的登录页面来串联 echo 的相关特性。因为该文主要关注各个特性，所以在目录结构和代码组织方面很随意。</p>
<h2 id="本节最终效果">本节最终效果</h2>
<p>1）登录页面</p>
<p><p class="md__image">
  <img src="../imgs/login.png"
    alt=""  />
</p>
</p>
<p>2）登录失败</p>
<p><p class="md__image">
  <img src="../imgs/login-fail.png"
    alt=""  />
</p>
</p>
<p>3）登录成功</p>
<p><p class="md__image">
  <img src="../imgs/login-success.png"
    alt=""  />
</p>
</p>
<h2 id="main-函数骨架">main 函数骨架</h2>
<p>使用 echo 框架，在程序入口处一般包含如下内容：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// 创建 echo 实例
</span><span class="c1"></span>	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>

	<span class="c1">// 配置日志
</span><span class="c1"></span>	<span class="nf">configLogger</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>

	<span class="c1">// 注册静态文件路由
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nf">Static</span><span class="p">(</span><span class="s">&#34;img&#34;</span><span class="p">,</span> <span class="s">&#34;img&#34;</span><span class="p">)</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">File</span><span class="p">(</span><span class="s">&#34;/favicon.ico&#34;</span><span class="p">,</span> <span class="s">&#34;img/favicon.ico&#34;</span><span class="p">)</span>

	<span class="c1">// 设置中间件
</span><span class="c1"></span>	<span class="nf">setMiddleware</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>

	<span class="c1">// 注册路由
</span><span class="c1"></span>	<span class="nf">RegisterRoutes</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>

	<span class="c1">// 启动服务
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2019&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><h2 id="日志">日志</h2>
<p>echo 中定义了一个接口：<a href="https://pkg.go.dev/github.com/labstack/echo?tab=doc#Logger" target="_blank" rel="noopener">Logger</a>
，而 <a href="https://pkg.go.dev/github.com/labstack/echo?tab=doc#Echo" target="_blank" rel="noopener">Echo 结构体</a>
有一个该接口的字段，这也就是 main 函数最后一句：<code>e.Logger.Fatal</code> 可以这么用的原因。框架中该接口的具体实现使用的是 <code>github.com/labstack/gommon/log</code>，如果需要，我们可以采用自己的实现，替换框架默认的。</p>
<p>默认情况下，日志输出到终端，而且 Level 级别是 ERROR，我们可以方便的通过 Logger 接口提供的方法进行修改：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">configLogger</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">echo</span><span class="p">.</span><span class="nx">Echo</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 定义日志级别
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetLevel</span><span class="p">(</span><span class="nx">log</span><span class="p">.</span><span class="nx">INFO</span><span class="p">)</span>
	<span class="c1">// 记录业务日志
</span><span class="c1"></span>	<span class="nx">echoLog</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;log/echo.log&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_APPEND</span><span class="p">,</span> <span class="mo">0644</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 同时输出到文件和终端
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">SetOutput</span><span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nf">MultiWriter</span><span class="p">(</span><span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span><span class="p">,</span> <span class="nx">echoLog</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>为了方便，开发中我将日志同时输出到了终端和文件中。</p>
<h2 id="中间件">中间件</h2>
<p>几乎所有的 Web 框架都支持中间件。其实这里的中间件跟传统的中间件不是一回事，这里的中间件其实是一种装饰模式。闲言少叙，我们看看 Echo 的中间件。</p>
<p>以 Recover 中间件为例讲解。</p>
<h3 id="中间件标准签名">中间件标准签名</h3>
<p>通过 <code>Echo.Use</code> 方法知晓，中间件是 MiddlewareFunc 类型，它的定义如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MiddlewareFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span>
</code></pre></div><p>也就是说，一个中间件应该是 MiddlewareFunc 类型。所以，一个函数，只要返回 MiddlewareFunc 类型就是一个 Echo 中间件。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Recover</span><span class="p">()</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">MiddlewareFunc</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h3 id="支持配置的中间件">支持配置的中间件</h3>
<p>Echo 的中间件通常都支持以下功能：</p>
<ul>
<li>通过配置修改中间件的行为</li>
<li>可以选择是否跳过该中间件</li>
</ul>
<p>一般做法就是：</p>
<ul>
<li>定义一个类型，如：RecoverConfig，用于配置 Recover 中间件的行为；</li>
<li>给上述类型的一个默认实例：DefaultRecoverConfig；</li>
<li>定义一个支持传递配置的函数，返回中间件类型，如：RecoverWithConfig；</li>
<li>定义一个不带参数的函数，返回中间件类型，内部调用带参数的中间件函数，参数用默认实例，如：Recover，它的实现是直接调用 <code>RecoverWithConfig(DefaultRecoverConfig)</code>；</li>
</ul>
<p>我们的例子代码中就通过配置修改了中间件行为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// access log 输出到文件中
</span><span class="c1"></span>	<span class="nx">accessLog</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">OpenFile</span><span class="p">(</span><span class="s">&#34;log/access.log&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_APPEND</span><span class="p">,</span> <span class="mo">0644</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 同时输出到终端和文件
</span><span class="c1"></span>	<span class="nx">middleware</span><span class="p">.</span><span class="nx">DefaultLoggerConfig</span><span class="p">.</span><span class="nx">Output</span> <span class="p">=</span> <span class="nx">accessLog</span>
	<span class="nx">e</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">middleware</span><span class="p">.</span><span class="nf">Logger</span><span class="p">())</span>
</code></pre></div><h3 id="自己定义一个简单中间件">自己定义一个简单中间件</h3>
<p>很多时候，我们业务的中间件，不需要那么灵活，没必要通过配置来控制行为，这时候可以像例子中的 AutoLogin 一样：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// AutoLogin 如果上次记住了，则自动登录
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AutoLogin</span><span class="p">(</span><span class="nx">next</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">HandlerFunc</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="nx">cookie</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Cookie</span><span class="p">(</span><span class="s">&#34;username&#34;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cookie</span><span class="p">.</span><span class="nx">Value</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
			<span class="c1">// 实际项目这里可以通过 username 读库获取用户信息
</span><span class="c1"></span>			<span class="nx">user</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span><span class="nx">Username</span><span class="p">:</span> <span class="nx">cookie</span><span class="p">.</span><span class="nx">Value</span><span class="p">}</span>

			<span class="c1">// 放入 context 中
</span><span class="c1"></span>			<span class="nx">ctx</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;user&#34;</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nf">next</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>接收一个 echo.HandlerFunc 类型，同时返回一个 echo.HandlerFunc 类型，这就是 MiddlewareFunc 的定义，因此 AutoLogin 可以直接当中间件使用。<strong>注意：在使用是这里和上面 Recover 的区别，Recover 是返回一个中间件，而 AutoLogin 本身是一个中间件，因此使用时分别是：Use(Recover()) 和 Use(AutoLogin)</strong>。</p>
<p>在具体实现中间件时，可以在调用 <code>next()</code> 函数前后增加该中间件需要的功能。</p>
<h2 id="cookie-和-session">Cookie 和 Session</h2>
<p>关于 Cookie、Session 和 Token 的介绍，可以通过 <a href="https://cloud.tencent.com/developer/article/1542456" target="_blank" rel="noopener">《一文带您彻底理解Cookie、Session、Token》</a>
 了解下。</p>
<p>在 Go 中，Session 相关功能最常用的包是 <code>github.com/gorilla/sessions</code>。Echo 提供了 Session 中间件，使用的就是该包。这里我们主要讲解一下登录需要用到的功能。</p>
<h3 id="登录成功种-cookie">登录成功种 Cookie</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 用标准库种 cookie
</span><span class="c1"></span><span class="nx">cookie</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Cookie</span><span class="p">{</span>
  <span class="nx">Name</span><span class="p">:</span>     <span class="s">&#34;username&#34;</span><span class="p">,</span>
  <span class="nx">Value</span><span class="p">:</span>    <span class="nx">username</span><span class="p">,</span>
  <span class="nx">HttpOnly</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">if</span> <span class="nx">rememberMe</span> <span class="o">==</span> <span class="s">&#34;1&#34;</span> <span class="p">{</span>
  <span class="nx">cookie</span><span class="p">.</span><span class="nx">MaxAge</span> <span class="p">=</span> <span class="mi">7</span><span class="o">*</span><span class="mi">24</span><span class="o">*</span><span class="mi">3600</span>	<span class="c1">// 7 天
</span><span class="c1"></span><span class="p">}</span>
<span class="nx">ctx</span><span class="p">.</span><span class="nf">SetCookie</span><span class="p">(</span><span class="nx">cookie</span><span class="p">)</span>
</code></pre></div><p>我们这里直接使用了标准库的方式实现，而不是使用 ``github.com/gorilla/sessions` 包。默认情况下，浏览器关闭，cookie 删除，当“记住我”，保存 7 天。这里留一个问题：<strong>cookie.Expires 和 cookie.MaxAge 的区别？</strong></p>
<h3 id="重定向保留用户名">重定向保留用户名</h3>
<p>在登录失败后，为了避免用户再次输入用户名，这里借用 <code>github.com/gorilla/sessions</code> 包的 Flash Message 功能。</p>
<p><code>github.com/gorilla/sessions</code> 实现了 Cookie 和文件系统 Session，默认情况下，使用 Cookie。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sess</span> <span class="o">:=</span> <span class="nf">getCookieSession</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="nx">sess</span><span class="p">.</span><span class="nf">AddFlash</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="s">&#34;username&#34;</span><span class="p">)</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">sess</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">(),</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Response</span><span class="p">())</span>
</code></pre></div><p>在读 Flash Message 的地方，一定要注意，需要再次执行 session.Save：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">sess</span> <span class="o">:=</span> <span class="nf">getCookieSession</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">flashes</span> <span class="o">:=</span> <span class="nx">sess</span><span class="p">.</span><span class="nf">Flashes</span><span class="p">(</span><span class="s">&#34;username&#34;</span><span class="p">);</span> <span class="nb">len</span><span class="p">(</span><span class="nx">flashes</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
  <span class="nx">data</span><span class="p">[</span><span class="s">&#34;username&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">flashes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">sess</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nf">Request</span><span class="p">(),</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Response</span><span class="p">())</span>
</code></pre></div><h2 id="总结">总结</h2>
<p>一个简单的登录，涉及到的知识点还是不少的，但依然有不少 Echo 框架的功能没包括。后面我们会介绍更多 Echo 的特性和功能，这个简单的例子，希望能够让你对 Echo 更有感觉。</p>
<p>完整示例代码：<a href="https://github.com/polaris1119/echo-login-example">https://github.com/polaris1119/echo-login-example</a></p>
]]></content>
		</item>
		
		<item>
			<title>更懂 module 的包资源中心：关于 pkg.go.dev 的前世今生和未来</title>
			<link>https://polarisxu.studygolang.com/posts/go/dynamic/pkg-go-dev-plan/</link>
			<pubDate>Fri, 15 Nov 2019 08:52:00 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/dynamic/pkg-go-dev-plan/</guid>
			<description>北京时间 2019 年 11 月 14 日凌晨 1 点 16 分，Go 官方团队在 golang-nuts 邮件组宣布 go.dev 上线，这是一个新的 Go 开发人员中心。具体的介绍可以看我之前发布的文章 大家用Go都做什么？Go官方新发布的 Go.Dev 告诉你 。同时，go.dev 还提供了一个 Go 软件包和模块的新信息资源中心：pkg.go.dev，而在此之前，Go 已经存在了一个包资源网站：godoc.org。2020 年 1 月 31 日，在 Go 官方博客又发布了</description>
			<content type="html"><![CDATA[<p>北京时间 2019 年 11 月 14 日凌晨 1 点 16 分，Go 官方团队在 golang-nuts 邮件组宣布 go.dev 上线，这是一个新的 Go 开发人员中心。具体的介绍可以看我之前发布的文章 <a href="https://mp.weixin.qq.com/s/vwBlrJvHXdWhqWmVFhv7-A" target="_blank" rel="noopener">大家用Go都做什么？Go官方新发布的 Go.Dev 告诉你</a>
。同时，go.dev 还提供了一个 Go 软件包和模块的新信息资源中心：pkg.go.dev，而在此之前，Go 已经存在了一个包资源网站：godoc.org。2020 年 1 月 31 日，在 Go 官方博客又发布了一篇博文，关于 pkg.go.dev 接下来要做的事情，一时间社区讨论激烈，很多人不解。官方（Russ）对此也进行了解释。本文就官方的博文和 Google 邮件组上的相关内容进行整理总结，分享给大家。</p>
<h2 id="一官方博文-next-steps-for-pkggodev快速解读">一、官方博文 《Next steps for pkg.go.dev》快速解读</h2>
<ol>
<li>将 godoc.org 请求重定向到 pkg.go.dev，并向社区开发者征求反馈意见</li>
<li>回答了开发者比较关心的几个问题：
<ul>
<li>在迁移过程中，如果 package 没有显示在 pkg.go.dev 上，可以通过从 proxy.golang.org 获取对应版本的 module 来添加；</li>
<li>开发者的package突然出现不明的许可证限制 ，不要慌，后面会优化证书检测算法；</li>
<li>pkg.go.dev 是否会开源？很多公司想搭建自己的代码文档中心，目前这个需求在征求意见可填官方的调查问卷：https://google.qualtrics.com/jfe/form/SV_6FHmaLveae6d8Bn</li>
</ul>
</li>
</ol>
<p>以下是全文：</p>
<hr>
<h2 id="介绍">介绍</h2>
<p>在 2019 年，我们官方启动了 <a href="https://go.dev/" target="_blank" rel="noopener">go.dev</a>
，这是 Go 开发人员新的资源中心。</p>
<p>作为该站点的一部分，我们还启动了 <a href="https://pkg.go.dev" target="_blank" rel="noopener">pkg.go.dev</a>
，它是有关 Go 软件包和模块的信息资源中心。像 <a href="https://godoc.org/" target="_blank" rel="noopener">godoc.org</a>
 一样 ，pkg.go.dev 也提供 Go 文档。然而，它还了解 module，并提供有关软件包以前版本的信息！</p>
<p>今年开始，我们将在 pkg.go.dev 中添加新的更多功能，以帮助我们的用户更好地了解他们的依赖关系，并帮助他们围绕要导入的库做出更好的决策。</p>
<h2 id="将-godocorg-请求重定向到-pkggodev">将 godoc.org 请求重定向到 pkg.go.dev</h2>
<p>为了减少在过渡的过程中对用户的打扰，我们计划在今年晚些时候将流量从 godoc.org 重定向到 pkg.go.dev 上。同时我们需要您的及时意见反馈，以确保 pkg.go.dev 能够满足我们所有用户的需求。我们鼓励大家从今天开始使用pkg.go.dev，并提供反馈。</p>
<p>您的反馈将为我们的过渡计划提供信息，目的是使 pkg.go.dev 成为包和模块的主要信息和文档来源。我们确定您想在pkg.go.dev上看到一些内容，并且希望您收到有关这些功能的信息！</p>
<p>您可以通过以下渠道与我们分享您的反馈意见：</p>
<ul>
<li>在 Go 问题跟踪器上发布 (<a href="https://golang.org/s/discovery-feedback">https://golang.org/s/discovery-feedback</a>)；</li>
<li>发邮件：go-discovery-feedback@google.com；</li>
<li>通过 go.dev 底部的 “Share Feedback” 或 “Report an Issue”；</li>
</ul>
<p>作为过渡的一部分，我们还将讨论对 pkg.go.dev 进行 API 访问的计划 。我们将在 Go issue 33654 (<a href="https://golang.org/s/discovery-updates">https://golang.org/s/discovery-updates</a>) 上发布更新 。</p>
<h2 id="问答">问答</h2>
<p>自 11 月推出以来，我们已经收到 Go 用户关于 pkg.go.dev 的大量反馈 。对于本文的剩下部分，我们将回答一些常见问题，希望对大家有帮助。</p>
<h3 id="1-我的-package-未显示在-pkggodev-上该怎么做">1. 我的 package 未显示在 pkg.go.dev 上，该怎么做？</h3>
<p>我们会定期监控 <a href="https://index.golang.org/index" target="_blank" rel="noopener">Go Module Index</a>
 以查找要添加到 pkg.go.dev 的新包。如果在 pkg.go.dev 上没有找到某个包，则可以通过从 proxy.golang.org 获取模块版本来添加它 。有关说明，请参见 <a href="https://go.dev/about">https://go.dev/about</a></p>
<h3 id="2--我的-package-有许可证限制它会是什么问题">2.  我的 package 有许可证限制。它会是什么问题？</h3>
<p>我们知道，无法在 pkg.go.dev 上完整地看到您想要的 package，这是一个令人沮丧的经历。感谢您在我们改进许可证检测算法过程中的耐心配合。</p>
<p>自 2019 年 11 月推出以来，我们进行了以下改进：</p>
<ul>
<li>更新了我们的许可政策(<a href="https://pkg.go.dev/license-policy">https://pkg.go.dev/license-policy</a>)，里面包括了我们检测和识别的许可列表；</li>
<li>与许可证检查(<a href="https://github.com/google/licensecheck">https://github.com/google/licensecheck</a>)团队合作，改善对版权声明的检测；</li>
<li>建立了特殊情况的手动审核流程；</li>
</ul>
<p>与往常一样，我们的许可政策位于 <a href="https://pkg.go.dev/license-policy">https://pkg.go.dev/license-policy</a> 。如果您遇到问题，请随时在 Go 问题跟踪器上提交问题 (<a href="https://golang.org/x/discovery-feedback">https://golang.org/x/discovery-feedback</a>)，或发送电子邮件至 <a href="mailto:go-discovery-feedback@google.com">go-discovery-feedback@google.com</a>， 以便我们直接与您合作！</p>
<h3 id="3-pkggodev-会开源吗以便可以在我的私人库上运行它">3. pkg.go.dev 会开源吗，以便可以在我的私人库上运行它？</h3>
<p>我们知道，拥有私有代码库的公司希望运行提供模块支持的文档服务器。我们希望帮助满足这一需求，但是我们目前还没有深入的了解这个需求痛点。</p>
<p>我们从用户那里听说，运行 godoc.org 服务器比实际上要复杂得多，因为它是为在 Internet 范围而不是仅在公司内部提供服务而设计的。我们认为当前的 pkg.go.dev 服务将出现相同的问题。</p>
<p>我们认为使用新的服务都能够提供私有代码部署，而不是让每家公司都面临运行在公网上面。而且除了提供文档之外，新服务器还可以为 goimports 和 gopls 提供帮助 。</p>
<p>如果要运行这样的服务，请填一个 3-5 分钟的调查( <a href="https://google.qualtrics.com/jfe/form/SV_6FHmaLveae6d8Bn">https://google.qualtrics.com/jfe/form/SV_6FHmaLveae6d8Bn</a> )，以帮助我们更好地了解您的需求。该调查将持续到 2020 年 3 月1日。（polaris 建议：<strong>国内用户可以反馈反馈关于大陆访问不到或慢的问题</strong>。）</p>
<p>最后，我们对 2020 年 pkg.go.dev 的未来感到兴奋，希望广大开发者也一样！我们期待听到您的反馈，并希望与 Go 社区在该迁移中紧密合作。</p>
<p>原文地址：https://blog.golang.org/pkg.go.dev-2020</p>
<h2 id="二go-团队核心成员-rscruss在邮件组的回复">二、Go 团队核心成员 RSC（Russ）在邮件组的回复</h2>
<p>以下是他邮件回复内容的整理：</p>
<p>这封邮件有点长，但我希望它能解决大部分讨论。如果您觉得缺少任何东西，请回复，我很高兴继续讨论。</p>
<h3 id="godev-出现的背景">go.dev 出现的背景</h3>
<p>过去一年左右的时间里，我们开始了解的一件事是，下一波 Go 采用者中的许多人都希望拥有一个包含 Go 资源的“一站式”网站，包括如何入门，谁正在使用它，指向学习资源，软件包文档等的链接。新的 <a href="http://go.dev" target="_blank" rel="noopener">go.dev</a>
 就是该一站式网站。在宣布它的博客中，我们将其称为 <a href="https://blog.golang.org/go.dev" target="_blank" rel="noopener">Go 开发人员的新中心</a>
。</p>
<h3 id="为什么-godev-不同于-golangorg">为什么 go.dev 不同于 golang.org？</h3>
<p>我个人认为，将两者分开可以使 <a href="http://go.dev" target="_blank" rel="noopener">go.dev</a>
 包含更多社区内容。从历史上看，<a href="http://golang.org" target="_blank" rel="noopener">golang.org</a>
 是权威地谈论 Go 的地方：它具有语言规范，标准库文档，官方下载等。对我们一直很重要的一点是，不要将它与世界上所有其他 Go 内容混在一起。新站点似乎是为其他资源创建更具包容性的场所的机会，因此是第二个站点。</p>
<h3 id="godocorg-出现的背景">godoc.org 出现的背景</h3>
<p>Gary Burd 从 2012 年末开始创建并运行了 <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
。它曾经是，现在仍然是一个绝妙的主意，并且显然是对 Go 社区的宝贵服务。大约一年后，Gary 决定不再运行并为服务器付费，因此将其交给 Go 项目采用。我们很乐意这样做，以确保所有 Go 用户仍然可以使用此资源。我们在 2014 年采用 <a href="http://godoc.com" target="_blank" rel="noopener">godoc.org</a>
 时说过 (<a href="https://groups.google.com/g/golang-nuts/c/_rbVuzl-OqA/m/N_xoNaD4kAoJ">https://groups.google.com/g/golang-nuts/c/_rbVuzl-OqA/m/N_xoNaD4kAoJ</a>)，我再说一遍：我非常感谢 Gary 创作的作品。</p>
<h3 id="为什么根本没有新的软件包文档站点为什么不就地更新-godocorg">为什么根本没有新的软件包文档站点？为什么不就地更新 godoc.org？</h3>
<p>通过引入模块和包的多个版本的概念，我们知道必须更新 <a href="https://godoc.org" target="_blank" rel="noopener">godoc.org</a>
。经过一番努力，似乎值得重新开始，特别是因为具有单 VM 数据库的 <a href="https://godoc.org" target="_blank" rel="noopener">godoc.org</a>
 服务器设计已经开始有点不合时宜了。除了模块工作之外，我们还要解决其他问题，例如服务的可访问性和整体可伸缩性。</p>
<p>As a side note, there&rsquo;s almost nothing in the Go distribution that has survived eight years without being redone. The compiler, the assembler, the linker, the go command itself, most of the standard library: all of them have been massively overhauled one or more times since the start of Go. That&rsquo;s how we take what we learn and make things better.</p>
<p>顺便提一句，Go 发行版中几乎没有任何内容可以重做 8 年。编译器，汇编器，链接器，go 命令本身，大多数标准库：自 Go 以来，所有这些库均已进行了一次或多次大修。这就是我们学习和改进事情的方式。</p>
<p>这种重写总是涉及一个过渡时期，在这个过渡时期中，旧版本仍然是大多数人使用的主力军，而新版本则为早期采用者测试和发现错误提供了新名称。</p>
<h3 id="为什么在-pkggodev-上有新的包文档站点">为什么在 pkg.go.dev 上有新的包文档站点？</h3>
<p>Docs for all the packages in the entire ecosystem are exactly the kind of community-generated content that <a href="http://go.dev" target="_blank" rel="noopener">go.dev</a>
 is meant to help find, so <a href="http://pkg.go.dev" target="_blank" rel="noopener">pkg.go.dev</a>
 seemed like a good name. Especially since <a href="http://go.dev" target="_blank" rel="noopener">go.dev</a>
 has a much broader scope than <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
, it makes sense to take the opportunity to fold it in and reduce the number of sites a typical user has to be aware of (once the transition is complete).</p>
<p>整个生态系统中所有软件包的文档都是 <a href="http://go.dev" target="_blank" rel="noopener">go.dev</a>
，旨在帮助查找社区产生的内容，因此 <a href="https://pkg.go.dev" target="_blank" rel="noopener">pkg.go.dev</a>
 似乎是个好名字。尤其是由于 <a href="https://go.dev" target="_blank" rel="noopener">go.dev</a>
 的范围比 <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
 更为广泛，因此有机会抓住它并减少它是有意义的。典型用户必须知道的站点数（一旦转换完成）。</p>
<h3 id="当-pkggodev-不够完善时为什么要谈论将-godocorg-重定向到-pkggodev">当 pkg.go.dev 不够完善时，为什么要谈论将 godoc.org 重定向到 pkg.go.dev？</h3>
<p>直言不讳，以便您可以帮助我们了解发生了什么问题，因此我们可以在重定向发生之前对其进行修复。我们知道一些事情，但是发现有些事情我们完全不知道也不会感到惊讶。最好是尽早发现而不是后来发现。同样，该博客文章首先是请求反馈有关在实际执行重定向之前需要发生的情况。</p>
<h3 id="为什么-pkggodev-需要检测到许可证才能显示文档为什么没有-godocorg">为什么 pkg.go.dev 需要检测到许可证才能显示文档？为什么没有 godoc.org？</h3>
<p>负责 pkg.go.dev 的团队已经花了很多时间与 Google 的律师讨论从互联网下载 Go 源码时我们可以做或不能做的事情。我们遵循的规则是，提供漂亮的 HTML 文档版本会显示原始文档的修改版本，并且只有在获得公认的已知良好许可证的情况下，我们才能这样做。</p>
<p>When we adopted <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
 from Gary Burd back in 2014, it did not occur to any of us to put it through that kind of review. If we had, maybe the community would have gone through this licensing pain earlier. For now we are focusing on making changes to <a href="http://pkg.go.dev" target="_blank" rel="noopener">pkg.go.dev</a>
 rather than correcting past mistakes on <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
. (At this point, more scrutiny of what <a href="http://godoc.org" target="_blank" rel="noopener">godoc.org</a>
 does is not likely to have an outcome that anyone likes.)</p>
<p>当我们在 2014 年采用 Gary Burd 的 godoc.org 时，我们所有人都没有想到要进行这种审查。如果有的话，也许社区会更早地经历这种许可痛苦。目前，我们专注于对 pkg.go.dev 进行更改，而不是更正 godoc.org 上的错误。（在这一点上，对 godoc.org 所做的事情进行更严格的审查可能不会产生任何人喜欢的结果。）</p>
<h3 id="pkggodev-上不显示那些热门软件包">pkg.go.dev 上不显示那些热门软件包？</h3>
<p>现在看来 pkg.go.dev 可以看到至少 100 个其他模块导入的 1200 个模块。其中，看起来 82 被标记为不可再发行，因此我们无法显示其文档。低于 7％，我们正在努力更好地理解这一点。如果有任何是我们的错误，我们将予以解决。</p>
<p>Another thing that was suggested that I think is a great idea is to change the “no docs available” page to have a command-line to bring up the docs in your own local godoc command.</p>
<p>我认为另一个好主意是建议更改 “无可用文档” 页面，以便使用命令行在您自己的本地 godoc 命令中显示该文档。</p>
<p>题外话：一般来说（不仅仅是关于 Go 的内容），你会惊讶于在某种元数据（GitHub meta，package.json，SPDX代码等）中具有声明的 “许可证类型”  但实际上没有许可证文本的软件包数量。这使得许可证无法遵守！例如，MIT 许可证要求“以上版权声明和此许可声明应包含在软件的所有副本或重要部分中”。但是，如果没有要包含的此类通知，仅包含“ // SPDX-License-Identifier：MIT”注释，则实际上没有办法遵守。真是一团糟。如果您从未遇到过程序员如何看待世界与律师如何做之间的差异，那么让我推荐 <a href="https://ansuz.sooke.bc.ca/entry/23" target="_blank" rel="noopener">What Colour are your bits?</a>
</p>
<p>encountered the differences between how programmers see the world</p>
<p>and how lawyers do, let me recommend &ldquo;<a href="https://ansuz.sooke.bc.ca/entry/23" target="_blank" rel="noopener">What Colour are your bits?</a>
&quot;]</p>
<h3 id="为什么pkggodev没有开源">为什么pkg.go.dev没有开源？</h3>
<p>这里没有任何阴谋。最初的计划是将其开源，但是开放源代码给代码库带来了压力，要求它们可以在其他环境中重用。目前，该代码仅针对以下一种情况编写：全球 pkg.go.dev 网站。</p>
<p>我帮助编辑了博客文章，并负责“将pkg.go.dev开源，以便我可以在我的私人代码上运行它吗？”这个问题。对于造成这么多人的冒犯，我深表歉意。</p>
<p>我并不是要暗示没有其他理由来运行文档服务器，只是举例说明我认为 Go 开发人员想要代码的最常见原因。</p>
<p>与我们发布不是全局代理站点的代理的开放源代码参考实现的方式几乎相同，我仍然希望我们将发布不需要模块代码的软件包文档站点的开放源代码参考实现。全球站点。不论是在使用私有代码还是在您的笔记本电脑上使用完全开源的代码，无需在全球范围内实现的实现都可以更轻松地运行。我还希望同一台服务器可以提供索引查询，以使诸如 goimports 和 gopls 之类的工具更快。相比之下，pkg.go.dev 可能无法（至少以不同的方式）为扩展关注点和隐私关注点提供此类查询。</p>
<p>因此，博客文章中的原因是真正的原因：当前的代码不是您可能应该运行的代码，无论是在工作中还是在离线模式下的笔记本电脑上，我都认为我们可以为此提供更好的答案。</p>
<p>但是，我听到所有想要查看网站上正在运行的代码并可能对其做出贡献的所有人，无论是否在其他情况下运行都有意义。我将对此进行调查。</p>
<p>再次感谢您在我们与大家沟通不畅时给我们打招呼。确实有帮助。希望这封邮件也能对您有所帮助，否则请告知我。</p>
<p>祝好，
Russ</p>
<hr>
<p>注意：目前 godoc.org 上已经有提示，建议使用 pkg.go.dev 了。</p>
<h2 id="三关于-golangclubcom">三、关于 golangclub.com</h2>
<p>最后，go.dev 的中国本土化站点：https://golangclub.com 仍在完善中，期待您的贡献。项目地址：https://github.com/polaris1119/golangclub</p>
<p><p class="md__image">
  <img src="https://s2.ax1x.com/2020/02/10/15aZUs.png"
    alt=""  />
</p>
</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——基础篇2：Echo 核心亮点介绍</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/basic02-feature/</link>
			<pubDate>Mon, 28 Oct 2019 11:15:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/basic02-feature/</guid>
			<description>在 Echo 的官网的首页，列出了 9 个核心功能或亮点。我这里将它说成是亮点（也许并不一定都比其他框架更好）。 一、优化的路由 高度优化的 HTTP 路由，动态内存分配为零，可对路由进行优先级排序。 这一点从上一篇：[搭建 Echo 开发环境](基础篇：搭建 Echo 开发环境.md) 可以看到。 Echo 路由基于 radix tree ，查询速度非常快。路由使用 sync pool 来重用内存，实现无 GC 开销下的零动态内存分配。 路由的注册和使用方式 各大</description>
			<content type="html"><![CDATA[<p>在 Echo 的官网的首页，列出了 9 个核心功能或亮点。我这里将它说成是亮点（也许并不一定都比其他框架更好）。</p>
<h2 id="一优化的路由">一、优化的路由</h2>
<p><strong>高度优化的 HTTP 路由，动态内存分配为零，可对路由进行优先级排序。</strong></p>
<p>这一点从上一篇：[搭建 Echo 开发环境](基础篇：搭建 Echo 开发环境.md) 可以看到。</p>
<p>Echo 路由基于 <a href="http://en.wikipedia.org/wiki/Radix_tree" target="_blank" rel="noopener">radix tree</a>
 ，查询速度非常快。路由使用 <a href="https://docs.studygolang.com/pkg/sync/#Pool" target="_blank" rel="noopener">sync pool</a>
 来重用内存，实现无 GC 开销下的零动态内存分配。</p>
<h3 id="路由的注册和使用方式">路由的注册和使用方式</h3>
<p>各大框架路由的注册和使用方式都类似，通过 HTTP 方法（GET、POST、PUT、DELETE 等），将 url 路径和一个处理程序绑定在一起，唯一不太一样的一般是处理程序的函数签名不一样（主要参数类型不一样）。例如，下面的代码则展示了一个注册路由的例子：它包括 <code>GET</code> 的访问方式， <code>/hello</code> 的访问路径，以及发送 <code>Hello World</code> HTTP 响应的处理程序。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 业务处理
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">hello</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 路由
</span><span class="c1"></span><span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/hello&#34;</span><span class="p">,</span> <span class="nx">hello</span><span class="p">)</span>
</code></pre></div><p>更多路由的特性，参考文档：<a href="https://echo.labstack.com/guide/routing/">https://echo.labstack.com/guide/routing/</a>（英文）、 <a href="https://www.bookstack.cn/read/echo-v3-zh/guide-routing.md">https://www.bookstack.cn/read/echo-v3-zh/guide-routing.md</a> （中文）。（上篇贴的中文文档打不开了。注意，中文文档基于 V3，而不是 V4）</p>
<h2 id="二scalable">二、Scalable</h2>
<p>Echo 方便构建健壮的 RESTful API，轻松将其组织起来。</p>
<p>根据上一节路由，我们可以轻松构建出 RESTful API，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">POST</span><span class="p">(</span><span class="s">&#34;/user&#34;</span><span class="p">,</span> <span class="nx">createUser</span><span class="p">)</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/user/1&#34;</span><span class="p">,</span> <span class="nx">findUser</span><span class="p">)</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">PUT</span><span class="p">(</span><span class="s">&#34;/user/1&#34;</span><span class="p">,</span> <span class="nx">updateUser</span><span class="p">)</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">DELETE</span><span class="p">(</span><span class="s">&#34;/user/1&#34;</span><span class="p">,</span> <span class="nx">deleteUser</span><span class="p">)</span>
</code></pre></div><p>可以轻松对应上 RESTful API 的标准。</p>
<h2 id="三自动-tls">三、自动 TLS</h2>
<p>Echo 能够通过 “Let&rsquo;s Encrypt” 自动安装 TLS 证书。<code>Echo#StartAutoTLS</code> 接受一个接听 443 端口的网络地址。类似 <code>:443</code> 这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span><span class="p">.</span><span class="nf">StartAutoTLS</span><span class="p">(</span><span class="s">&#34;:443&#34;</span><span class="p">)</span>
</code></pre></div><p>可以通过 <code>e.AutoTLSManager</code> 做一些控制，比如缓存等。</p>
<h2 id="四http2">四、HTTP/2</h2>
<p>Echo 自动支持 HTTP/2。HTTP/2 (原本的名字是 HTTP/2.0) 是万维网使用的 HTTP 网络协议的第二个主要版本。HTTP/2 提供了更快的速度和更好的用户体验。</p>
<h3 id="特性">特性</h3>
<ul>
<li>使用二进制格式传输数据，而不是文本。使得在解析和优化扩展上更为方便。</li>
<li>多路复用，所有的请求都是通过一个 TCP 连接并发完成。</li>
<li>对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。</li>
<li>Server Push：服务端能够更快的把资源推送给客户端。</li>
</ul>
<h2 id="五中间件">五、中间件</h2>
<p>这是让 Echo 可扩展、功能强大、好用的关键组件。</p>
<p>中间件是一个函数，嵌入在 HTTP 的请求和响应之间。它可以获得 <code>Echo#Context</code> 对象用来进行一些特殊的操作， 比如记录每个请求或者统计请求数。</p>
<h3 id="不同级别的中间件">不同级别的中间件</h3>
<h4 id="1根级别中间件router-之前">1、根级别中间件（router 之前）</h4>
<p><code>Echo#Pre()</code> 用于注册一个在路由执行之前运行的中间件，可以用来修改请求的一些属性。比如在请求路径结尾添加或者删除一个 <code>/</code> 来使之能与路由匹配。</p>
<p>下面的这几个内建中间件应该被注册在这一级别：</p>
<ul>
<li>AddTrailingSlash</li>
<li>RemoveTrailingSlash</li>
<li>MethodOverride</li>
</ul>
<p><em>注意</em>: 由于在这个级别路由还没有执行，所以这个级别的中间件不能调用任何 <code>echo.Context</code> 的 API。</p>
<h4 id="2根级别中间件router-之后">2、根级别中间件（router 之后）</h4>
<p>大部分时间你将用到 <code>Echo#Use()</code> 在这个级别注册中间件。 这个级别的中间件运行在路由处理完请求之后，可以调用所有的 <code>echo.Context</code> API。</p>
<p>下面的这几个内建中间件应该被注册在这一级别：</p>
<ul>
<li>BodyLimit</li>
<li>Logger</li>
<li>Gzip</li>
<li>Recover</li>
<li>BasicAuth</li>
<li>JWTAuth</li>
<li>Secure</li>
<li>CORS</li>
<li>Static</li>
</ul>
<h4 id="3组级别中间件">3、组级别中间件</h4>
<p>当在路由中创建一个组的时候，可以为这个组注册一个中间件。例如，给 admin 这个组注册一个 BasicAuth 中间件。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">admin</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nf">Group</span><span class="p">(</span><span class="s">&#34;/admin&#34;</span><span class="p">,</span> <span class="nx">middleware</span><span class="p">.</span><span class="nf">BasicAuth</span><span class="p">())</span>
</code></pre></div><p>也可以在创建组之后用 <code>admin.Use()</code>注册该中间件。</p>
<h4 id="4路由级别中间件">4、路由级别中间件</h4>
<p>当你创建了一个新的路由，可以选择性的给这个路由注册一个中间件。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="p">&lt;</span><span class="nx">Handler</span><span class="p">&gt;,</span> <span class="p">&lt;</span><span class="nx">Middleware</span><span class="o">...</span><span class="p">&gt;)</span>
</code></pre></div><h2 id="六数据绑定">六、数据绑定</h2>
<p>HTTP 请求有效负载的数据绑定，包括 JSON，XML 或表单数据。</p>
<p>可以使用 <code>Context#Bind(i interface{})</code> 将请求内容体绑定至 go 的结构体。默认绑定器支持基于 <code>Content-Type</code>  请求头包含 application/json，application/xml 和 application/x-www-form-urlencoded 的数据。</p>
<p>下面是绑定请求数据到 <code>User</code> 结构体的例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// User
</span><span class="c1"></span><span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`json:&#34;name&#34; form:&#34;name&#34; query:&#34;name&#34;`</span>
  <span class="nx">Email</span> <span class="kt">string</span> <span class="s">`json:&#34;email&#34; form:&#34;email&#34; query:&#34;email&#34;`</span>
<span class="p">}</span>

<span class="c1">// Handler
</span><span class="c1"></span><span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">u</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">User</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="nx">u</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="nx">u</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>以上代码支持如下请求数据的绑定：</p>
<p>1、JSON 数据</p>
<pre><code>curl \
  -X POST \
  http://localhost:1323/users \
  -H 'Content-Type: application/json' \
  -d '{&quot;name&quot;:&quot;Joe&quot;,&quot;email&quot;:&quot;joe@labstack&quot;}'
</code></pre><p>2、Form 表单数据</p>
<pre><code>curl \
  -X POST \
  http://localhost:1323/users \
  -d 'name=Joe' \
  -d 'email=joe@labstack.com'
</code></pre><p>3、查询参数 (Query Parameters)</p>
<pre><code>curl \
  -X GET \
  http://localhost:1323/users\?name\=Joe\&amp;email\=joe@labstack.com
</code></pre><h2 id="七数据呈现">七、数据呈现</h2>
<p>有发送各种 HTTP 响应的 API，包括 JSON，XML，HTML，文件，附件，内联，流或 Blob。</p>
<h2 id="八模板">八、模板</h2>
<p>支持使用任何模板引擎进行模板渲染。</p>
<p>使用 <code>Context#Render(code int, name string, data interface{}) error</code> 命令渲染带有数据的模板，并发送带有状态代码的 <code>text/html</code> 响应。通过 <code>Echo.Renderer</code> 的设置我们可以使用任何模板引擎。</p>
<h2 id="九可扩展extensible">九、可扩展（Extensible）</h2>
<p>拥有可定制的集中 HTTP 错误处理和易于扩展的 API 等。</p>
<h2 id="总结">总结</h2>
<p>以上是 Echo 首页给出的 9 大核心亮点，后续教程会给出详细的讲解或实际例子。</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——基础篇1：搭建 Echo 开发环境</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/basic01-env/</link>
			<pubDate>Mon, 21 Oct 2019 14:17:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/basic01-env/</guid>
			<description>工欲善其事必先利其器。我们先搞定 Echo 环境。 Go 开发环境 这个系列基于 Go1.14.4，Linux 系统。 安装 Go 的方式有很多，可以在这里 https://studygolang.com/dl 下载对应操作系统的版本。我自己比较喜欢通过源码安装。我将我的方式告诉大家。（Windows 环境比较建议直接下载对应的包进行安装 https://studygolang.com/dl/golang/go1.14.4.windows-am</description>
			<content type="html"><![CDATA[<p>工欲善其事必先利其器。我们先搞定 Echo 环境。</p>
<h2 id="go-开发环境">Go 开发环境</h2>
<p>这个系列基于 Go1.14.4，Linux 系统。</p>
<p>安装 Go 的方式有很多，可以在这里 <a href="https://studygolang.com/dl">https://studygolang.com/dl</a> 下载对应操作系统的版本。我自己比较喜欢通过源码安装。我将我的方式告诉大家。（Windows 环境比较建议直接下载对应的包进行安装 <a href="https://studygolang.com/dl/golang/go1.14.4.windows-amd64.msi">https://studygolang.com/dl/golang/go1.14.4.windows-amd64.msi</a>）</p>
<h3 id="下载源码">下载源码</h3>
<p>在你本地某个目录（比如 $HOME/golang），执行如下命令（确保安装了 git）：</p>
<blockquote>
<p>git clone <a href="https://github.com/golang/go">https://github.com/golang/go</a></p>
</blockquote>
<p>因为 Go 自从 1.5 开始实现了自举，因此要从源码安装 1.5 或以后的版本，必须先有 Go 环境，也就是必须有 Go1.4 或以下版本，这里我们安装 Go1.4。</p>
<h4 id="安装-go14">安装 Go1.4</h4>
<p>执行如下命令进行安装：（需要有 root 权限）</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ git checkout -b release-branch.go1.4 origin/release-branch.go1.4
$ sudo cp -rf ../go /root/go1.4
$ sudo -s
$ <span class="nb">cd</span> /root/go1.4/src
$ ./make.bash
</code></pre></div><p>验证下 Go1.4 是否安装成功：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ /root/go1.4/bin/go version
</code></pre></div><p>如果输出版本信息表示成功！</p>
<h3 id="安装-go1144">安装 Go1.14.4</h3>
<p>接下来我们安装 Go1.14.4：（<code>ctrl + d</code> 切换回原用户）</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/golang/go
$ git checkout -b release-branch.go1.14 origin/release-branch.go1.14
$ sudo cp -rf ../go /usr/local/go1.14
$ <span class="nb">cd</span> /usr/local/go1.14/src
$ sudo ./make.bash
</code></pre></div><p>然后我们加上一个软链，这样以后升级版本后，只需要重新设置软链即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ sudo ln -s /usr/local/go1.14 /usr/local/go
</code></pre></div><h3 id="配置-go-环境">配置 Go 环境</h3>
<p>最后，将 Go 加入 PATH 中，Linux 中可以在 <code>/etc/bashrc</code> 文件最后加上 <code>export PATH=$PATH:/usr/local/go/bin</code>。</p>
<p>MacOS 中可以在 <code>~/.bash_profile</code> 中加上这行配置。</p>
<p>Windows 下的环境变量配置请自行查找解决，实在有问题可以咨询我！</p>
<p>之后，打开新的 shell，执行 <code>go env</code> 可以看到类似如下的输出（Linux 下）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="nv">GO111MODULE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOARCH</span><span class="o">=</span><span class="s2">&#34;amd64&#34;</span>
<span class="nv">GOBIN</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOCACHE</span><span class="o">=</span><span class="s2">&#34;/home/xuxinhua/.cache/go-build&#34;</span>
<span class="nv">GOENV</span><span class="o">=</span><span class="s2">&#34;/home/xuxinhua/.config/go/env&#34;</span>
<span class="nv">GOEXE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOFLAGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOHOSTARCH</span><span class="o">=</span><span class="s2">&#34;amd64&#34;</span>
<span class="nv">GOHOSTOS</span><span class="o">=</span><span class="s2">&#34;linux&#34;</span>
<span class="nv">GONOPROXY</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GONOSUMDB</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOOS</span><span class="o">=</span><span class="s2">&#34;linux&#34;</span>
<span class="nv">GOPATH</span><span class="o">=</span><span class="s2">&#34;/home/xuxinhua/go&#34;</span>
<span class="nv">GOPRIVATE</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOPROXY</span><span class="o">=</span><span class="s2">&#34;https://proxy.golang.org,direct&#34;</span>
<span class="nv">GOROOT</span><span class="o">=</span><span class="s2">&#34;/usr/local/go1.14&#34;</span>
<span class="nv">GOSUMDB</span><span class="o">=</span><span class="s2">&#34;sum.golang.org&#34;</span>
<span class="nv">GOTMPDIR</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">GOTOOLDIR</span><span class="o">=</span><span class="s2">&#34;/usr/local/go1.14/pkg/tool/linux_amd64&#34;</span>
<span class="nv">GCCGO</span><span class="o">=</span><span class="s2">&#34;gccgo&#34;</span>
<span class="nv">AR</span><span class="o">=</span><span class="s2">&#34;ar&#34;</span>
<span class="nv">CC</span><span class="o">=</span><span class="s2">&#34;gcc&#34;</span>
<span class="nv">CXX</span><span class="o">=</span><span class="s2">&#34;g++&#34;</span>
<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="s2">&#34;1&#34;</span>
<span class="nv">GOMOD</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">CGO_CFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_CPPFLAGS</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
<span class="nv">CGO_CXXFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_FFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">CGO_LDFLAGS</span><span class="o">=</span><span class="s2">&#34;-g -O2&#34;</span>
<span class="nv">PKG_CONFIG</span><span class="o">=</span><span class="s2">&#34;pkg-config&#34;</span>
<span class="nv">GOGCCFLAGS</span><span class="o">=</span><span class="s2">&#34;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build537145581=/tmp/go-build -gno-record-gcc-switches&#34;</span>
</code></pre></div><p>为了后续使用的顺畅，我们配置上 goproxy：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">go env -w <span class="nv">GOPROXY</span><span class="o">=</span>https://goproxy.cn,direct
</code></pre></div><p>自此，我们的 Go 环境就搞定了！</p>
<h4 id="升级-go-版本">升级 Go 版本</h4>
<p>后续如果要升级 Go，分两种情况。</p>
<p>1）升级到 Go1.14.x，执行如下操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/golang/go
$ git pull
$ sudo rm -rf /usr/local/go1.14
$ sudo cp -rf ../go /usr/local/go1.14
$ <span class="nb">cd</span> /usr/local/go1.14/src
$ ./make.bash
</code></pre></div><p>2）将来升级到 Go1.15 及后续版本，执行类似如下操作（注意改分支信息和目录）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nb">cd</span> ~/golang/go
$ git pull
$ git checkout -b release-branch.go1.15 origin/release-branch.go1.15
$ sudo cp -rf ../go /usr/local/go1.15
$ <span class="nb">cd</span> /usr/local/go1.15/src
$ ./make.bash
$ ln -s /usr/local/go1.15 /usr/local/go
</code></pre></div><p>这样就搞定了！</p>
<p>另外，如果感兴趣也可以使用类似 <a href="https://github.com/moovweb/gvm" target="_blank" rel="noopener">gvm</a>
 这样的工具进行 Go 版本管理和切换。</p>
<h2 id="开始-echo">开始 Echo</h2>
<blockquote>
<p>官方文档：https://echo.labstack.com/guide</p>
<p>中文翻译版：http://go-echo.org/</p>
</blockquote>
<p>是什么？</p>
<blockquote>
<p>High performance, extensible, minimalist Go web framework</p>
</blockquote>
<p>Echo 是一个高性能、可扩展、极简的 Go Web 框架。</p>
<h3 id="hello-world">Hello World</h3>
<p>所有的练习都在 <code>~/project/golang/studyecho</code> 下进行。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ mkdir -p ~/project/golang/studyecho
$ <span class="nb">cd</span> ~/project/golang/studyecho
</code></pre></div><p>接着初始化项目：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ go mod init studyecho
</code></pre></div><p>这会在当前目录生成 go.mod 文件，内容如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">module studyecho

go 1.14
</code></pre></div><p>安装 echo（我们使用 4.x.x）：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ go get -u github.com/labstack/echo/v4
</code></pre></div><p>这会在当前目录生成 <code>go.sum</code> 文件，同时修改 <code>go.mod</code> 文件。如果你对 Go module 不熟悉，建议阅读 <a href="https://studygolang.com/articles/19334" target="_blank" rel="noopener">Go Modules 的使用方法 —— Go 官方博文</a>
。</p>
<p>创建文件 main.go：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="c1">// 注意这里的路径
</span><span class="c1"></span>	<span class="nx">echo</span> <span class="s">&#34;github.com/labstack/echo/v4&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 得到一个 echo.Echo 的实例
</span><span class="c1"></span>	<span class="nx">e</span> <span class="o">:=</span> <span class="nx">echo</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
  <span class="c1">// 注册路由
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">echo</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">,</span> <span class="s">&#34;Hello, World!&#34;</span><span class="p">)</span>
	<span class="p">})</span>
  <span class="c1">// 开启 HTTP Server
</span><span class="c1"></span>	<span class="nx">e</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nf">Start</span><span class="p">(</span><span class="s">&#34;:2020&#34;</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>启动服务：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ go run main.go
</code></pre></div><p>终端输出：</p>
<p><p class="md__image">
  <img src="../imgs/terminal.png"
    alt=""  />
</p>
</p>
<p>打开浏览器，输入：http://localhost:2020 你会看到：Hello, World!</p>
<p>本节完~</p>
]]></content>
		</item>
		
		<item>
			<title>Echo 系列教程——Go 语言 Web 框架 Echo 系列教程</title>
			<link>https://polarisxu.studygolang.com/posts/go/echo/echo/</link>
			<pubDate>Mon, 21 Oct 2019 13:42:51 +0800</pubDate>
			
			<guid>https://polarisxu.studygolang.com/posts/go/echo/echo/</guid>
			<description>大家好，从今天起，我们一起来学习 Echo 框架。 这几年，随着 Go 语言的发展，各种 Web 框架也出现了。常言道：没有选择是一种无奈，有选择是一种痛苦。所以，大家总是问：Web 框架大佬推荐哪个？ 这一年，国内推荐 Gin 的人很多，也让 Gin 的 Star 数增加到了 32k+（2019-10-17），网络上 Gin 相关的教程也很多。总体来说，Gin、Echo 等都比较轻量，易用性也差距不大，而 Gin 最大的一个优势是</description>
			<content type="html"><![CDATA[<p>大家好，从今天起，我们一起来学习 Echo 框架。</p>
<p>这几年，随着 Go 语言的发展，各种 Web 框架也出现了。常言道：没有选择是一种无奈，有选择是一种痛苦。所以，大家总是问：Web 框架大佬推荐哪个？</p>
<p>这一年，国内推荐 Gin 的人很多，也让 Gin 的 Star 数增加到了 32k+（2019-10-17），网络上 Gin 相关的教程也很多。总体来说，Gin、Echo 等都比较轻量，易用性也差距不大，而 Gin 最大的一个优势是直接使用了 <a href="https://github.com/julienschmidt/httprouter" target="_blank" rel="noopener">httprouter</a>
，因此性能很高，从 Gin 项目中的 Benchmark 表格可以看出：</p>
<table>
<thead>
<tr>
<th>Benchmark name</th>
<th style="text-align:right">(1)</th>
<th style="text-align:right">(2)</th>
<th style="text-align:right">(3)</th>
<th style="text-align:right">(4)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>BenchmarkGin_GithubAll</strong></td>
<td style="text-align:right"><strong>30000</strong></td>
<td style="text-align:right"><strong>48375</strong></td>
<td style="text-align:right"><strong>0</strong></td>
<td style="text-align:right"><strong>0</strong></td>
</tr>
<tr>
<td>BenchmarkAce_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">134059</td>
<td style="text-align:right">13792</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkBear_GithubAll</td>
<td style="text-align:right">5000</td>
<td style="text-align:right">534445</td>
<td style="text-align:right">86448</td>
<td style="text-align:right">943</td>
</tr>
<tr>
<td>BenchmarkBeego_GithubAll</td>
<td style="text-align:right">3000</td>
<td style="text-align:right">592444</td>
<td style="text-align:right">74705</td>
<td style="text-align:right">812</td>
</tr>
<tr>
<td>BenchmarkBone_GithubAll</td>
<td style="text-align:right">200</td>
<td style="text-align:right">6957308</td>
<td style="text-align:right">698784</td>
<td style="text-align:right">8453</td>
</tr>
<tr>
<td>BenchmarkDenco_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">158819</td>
<td style="text-align:right">20224</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkEcho_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">154700</td>
<td style="text-align:right">6496</td>
<td style="text-align:right">203</td>
</tr>
<tr>
<td>BenchmarkGocraftWeb_GithubAll</td>
<td style="text-align:right">3000</td>
<td style="text-align:right">570806</td>
<td style="text-align:right">131656</td>
<td style="text-align:right">1686</td>
</tr>
<tr>
<td>BenchmarkGoji_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">818034</td>
<td style="text-align:right">56112</td>
<td style="text-align:right">334</td>
</tr>
<tr>
<td>BenchmarkGojiv2_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">1213973</td>
<td style="text-align:right">274768</td>
<td style="text-align:right">3712</td>
</tr>
<tr>
<td>BenchmarkGoJsonRest_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">785796</td>
<td style="text-align:right">134371</td>
<td style="text-align:right">2737</td>
</tr>
<tr>
<td>BenchmarkGoRestful_GithubAll</td>
<td style="text-align:right">300</td>
<td style="text-align:right">5238188</td>
<td style="text-align:right">689672</td>
<td style="text-align:right">4519</td>
</tr>
<tr>
<td>BenchmarkGorillaMux_GithubAll</td>
<td style="text-align:right">100</td>
<td style="text-align:right">10257726</td>
<td style="text-align:right">211840</td>
<td style="text-align:right">2272</td>
</tr>
<tr>
<td>BenchmarkHttpRouter_GithubAll</td>
<td style="text-align:right">20000</td>
<td style="text-align:right">105414</td>
<td style="text-align:right">13792</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkHttpTreeMux_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">319934</td>
<td style="text-align:right">65856</td>
<td style="text-align:right">671</td>
</tr>
<tr>
<td>BenchmarkKocha_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">209442</td>
<td style="text-align:right">23304</td>
<td style="text-align:right">843</td>
</tr>
<tr>
<td>BenchmarkLARS_GithubAll</td>
<td style="text-align:right">20000</td>
<td style="text-align:right">62565</td>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
</tr>
<tr>
<td>BenchmarkMacaron_GithubAll</td>
<td style="text-align:right">2000</td>
<td style="text-align:right">1161270</td>
<td style="text-align:right">204194</td>
<td style="text-align:right">2000</td>
</tr>
<tr>
<td>BenchmarkMartini_GithubAll</td>
<td style="text-align:right">200</td>
<td style="text-align:right">9991713</td>
<td style="text-align:right">226549</td>
<td style="text-align:right">2325</td>
</tr>
<tr>
<td>BenchmarkPat_GithubAll</td>
<td style="text-align:right">200</td>
<td style="text-align:right">5590793</td>
<td style="text-align:right">1499568</td>
<td style="text-align:right">27435</td>
</tr>
<tr>
<td>BenchmarkPossum_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">319768</td>
<td style="text-align:right">84448</td>
<td style="text-align:right">609</td>
</tr>
<tr>
<td>BenchmarkR2router_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">305134</td>
<td style="text-align:right">77328</td>
<td style="text-align:right">979</td>
</tr>
<tr>
<td>BenchmarkRivet_GithubAll</td>
<td style="text-align:right">10000</td>
<td style="text-align:right">132134</td>
<td style="text-align:right">16272</td>
<td style="text-align:right">167</td>
</tr>
<tr>
<td>BenchmarkTango_GithubAll</td>
<td style="text-align:right">3000</td>
<td style="text-align:right">552754</td>
<td style="text-align:right">63826</td>
<td style="text-align:right">1618</td>
</tr>
<tr>
<td>BenchmarkTigerTonic_GithubAll</td>
<td style="text-align:right">1000</td>
<td style="text-align:right">1439483</td>
<td style="text-align:right">239104</td>
<td style="text-align:right">5374</td>
</tr>
<tr>
<td>BenchmarkTraffic_GithubAll</td>
<td style="text-align:right">100</td>
<td style="text-align:right">11383067</td>
<td style="text-align:right">2659329</td>
<td style="text-align:right">21848</td>
</tr>
<tr>
<td>BenchmarkVulcan_GithubAll</td>
<td style="text-align:right">5000</td>
<td style="text-align:right">394253</td>
<td style="text-align:right">19894</td>
<td style="text-align:right">609</td>
</tr>
</tbody>
</table>
<ul>
<li>(1): Total Repetitions achieved in constant time, higher means more confident result</li>
<li>(2): Single Repetition Duration (ns/op), lower is better</li>
<li>(3): Heap Memory (B/op), lower is better</li>
<li>(4): Average Allocations per Repetition (allocs/op), lower is better</li>
</ul>
<p>然而我下载 Gin 上提供的测试代码，发现 Echo 性能更好（或至少不比 Gin 差），下面是和上面对应的在我本地的测试（MacOS 4核 8G），测试代码：<a href="https://github.com/julienschmidt/go-http-routing-benchmark">https://github.com/julienschmidt/go-http-routing-benchmark</a></p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">BenchmarkEcho_GithubAll               	   35334	     <span class="m">34642</span> ns/op	       <span class="m">0</span> B/op	       <span class="m">0</span> allocs/op
BenchmarkGin_GithubAll                	   34724	     <span class="m">34696</span> ns/op	       <span class="m">0</span> B/op	       <span class="m">0</span> allocs/op
</code></pre></div><p>而且 Echo 上提供的测试结果也表明了这一点（我本地试验了，确实如此）：</p>
<p><p class="md__image">
  <img src="../imgs/benchmarks.png"
    alt=""  />
</p>
</p>
<h2 id="为什么是-echo">为什么是 Echo？</h2>
<p>截止 2019 年 10 月 20 日，Gin 的 Star 数高达 32k+，而 Echo 的 Star 数才 15k+，为什么不是选择讲解 Gin 而是 Echo？</p>
<p>我想理由有如下几个：</p>
<ol>
<li>Gin 的教程不少，但 Echo 教程不多；</li>
<li>Echo 1.x 时候，我就用在了 studygolang.com 上，现在更新到了 4.x，studygolang 也升级到了 Echo 最新版；</li>
<li>两者都是轻量级框架，而且性能不分伯仲，甚至 Echo 更胜一筹；</li>
<li>Gin 的 Star 数这么高，跟大家的推广很有关系；作为最早一批使用 Echo 的用户，我认为有必要推广下 Echo，好东西希望更多人学习、使用；</li>
</ol>
<h2 id="计划">计划</h2>
<p>本系列教程计划包含如下部分：</p>
<h3 id="一基础教程篇">一、基础教程篇</h3>
<p>讲解 Echo 的基础使用</p>
<h3 id="二定制篇">二、定制篇</h3>
<p>讲解如何定制或扩展 Echo</p>
<h3 id="三实战篇">三、实战篇</h3>
<p>通过一个项目讲解 Echo 的实战</p>
<h3 id="四源码学习篇">四、源码学习篇</h3>
<p>分析 Echo 的源码，了解它的设计，看看能领悟、学习到什么</p>
]]></content>
		</item>
		
	</channel>
</rss>
